quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"st; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values; need to call also SetParameters in TF1 in ace some other operations (re-normalizations) are needed. unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values (of TF1); re-implement for better efficiency. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html:5078,cache,cachen,5078,root/html604/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html,2,['cache'],['cachen']
Performance,"st; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyNLLWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidcalculate() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:2905,Cache,CacheModeRooAbsArg,2905,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:5139,load,load,5139,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,2,['load'],['load']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:4542,load,load,4542,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; ROOT::ESTLTypeTClass::GetCollectionType() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQClass.html:7505,load,load,7505,root/html604/TQClass.html,https://root.cern,https://root.cern/root/html604/TQClass.html,2,['load'],['load']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tTClass::GetConvStreamerFunc() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:7505,load,load,7505,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['load'],['load']
Performance,"st; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:12283,cache,cache,12283,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,6,['cache'],['cache']
Performance,"st; virtual voidTFormula::GetParameters(Double_t* params); virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tTFormula::IsLinear(); virtual Bool_tTFormula::IsNormalized(); Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidTFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFormula::Print(Option_t* option = """") constMENU ; virtual char*PrintValue(Int_t mode = 0) const; virtual char*PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeFormula.html:6606,Optimiz,Optimize,6606,root/html532/TTreeFormula.html,https://root.cern,https://root.cern/root/html532/TTreeFormula.html,2,['Optimiz'],['Optimize']
Performance,"st; voidTObject::MakeZombie(). private:. TCint(); TCint(const TCint&); virtual voidExecute(TMethod*, TObjArray*, int* = 0); TCint&operator=(const TCint&). Data Members; public:. enum TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCint.html:19119,load,loaded,19119,root/html528/TCint.html,https://root.cern,https://root.cern/root/html528/TCint.html,8,['load'],"['load', 'loaded', 'loading']"
Performance,"st;  ; Int_t GetStop () const;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the content of this object. ;  ; void Run (const char *dset, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t) override;  Run benchmark Input parameters dset: Dataset on which to run start: Start scan with 'start' workers. ;  ; void Run (Long64_t, Int_t, Int_t, Int_t, Int_t, Int_t, Int_t) override;  ; void SetDebug (Int_t debug);  ; void SetDirProofBench (TDirectory *dir);  ; void SetFilesPerWrk (Int_t fpw);  ; void SetNEvents (Long64_t nevents);  ; void SetNTries (Int_t ntries);  ; void SetReadType (TPBReadType *readtype);  ; void SetReleaseCache (Bool_t on=kTRUE);  ; void SetStart (Int_t start);  ; void SetStep (Int_t step);  ; void SetStop (Int_t stop);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofBenchRun;  TProofBenchRun (TProof *proof=0, const char *sel=0);  Constructor: check PROOF and load selectors PAR. ;  ;  ~TProofBenchRun () override;  destructor ;  ; virtual const char * GetParList ();  ; virtual const char * GetSelName ();  ; virtual void SetParList (const char *pars);  ; virtual void SetSelName (const char *sel);  ; virtual void SetSelOption (const char *opt);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBenchRunDataRead.html:2737,load,load,2737,doc/master/classTProofBenchRunDataRead.html,https://root.cern,https://root.cern/doc/master/classTProofBenchRunDataRead.html,1,['load'],['load']
Performance,"st;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooObjCacheManager _cacheMgr;  ; RooListProxy _compCSet;  ; RooListProxy _compRSet;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:54942,cache,cached,54942,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['cache'],['cached']
Performance,"st;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _cdfBoundaries = false;  Use boundary conditions for CDFs. ;  ; RooAICRegistry _codeReg;  ! Auxiliary class keeping tracking of analytical integration code ;  ; RooDataHist * _dataHist = nullptr;  Unowned pointer to underl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:55771,cache,cached,55771,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['cache'],['cached']
Performance,"st;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TEveElement; static const char * ToString (Bool_t b);  Convert Bool_t to string - kTRUE or kFALSE. ;  . #include <TEveCaloData.h>. Inheritance diagram for TEveCaloDataHist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveCaloDataHist() [1/2]. TEveCaloDataHist::TEveCaloDataHist ; (; const TEveCaloDataHist & ; ). private . ◆ TEveCaloDataHist() [2/2]. TEveCaloDataHist::TEveCaloDataHist ; (; ). Constructor. ; Definition at line 739 of file TEveCaloData.cxx. ◆ ~TEveCaloDataHist(). TEveCaloDataHist::~TEveCaloDataHist ; (; ). override . Destructor. ; Definition at line 751 of file TEveCaloData.cxx. Member Function Documentation. ◆ AddHistogram(). Int_t TEveCaloDataHist::AddHistogram ; (; TH2F * ; hist). Add new slice to calo tower. ; Updates cached variables fMaxValE and fMaxValEt Return last index in the vector of slice infos. ; Definition at line 900 of file TEveCaloData.cxx. ◆ Class(). static TClass * TEveCaloDataHist::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveCaloDataHist::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveCaloDataHist::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 329 of file TEveCaloData.h. ◆ DataChanged(). void TEveCaloDataHist::DataChanged ; (; ). overridevirtual . Update limits and notify data users. ; Reimplemented from TEveCaloData.; Definition at line 759 of file TEveCaloData.cxx. ◆ DeclFileName(). static const char * TEveCaloDataHist::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 329 of file TEveCaloData.h. ◆ GetCellData(). void TEveCaloDataHist::GetCellData ; (; const TEveCaloData::CellId_t & ; id, . T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloDataHist.html:34515,cache,cached,34515,doc/master/classTEveCaloDataHist.html,https://root.cern,https://root.cern/doc/master/classTEveCaloDataHist.html,1,['cache'],['cached']
Performance,"st;  get index number for a given daughter ;  ; TGeoMaterial * GetMaterial () const;  ; TGeoMedium * GetMedium () const;  ; Int_t GetNdaughters () const;  ; virtual Int_t GetNextNodeIndex () const;  ; TGeoNode * GetNode (const char *name) const;  get the pointer to a daughter node ;  ; TGeoNode * GetNode (Int_t i) const;  ; Int_t GetNodeIndex (const TGeoNode *node, Int_t *check_list, Int_t ncheck) const;  Get the index of a daughter within check_list by providing the node pointer. ;  ; TObjArray * GetNodes ();  ; Int_t GetNtotal () const;  ; Int_t GetNumber () const;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get volume info for the browser. ;  ; Bool_t GetOptimalVoxels () const;  Returns true if cylindrical voxelization is optimal. ;  ; Option_t * GetOption () const override;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; Int_t GetRefCount () const;  ; TGeoShape * GetShape () const;  ; Char_t GetTransparency () const;  ; TGeoExtension * GetUserExtension () const;  ; TGeoVoxelFinder * GetVoxels () const;  Getter for optimization structure. ;  ; void Grab ();  ; void GrabFocus ();  Move perspective view focus to this volume. ;  ; TGeoExtension * GrabFWExtension () const;  Get a copy of the framework extension pointer. ;  ; TGeoExtension * GrabUserExtension () const;  Get a copy of the user extension pointer. ;  ; void Gsord (Int_t);  ; void InspectMaterial () const;  Inspect the material for this volume. ;  ; void InspectShape () const;  ; void InvisibleAll (Bool_t flag=kTRUE);  Make volume and each of it daughters (in)visible. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsAdded () const;  ; Bool_t IsAllInvisible () const;  Return TRUE if volume and all daughters are invisible. ;  ; virtual Bool_t IsAssembly () const;  Returns true if the volume is an assembly or a scaled assembly. ;  ; Bool_t IsCylVoxels () const;  ; Bool_t IsFolder () const override;  Return TRUE if volume ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:14737,optimiz,optimization,14737,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['optimiz'],['optimization']
Performance,"st;  get index number for a given daughter ;  ; TGeoMaterial * GetMaterial () const;  ; TGeoMedium * GetMedium () const;  ; Int_t GetNdaughters () const;  ; virtual Int_t GetNextNodeIndex () const;  ; TGeoNode * GetNode (const char *name) const;  get the pointer to a daughter node ;  ; TGeoNode * GetNode (Int_t i) const;  ; Int_t GetNodeIndex (const TGeoNode *node, Int_t *check_list, Int_t ncheck) const;  Get the index of a daughter within check_list by providing the node pointer. ;  ; TObjArray * GetNodes ();  ; Int_t GetNtotal () const;  ; Int_t GetNumber () const;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get volume info for the browser. ;  ; Bool_t GetOptimalVoxels () const;  Returns true if cylindrical voxelization is optimal. ;  ; Option_t * GetOption () const override;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; Int_t GetRefCount () const;  ; TGeoShape * GetShape () const;  ; Char_t GetTransparency () const;  ; TGeoExtension * GetUserExtension () const;  ; TGeoVoxelFinder * GetVoxels () const;  Getter for optimization structure. ;  ; void Grab ();  ; void GrabFocus ();  Move perspective view focus to this volume. ;  ; TGeoExtension * GrabFWExtension () const;  Get a copy of the framework extension pointer. ;  ; TGeoExtension * GrabUserExtension () const;  Get a copy of the user extension pointer. ;  ; void Gsord (Int_t);  ; void InspectMaterial () const;  Inspect the material for this volume. ;  ; void InspectShape () const;  ; void InvisibleAll (Bool_t flag=kTRUE);  Make volume and each of it daughters (in)visible. ;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsAdded () const;  ; Bool_t IsAllInvisible () const;  Return TRUE if volume and all daughters are invisible. ;  ; virtual Bool_t IsAssembly () const;  Returns true if the volume is an assembly or a scaled assembly. ;  ; Bool_t IsCylVoxels () const;  ; Bool_t IsFolder () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:18047,optimiz,optimization,18047,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['optimiz'],['optimization']
Performance,"stBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. Int_tBroadcast(const TMessage& mess); Int_tBroadcast(Int_t kind, Int_t type = kRRT_Undef); Int_tBroadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Int_tBroadcastRaw(const void* buffer, Int_t length); Bool_tCheckFile(const char* file, Long_t modtime); Int_tCollect(Long_t tim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationRemote.html:11174,Load,LoadGraphicsLibs,11174,root/html602/TApplicationRemote.html,https://root.cern,https://root.cern/root/html602/TApplicationRemote.html,2,['Load'],['LoadGraphicsLibs']
Performance,"stMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLimitsFinder.html:4023,Optimiz,Optimize,4023,root/html532/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html532/TProofLimitsFinder.html,2,['Optimiz'],['Optimize']
Performance,"stNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_unsigned_int_double_.html:35314,cache,cache,35314,root/html534/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"stNSet!; RooMinuit*_minuit! Internal minuit instance; static Int_tRooPrintable::_nameLength; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:32983,cache,cache,32983,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['cache'],['cache']
Performance,"stProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooGaussBasis { noBasis; expBasisMinus; expBasisSum; expBasisPlus; sinBasisMinus; sinBasisSum; sinBasisPlus; cosBasisMinus; cosBasisSum; cosBasisPlus; linBasisPlus; quadBasisPlus; coshBasisMinus; coshBasisSum; coshBasisPlus; sinhBasisMinus; sinhBasisSum; sinhBasisPlus; };; enum BasisType { none; expBasis; sinBasis; cosBasis; linBasis; quadBasis; coshBasis; sinhBasis; };; enum BasisSign { Both; Plus; Minus; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. Bool_t_asympIntadded FMV,07/24/03; RooFor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:39885,Cache,CacheMode,39885,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,1,['Cache'],['CacheMode']
Performance,"stReturns the integer value for a resource.Definition TEnv.cxx:491; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::fOptionFoption_t fOptionStruct with the fit options.Definition TVirtualFitter.h:32; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; TVirtualFitter::SetPrecisionstatic void SetPrecision(Double_t prec=1e-6)static: Set the tolerance used in the minimization algorithm For example for MIGRAD this is tolerance...Definition TVirtualFitter.cxx:323; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetConfidenceIntervalsvirtual void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95)return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitterDefinition TVirtualFitter.cxx:185; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Double_t GetPrecision()static: Return the fit relative precisionDefinition TVirtualFitter.cxx:236; TVirtualFitter::fYlastInt_t fYlastLast bin on Y axis.Definition TVirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:13453,cache,cache,13453,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,1,['cache'],['cache']
Performance,stStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:40946,cache,cache,40946,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,2,['cache'],['cache']
Performance,"stalled). ;  ; virtual void SetMsgReadBuffer10 (const char *redirectLocation=nullptr, Bool_t tempRedirect=kFALSE);  Set GET command for use by ReadBuffer(s)10(), handle redirection if needed. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Return file stat information. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; virtual Int_t SysWrite (Int_t fd, const void *buf, Int_t len);  Interface to system write. All arguments like in POSIX write(). ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:32000,cache,cache,32000,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cache']
Performance,"stamp_t fSendStamp; ///<! last server operation, always used from window thread; 78 bool fActive{false}; ///<! flag indicates if connection is active; 79 unsigned fWSId{0}; ///<! websocket id; 80 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 81 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 82 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 83 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 84 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 85 int fClientCredits{0}; ///<! number of credits received from client; 86 bool fDoingSend{false}; ///<! true when performing send operation; 87 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 88 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 89 std::queue<QueueItem> fQueue; ///<! output queue; 90 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 91 WebConn() = default;; 92 WebConn(unsigned connid) : fConnId(connid) {}; 93 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 94 WebConn(unsigned connid, bool headless_mode, const std::string &key); 95 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 96 {; 97 ResetStamps();; 98 }; 99 ~WebConn();; 100 ; 101 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 102 ; 103 void ResetData(); 104 {; 105 fActive = false;; 106 fWSId = 0;; 107 fReady = 0;; 108 fDoingSend = false;; 109 fSendCredits = 0;; 110 fClientCredits = 0;; 111 fRecvSeq = 0;; 112 fSendSeq = 1;; 113 while (!fQueue.empty()); 114 fQueue.pop();; 115 }; 116 };; 117 ; 118 struct MasterConn {; 119 unsigned connid{0};; 120 int channel{-1};; 121 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 122 };; 123 ; 124 enum EQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:3692,perform,performed,3692,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,4,"['perform', 'queue']","['performed', 'performing', 'queue']"
Performance,"standard deviation in Y is zero.; In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 1./SQRT(12*N).; This approximation assumes that the Y values are integer (e.g. ADC counts); and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12). 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin J; W is obtained as from TProfile::GetBinEntries(ibin); This errors corresponds to the standard deviation of weighted mean where each; measurement Y is uncorrelated and has an error sigma, which is expressed in the; weight used to fill the Profile: w = 1/sigma^2; The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ). TProfile(const TProfile& profile); Copy constructor. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*Replace contents of this profile by the addition of h1 and h2; *-* =============================================================. this = c1*h1 + c2*h2. c1 and c2 are considered as weights applied to the two summed profiles.; The operation acts therefore like merging the two profiles with a weight c1 and c2. void Approximate(Bool_t approx = kTRUE); static function; set the fgApproximate flag. When the flag is true, the function GetBinError; will approximate the bin error with the average profile error on all bins; in the following situation only; - the number of bins in the profile is less than 1002; - the bin number of entries is small ( <5); - the estimated bin error is extremely small compared to the bin content; (see TProfile::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:32201,Perform,Performs,32201,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,3,['Perform'],['Performs']
Performance,"stant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t saveSnapshot(const char* name, const RooArgSet& params, Bool_t importValues = kFALSE); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t loadSnapshot(const char* name); Load the values and attributes of the parameters in the snapshot saved with; the given name. const RooArgSet* getSnapshot(const char* name) const; Return the RooArgSet containgin a snapshot of variables contained in the workspace. Note that the variables of the objects in the snapshots are _copies_ of the; variables in the workspace. To load the values of a snapshot in the workspace; variables use loadSnapshot() instead. RooAbsPdf* pdf(const char* name) const; Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. RooAbsReal* function(const char* name) const; Retrieve function (RooAbsReal) with given name. Note that all RooAbsPdfs are also RooAbsReals. A null pointer is returned if not found. RooRealVar* var(const char* name) const; Retrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found. RooCategory* cat(const char* name) const; Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. RooAbsCategory* catfunc(const char* name) const; Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. RooAbsArg* arg(const char* name) const; Return RooAbsArg with given name. A null pointer is returned if none is found. RooArgSet argSet(const char* nameList) const; Return set of RooAbsArgs matching to given list o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace.html:20208,load,load,20208,root/html534/RooWorkspace.html,https://root.cern,https://root.cern/root/html534/RooWorkspace.html,12,['load'],"['load', 'loadSnapshot']"
Performance,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFormula.html:13001,cache,cache,13001,root/html528/TFormula.html,https://root.cern,https://root.cern/root/html528/TFormula.html,8,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor. TFormula(const char* name, const char* formula); Normal Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:12535,cache,cache,12535,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:36173,cache,cache,36173,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,351,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpSolverBase.html:9828,perform,perform,9828,root/html528/TQpSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html,1,['perform'],['perform']
Performance,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQpSolverBase.html:9897,perform,perform,9897,root/html530/TQpSolverBase.html,https://root.cern,https://root.cern/root/html530/TQpSolverBase.html,1,['perform'],['perform']
Performance,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpSolverBase.html:9897,perform,perform,9897,root/html532/TQpSolverBase.html,https://root.cern,https://root.cern/root/html532/TQpSolverBase.html,2,['perform'],['perform']
Performance,"state permutations of a list of categories; RooMultiCategory Product operator for categories; RooMultiGenFunction Export RooAbsReal as functor; RooMultiVarGaussian Multivariate Gaussian PDF with correlations; RooMultiVarGaussian::AnaIntData ; RooMultiVarGaussian::GenData ; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNonCentralChiSquare non-central chisquare pdf; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParamHistFunc Your description goes here...; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:38188,cache,caches,38188,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,6,"['Cache', 'cache']","['Cache', 'caches']"
Performance,"static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:33030,cache,cache,33030,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,1,['cache'],['cache']
Performance,static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:36792,cache,cache,36792,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,2,['cache'],['cache']
Performance,"static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:18477,optimiz,optimizeCacheMode,18477,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,6,['optimiz'],['optimizeCacheMode']
Performance,"static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFormulaVar&operator=(const RooFormulaVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:20100,optimiz,optimizeCacheMode,20100,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,4,['optimiz'],['optimizeCacheMode']
Performance,"static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); PiecewiseInterpolation&operator=(const PiecewiseInterpolation&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; PiecewiseInterpolation(); PiecewiseInterpolation(const PiecewiseInterpolation& other, const char* name = 0); PiecewiseInterpolation(const char* name, const char* title, const RooAbsReal& nominal, const RooArgList& lowSet, const RooArgList& highSet, const RooArgList& paramSet, Bool_t takeOwnerShip = kFALSE); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:19229,optimiz,optimizeCacheMode,19229,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,4,['optimiz'],['optimizeCacheMode']
Performance,"static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:39664,cache,cache,39664,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['cache'],['cache']
Performance,"static TClass*Class(); static voidcleanup(); static RooComplexComplexErrFunc(const RooComplex& z); static RooComplexComplexErrFunc(Double_t re, Double_t im = 0); static Double_terf(Double_t x); static Double_terfc(Double_t x); static RooComplexFastComplexErrFunc(const RooComplex& z); static Double_tFastComplexErrFuncIm(const RooComplex& z); static Double_tFastComplexErrFuncRe(const RooComplex& z); static Double_tinterpolate(Double_t* yArr, Int_t nOrder, Double_t x); static Double_tinterpolate(Double_t* xa, Double_t* ya, Int_t n, Double_t x); virtual TClass*IsA() const; static RooComplexITPComplexErrFunc(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncIm(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); RooMath&operator=(const RooMath&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static const char*cacheFileName(); static voidinitFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); static Bool_tloadCache(); static voidstoreCache(). Data Members; private:. static Bool_t_cacheTableSwitch activating use of file cache for CERF-LUT; static Int_t_imBinsNumber of grid points in imaginary dimension of CERF-LUT ; static double**_imCerfArrayLookup table for Im part of complex error function; static Double_t_imMaxHigh edge of imaginary dimension of CERF-LUT; static Double_t_imMinLow edge of imaginary dimension of CERF-LUT; static Double_t_imRangeRange in imaginary dimension of CERF-LUT; static Double_t_imStepGrid spacing in imaginary dimension of CERF-LUT; static Int_t_reBinsNumber of grid points in real dimension of CERF-LUT; static double**_reCerfArrayLookup table for Re part of complex error function; static Double_t_reMaxHigh edge of real dimension of CERF-LUT; static Double_t_reMinLow edge of real dimension of CERF-LUT; static Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMath.html:1378,cache,cacheFileName,1378,root/html528/RooMath.html,https://root.cern,https://root.cern/root/html528/RooMath.html,4,['cache'],['cacheFileName']
Performance,"static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQUndoManager.html:20256,Perform,Performs,20256,root/html604/TQUndoManager.html,https://root.cern,https://root.cern/root/html604/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:20256,Perform,Performs,20256,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same plot (default); dofit = 0 no fit; 1 fit with the relevant '1st degree related' function; 2 fit with the relevant '2nd degree related' function; 3 fit with varying rcpu function; n0 = for dofit == 3, number of real cores; n1 = for dofit == 3, number of total cores (real + hyperthreaded). TGraphErrors * GetGraph(TDirectory* d, const char* pfn, Int_t& nb, Double_t& xmi, Double_t& xmx, Double_t& ymi, Double_t& ymx, Int_t& kmx, TProfile*& pf); Get f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:9790,Perform,Perform,9790,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,3,['Perform'],['Perform']
Performance,"static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance Chart:. TObject. ←; TRefTable. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRefTable.html:7994,cache,cache,7994,root/html602/TRefTable.html,https://root.cern,https://root.cern/root/html602/TRefTable.html,4,['cache'],['cache']
Performance,"static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooCategoryProxy_rhoQ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooNonCPEigenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_wQ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:47663,cache,cache,47663,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,4,['cache'],['cache']
Performance,"static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxydm; RooRealProxydm0; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDstD0BG.html:40145,cache,cache,40145,root/html532/RooDstD0BG.html,https://root.cern,https://root.cern/root/html532/RooDstD0BG.html,4,['cache'],['cache']
Performance,"static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  THttpWSHandler (const char *name, const char *title, Bool_t syncmode=kTRUE);  normal constructor ;  ; virtual void CompleteWSSend (UInt_t);  Method called when multi-threaded send operation is completed. ;  ; virtual std::string GetCodeVersion ();  Method generate extra suffix for all kinds of loaded code. ;  ; virtual Bool_t ProcessBatchHolder (std::shared_ptr< THttpCallArg > &);  Method used to accept or reject root_batch_holder.js request. ;  ; virtual void VerifyDefaultPageContent (std::shared_ptr< THttpCallArg > &arg);  Method called when default page content is prepared for use By default no-cache header is provided. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; Int_t CompleteSend (std::shared_ptr< THttpWSEngine > &engine);  Complete current send operation. ;  ; std::shared_ptr< THttpWSEngine > FindEngine (UInt_t id, Bool_t book_send=kFALSE);  Find websocket connection handle with given id If book_send parameter specified, have to book send operation under the mutex. ;  ; Bool_t HandleWS (std::shared_ptr< THttpCallArg > &arg);  Process request to websocket Different kind of requests coded into THttpCallArg::Method: ;  ; Int_t PerformSend (std::shared_ptr< THttpWSEngine > engine);  Perform send operation, stored in buffer. ;  ; void RemoveEngine (std::shared_ptr< THttpWSEngine > &engine, Bool_t terminate=kFALSE);  R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:14148,cache,cache,14148,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['cache'],['cache']
Performance,"static voidSetHinting(Bool_t state); static voidSetKerning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; public:. enum { kTTMaxFonts; kMaxGlyphs; };. private:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static void*fgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static void*fgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static void*fgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void LayoutGlyphs(); Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTF.html:1821,load,loaded,1821,root/html528/TTF.html,https://root.cern,https://root.cern/root/html528/TTF.html,4,['load'],['loaded']
Performance,"static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:15193,cache,cache,15193,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['cache'],['cache']
Performance,"static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:11049,optimiz,optimizeCacheMode,11049,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,13,['optimiz'],['optimizeCacheMode']
Performance,"static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TMessage (void *buf, Int_t bufsize);  Create a TMessage object for reading objects. ;  ; void SetLength () const;  Set the message length at the beginning of the message buffer. ;  ;  Protected Member Functions inherited from TBufferFile;  TBufferFile ();  ;  TBufferFile (const TBufferFile &)=delete;  not implemented ;  ; Int_t CheckByteCount (UInt_t startpos, UInt_t bcnt, const TClass *clss, const char *classname);  Check byte count with current buffer position. ;  ; void CheckCount (UInt_t offset) override;  Check if offset is not too large (< kMaxMapCount) when writing. ;  ; UInt_t CheckObject (UInt_t offset, const TClass *cl, Bool_t readClass=kFALSE);  Check for object in the read map. ;  ; void operator= (const TBufferFile &)=delete;  not implemented ;  ; void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse) override;  Write object to I/O buffer. ;  ;  Protected Member Functions inherited from TBufferIO;  TBufferIO ();  ;  TBufferIO (TBuffer::EMode mode);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  constructor ;  ; Long64_t GetObjectTag (const void *obj);  Returns tag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:35372,cache,cacheReuse,35372,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,1,['cache'],['cacheReuse']
Performance,"static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate and return value of polynomial. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html:49268,cache,cached,49268,doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,4,['cache'],"['cache', 'cached']"
Performance,"static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Return sum of -log of constraint p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:48677,cache,cached,48677,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,2,['cache'],"['cache', 'cached']"
Performance,staticprivate . frustum basis (as box) of current interest box (DEBUG) ; Definition at line 65 of file TGLCamera.h. ◆ fInterestBox. TGLBoundingBox TGLCamera::fInterestBox. protected . viewport (GL coords - origin bottom left) ; Definition at line 105 of file TGLCamera.h. ◆ fInterestFrustum. TGLBoundingBox TGLCamera::fInterestFrustum. private . previous interest box (DEBUG) ; Definition at line 62 of file TGLCamera.h. ◆ fInterestFrustumAsBox. TGLBoundingBox TGLCamera::fInterestFrustumAsBox. private . frustum basis of current interest box - NOT a true BB! (DEBUG) ; Definition at line 63 of file TGLCamera.h. ◆ fLargestSeen. Double_t TGLCamera::fLargestSeen. mutableprotected . the interest box - created in UpdateInterest() ; Definition at line 106 of file TGLCamera.h. ◆ fLastNoPickProjM. TGLMatrix TGLCamera::fLastNoPickProjM. mutableprotected . timestamp ; Definition at line 97 of file TGLCamera.h. ◆ fModVM. TGLMatrix TGLCamera::fModVM. mutableprotected . projection matrix (cached) ; Definition at line 99 of file TGLCamera.h. ◆ fNearClip. Double_t TGLCamera::fNearClip. mutableprotected . current camera center ; Definition at line 86 of file TGLCamera.h. ◆ fPreviousInterestBox. TGLBoundingBox TGLCamera::fPreviousInterestBox. private . Definition at line 61 of file TGLCamera.h. ◆ fProjM. TGLMatrix TGLCamera::fProjM. mutableprotected . no-pick projection matrix (cached) ; Definition at line 98 of file TGLCamera.h. ◆ fTimeStamp. UInt_t TGLCamera::fTimeStamp. mutableprotected . cached items dirty? ; Definition at line 96 of file TGLCamera.h. ◆ fVAxisMinAngle. Float_t TGLCamera::fVAxisMinAngle. protected . Definition at line 92 of file TGLCamera.h. ◆ fViewport. TGLRect TGLCamera::fViewport. protected . frustum planes (cached) ; Definition at line 103 of file TGLCamera.h. ◆ fWasArcBalled. Bool_t TGLCamera::fWasArcBalled. protected . Definition at line 80 of file TGLCamera.h. Libraries for TGLCamera:. [legend]; The documentation for this class was generated from the following f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:43960,cache,cached,43960,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cached']
Performance,"statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19990,cache,cache,19990,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPolyVar.html:31988,cache,cache,31988,root/html526/RooPolyVar.html,https://root.cern,https://root.cern/root/html526/RooPolyVar.html,2,['cache'],['cache']
Performance,"status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TString_rangeName; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRangeBoolean.html:31944,cache,cache,31944,root/html528/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html528/RooRangeBoolean.html,1,['cache'],['cache']
Performance,status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this objec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:39610,cache,cache,39610,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['cache'],['cache']
Performance,status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:39992,cache,cache,39992,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,1,['cache'],['cache']
Performance,status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:40461,cache,cache,40461,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['cache'],['cache']
Performance,"std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TTreePerfStats.cxx:657; TTreePerfStats::PrintBasketInfovoid PrintBasketInfo(Option_t *option="""") const overridePrint the TTree basket information.Definition TTreePerfStats.cxx:581; TTreePerfStats::GetReadaheadSizevirtual Int_t GetReadaheadSize() constDefinition TTreePerfStats.h:106; TTreePerfStats::fFileTFile * fFile! Pointer to the file containing the TreeDefinition TTreePerfStats.h:67; TTreePerfStats::GetHostInfoconst char * GetHostInfo() constDefinition TTreePerfStats.h:101; TTreePerfStats::GetUnzipTimevirtual Double_t GetUnzipTime() constDefinition TTreePerfStats.h:111; TTreePerfStats::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:217; TTreePerfStats::fRealTimeDouble_t fRealTimeReal time.Definition TTreePerfStats.h:58; TTreePerfStats::fReadaheadSizeInt_t fReadaheadSizeRead-ahead cache size.Definition TTreePerfStats.h:54; TTreePerfStats::SetLoadedMissvoid SetLoadedMiss(size_t bi, size_t basketNumber) overrideDefinition TTreePerfStats.h:148; TTreePerfStats::GetRealTimevirtual Double_t GetRealTime() constDefinition TTreePerfStats.h:108; TTreePerfStats::SetUnzipTimevirtual void SetUnzipTime(Double_t uztime)Definition TTreePerfStats.h:142; TTreePerfStats::SetReadCallsvirtual void SetReadCalls(Int_t ncalls)Definition TTreePerfStats.h:138; TTreePerfStats::GetDiskTimevirtual Double_t GetDiskTime() constDefinition TTreePerfStats.h:98; TTreePerfStats::fBranchIndexCachestd::unordered_map< TBranch *, size_t > fBranchIndexCacheDefinition TTreePerfStats.h:76; TTreePerfStats::~TTreePerfStats~TTreePerfStats() overrideDestructor.Definition TTreePerfStats.cxx:188; TTreePerfStats::FileOpenEventvoid FileOpenEvent(TFile *, const char *, Double_t) overrideDefinition TTreePerfStats.h:119; TTreePerfStats::SetGraphTimevirtual void SetGraphTime(TGraphErrors ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:18287,cache,cache,18287,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['cache'],['cache']
Performance,"std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls(); max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations(); max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. void SetPrintLevel(int level); set print level. { fDebug = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { if (maxfcn > 0) fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { if (maxiter > 0) fMaxIter = maxiter; }. void SetTolerance(double tol); set the tolerance. { fTol = tol; }. void SetPrecision(double prec); set in the minimizer the objective function evaluation precision; ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. default case). { fPrec = prec; }. void SetStrategy(int strategyLevel); set the strategy. { fStrategy = strategyLevel; }. void SetErrorDef(double up); set scale for calculating the errors. { fUp = up; }. void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:9731,perform,performed,9731,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,1,['perform'],['performed']
Performance,"std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__LinInterpVar.html:33239,cache,cache,33239,root/html534/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__LinInterpVar.html,7,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"std::vector< Matrix_t > & ; biasGradients . ). protectedvirtual . Update the biases, given the current bias gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 169 of file Adam.h. ◆ UpdateWeights(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . auto TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::UpdateWeights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedvirtual . Update the weights, given the current weight gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 141 of file Adam.h. Member Data Documentation. ◆ fBeta1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fBeta1. protected . The Beta1 constant used by the optimizer. ; Definition at line 51 of file Adam.h. ◆ fBeta2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fBeta2. protected . The Beta2 constant used by the optimizer. ; Definition at line 52 of file Adam.h. ◆ fEpsilon. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fEpsilon. protected . The Smoothing term used to avoid division by zero. ; Definition at line 53 of file Adam.h. ◆ fFirstMomentBiases. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fFirstMomentBiases. protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:10436,optimiz,optimizer,10436,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['optimiz'],['optimizer']
Performance,"stdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ;  ; virtual Int_t Echo (const char *str);  Sends a string to master and workers and expect them to echo it back to the client via a message. ;  ; virtual Int_t Echo (const TObject *obj);  Sends an object to master and workers and expect them to send back a message with the output of its TObject::Print(). ;  ; Int_t EnablePackage (const char *package, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, const char *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, TList *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t Exec (const char *cmd, Bool_t plusMaster=kFALSE);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t Exec (const char *cmd, const char *ord, Bool_t logtomacro=kFALSE);  Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ;  ; void Feedback (TList *objs);  Get list of feedback objects. ;  ; Long64_t Finalize (const char *queryref, Bool_t force=kFALSE);  Finalize query with reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; TMap * GetDataSetQuota (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:9653,load,loadopts,9653,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['load'],['loadopts']
Performance,"stead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::ApplyToInterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:426341,load,loaded,426341,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"stead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::fExitCodeInt_t fExitCodeDefinition TCling.h:109; TCling::ApplyToInterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:52054,load,loaded,52054,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"stem.; Definition at line 1643 of file TUnixSystem.cxx. ◆ Link(). int TUnixSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1686 of file TUnixSystem.cxx. ◆ ListLibraries(). void TUnixSystem::ListLibraries ; (; const char * ; regexp = """"). overridevirtual . List all loaded shared libraries. ; Reimplemented from TSystem.; Definition at line 2848 of file TUnixSystem.cxx. ◆ ListSymbols(). void TUnixSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). overridevirtual . List symbols in a shared library. ; Reimplemented from TSystem.; Definition at line 2840 of file TUnixSystem.cxx. ◆ Load(). int TUnixSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 2824 of file TUnixSystem.cxx. ◆ MakeDirectory(). int TUnixSystem::MakeDirectory ; (; const char * ; name). overridevirtual . Make a Unix file system directory. ; Returns 0 in case of success and -1 if the directory could not be created. ; Reimplemented from TSystem.; Definition at line 1380 of file TUnixSystem.cxx. ◆ Now(). TTime TUnixSystem::Now ; (; ). overridevirtual . Get current time in milliseconds since 0:00 Jan 1 1995. ; Reimplemented from TSystem.; Definition at line 2970 of file TUnixSystem.cxx. ◆ OpenConnection(). int TUnixSystem::OpenConnection ; (; const char * ; server, . int ; port, . int ; tcpwindowsize = -1, . const char * ; protocol = ""tcp"" . ). overridevirtual . Open a connection to a service on a server. ; Returns -1 in case connection cannot be opened. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:58886,load,loading,58886,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,2,['load'],"['loaded', 'loading']"
Performance,"stemDefinition TSystem.h:561; TTree.h; Tools.h; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTargetvoid AddTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Tools::Instance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:21006,perform,perform,21006,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['perform'],['perform']
Performance,"steps. ;  ; Int_t fGA_preCalc;  GA settings: number of pre-calc steps. ;  ; Double_t fGA_SC_factor;  GA settings: SC_factor. ;  ; Int_t fGA_SC_rate;  GA settings: SC_rate. ;  ; Int_t fGA_SC_steps;  GA settings: SC_steps. ;  ; Double_t fLastAlpha;  line search variable ;  ; Double_t fLearnRate;  learning rate for synapse weight adjustments ;  ; Double_t fPrior;  zjh ;  ; std::vector< Double_t > fPriorDev;  zjh ;  ; Int_t fResetStep;  reset time (how often we clear hessian matrix) ;  ; Float_t fSamplingEpoch;  fraction of epochs where sampling is used ;  ; Float_t fSamplingFraction;  fraction of events which is sampled for training ;  ; Bool_t fSamplingTesting;  The testing sample is sampled. ;  ; Bool_t fSamplingTraining;  The training sample is sampled. ;  ; Float_t fSamplingWeight;  changing factor for event weights when sampling is turned on ;  ; Double_t fTau;  line search variable ;  ; Int_t fTestRate;  test for overtraining performed at each #th epochs ;  ; ETrainingMethod fTrainingMethod;  method of training, BP or GA ;  ; TString fTrainMethodS;  training method option param ;  ; Int_t fUpdateLimit;  zjh ;  ; bool fUseRegulator;  zjh ;  ; Float_t fWeightRange;  suppress outliers for the estimator calculation ;  . Static Private Attributes; static const Bool_t fgPRINT_BATCH = kFALSE;  debug flags ;  ; static const Int_t fgPRINT_ESTIMATOR_INC = 10;  debug flags ;  ; static const Bool_t fgPRINT_SEQ = kFALSE;  debug flags ;  . Additional Inherited Members;  Public Attributes inherited from TMVA::MethodANNBase; TObjArray * fNetwork;  ;  Public Attributes inherited from TMVA::MethodBase; Bool_t fSetupCompleted;  ; TrainingHistory fTrainHistory;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TMVA::MethodANNBase; TActivation * fActivation;  ; std::vector< TH1 * > fEpochMonHistB;  ; std::vector< TH1 * > fEpochMonHistS;  ; std::vector< TH1 * > fEpochMonHistW;  ; EEstimator fEstimator;  ; TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:35406,perform,performed,35406,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['perform'],['performed']
Performance,"sterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). private:. Double_tevaluateFull(Double_t thisX, Double_t thisY) const; Double_tg(Double_t var1, Double_t* _var1, Double_t sigma1, Double_t var2, Double_t* _var2, Double_t sigma2) const; Double_thighBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t high, Double_t tVar) const; Double_tlowBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t low, Double_t tVar) const. Data Members; public:. enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start; RooRealProxyx; RooRealProxyy. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:38879,Cache,CacheMode,38879,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,1,['Cache'],['CacheMode']
Performance,"sterRangeEnd = new Long64_t[fMaxClusterRange];; 8276 fClusterSize = new Long64_t[fMaxClusterRange];; 8277 }; 8278 }; 8279 fClusterRangeEnd[fNClusterRange] = fEntries - 1;; 8280 // If we are auto-flushing, then the cluster size is the same as the current auto-flush setting.; 8281 if (fAutoFlush > 0) {; 8282 // Even if the user triggers MarkEventRange prior to fAutoFlush being present, the TClusterIterator; 8283 // will appropriately go to the next event range.; 8284 fClusterSize[fNClusterRange] = fAutoFlush;; 8285 // Otherwise, assume there is one cluster per event range (e.g., user is manually controlling the flush).; 8286 } else if (fNClusterRange == 0) {; 8287 fClusterSize[fNClusterRange] = fEntries;; 8288 } else {; 8289 fClusterSize[fNClusterRange] = fClusterRangeEnd[fNClusterRange] - fClusterRangeEnd[fNClusterRange-1];; 8290 }; 8291 ++fNClusterRange;; 8292}; 8293 ; 8294/// Estimate the median cluster size for the TTree.; 8295/// This value provides e.g. a reasonable cache size default if other heuristics fail.; 8296/// Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet,; 8297/// are ignored for the purposes of the calculation.; 8298Long64_t TTree::GetMedianClusterSize(); 8299{; 8300 std::vector<Long64_t> clusterSizesPerRange;; 8301 clusterSizesPerRange.reserve(fNClusterRange);; 8302 ; 8303 // We ignore cluster sizes of 0 for the purposes of this function.; 8304 // We also ignore the very last cluster range which might not have been committed to fClusterSize.; 8305 std::copy_if(fClusterSize, fClusterSize + fNClusterRange, std::back_inserter(clusterSizesPerRange),; 8306 [](Long64_t size) { return size != 0; });; 8307 ; 8308 std::vector<double> nClustersInRange; // we need to store doubles because of the signature of TMath::Median; 8309 nClustersInRange.reserve(clusterSizesPerRange.size());; 8310 ; 8311 auto clusterRangeStart = 0ll;; 8312 for (int i = 0; i < fNClusterRange; ++i) {; 8313 const auto size = fCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:323224,cache,cache,323224,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"stexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return the observables to be cached given the normalization set nset. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters on which the cache depends given normalization set nset. ;  ; void calcParams ();  (Re)calculate effective parameters of this p.d.f. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Return specialized cache subclass for FFT calculations. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the contents of the cache the FFT convolution output. ;  ; void fillCacheSlice (FFTCacheElem &cache, const RooArgSet &slicePosition) const;  Fill a slice of cachePdf with the output of the FFT convolution calculation. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:68208,cache,cached,68208,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cached']
Performance,stic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; Double_t_offsetCarrySaveW2!; Double_t_offsetSaveW2!; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of serve,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:41220,cache,cache,41220,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,2,['cache'],['cache']
Performance,stlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfInput p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExtendPdf.html:37413,cache,cache,37413,root/html526/RooExtendPdf.html,https://root.cern,https://root.cern/root/html526/RooExtendPdf.html,2,['cache'],['cache']
Performance,stlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Double_t_maxWeight; vector<Double_t>_mean; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:44943,cache,cache,44943,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"stly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfuncsDefinition rf103_interprfuncs.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; ------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf103__interprfuncs_8C.html:6654,optimiz,optimization,6654,doc/master/rf103__interprfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html,4,['optimiz'],['optimization']
Performance,"stribution for signal events, used for spline fit. ;  ; TH1D * fMvaSigFineBin;  MVA distribution for signal events. ;  ; Bool_t fNotDoneYet;  flat to indicate of Method Transformations have been obtained yet or not (normally done in MethodBase::TrainMethod) ;  ; TString fOptimizationFitType;  which type of optimisation procedure to be used ;  ; std::map< TString, Double_t > fTunedParameters;  parameters included in the tuning ;  ; std::map< TString, TMVA::Interval * > fTuneParameters;  parameters included in the tuning ;  . #include <TMVA/OptimizeConfigParameters.h>. Inheritance diagram for TMVA::OptimizeConfigParameters:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::OptimizeConfigParameters ; (; MethodBase *const ; method, . std::map< TString, TMVA::Interval * > ; tuneParameters, . TString ; fomType = ""Separation"", . TString ; optimizationType = ""GA"" . ). Constructor which sets either ""Classification or Regression"". ; Definition at line 60 of file OptimizeConfigParameters.cxx. ◆ ~OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::~OptimizeConfigParameters ; (; ). virtual . the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it) ; Definition at line 96 of file OptimizeConfigParameters.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::OptimizeConfigParameters::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::OptimizeConfigParameters::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::OptimizeConfigParameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ DeclFileName(). static const char * TMVA::OptimizeConfigParameters::DeclFileName ; (; ). inlinestatic . Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:4694,optimiz,optimizationType,4694,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimizationType']
Performance,"string * ; FullFileName = nullptr . ). static . Checks if there is an ASTFile on disk for the given module M. ; Definition at line 1065 of file TCling.cxx. ◆ hasParsedRootmapForLibrary(). static bool hasParsedRootmapForLibrary ; (; llvm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TStreamerInfo is created. ; Definition at line 1664 of file TCling.cxx. ◆ RegisterCxxModules(). static void RegisterCxxModules ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1183 of file TCling.cxx. ◆ RegisterPreInclude",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:15053,load,loaded,15053,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['load'],['loaded']
Performance,"string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057953,load,loaded,1057953,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter!; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume contents is u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:44437,cache,cache,44437,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,4,['cache'],['cache']
Performance,"string, value_type >::const_iterator RooAbsCategory::begin ; (; ); const. inline . Iterator for category state names. Points to pairs of index and name. ; Definition at line 91 of file RooAbsCategory.h. ◆ Class(). static TClass * RooAbsCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCategory::Class_Version ; (; ). inlinestaticconstexpr . A buffer for reading values from trees. ; ReturnsVersion of this class ; Definition at line 226 of file RooAbsCategory.h. ◆ clearTypes(). void RooAbsCategory::clearTypes ; (; ). protected . Delete all currently defined states. ; Definition at line 277 of file RooAbsCategory.cxx. ◆ copyCache(). void RooAbsCategory::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value from given source and raise dirty flag. ; It is the callers responsibility to ensure that the sources cache is clean(valid) before this function is called, e.g. by calling syncCache() on the source. ; Implements RooAbsArg.; Reimplemented in RooAbsCategoryLValue.; Definition at line 560 of file RooAbsCategory.cxx. ◆ createFundamental(). RooFit::OwningPtr< RooAbsArg > RooAbsCategory::createFundamental ; (; const char * ; newname = nullptr); const. overridevirtual . Create a RooCategory fundamental object with our properties. ; Implements RooAbsArg.; Definition at line 642 of file RooAbsCategory.cxx. ◆ createTable(). Roo1DTable * RooAbsCategory::createTable ; (; const char * ; label); const. Create a table matching the shape of this category. ; Definition at line 371 of file RooAbsCategory.cxx. ◆ DeclFileName(). static const char * RooAbsCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file RooAbsCategory.h. ◆ defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:48295,cache,cached,48295,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cached']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:33351,cache,cache,33351,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,7,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:34924,cache,cache,34924,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_mea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:34810,cache,cache,34810,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,8,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:34741,cache,cache,34741,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:35578,cache,cache,35578,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TMatrixD_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DMomentMorphFunction.html:36125,cache,cache,36125,root/html602/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo2DMomentMorphFunction.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLengt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:34923,cache,cache,34923,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:35760,cache,cache,35760,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLeng",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:34848,cache,cache,34848,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:40491,cache,cache,40491,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:45419,cache,cache,45419,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_loc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:44548,cache,cache,44548,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooListProxy_gamma; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:41416,cache,cache,41416,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:41358,cache,cache,41358,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:42290,cache,cache,42290,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxyRooSimultaneous::_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:43407,cache,cache,43407,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:42478,cache,cache,42478,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected events;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedTerm.html:41489,cache,cache,41489,root/html602/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html602/RooExtendedTerm.html,8,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:42457,cache,cache,42457,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,160,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:44074,cache,cache,44074,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:43928,cache,cache,43928,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:44674,cache,cache,44674,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooDataHist_dataSet; RooListProxy_dataVarsThe RooRealVars; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:35399,cache,cache,35399,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:34528,cache,cache,34528,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:34707,cache,cache,34707,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,7,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:33565,cache,cache,33565,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,5,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"struct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id: Polynomial.h 37160 2010-12-01 21:52:04Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Polynomial.html:5562,Optimiz,Optimized,5562,root/html532/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"structor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition at line 64 of file TGenCollectionProxy.h. ◆ fCtor. ROOT::NewFunc_t TGenCollectionProxy::Value::fCtor. Method cache for containee constructor. ; Definition at line 61 of file TGenCollectionProxy.h. ◆ fDelete. ROOT::DelFunc_t TGenCollectionProxy::Value::fDelete. Method cache for containee delete. ; Definition at line 63 of file TGenCollectionProxy.h. ◆ fDtor. ROOT::DesFunc_t TGenCollectionProxy::Value::fDtor. Method cache for containee destructor. ; Definition at line 62 of file TGenCollectionProxy.h. ◆ fKind. EDataType TGenCollectionProxy::Value::fKind. kind of ROOT-fundamental type ; Definition at line 67 of file TGenCollectionProxy.h. ◆ fProperties. UInt_t TGenCollectionProxy::Value::fProperties. Additional properties of the value type (kNeedDelete) ; Definition at line 65 of file TGenCollectionProxy.h. ◆ fSize. size_t TGenCollectionProxy::Value::fSize. fSize of the contained object ; Definition at line 68 of file TGenCollectionProxy.h. ◆ fType. TClassRef TGenCollectionProxy::Value::fType. TClass reference of Value_type in collection. ; Definition at line 66 of file TGenCollectionProxy.h. Collaboration diagram for TGenCollectionProxy::Value:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:2270,cache,cache,2270,doc/master/structTGenCollectionProxy_1_1Value.html,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html,1,['cache'],['cache']
Performance,"structor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate value. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDerivative.html:48402,cache,cached,48402,doc/master/classRooDerivative.html,https://root.cern,https://root.cern/doc/master/classRooDerivative.html,10,['cache'],"['cache', 'cached']"
Performance,"structor. ; Definition at line 213 of file TMehrotraSolver.cxx. Member Function Documentation. ◆ Class(). static TClass * TMehrotraSolver::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMehrotraSolver::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMehrotraSolver::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMehrotraSolver.h. ◆ DeclFileName(). static const char * TMehrotraSolver::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMehrotraSolver.h. ◆ DefMonitor(). void TMehrotraSolver::DefMonitor ; (; TQpDataBase * ; data, . TQpVar * ; vars, . TQpResidual * ; resids, . Double_t ; alpha, . Double_t ; sigma, . Int_t ; i, . Double_t ; mu, . Int_t ; status_code, . Int_t ; level . ). overridevirtual . Print information about the optimization process and monitor the convergence status of thye algorithm. ; Implements TQpSolverBase.; Definition at line 171 of file TMehrotraSolver.cxx. ◆ IsA(). TClass * TMehrotraSolver::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 85 of file TMehrotraSolver.h. ◆ operator=(). TMehrotraSolver & TMehrotraSolver::operator= ; (; const TMehrotraSolver & ; source). Assignment operator. ; Definition at line 222 of file TMehrotraSolver.cxx. ◆ Solve(). Int_t TMehrotraSolver::Solve ; (; TQpDataBase * ; prob, . TQpVar * ; iterate, . TQpResidual * ; resid . ). overridevirtual . Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ; Monitor the residuals during the iterations through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . ; Implements TQpSolverBase.; Definition at line 97 of file TMehrotraSolver.cxx. ◆ Streamer(). void TMehrotraSolver:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMehrotraSolver.html:15386,optimiz,optimization,15386,doc/master/classTMehrotraSolver.html,https://root.cern,https://root.cern/doc/master/classTMehrotraSolver.html,1,['optimiz'],['optimization']
Performance,"sts; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; ///<! list of local directories, which could be accessed via server; 49 ; 50 std::string fDefaultPage; ///<! file name for default page name; 51 std::string fDefaultPageCont; ///<! content of default html page; 52 std::string fDrawPage; ///<! file name for drawing of single element; 53 std::string fDrawPageCont; ///<! content of draw html page; 54 std::string fCors; ///<! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses; 55 std::string fCorsCredentials; ///<! CORS: add Access-Control-Allow-Credentials: true response header; 56 ; 57 std::mutex fMutex; ///<! mutex to protect list with arguments; 58 std::queue<std::shared_ptr<THttpCallArg>> fArgs; ///<! submitted arguments; 59 ; 60 std::mutex fWSMutex; ///<! mutex to protect WS handler lists; 61 std::vector<std::shared_ptr<THttpWSHandler>> fWSHandlers; ///<! list of WS handlers; 62 ; 63 virtual void MissedRequest(THttpCallArg *arg);; 64 ; 65 virtual void ProcessRequest(std::shared_ptr<THttpCallArg> arg);; 66 ; 67 virtual void ProcessBatchHolder(std::shared_ptr<THttpCallArg> &arg);; 68 ; 69 void StopServerThread();; 70 ; 71 std::string BuildWSEntryPage();; 72 ; 73 void ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version = """");; 74 ; 75 static Bool_t VerifyFilePath(const char *fname);; 76 ; 77 THttpServer(const THttpServer &) = delete;; 78 THttpServer &operator=(const THttpServer &) = delete;; 79 ; 80public:; 81 THttpServer(const char *engine = ""http:8080"");; 82 virtual ~THttpServer();; 83 ; 84 Bool_t CreateEngine(const char *engine);; 85 ; 86 Bool_t IsAnyEngine() const { return fEngines.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:2634,queue,queue,2634,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,1,['queue'],['queue']
Performance,"stsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TProofLite(const TProofLite& ). void operator=(const TProofLite& ). TProofLite(); { }. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); { return TProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:31360,cache,cache,31360,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cache']
Performance,"stsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves that have a unique; (user) file system image. This information is used to transfer files; only once to nodes that share a file system",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:31823,cache,cache,31823,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,3,['cache'],['cache']
Performance,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:34577,cache,cache,34577,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['cache'],['cache']
Performance,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35063,cache,cache,35063,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['cache'],['cache']
Performance,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36309,cache,cache,36309,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"sualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:44433,cache,cache,44433,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,4,['cache'],['cache']
Performance,"sualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:46779,cache,cache,46779,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,6,['cache'],['cache']
Performance,subset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value ne,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:32498,cache,cache,32498,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,subset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsTestStatistic.html:33040,cache,cache,33040,root/html528/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"subset of dimensions ;  CTHistViewOutOfRange;  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:17279,perform,performing,17279,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performing']
Performance,"such a binning is not set, the same number of bins as for convVar will be used. ; [in]pdfConvVarIf the variable used for convolution is a PDF, itself, pass the PDF here, and pass the convolution variable to convVar. See also rf210_angularconv.C in the roofit tutorials . Definition at line 248 of file RooFFTConvPdf.cxx. ◆ RooFFTConvPdf() [4/4]. RooFFTConvPdf::RooFFTConvPdf ; (; const RooFFTConvPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 272 of file RooFFTConvPdf.cxx. ◆ ~RooFFTConvPdf(). RooFFTConvPdf::~RooFFTConvPdf ; (; ). override . Destructor. ; Definition at line 292 of file RooFFTConvPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the observables to be cached given the normalization set nset. ; If the cache observable is in nset then this is; the convolution observable plus; any member of nset that is either a RooCategory,; or was previously specified through setCacheObservables(). In case the cache observable is not in nset, then it is; the convolution observable plus; all member of nset that are observables of this p.d.f. . Implements RooAbsCachedPdf.; Definition at line 778 of file RooFFTConvPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters on which the cache depends given normalization set nset. ; For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:87092,cache,cache,87092,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.; Resize Opaque: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.; Interrupt: interrupts the current drawing process.; Refresh: redraws the canvas contents.; Pad Auto Exec: executes the list of TExecs in the current pad.; Statistics: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:39831,response time,response time,39831,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['response time'],['response time']
Performance,"such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:16925,cache,cacheArgs,16925,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,5,"['Cache', 'cache']","['Cache', 'cache', 'cacheArgs']"
Performance,"suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:215097,cache,cacheSize,215097,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,4,['cache'],"['cacheFactor', 'cacheSize']"
Performance,"sult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:3590,cache,cache,3590,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,3,['cache'],['cache']
Performance,"sult of this action (of type; 2941 /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; 2942 /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; 2943 /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; 2944 /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; 2945 /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; 2946 /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; 2947 /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; 2948 /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; 2949 /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; 2950 /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; 2951 /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; 2952 /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; 2953 /// the requested columns for the particular entry being processed.; 2954 /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; 2955 /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; 2956 /// diagnostics, SaveGraph(), etc.; 2957 ///; 2958 /// ### Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:166764,optimiz,optimizations,166764,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['optimiz'],['optimizations']
Performance,"sy to make and mismatches between Streamer writers and readers are frequent and increase as the number of classes increase. We recommend you use rootcling generated Streamers whenever you can, and profit from the automatic schema evolution.; 11.5.8 Building Class Definitions with the StreamerInfo; A ROOT file’s StreamerInfolist contains the description of all versions of all classes in the file. When a file is opened the StreamerInfois read into memory and it provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506344,load,loaded,506344,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"sym, RooAbsCategory& blindState); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:24829,cache,cache,24829,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:35427,load,loaded,35427,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,4,['load'],['loaded']
Performance,"system.rootrc,; //it will appear in the GL viewer; //#Viewer3D.DefaultDrawOption: ogl; ; geom->SetVisLevel(4);; if (vis) top->Draw(""ogle"");; }; ; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; R; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoMaterialBase class describing materials.Definition TGeoMateri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:10847,perform,performedDefinition,10847,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['perform'],['performedDefinition']
Performance,"t 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& ); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histograms have in principle events weight != 1. Double_t weight() const; Return weight of current bin. Double_t binVolume() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:35864,load,loaded,35864,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,4,['load'],['loaded']
Performance,"t 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& ); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.0); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histograms have in principle events weight != 1. Double_t weight() const; Return weight of current bin. Double_t binVolume() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:34659,load,loaded,34659,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,2,['load'],['loaded']
Performance,"t 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& b); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.0); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histograms have in principle events weight != 1. Double_t weight() const; Return weight of current bin. Double_t binVolume() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:31350,load,loaded,31350,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,5,['load'],['loaded']
Performance,"t (RooAbsData const &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={});  Import a dataset (RooDataSet or RooDataHist) into the workspace. ;  ; bool import (TObject const &object, bool replaceExisting=false);  Import a clone of a generic TObject into workspace generic object container. ;  ; bool import (TObject const &object, const char *aliasName, bool replaceExisting=false);  Import a clone of a generic TObject into workspace generic object container. ;  ; bool importClassCode (const char *pat=""*"", bool doReplace=false);  Import code of all classes in the workspace that have a class name that matches pattern 'pat' and which are not found to be part of the standard ROOT distribution. ;  ; bool importClassCode (TClass *theClass, bool doReplace=false);  ; TClass * IsA () const override;  ; bool loadSnapshot (const char *name);  Load the values and attributes of the parameters in the snapshot saved with the given name. ;  ; bool makeDir ();  Create transient TDirectory representation of this workspace. ;  ; void merge (const RooWorkspace &);  ; TObject * obj (RooStringView name) const;  Return any type of object (RooAbsArg, RooAbsData or generic object) with given name) ;  ; RooAbsPdf * pdf (RooStringView name) const;  Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. ;  ; void Print (Option_t *opts=nullptr) const override;  Print contents of the workspace. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; bool removeSet (const char *name);  Remove a named set from the workspace. ;  ; bool renameSet (const char *name, const char *newName);  Rename set to a new name. ;  ; bool saveSnapshot (RooStringView, const char *paramNames);  Save snapshot of values and attrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:7928,load,loadSnapshot,7928,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['load'],['loadSnapshot']
Performance,"t * frame(Double_t lo, Double_t hi) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. RooPlot * frame(Int_t nbins) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. RooPlot * frame() const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another RooAbsArg to our cache. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. void randomize(const char* rangeName = 0); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBin(Int_t ibin, const char* rangeName = 0); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). void setBin(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'binning'. void randomize(const RooAbsBinning& binning); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBinFast(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). Bool_t fitRange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsRealLValue.html:39959,cache,cache,39959,root/html528/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsRealLValue.html,4,['cache'],['cache']
Performance,"t *) const =0;  ; virtual Bool_t FuncTempInfo_IsValid (FuncTempInfo_t *) const =0;  ; virtual void FuncTempInfo_Name (FuncTempInfo_t *, TString &name) const =0;  ; virtual Long_t FuncTempInfo_Property (FuncTempInfo_t *) const =0;  ; virtual UInt_t FuncTempInfo_TemplateMinReqArgs (FuncTempInfo_t *) const =0;  ; virtual UInt_t FuncTempInfo_TemplateNargs (FuncTempInfo_t *) const =0;  ; virtual void FuncTempInfo_Title (FuncTempInfo_t *, TString &title) const =0;  ; virtual Bool_t FunctionDeclId_IsMethod (DeclId_t) const;  ; virtual Int_t GenerateDictionary (const char *classes, const char *includes=nullptr, const char *options=nullptr)=0;  ; virtual TClass * GenerateTClass (ClassInfo_t *classinfo, Bool_t silent=kFALSE)=0;  ; virtual TClass * GenerateTClass (const char *classname, Bool_t emulation, Bool_t silent=kFALSE)=0;  ; virtual void GenericError (const char *) const;  ; virtual void * GetAutoLoadCallBack () const;  ; virtual TClass * GetClass (const std::type_info &typeinfo, Bool_t load) const =0;  ; virtual const char * GetClassSharedLibs (const char *cls, bool skipCore=true)=0;  ; virtual const char * GetCurrentMacroName () const;  ; virtual DeclId_t GetDataMember (ClassInfo_t *cl, const char *name) const =0;  ; virtual DeclId_t GetDataMemberAtAddr (const void *addr) const =0;  ; virtual DeclId_t GetDataMemberWithValue (const void *ptrvalue) const =0;  ; virtual DeclId_t GetDeclId (CallFunc_t *info) const =0;  ; virtual DeclId_t GetDeclId (ClassInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (DataMemberInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (FuncTempInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (MethodInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (TypedefInfo_t *info) const =0;  ; virtual DeclId_t GetEnum (TClass *cl, const char *name) const =0;  ; virtual Long_t GetExecByteCode () const;  ; virtual Int_t GetExitCode () const =0;  ; virtual DeclId_t GetFunction (ClassInfo_t *cl, const char *funcname)=0;  ; virtual void GetFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:14268,load,load,14268,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['load'],['load']
Performance,"t *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLECTION_WRITE_GUARD();; 404 ; 405 Bool_t nodel = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 406 ; 407 if (!nodel && IsOwner()) {; 408 Delete(option);; 409 return;; 410 }; 411 ; 412 // In some case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:11114,cache,cached,11114,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'. In particular those are used to; 597 // implement TObject like methods for non-TObject classes.; 598 Int_t Browse(void *obj, TBrowser *b) const;; 599 void DeleteArray(void *ary, Bool_t dtorOnly = kFALSE);; 600 void DeleteArray(ObjectPtr ary, Bool_t dtorOnly = kFALSE);; 601 void Destructor(void *obj, Bool_t dtorOnly = kFALSE);; 602 void Destructor(ObjectPtr obj, Bool_t dtorOnly = kFALSE);; 603 void *DynamicCast(const TClass *base, void *obj, Bool_t up = kTRUE);; 604 const void *DynamicCast(const TClass *base, const void *obj, Bool_t up = kTRUE);; 605 Bool_t IsFolder(void *obj) const;; 606 ; 607 inline void Streamer(void *obj, TBuffer &b, const TClass *onfile_class = nullptr) const; 608 {; 609 // Inline for performance, skipping one function call.; 610#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 611 fStreamerImpl(this,obj,b,onfile_class);; 612#else; 613 auto t = fStreamerImpl.load();; 614 t(this,obj,b,onfile_class);; 615#endif; 616 }; 617 ; 618 ClassDefOverride(TClass,0) //Dictionary containing class information; 619};; 620 ; 621namespace ROOT {; 622namespace Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:31780,perform,performance,31780,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['perform'],['performance']
Performance,"t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::GetInterpreterStateMarkerunsigned long long GetInterpreterStateMarker() const finalDefinition TCling.h:224; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCallbacks (used to update the list of types)Definition TCling.cxx:3899; TCling::TypedefInfo_PropertyLong_t TypedefInfo_Property(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:90767,load,loading,90767,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loading']
Performance,"t *minfo) const final;  ; std::string MethodInfo_TypeNormalizedName (MethodInfo_t *minfo) const final;  ; void PrintIntro () final;  No-op; see TRint instead. ;  ; Longptr_t ProcessLine (const char *line, EErrorCode *error=nullptr) final;  ; Longptr_t ProcessLineAsynch (const char *line, EErrorCode *error=nullptr);  Let cling process a command line asynch. ;  ; Longptr_t ProcessLineSynch (const char *line, EErrorCode *error=nullptr) final;  Let cling process a command line synchronously, i.e we are waiting it will be finished. ;  ; void RecursiveRemove (TObject *obj) final;  Delete object from cling symbol table so it can not be used anymore. ;  ; void RefreshClassInfo (TClass *cl, const clang::NamedDecl *def, bool alias);  Internal function. Actually do the update of the ClassInfo when seeing. ;  ; void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) final;  Inject the module named ""modulename"" into cling; load all headers. ;  ; bool RegisterPrebuiltModulePath (const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const final;  ; void RegisterTClassUpdate (TClass *oldcl, DictFuncPtr_t dict) final;  Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ;  ; void RegisterTemporary (const cling::Value &value);  Register value as a temporary, extending its lifetime to that of the interpreter. ;  ; void RegisterTemporary (const TInterpreterValue &value);  ; Int_t ReloadAllSharedLibraryMaps () final;  Reload the library map entries coming from all the loaded shared libraries, after first unloading the current ones. ;  ; void ReportDiagnosticsToErrorHandler (bool enable=true) final;  Report ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:28105,load,load,28105,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['load']
Performance,"t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; bool IsFolder () const override;  Return true if more than one leaf or browsables, false otherwise. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:8183,cache,cached,8183,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,2,['cache'],"['cache', 'cached']"
Performance,"t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Execute the specified drawing action on a data set (TDSet). ;  ; Bool_t ExistsDataSet (const char *uri) override;  Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. ;  ; TFileCollection * GetDataSet (const char *uri, const char *=0) override;  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSets (const char *uri="""", const char *=0) override;  lists all datasets that match given uri ;  ; TList * GetListOfQueries (Option_t *opt="""") override;  Get the list of queries. ;  ; TFileCollection * GetStagingStatusDataSet (const char *dataset) override;  Obtains a TFileCollection showing the staging status of the specified dataset. ;  ; TTree * GetTreeHeader (TDSet *tdset) override;  Creates a tree header (a tree with nonexisting files) object for the DataSet. ;  ; TClass * IsA () const override;  ; Int_t Load (const char *macro, Bool_t notOnClient=kFALSE, Bool_t uniqueOnly=kTRUE, TList *wrks=0) override;  Copy the specified macro in the cache directory. ;  ; void Print (Option_t *option="""") const override;  Print status of PROOF-Lite cluster. ;  ; Long64_t Process (const char *dsname, const char *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0, TObject *enl=0) override;  Process a dataset which is stored on the master with name 'dsetname'. ;  ; Long64_t Process (const char *dsname, TSelector *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0, TObject *enl=0) override;  Process with name of dataset and TSelector object. ;  ; Long64_t Process (const char *sel, Long64_t nent, Option_t *o="""") override;  Generic (non-data based) selector processing: the Process() method of the specified selector (.C) or TSelector object is called 'n' times. ;  ; Long64_t Process (TDSet *dset, const char *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0) override;  Process a data set (TDSet) using the specified selector (.C) file. ;  ; Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:2468,cache,cache,2468,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"t *p);  Return the next markup type [TGHtmlElement::NextMarkupType]. ;  ; SHtmlStyle_t PopStyleStack (int tag);  Pop a rendering style off of the stack. ;  ; void PushStyleStack (int tag, SHtmlStyle_t style);  Push a new rendering style onto the stack. ;  ; void Redraw ();  This routine is invoked in order to redraw all or part of the HTML widget. ;  ; void RedrawArea (int left, int top, int right, int bottom);  If any part of the screen needs to be redrawn, then call this routine with the values of a box (in window coordinates) that needs to be redrawn. ;  ; void RedrawBlock (TGHtmlBlock *p);  Redraw the TGHtmlBlock given. ;  ; void RedrawEverything ();  Call this routine to force the entire widget to be redrawn. ;  ; void RedrawText (int y);  Call this routine to cause all of the rendered HTML at the virtual canvas coordinate of Y and beyond to be redrawn. ;  ; void ResetLayoutContext ();  Reset the main layout context in the main widget. ;  ; void ScheduleRedraw ();  Make sure that a call to the Redraw() routine has been queued. ;  ; int SelectionSet (const char *startIx, const char *endIx);  Set selection. ;  ; int SetInsert (const char *insIx);  Set the position of the insertion cursor. ;  ; void SizeAndLink (TGFrame *frame, TGHtmlInput *pElem);  'frame' is the child widget that is used to implement an input element. ;  ; void Sizer ();  Compute the size of all elements in the widget. ;  ; void StringHW (const char *str, int *h, int *w);  Return the height and width of string. ;  ; void TableBgndImage (TGHtmlElement *p);  Set background picture of a html table. ;  ; int TextInsertCmd (int argc, char **argv);  Insert text into text token, or break token into two text tokens. ;  ; TGHtmlElement * TokenByIndex (int N, int flag);  Return a pointer to the Nth TGHtmlElement in the list. ;  ; int Tokenize ();  Process as much of the input HTML as possible. ;  ; void TokenizerAppend (const char *text);  Append text to the tokenizer engine. ;  ; int TokenNumber (TGHtmlEl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:36047,queue,queued,36047,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['queue'],['queued']
Performance,"t *s, Option_t *option, Int_t netopt);  Create a NetFile object using an existing connection (socket s). ;  ; void Init (Bool_t create) override;  Initialize a TNetFile object. ;  ; TNetFile & operator= (const TNetFile &);  ; void Print (Option_t *option) const override;  Print some info about the net file. ;  ; void PrintError (const char *where, Int_t err);  Print error string depending on error code. ;  ; Int_t Recv (Int_t &status, EMessageTypes &kind);  Return status from rootd server and message kind. ;  ; Int_t SysClose (Int_t fd) override;  Close currently open file. ;  ; Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode) override;  Open a remote file. Requires fOption to be set correctly. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Return file stat information. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All argumen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:31944,cache,cache,31944,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['cache'],['cache']
Performance,"t *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Hand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:4830,cache,cache,4830,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['cache'],['cache']
Performance,"t * ; wrks = 0 . ). protected . Start up PROOF workers. ; Definition at line 489 of file TProofLite.cxx. ◆ ShowCache(). void TProofLite::ShowCache ; (; Bool_t ; all = kFALSE). overridevirtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented from TProof.; Definition at line 1508 of file TProofLite.cxx. ◆ ShowData(). void TProofLite::ShowData ; (; ). overridevirtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented from TProof.; Definition at line 2479 of file TProofLite.cxx. ◆ ShowDataDir(). void TProofLite::ShowDataDir ; (; const char * ; dirname). private . List contents of the data directory 'dirname'. ; Definition at line 2495 of file TProofLite.cxx. ◆ ShowDataSetCache(). void TProofLite::ShowDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2292 of file TProofLite.cxx. ◆ ShowDataSets(). void TProofLite::ShowDataSets ; (; const char * ; uri = """", . const char * ; opt = 0 . ). overridevirtual . Shows datasets in locations that match the uri By default shows the user's datasets and global ones. ; Reimplemented from TProof.; Definition at line 2070 of file TProofLite.cxx. ◆ Streamer(). void TProofLite::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProof. ◆ StreamerNVirtual(). void TProofLite::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 170 of file TProofLite.h. ◆ VerifyDataSet(). Int_t TProofLite::VerifyDataSet ; (; const char * ; uri, . const char * ; optStr = 0 . ). overridevirtual . Verify if all files in the specified dataset are available. ; Print a list and return the number of missing files. ; Reimplemented from TProof.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:67121,cache,cache,67121,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"t * GetTestingEvent (Long64_t ievt) const;  ; Double_t GetTestTime () const;  ; const TString & GetTestvarName () const;  ; virtual Double_t GetTrainingEfficiency (const TString &);  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; virtual const std::vector< Float_t > & GetTrainingHistory (const char *);  ; UInt_t GetTrainingROOTVersionCode () const;  ; TString GetTrainingROOTVersionString () const;  calculates the ROOT version string from the training version code on the fly ;  ; UInt_t GetTrainingTMVAVersionCode () const;  ; TString GetTrainingTMVAVersionString () const;  calculates the TMVA version string from the training version code on the fly ;  ; Double_t GetTrainTime () const;  ; TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true);  ; const TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true) const;  ; TString GetWeightFileName () const;  retrieve weight file name ;  ; Double_t GetXmax (Int_t ivar) const;  ; Double_t GetXmin (Int_t ivar) const;  ; Bool_t HasMVAPdfs () const;  ; void InitIPythonInteractive ();  ; Bool_t IsModelPersistence () const;  ; virtual Bool_t IsSignalLike ();  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event would be selected as signal or background ;  ; virtual Bool_t IsSignalLike (Double_t mvaVal);  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event with this mva output value would be selected as signal or background ;  ; Bool_t IsSilentFile () const;  ; TDirectory * MethodBaseDir () const;  returns the ROOT directory where all instances of the corresponding MVA method are stored ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  call the Optimizer with the set of parameters and ranges that are meant to be tuned.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodC50.html:8956,tune,tuned,8956,doc/master/classTMVA_1_1MethodC50.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodC50.html,4,['tune'],['tuned']
Performance,"t * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:28584,cache,cache,28584,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,7,['cache'],['cache']
Performance,"t 90047b0cba6fd295f5c5722749a0d043fbc11ea5.; Do not insert macro definition of ROOTCLING into the pch. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258; Fix detection of errors that appears in nested TTreeFormula ROOT-8218; Avoid autoparse looking for default constructor in TTreeCloner::CopyStreamerInfos(). Bugs fixed in this release. [ROOT-6753] - PROOF-Lite doesn’t find TSelector type from an already loaded library; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-8038] - [patch] “for e in getSTLLikeCollection()” crashes pyroot; [ROOT-8166] - Update INSTALL to reflect CMake; [ROOT-8184] - Error building XrdSysPthread with GCC 6.1; [ROOT-8197] - rootcp not preserving kSingleKey; [ROOT-8205] - TSystem::ExpandPathName is not thread safe; [ROOT-8207] - tmva/tmva/CMakeLists.txt unnecessarily includes TreeViewer; [ROOT-8217] - TMinuit::TMinuit data race; [ROOT-8218] - Detection of TTreeFormula without breaking formula; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6; [ROOT-8226] - CMake 3.5.2: circular dependency libMathMore; [ROOT-8231] - _GLIBCXX_USE_CXX11_ABI=0 should be propagated into root-config –cflags. Release 6.06/08; Released on September 1, 2016; Core. Prevent race condition in the creation of the list of base classes (but avoiding to publish the list too early). Hist. Resolved issues with inconsistent handling of the ‘gaus’ function in TFormula [[ROT-8105]]. Bugs fixed in this release. [ROOT-8105] - TFormula does not always handle ‘gaus’ correctly.; [ROOT-8239] - “python: free(): invalid next size (fast)” in PyROOT 6.06.02 and patches; [ROOT-8270] - C++14; [ROOT-8293] - CMake does not find Castor libraries; [ROOT-8328] - patches used by art; [ROOT-8307] - Crash when leaving ROOT from GUI menu item.; [ROOT-8332] - support linked libraries paths with spaces in aclic. HEAD of the v6-06-00-patches branch; Changes will be part of the future 6.06/10. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:32719,race condition,race condition,32719,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['race condition'],['race condition']
Performance,"t ; (; Option_t * ; option = """"); const. inlinefinalvirtual . Print all objects in the file. ; Reimplemented from TFile.; Definition at line 82 of file TXMLFile.h. ◆ ProduceFileNames(). void TXMLFile::ProduceFileNames ; (; const char * ; filename, . TString & ; fname, . TString & ; dtdname . ). staticprotected . function produces pair of xml and dtd file names ; Definition at line 424 of file TXMLFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TXMLFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). inlinefinalvirtual . Read a buffer from the file. ; This is the basic low level read operation. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 83 of file TXMLFile.h. ◆ ReadBuffer() [2/2]. Bool_t TXMLFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). inlinefinalvirtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 84 of file TXMLFile.h. ◆ ReadFree(). void TXMLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 85 of file TXMLFile.h. ◆ ReadFromFile(). Bool_t TXMLFile::ReadFromFile ; (; ). protected . read document from file Now full content of document reads into the memory Then document decomposed to separate keys and streamer info structures All irrelevant data will be cleaned ; Definition at line 559 of file TXMLFile.cxx. ◆ ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:65314,cache,cache,65314,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['cache'],['cache']
Performance,"t = (dynamic_cast<MethodCategory *>(im)); // DSMTEST; 433 if (!methCat) { // DSMTEST; 434 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Factory""; 435 << Endl; // DSMTEST; 436 return nullptr;; 437 }; 438 if (fModelPersistence); 439 methCat->SetWeightFileDir(fileDir);; 440 methCat->SetModelPersistence(fModelPersistence);; 441 methCat->fDataSetManager = loader->GetDataSetInfo().GetDataSetManager(); // DSMTEST; 442 methCat->SetFile(fgTargetFile);; 443 methCat->SetSilentFile(IsSilentFile());; 444 } // DSMTEST; 445 ; 446 if (!method->HasAnalysisType(fAnalysisType, loader->GetDataSetInfo().GetNClasses(),; 447 loader->GetDataSetInfo().GetNTargets())) {; 448 Log() << kWARNING << ""Method "" << method->GetMethodTypeName() << "" is not capable of handling "";; 449 if (fAnalysisType == Types::kRegression) {; 450 Log() << ""regression with "" << loader->GetDataSetInfo().GetNTargets() << "" targets."" << Endl;; 451 } else if (fAnalysisType == Types::kMulticlass) {; 452 Log() << ""multiclass classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 453 } else {; 454 Log() << ""classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 455 }; 456 return 0;; 457 }; 458 ; 459 if (fModelPersistence); 460 method->SetWeightFileDir(fileDir);; 461 method->SetModelPersistence(fModelPersistence);; 462 method->SetAnalysisType(fAnalysisType);; 463 method->SetupMethod();; 464 method->ParseOptions();; 465 method->ProcessSetup();; 466 method->SetFile(fgTargetFile);; 467 method->SetSilentFile(IsSilentFile());; 468 ; 469 // check-for-unused-options is performed; may be overridden by derived classes; 470 method->CheckSetup();; 471 ; 472 if (fMethodsMap.find(datasetname) == fMethodsMap.end()) {; 473 MVector *mvector = new MVector;; 474 fMethodsMap[datasetname] = mvector;; 475 }; 476 fMethodsMap[datasetname]->push_back(method);; 477 return method;; 478}; 479 ; 480//////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:18736,load,loader,18736,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"t = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); Int_tCopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQuery",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:21088,cache,cachedir,21088,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,2,['cache'],['cachedir']
Performance,"t = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; static voidRooAbsReal::printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidRooAbsReal::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsArg::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooDerivative(); RooDerivative(const RooDerivative& other, const char* name = 0); RooDerivative(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:22863,cache,cache,22863,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,4,['cache'],['cache']
Performance,"t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:41994,cache,cache,41994,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,2,['cache'],"['cache', 'cached']"
Performance,"t == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVersionCode2Int(gLibraryVersion[gLibraryVersionIdx]);; 1950 Error(""Load"", ""version mismatch, %s = %d, ROOT = %d"",; 1951 path, v, gROOT->GetVersionInt());; 1952 ret = -2;; 1953 gLibraryVersion[gLibraryVersionIdx] = 0;; 1954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:63913,load,loadedlibs,63913,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loadedlibs']
Performance,"t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; std::vector< std::vector< Matrix_t > > fBiasUpdates;  The accumulation of the past Biases for performing updates. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWeightUpdates;  The accumulation of the past Weights for performing updates. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor2;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/RMSProp.h>. Inheritance diagram for TMVA::DNN::TRMSProp< Architectu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:3645,perform,performing,3645,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['perform'],['performing']
Performance,"t >::SetBatchSize ; (; Scalar_t ; rate). inline . Definition at line 168 of file Minimizers.h. ◆ SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetConvergenceSteps ; (; size_t ; steps). inline . Definition at line 165 of file Minimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 167 of file Minimizers.h. ◆ SetTestInterval(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetTestInterval ; (; size_t ; interval). inline . Definition at line 166 of file Minimizers.h. ◆ Step() [1/2]. template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Step ; (; Net_t & ; master, . std::vector< Net_t > & ; nets, . std::vector< TBatch< Architecture_t > > & ; batches . ). inline . Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 374 of file Minimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Step ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). inline . Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 331 of file Minimizers.h. ◆ StepLoss() [1/2]. template<typename A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:9104,optimiz,optimization,9104,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['optimiz'],['optimization']
Performance,"t >::max()) override;  Load values from dataset 't' into this data collection, optionally selecting events using 'select' RooFormulaVar. ;  ; void loadValues (const TTree *t, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, Int_t nStart=0, Int_t nStop=2000000000);  Load values from tree 't' into this data collection, optionally selecting events using the RooFormulaVar 'select'. ;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  Merge columns of supplied data set(s) with this data set. ;  ; Int_t numEntries () const override;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void Reset (Option_t *option=nullptr);  Interface function to TTree::Reset. ;  ; void resetBuffers () override;  ; void resetCache () override;  Remove tree with values of cached observables and clear list of cached observables. ;  ; void restoreAlternateBuffers ();  ; const RooArgSet & row ();  ; void setArgStatus (const RooArgSet &set, bool active) override;  Activate or deactivate the branch status of the TTree branch associated with the given set of dataset observables. ;  ; void setExternalWeightArray (const double *arrayWgt, const double *arrayWgtErrLo, const double *arrayWgtErrHi, const double *arraySumW2) override;  ; void Streamer (TBuffer &) override;  Stream an object of class RooTreeDataStore. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  ; TTree & tree ();  ; const TTree * tree () const override;  ; double weight () const override;  Return the weight of the n-th data point (n='index') in memory. ;  ; virtual double weight () const=0;  ; double weight (Int_t index) const;  ; void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:5988,cache,cached,5988,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,2,['cache'],['cached']
Performance,"t Double_t * ; a, . const Double_t * ; b, . Int_t ; maxpts, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). virtual . This function computes, to an attempted specified accuracy, the value of the integral. ; Parameters. [in]nNumber of dimensions [2,15] ; [in]a,bOne-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100053,perform,performed,100053,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['perform'],['performed']
Performance,"t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:23934,cache,cache,23934,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:39991,Load,LoadTree,39991,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,1,['Load'],['LoadTree']
Performance,"t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:50163,cache,cache,50163,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,10,['cache'],['cache']
Performance,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. TGeoParallelWorld * CreateParallelWorld(const char* name); Create a parallel world for prioritized navigation. This can be populated; with physical nodes and can be navigated independently using its API.; In case the flag SetUseParallelWorldNav is set, any navigation query in the; main geometry is checked against the parallel geometry, which gets priority; in case of overlaps with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:71477,load,loaded,71477,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,6,['load'],['loaded']
Performance,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_t * GetIntBuffer(Int_t length); Get a temporary buffer of Int_t*. Double_t * GetDblBuffer(Int_t length); Get a temporary buffer of Double_t*. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. Bool_t IsLoopingVolumes() const; --- private methods. {return fLoopVolumes;}. void SetLoopVolumes(Bool_t flag = kTRUE); {fLoopVolumes=flag;}. Int_t GetNmany() const; {return fCurrentNavigator->GetNmany();}. Bool_t IsFolder() const; --- visual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:68238,load,loaded,68238,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,2,['load'],['loaded']
Performance,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_t * GetIntBuffer(Int_t length); Get a temporary buffer of Int_t*. Double_t * GetDblBuffer(Int_t length); Get a temporary buffer of Double_t*. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. Bool_t IsLoopingVolumes() const; --- private methods. {return fLoopVolumes;}. void SetLoopVolumes(Bool_t flag = kTRUE); {fLoopVolumes=flag;}. ThreadData_t& GetThreadData() const. Int_t GetNmany() const; {return GetCurrentNavigator()->GetNmany",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:69949,load,loaded,69949,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,2,['load'],['loaded']
Performance,"t Name = TrainingHistory_PyKeras_'accuracy', Entries= 0, Total sum= 6.25938; TH1.Print Name = TrainingHistory_PyKeras_'loss', Entries= 0, Total sum= 7.32887; TH1.Print Name = TrainingHistory_PyKeras_'val_accuracy', Entries= 0, Total sum= 5.40937; TH1.Print Name = TrainingHistory_PyKeras_'val_loss', Entries= 0, Total sum= 7.21788; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.00573 sec ; Factory : Test method: TMVA_DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.023 sec ; Factory : Test method: TMVA_CNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.149 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:37881,perform,performance,37881,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance,"t RGB value for the pixel in the ""color"" structure. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Returns the pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask) override;  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; void RaiseWindow (Window_t id) override;  Raises the specified window to the top of the stack so that no sibling window obscures it. ;  ; void ReadGIF (Int_t x0, Int_t y0, const char *file);  ; Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data) override;  Reads picture data from file ""filename"" and store it in ""ret_data"". ;  ; void RemoveWindow (ULongptr_t qwid) override;  Removes the created by Qt window ""qwid"". ;  ; void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y) override;  If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ;  ; Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) override;  Requests Locator position. ;  ; Int_t RequestString (Int_t x, Int_t y, char *text) override;  Requests string: text is displayed and can be edited with Emacs-like keybinding. ;  ; void RescaleWindow (Int_t wid, UInt_t w, UInt_t h) override;  Rescales the window ""wid"". ;  ; void ResetAttFill (Option_t *option="""") override;  Reset this fill attributes to default values. ;  ; void ResetAttLine (Option_t *option="""") override;  Reset this line attributes to default values. ;  ; void ResetAttMarker (Option_t *toption="""") override;  Reset this marker attributes to the default values. ;  ; void ResetAttText (Option_t *toption="""") override;  Reset this text attributes to default values. ;  ; Int_t ResizePixmap (Int_t wid, UInt_t w, UInt_t h) override;  Resizes the speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:20002,perform,performs,20002,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['perform'],['performs']
Performance,"t ROOT::RWebWindow::GetOperationTmout ; (; ); const. inline . Returns timeout for synchronous WebWindow operations. ; Definition at line 351 of file RWebWindow.hxx. ◆ GetRelativeAddr() [1/2]. std::string RWebWindow::GetRelativeAddr ; (; const RWebWindow & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1270 of file RWebWindow.cxx. ◆ GetRelativeAddr() [2/2]. std::string RWebWindow::GetRelativeAddr ; (; const std::shared_ptr< RWebWindow > & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1260 of file RWebWindow.cxx. ◆ GetSendQueueLength(). int RWebWindow::GetSendQueueLength ; (; unsigned ; connid); const. Returns send queue length for specified connection. ; Parameters. connidconnection id, 0 - maximal value for all connections is returned If wrong connection id specified, -1 is return . Definition at line 1509 of file RWebWindow.cxx. ◆ GetServer(). THttpServer * RWebWindow::GetServer ; (; ). Return THttpServer instance serving requests to the window. ; Definition at line 181 of file RWebWindow.cxx. ◆ GetUrl(). std::string RWebWindow::GetUrl ; (; bool ; remote = true). Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ; Parameters. remoteis true, real HTTP server will be started automatically and widget can be connected from the web browser. If; remoteis false, HTTP server will not be started and window can be connected only from ROOT application itself. !!! WARNING - do not invoke this method without real need, each URL consumes resources in widget and in http server .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:33295,queue,queue,33295,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"t ROOT::RWebWindowWSHandler::CanServeFiles ; (; ); const. inlineoverridevirtual . returns true when window allowed to serve files relative to default page ; Reimplemented from THttpWSHandler.; Definition at line 138 of file RWebWindowWSHandler.hxx. ◆ CompleteWSSend(). void ROOT::RWebWindowWSHandler::CompleteWSSend ; (; UInt_t ; wsid). inlineoverridevirtual . React on completion of multi-threaded send operation. ; Reimplemented from THttpWSHandler.; Definition at line 155 of file RWebWindowWSHandler.hxx. ◆ GetBoolEnv(). int RWebWindowWSHandler::GetBoolEnv ; (; const std::string & ; name, . int ; dflt = -1 . ). static . Parse boolean gEnv variable which should be ""yes"" or ""no"". ; Returns1 for true or 0 for false Returns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 47 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandler.hxx. ◆ ProcessBatchHolder(). Bool_t ROOT::RWebWindowWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineoverrideprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented from THttpWSHandler.; Definition at line 33 of file RWebWindowWSHandler.hxx. ◆ ProcessWS(). Bool_t ROOT::RWebWindowWSHandler::ProcessWS ; (; THttpCallArg * ; arg). inlineoverridevirtual . Process websocket request - called from THttpServer thread THttpWSHandler interface. ; Implements THttpWSHandler.; Definition at line 142 of file RWebWindowWSHandler.hxx. ◆ VerifyDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html:16462,load,loaded,16462,doc/v632/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html,1,['load'],['loaded']
Performance,"t ROOT::RWebWindowWSHandler::CanServeFiles ; (; ); const. inlineoverridevirtual . returns true when window allowed to serve files relative to default page ; Reimplemented from THttpWSHandler.; Definition at line 138 of file RWebWindowWSHandler.hxx. ◆ CompleteWSSend(). void ROOT::RWebWindowWSHandler::CompleteWSSend ; (; UInt_t ; wsid). inlineoverridevirtual . React on completion of multi-threaded send operation. ; Reimplemented from THttpWSHandler.; Definition at line 155 of file RWebWindowWSHandler.hxx. ◆ GetBoolEnv(). int RWebWindowWSHandler::GetBoolEnv ; (; const std::string & ; name, . int ; dflt = -1 . ). static . Parse boolean gEnv variable which should be ""yes"" or ""no"". ; Returns1 for true or 0 for false Returns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 48 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandler.hxx. ◆ ProcessBatchHolder(). Bool_t ROOT::RWebWindowWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineoverrideprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented from THttpWSHandler.; Definition at line 33 of file RWebWindowWSHandler.hxx. ◆ ProcessWS(). Bool_t ROOT::RWebWindowWSHandler::ProcessWS ; (; THttpCallArg * ; arg). inlineoverridevirtual . Process websocket request - called from THttpServer thread THttpWSHandler interface. ; Implements THttpWSHandler.; Definition at line 142 of file RWebWindowWSHandler.hxx. ◆ VerifyDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html:16455,load,loaded,16455,doc/master/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html,1,['load'],['loaded']
Performance,"t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReadBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile. If ReadBuffers; is supported by xrootd it will try to get the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(const Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(const Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClose (see paren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:29525,latency,latency,29525,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,4,['latency'],['latency']
Performance,"t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 41101 2011-10-03 16:23:48Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23901,cache,cache,23901,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['cache'],['cache']
Performance,"t RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps! ; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooComp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:9143,cache,cached,9143,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,8,"['cache', 'load']","['cached', 'loading']"
Performance,"t RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tsyncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:40949,Cache,CacheMode,40949,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['Cache'],['CacheMode']
Performance,"t RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsPdf::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; virtual Bool_tRooResolutionModel::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateCoefficients(RooAddModel::CacheElem& cache, const RooArgSet* nset) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:36292,cache,cache,36292,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,4,['cache'],['cache']
Performance,"t RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:45999,optimiz,optimization,45999,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,4,['optimiz'],['optimization']
Performance,"t RooArgSet& vars, const char* wgtVarName = 0); RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooVectorDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); const RooVectorDataStore*cache() const; virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:1840,cache,cacheOwner,1840,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,2,['cache'],['cacheOwner']
Performance,"t RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooThresholdCategory&operator=(const RooThresholdCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:11283,optimiz,optimizeCacheMode,11283,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,4,['optimiz'],['optimizeCacheMode']
Performance,"t RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringRooAbsCachedPdf::histNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:37324,optimiz,optimizeDirtyHook,37324,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,12,['optimiz'],['optimizeDirtyHook']
Performance,"t RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:19677,optimiz,optimizeDirtyHook,19677,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"t RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:38679,optimiz,optimizeDirtyHook,38679,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"t RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Bool_tRooAbsArg::inhibitDirty() const; voidinitializeFromCmdArgList(const RooArgSet& fullPdfSet, const RooLinkedList& l); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; RooAbsReal*makeCondPdfRatioCorr(RooAbsReal& term, const RooArgSet& termNset, const RooArgSet& termImpSet, const char* normRange, const char* refRange) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; const char*makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:38547,optimiz,optimizeDirtyHook,38547,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,6,['optimiz'],['optimizeDirtyHook']
Performance,"t TFileCacheWrite::Flush ; (; ). virtual . Flush the current write buffer to the file. ; Returns kTRUE in case of error. ; Definition at line 79 of file TFileCacheWrite.cxx. ◆ GetBytesInCache(). virtual Int_t TFileCacheWrite::GetBytesInCache ; (; ); const. inlinevirtual . Definition at line 38 of file TFileCacheWrite.h. ◆ IsA(). TClass * TFileCacheWrite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 44 of file TFileCacheWrite.h. ◆ operator=(). TFileCacheWrite & TFileCacheWrite::operator= ; (; const TFileCacheWrite & ; ). privatedelete . ◆ Print(). void TFileCacheWrite::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print class internal structure. ; Reimplemented from TObject.; Definition at line 94 of file TFileCacheWrite.cxx. ◆ ReadBuffer(). Int_t TFileCacheWrite::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Called by the read cache to check if the requested data is not in the write cache buffer. ; Returns -1 if data not in write cache, 0 otherwise. ; Definition at line 108 of file TFileCacheWrite.cxx. ◆ SetFile(). void TFileCacheWrite::SetFile ; (; TFile * ; file). virtual . Set the file using this cache. ; Any write not yet flushed will be lost. ; Definition at line 153 of file TFileCacheWrite.cxx. ◆ Streamer(). void TFileCacheWrite::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileCacheWrite::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 44 of file TFileCacheWrite.h. ◆ WriteBuffer(). Int_t TFileCacheWrite::WriteBuffer ; (; const char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Write buffer at position pos in the write buffer. ; The function returns 1 if the buffer has been successfully entered into the write buffer. The function returns 0 in case WriteBuffer() was recusively ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:14038,cache,cache,14038,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,2,['cache'],['cache']
Performance,"t TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:12690,cache,cache,12690,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,10,['cache'],['cache']
Performance,"t TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:3676,cache,cache,3676,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,1,['cache'],['cache']
Performance,"t TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); Create a THnSparse object from a histogram deriving from TH1. void FillExMap(); We have been streamed; set up fBins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparse.html:16252,Perform,Perform,16252,root/html532/THnSparse.html,https://root.cern,https://root.cern/root/html532/THnSparse.html,1,['Perform'],['Perform']
Performance,"t TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; AuthorHarshal Shende ; Definition in file TMVA_CNN_Classification.py. tutorialstmvaTMVA_CNN_Classification.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:18438,multi-thread,multi-threading,18438,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['multi-thread'],['multi-threading']
Performance,"t TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<std::vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:48944,load,loadDataSet,48944,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,2,['load'],['loadDataSet']
Performance,"t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:46357,cache,cache,46357,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; Additional files to be uploaded (or updated, if needed) can be specified; after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; If existing in the same directory, a header basename(macro).h or .hh, is also; uploaded.; The default is to load the macro also on the client; notOnClient can be used; to avoid loading on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'libpath' to the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'lib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:68683,load,load,68683,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,6,['load'],"['load', 'loading']"
Performance,"t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; Additional files to be uploaded (or updated, if needed) can be specified; after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; If existing in the same directory, a header basename(macro).h or .hh, is also; uploaded.; The default is to load the macro also on the client; notOnClient can be used; to avoid loading on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); Add 'libpath' to the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:78548,load,load,78548,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,12,['load'],"['load', 'loading']"
Performance,"t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:29733,optimiz,optimize,29733,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,9,['optimiz'],['optimize']
Performance,"t a typical user session should be at most: root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#define I(x, y, z); And also support for MakeSharedLibs() and MakeExe().; (the ... have to be replaced by the actual values and are here only to shorten this comment).; Note that the default behavior is to remove libraries when closing ROOT, ie TSystem::CleanCompiledMacros() is called in the TROOT destructor. The default behavior of .L ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:45396,load,loaded,45396,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"t accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. » Last changed: Mon Dec 7 13:47:00 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_vector_double___.html:4268,cache,cacheSize,4268,root/html526/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_vector_double___.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"t after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:62646,load,load,62646,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"t alpha = 1.); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1, Float_t alpha = 1.); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.005); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.04); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.03); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size = 0.04); Set size of axis title; The size is expressed in per cent of the pad width. void SetTitleColor(Color_t color = 1); Set color of axis title. void SetTitleFont(Style_t font = 62); Set the title font. void Streamer(TBuffer& ); Stream an object of class TAttAxis. TAttAxis(). Int_t GetNdivisions() const; {return fNdivisions;}. Color_t GetAxisColor() const; {return fAxisColor;}. Color_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttAxis.html:3850,optimiz,optimized,3850,root/html534/TAttAxis.html,https://root.cern,https://root.cern/root/html534/TAttAxis.html,2,['optimiz'],['optimized']
Performance,"t also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18776,cache,cache,18776,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,2,['cache'],['cache']
Performance,"t also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Int_t GetThreadId() const; {return fThreadId;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:19127,cache,cache,19127,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,8,['cache'],['cache']
Performance,"t also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions;  TListOfEnums (const TListOfEnums &)=delete;  Represent interpreter state when we last did a full load. ;  ; void Load ();  Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ;  ; void MapObject (TObject *obj);  Add pair<id, object> to the map of functions and their ids. ;  ; TListOfEnums & operator= (const TListOfEnums &)=delete;  ; void SetClass (TClass *cl);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TEnum *e);  Mark enum 'e' as being unloaded. ;  ; void UnmapObject (TObject *obj);  Remove a pair<id, object> from the map of functions and their ids. ;  . Private Attributes; TClass * fClass;  ; TExMap * fIds;  Context of this list. Not owned. ;  ; Bool_t fIsLoaded;  Holder of TEnum for unloaded Enums. ;  ; ULong64_t fLastLoadMarker;  Mark whether Load was executed. ;  ; THashList * fUnloaded;  Map from DeclId_t to TEnum*. ;  . Friends; class TClass;  ; class TCling;  ; class TProtoClass;  ; class TROOT;  . Additional Inherited Members;  Protected Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:20882,load,load,20882,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['load'],['load']
Performance,"t an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058031,load,loaded,1058031,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Load', 'load']","['Load', 'loaded']"
Performance,"t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader->AddSignalTree ( signalTree, signalWeight );; loader->AddBackgroundTree( backgroundTree, backgroundWeight );; ; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; //loader->SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; // To also specify the number of testing events, use:; ; loader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=7000:nTrain_Background=7000:SplitMode=Random:NormMode=NumEvents:!V"" );; ; /***; ## Booking Methods; ; Here we book the TMVA methods. We book first a Likelihood based on KDE (Kernel Density Estimation), a Fischer discriminant, a BDT; and a shallow neural network; ; */; ; ; // Likelihood (""naive Bayes estimator""); if (useLikelihood) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""Likelihood"",; ""H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; }; // Use a kernel density estimator to approximate the PDFs; if (useLikelihoodKDE) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""LikelihoodKDE"",; ""!H:!V:!TransformOutput:PDFInterpol=KDE:KDEtype=Gauss:KDEiter=Adaptive:KDEFineFactor=0.3:KDEborder=None:NAvEvtPerBin=50"" );; ; }; ; // Fisher discriminant (same as LD); if (useFisc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:61272,load,loader,61272,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['load'],['loader']
Performance,"t base class for p.d.f.s that need or want to cache their evaluate() output in a RooHistPdf defined in terms of the used observables. More...;  ; class  RooAbsCachedReal;  Abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables. More...;  ; class  RooAbsCacheElement;  Abstract base class for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:1961,perform,performing,1961,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['perform'],['performing']
Performance,"t be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition at line 81 of file h1analysisTreeReader.h. ◆ SetInputList(). void h1analysisTreeReader::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 72 of file h1analysisTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:16407,load,loaded,16407,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,1,['load'],['loaded']
Performance,"t be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:57227,cache,cached,57227,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,14,['cache'],"['cache', 'cached']"
Performance,"t branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:133371,cache,cachesize,133371,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['cache'],['cachesize']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPGenDecay.html:39523,cache,cache,39523,root/html526/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPGenDecay.html:40097,cache,cache,40097,root/html528/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPGenDecay.html:40374,cache,cache,40374,root/html530/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPGenDecay.html:40777,cache,cache,40777,root/html532/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:4189,perform,performance,4189,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,10,['perform'],['performance']
Performance,"t can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Bool_t checkObservables(const RooArgSet* nset) const; Obsolete. RooAbsPdf::ExtendMode extendMode() const; If this product contains exactly one extendable p.d.f return the extension abilities of; that p.d.f, otherwise return CanNotBeExtended. Double_t expectedEvents(const RooArgSet* nset) const; Return the expected number of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:53385,optimiz,optimized,53385,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,10,['optimiz'],['optimized']
Performance,"t can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will destroy the contents of the Matrix!; 531 */; 532 bool Det(T& det);; 533 ; 534 /**; 535 determinant of square Matrix via Dfact.; 536 Return true when the calculation is successful.; 537 \param det will contain the calculated determinant value; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:17495,perform,performing,17495,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['perform'],['performing']
Performance,"t char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9123,optimiz,optimization,9123,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"t char *datamember) constTClass; GetDataMemberOffset(const char *membername) constTClass; GetDeclFileLine() constTClassinline; GetDeclFileName() constTClass; GetDeclIdMap()TClassprivatestatic; GetDelete() constTClass; GetDeleteArray() constTClass; GetDestructor() constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9358,load,load,9358,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"t char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::UpdateBranchesvirtual void UpdateBranches(TTree *tree)Update pointer to current Tree and recompute pointers to the branches in the cache.Definition TTreeCache.cxx:2211; TTreeCache::ResetCachevirtual void ResetCache()This will simply clear the cache.Definition TTreeCache.cxx:2040; TTree::TClusterIteratorHelper class to iterate over cluster of baskets.Definition TTree.h:270; TTree::TFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends.Definition TTree.h:188; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::AddFriendvirtual TFriendElement * AddFriend(const char *treename, const char *filename="""")Add a TFriendElement to the list of friends.Definition TTree.cxx:1332; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:143547,cache,cache,143547,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['cache'],['cache']
Performance,"t char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:49650,load,loaded,49650,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['load'],['loaded']
Performance,"t char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static Int_t AssertDataSet (TDSet *dset, TList *input, TDataSetManager *mgr, TString &emsg);  Make sure that dataset is in the form to be processed. ;  ; static void AssertMacroPath (const char *macro);  Make sure that the directory path contained by macro is in the macro path. ;  ; static Bool_t GetFileInCmd (const char *cmd, TString &fn);  Static method to extract the filename (if any) form a CINT command. ;  ; static Int_t GetInputData (TList *input, const char *cachedir, TString &emsg);  Get the input data from the file defined in the input list. ;  ; static Int_t SaveInputData (TQueryResult *qr, const char *cachedir, TString &emsg);  Save input data file from 'cachedir' into the sandbox or create a the file with input data objects. ;  ; static Int_t SendInputData (TQueryResult *qr, TProof *p, TString &emsg);  Send the input data file to the workers. ;  ; static void * SlaveStartupThread (void *arg);  ; static void SystemCmd (const char *cmd, Int_t fdout);  Exec system command 'cmd'. If fdout > -1, append the output to fdout. ;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:40951,cache,cachedir,40951,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['cachedir']
Performance,"t char *path) : TNamed(path, """"); 93{; 94 if (!path[0]) {; 95 Error(""ctor"", ""path not valid"");; 96 return;; 97 }; 98 fLevel = 0;; 99 fMatrices = new TObjArray(30);; 100 fNodes = new TObjArray(30);; 101 fMatrixOrig = nullptr;; 102 SetPath(path);; 103 SetVisibility(kTRUE);; 104 SetVisibleFull(kFALSE);; 105 SetIsVolAtt(kTRUE);; 106 SetAligned(kFALSE);; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Destructor; 111 ; 112TGeoPhysicalNode::~TGeoPhysicalNode(); 113{; 114 if (fMatrices) {; 115 fMatrices->Delete();; 116 delete fMatrices;; 117 }; 118 if (fNodes); 119 delete fNodes;; 120 if (fMatrixOrig); 121 delete fMatrixOrig;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////////; 125/// Align a physical node with a new relative matrix/shape.; 126/// Example: /TOP_1/A_1/B_1/C_1; 127/// node->Align(transl_1, box) will perform:; 128/// - change RELATIVE translation of C_1 node (with respect to its; 129/// container volume B) to transl_1; 130/// - change the shape of the C volume; 131/// *NOTE* The operations will affect ONLY the LAST node in the branch. All; 132/// volumes/nodes in the branch represented by this physical node are; 133/// CLONED so the operation does not affect other possible replicas.; 134 ; 135Bool_t TGeoPhysicalNode::Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check, Double_t ovlp); 136{; 137 if (!newmat && !newshape); 138 return kFALSE;; 139 if (TGeoManager::IsLocked()) {; 140 Error(""Align"", ""Not performed. Geometry in LOCKED mode !"");; 141 return kFALSE;; 142 }; 143 if (newmat == gGeoIdentity) {; 144 Error(""Align"", ""Cannot align using gGeoIdentity. Use some default matrix constructor to represent identities."");; 145 return kFALSE;; 146 }; 147 TGeoNode *node = GetNode();; 148 if (node->IsOffset()) {; 149 Error(""Align"", ""Cannot align division nodes: %s\n"", node->GetName());; 150 return kFALSE;; 151 }; 152 // Refresh the node since other Align calls ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:4260,perform,perform,4260,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['perform'],['perform']
Performance,"t char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for fix bin size 2-D histograms. ;  ; virtual Int_t BufferFill (Double_t x, Double_t y, Double_t w);  accumulate arguments in buffer. ;  ; Int_t BufferFill (Double_t, Double_t) override;  accumulate arguments in buffer. ;  ; virtual void DoFitSlices (bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr);  ; virtual TProfile * DoProfile (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  ; virtual TH1D * DoProjection (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ; Int_t Fill (const char *, Double_t) override;  Increment bin with namex with a weight w. ;  ; Int_t Fill (Double_t) override;  Invalid Fill method. ;  ; Double_t Interpolate (Double_t x) const override;  illegal for a TH2 ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input arr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:47407,perform,performing,47407,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,7,['perform'],['performing']
Performance,"t char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for fix bin size 2-D histograms. ;  ; virtual Int_t BufferFill (Double_t x, Double_t y, Double_t w);  accumulate arguments in buffer. ;  ; Int_t BufferFill (Double_t, Double_t) override;  accumulate arguments in buffer. ;  ; virtual void DoFitSlices (bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr);  ; virtual TProfile * DoProfile (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  ; virtual TH1D * DoProjection (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:56128,perform,performing,56128,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['perform'],['performing']
Performance,"t char * GetTypeName () const override;  Returns name of leaf type. ;  ; Double_t GetValue (Int_t i=0) const override;  Returns current value of leaf. ;  ; Long64_t GetValueLong64 (Int_t i=0) const override;  ; LongDouble_t GetValueLongDouble (Int_t i=0) const override;  Returns current value of leaf. ;  ; void * GetValuePointer () const override;  ; void Import (TClonesArray *list, Int_t n) override;  Import element from ClonesArray into local leaf buffer. ;  ; bool IncludeRange (TLeaf *) override;  Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ;  ; TClass * IsA () const override;  ; void PrintValue (Int_t i=0) const override;  Prints leaf value. ;  ; void ReadBasket (TBuffer &b) override;  Read leaf elements from Basket input buffer. ;  ; void ReadBasketExport (TBuffer &b, TClonesArray *list, Int_t n) override;  Read leaf elements from Basket input buffer and export buffer to TClonesArray objects. ;  ; bool ReadBasketFast (TBuffer &, Long64_t) override;  Deserialize input by performing byteswap as needed. ;  ; void ReadValue (std::istream &s, Char_t delim=' ') override;  Read a long integer from std::istream s and store it into the branch buffer. ;  ; void SetAddress (void *add=nullptr) override;  Set leaf buffer data address. ;  ; virtual void SetMaximum (Long64_t max);  ; virtual void SetMinimum (Long64_t min);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TLeaf;  TLeaf ();  ;  TLeaf (TBranch *parent, const char *name, const char *type);  Create a Leaf. ;  ;  ~TLeaf () override;  Destructor. ;  ; void Browse (TBrowser *b) override;  Browse the content of this leaf. ;  ; virtual bool CanGenerateOffsetArray ();  ; virtual Int_t * GenerateOffsetArray (Int_t base, Int_t events);  ; TBranch * GetBranch () const;  ; virtual TString GetFullName () const;  Return the full name (including the parent's branch names",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafL.html:1947,perform,performing,1947,doc/master/classTLeafL.html,https://root.cern,https://root.cern/doc/master/classTLeafL.html,1,['perform'],['performing']
Performance,"t char * GetTypeName () const override;  Returns name of leaf type. ;  ; Double_t GetValue (Int_t i=0) const override;  Returns current value of leaf. ;  ; Long64_t GetValueLong64 (Int_t i=0) const override;  ; LongDouble_t GetValueLongDouble (Int_t i=0) const override;  Returns current value of leaf. ;  ; void * GetValuePointer () const override;  ; void Import (TClonesArray *list, Int_t n) override;  Import element from ClonesArray into local leaf buffer. ;  ; bool IncludeRange (TLeaf *) override;  Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ;  ; TClass * IsA () const override;  ; void PrintValue (Int_t i=0) const override;  Prints leaf value. ;  ; void ReadBasket (TBuffer &b) override;  Read leaf elements from Basket input buffer. ;  ; void ReadBasketExport (TBuffer &b, TClonesArray *list, Int_t n) override;  Read leaf elements from Basket input buffer and export buffer to TClonesArray objects. ;  ; bool ReadBasketFast (TBuffer &, Long64_t) override;  Deserialize input by performing byteswap as needed. ;  ; void ReadValue (std::istream &s, Char_t delim=' ') override;  Read a long integer from std::istream s and store it into the branch buffer. ;  ; void SetAddress (void *add=nullptr) override;  Set leaf buffer data address. ;  ; virtual void SetMaximum (Long_t max);  ; virtual void SetMinimum (Long_t min);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TLeaf;  TLeaf ();  ;  TLeaf (TBranch *parent, const char *name, const char *type);  Create a Leaf. ;  ;  ~TLeaf () override;  Destructor. ;  ; void Browse (TBrowser *b) override;  Browse the content of this leaf. ;  ; virtual bool CanGenerateOffsetArray ();  ; virtual Int_t * GenerateOffsetArray (Int_t base, Int_t events);  ; TBranch * GetBranch () const;  ; virtual TString GetFullName () const;  Return the full name (including the parent's branch names) of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafG.html:1947,perform,performing,1947,doc/master/classTLeafG.html,https://root.cern,https://root.cern/doc/master/classTLeafG.html,1,['perform'],['performing']
Performance,"t char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:18617,optimiz,optimizeDirtyHook,18617,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:2155,cache,cachedVars,2155,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,3,['cache'],['cachedVars']
Performance,"t char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tExec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:5625,load,loadopts,5625,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,4,['load'],['loadopts']
Performance,"t char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:14806,Load,Load,14806,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,4,['Load'],['Load']
Performance,"t char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:20223,cache,cachedir,20223,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cachedir']
Performance,"t class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:37976,perform,performing,37976,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performing']
Performance,"t class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:39318,perform,performing,39318,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['perform'],['performing']
Performance,"t class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxillary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:33908,perform,performing,33908,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['perform'],['performing']
Performance,"t cling::Transaction&);; 93 TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);; 94 const clang::Decl* TCling__GetObjectDecl(TObject *obj);; 95 void TCling__LibraryLoaded(const void* dyLibHandle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unord",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:3482,load,loaded,3482,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:2071,cache,cacheUniqueSuffix,2071,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,4,['cache'],['cacheUniqueSuffix']
Performance,"t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGExpModel.html:2898,cache,cacheUniqueSuffix,2898,root/html532/RooGExpModel.html,https://root.cern,https://root.cern/root/html532/RooGExpModel.html,4,['cache'],['cacheUniqueSuffix']
Performance,"t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGExpModel.html:2898,cache,cacheUniqueSuffix,2898,root/html528/RooGExpModel.html,https://root.cern,https://root.cern/root/html528/RooGExpModel.html,4,['cache'],['cacheUniqueSuffix']
Performance,"t containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3812 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3786 of file TClass.cxx. ◆ GetMenuItems(). void TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:83211,load,load,83211,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"t containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3879 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3853 of file TClass.cxx. ◆ GetMenuItems(). void TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:83212,load,load,83212,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"t copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:37079,cache,cache,37079,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,4,['cache'],['cache']
Performance,"t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:4565,load,load,4565,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"t data file and signal and background trees; ; inputFileName = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59368,load,loader,59368,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,t destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill cache using running integral cache elements calculate() method with specification of cdf-specific boundary conditions. ;  ;  Protected Member Functions inherited from RooNumRunningInt; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:50064,cache,cached,50064,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cached']
Performance,"t empty cell or AddLast if there is no empty cell ; Reimplemented from TObjArray.; Definition at line 60 of file TClonesArray.h. ◆ AddBefore(). void TClonesArray::AddBefore ; (; const TObject * ; , . TObject * ;  . ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 62 of file TClonesArray.h. ◆ AddFirst(). void TClonesArray::AddFirst ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 56 of file TClonesArray.h. ◆ AddLast(). void TClonesArray::AddLast ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 57 of file TClonesArray.h. ◆ AddrAt(). TObject * TClonesArray::AddrAt ; (; Int_t ; idx). inline . Definition at line 86 of file TClonesArray.h. ◆ BypassStreamer(). void TClonesArray::BypassStreamer ; (; Bool_t ; bypass = kTRUE). When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::WriteBuffer. ; Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However there is a drawback: When a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfo of the class in the array being optimized, one cannot use later the TClonesArray with split>0. For example, there is a problem with the following scenario:; A class Foo has a TClonesArray of Bar objects; The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.; In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1; When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solutio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:31207,perform,performance,31207,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['perform'],['performance']
Performance,"t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddPdf::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:35751,optimiz,optimizeDirtyHook,35751,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; const RooAbsReal*getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:34934,optimiz,optimizeDirtyHook,34934,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). Bool_t hasFilledCache() const; { return _cache ? kTRUE : kFALSE ; }. » Last changed: Sat Jun 20 16:42:58 2015 » Last generated: 2015-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:17047,cache,cacheOwner,17047,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,4,"['cache', 'optimiz']","['cacheOwner', 'optimizer']"
Performance,"t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). Bool_t hasFilledCache() const; { return _cache ? kTRUE : kFALSE ; }. » Last changed: Sat Jun 20 17:31:08 2015 » Last generated: 2015-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooVectorDataStore.html:18172,cache,cacheOwner,18172,root/html604/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html604/RooVectorDataStore.html,4,"['cache', 'optimiz']","['cacheOwner', 'optimizer']"
Performance,"t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). Bool_t hasFilledCache() const; { return _cache ? kTRUE : kFALSE ; }. » Last changed: Tue Jun 30 14:38:02 2015 » Last generated: 2015-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVectorDataStore.html:18172,cache,cacheOwner,18172,root/html602/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html602/RooVectorDataStore.html,4,"['cache', 'optimiz']","['cacheOwner', 'optimizer']"
Performance,"t flag); voidsetAsymError(Double_t lo, Double_t hi); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins, const char* name = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetError(Double_t value); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(RooAbsReal& min, RooAbsReal& max); voidsetRange(const char* name, Double_t min, Double_t max); voidsetRange(const char* name, RooAbsReal& min, RooAbsReal& max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealVar.html:27599,cache,cache,27599,root/html528/RooRealVar.html,https://root.cern,https://root.cern/root/html528/RooRealVar.html,1,['cache'],['cache']
Performance,"t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:35234,cache,cache,35234,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,6,['cache'],['cache']
Performance,"t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:35429,cache,cache,35429,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,6,['cache'],['cache']
Performance,"t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Jun 30 14:35:01 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:61667,Cache,CacheMode,61667,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,1,['Cache'],['CacheMode']
Performance,"t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Mar 10 17:18:32 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:60012,Cache,CacheMode,60012,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['Cache'],['CacheMode']
Performance,"t good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1064204,optimiz,optimizes,1064204,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['optimiz', 'perform']","['optimizes', 'performance']"
Performance,"t histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); standard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(). void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-targe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodKNN.html:17433,optimiz,optimization,17433,root/html530/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodKNN.html,3,['optimiz'],['optimization']
Performance,"t histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); standard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodKNN.html:17406,optimiz,optimization,17406,root/html534/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodKNN.html,2,['optimiz'],['optimization']
Performance,t implemented for CrossValidation; <WARNING> <WARNING> : MakeClassSpecific not implemented for CrossValidation; : Elapsed time for training with 1998 events: 3.81e-06 sec ; <HEADER> Fisher : [datasetcv] : Evaluation of Fisher on training sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.000313 sec ; : Creating xml weight file: datasetcv/weights/TMVACrossValidation_Fisher.weights.xml; : Creating standalone class: datasetcv/weights/TMVACrossValidation_Fisher.class.C; <WARNING> <WARNING> : MakeClassSpecificHeader not implemented for CrossValidation; <WARNING> <WARNING> : MakeClassSpecific not implemented for CrossValidation; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG for Classification performance; : ; <HEADER> BDTG : [datasetcv] : Evaluation of BDTG on testing sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.00612 sec ; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [datasetcv] : Evaluation of Fisher on testing sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.000313 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: BDTG; : ; <HEADER> BDTG : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: -0.014284 1.4061 [ -4.1075 4.0969 ]; : y: -0.0066370 1.4204 [ -4.8520 4.0761 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: -0.014284 1.4061 [ -4.1075 4.0969 ]; : y: -0.0066370 1.4204 [ -4.8520 4.0761 ]; : ---------------------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:15868,perform,performance,15868,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['perform'],['performance']
Performance,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:13334,perform,performed,13334,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,30,['perform'],['performed']
Performance,"t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:20537,Cache,CacheMode,20537,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['Cache'],['CacheMode']
Performance,"t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:18750,optimiz,optimizeCacheMode,18750,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,12,['optimiz'],['optimizeCacheMode']
Performance,"t is a vector of TFormula pointers) needs to be copied one by one; 705 // looping at all the elements; 706 // delete first previous elements; 707 int nLinParts = fnew.fLinearParts.size();; 708 if (nLinParts > 0) {; 709 for (int i = 0; i < nLinParts; ++i) delete fnew.fLinearParts[i];; 710 fnew.fLinearParts.clear();; 711 }; 712 // old size that needs to be copied; 713 nLinParts = fLinearParts.size();; 714 if (nLinParts > 0) {; 715 fnew.fLinearParts.reserve(nLinParts);; 716 for (int i = 0; i < nLinParts; ++i) {; 717 TFormula * linearNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; 739 bool ret = fnew.InitLambdaExpression(fnew.fFormula);; 740 if (ret) {; 741 fnew.SetBit(TFormula::kLambda);; 742 fnew.fReadyToExecute = true;; 743 }; 744 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:26870,load,load,26870,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['load'],['load']
Performance,"t is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:7655,perform,performs,7655,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,4,['perform'],['performs']
Performance,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:38352,load,loaded,38352,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,8,['load'],['loaded']
Performance,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:36266,load,loaded,36266,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,2,['load'],['loaded']
Performance,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: May set current tree!. Returns 1 on success and 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:35712,load,loaded,35712,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['load'],['loaded']
Performance,"t label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_t_valueConstant value of self; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstVar(const char* name, const char* title, Double_t value); Constructor with value; _fast = kTRUE ;. RooConstVar(const RooCons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConstVar.html:34382,cache,cache,34382,root/html534/RooConstVar.html,https://root.cern,https://root.cern/root/html534/RooConstVar.html,4,['cache'],['cache']
Performance,"t len);  Add block of length len at position pos in the list of blocks to be prefetched. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; virtual Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read buffer at position pos. ;  ; virtual Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc);  ; virtual Int_t ReadBufferExtNormal (char *buf, Long64_t pos, Int_t len, Int_t &loc);  Base function for ReadBuffer. ;  ; virtual Int_t ReadBufferExtPrefetch (char *buf, Long64_t pos, Int_t len, Int_t &loc);  prefetch the first block ;  ; virtual void SecondPrefetch (Long64_t, Int_t);  ; virtual void SecondSort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; virtual Int_t SetBufferSize (Long64_t buffersize);  Sets the buffer size. ;  ; virtual void SetEnablePrefetching (Bool_t setPrefetching=kFALSE);  Set the prefetching mode of this file. ;  ; virtual void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect);  Set the file using this cache and reset the current blocks (if any). ;  ; virtual void SetSkipZip (Bool_t=kTRUE);  ; virtual void Sort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void WaitFinishPrefetch ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:3347,cache,cache,3347,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cache']
Performance,"t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TString.h; TVirtualPerfStats.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTextBase class for several text objects.Definition TText.h:22; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::GetNumEventsLong64_t GetNumEvents() const overrideDefinition TTreePerfStats.h:104; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::SetUsedvoid SetUsed(size_t bi, size_t basketNumber) overrideDefinition TTreePerfStats.h:152; TTreePerfStats::SetGraphIOvirtual void SetGraphIO(TGraphErrors *gr)Definition TTreePerfStats.h:132; TTreePerfStats::GetPaveTPaveText * GetPave()Definition TTreePerfStats.h:105; TTreePerfStats::SetUsedvoid SetUsed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:151; TTreePerfStats::SetRealNormvirtual void SetRealNorm(Double_t rnorm)Definition TTreePerfStats.h:139; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:11135,perform,performance,11135,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['perform'],['performance']
Performance,"t line 161 of file TRInterface.cxx. ◆ IsA(). virtual TClass * ROOT::R::TRInterface::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 320 of file TRInterface.h. ◆ IsInstalled(). Bool_t TRInterface::IsInstalled ; (; TString ; pkg). Method to verify if a package is installed. ; Parameters. pkgR's pkg name . Returnstrue or false if the package is installed or not ; Definition at line 193 of file TRInterface.cxx. ◆ operator[](). TRInterface::Binding TRInterface::operator[] ; (; const TString & ; name). Definition at line 142 of file TRInterface.cxx. ◆ ProcessEventsLoop(). void TRInterface::ProcessEventsLoop ; (; ). Init event loop in a thread to support actions in windows from R graphics system. ; Definition at line 219 of file TRInterface.cxx. ◆ Require(). Bool_t TRInterface::Require ; (; TString ; pkg). Method to load an R's package. ; Parameters. pkgR's pkg name . Returnstrue or false if the package was loaded or not ; Definition at line 200 of file TRInterface.cxx. ◆ SetVerbose(). void TRInterface::SetVerbose ; (; Bool_t ; status). Method to set verbose mode, that produce extra output. ; Notesome time can produce so much noise in the output ; Parameters. statusboolean to enable of disable . Definition at line 134 of file TRInterface.cxx. ◆ Streamer(). virtual void ROOT::R::TRInterface::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ROOT::R::TRInterface::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 320 of file TRInterface.h. Member Data Documentation. ◆ fR. RInside* ROOT::R::TRInterface::fR. protected . Definition at line 138 of file TRInterface.h. ◆ th. TThread* ROOT::R::TRInterface::th. protected . Definition at line 139 of file TRInterface.h. Libraries for ROOT::R::TRInterface:. [legend]; The documentation for this class was generated from the following file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:23948,load,loaded,23948,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['load'],['loaded']
Performance,t line 274 of file RooNumRunningInt.cxx. ◆ binningName(). const char * RooNumRunningInt::binningName ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 47 of file RooNumRunningInt.h. ◆ Class(). static TClass * RooNumRunningInt::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumRunningInt::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumRunningInt::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 63 of file RooNumRunningInt.h. ◆ clone(). TObject * RooNumRunningInt::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooNumRunningInt.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooNumRunningInt::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create custom cache element for running integral calculations. ; Reimplemented from RooAbsCachedReal.; Definition at line 285 of file RooNumRunningInt.cxx. ◆ DeclFileName(). static const char * RooNumRunningInt::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooNumRunningInt.h. ◆ evaluate(). double RooNumRunningInt::evaluate ; (; ); const. overrideprotectedvirtual . Dummy function that is never called. ; Implements RooAbsReal.; Definition at line 294 of file RooNumRunningInt.cxx. ◆ fillCacheObject(). void RooNumRunningInt::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache object by calling its calculate() method. ; Implements RooAbsCachedReal.; Definition at line 248 of file RooNumRunningInt.cxx. ◆ inputBaseName(). const char * RooNumRunningInt::inputBaseName ; (; ); const. overrideprotectedvirtual . Return unique name for RooAbsCachedPdf cache components constructed from inpu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:65783,cache,cache,65783,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"t line 391 of file TFumili.cxx. ◆ ExecuteSetCommand(). Int_t TFumili::ExecuteSetCommand ; (; Int_t ; nargs). Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"". ; Definition at line 558 of file TFumili.cxx. ◆ FitChisquare(). void TFumili::FitChisquare ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1738 of file TFumili.cxx. ◆ FitChisquareI(). void TFumili::FitChisquareI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 2D : bc,e,xc,xw,yc,yw; 3D : bc,e,xc,xw,yc,yw,zc,zw . Definition at line 1809 of file TFumili.cxx. ◆ FitLikelihood(). void TFumili::FitLikelihood ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1884 of file TFumili.cxx. ◆ FitLikelihoodI(). void TFumili::FitLikelihoodI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:30364,cache,cache,30364,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['cache'],['cache']
Performance,"t line 48 of file GeneticPopulation.h. Public Member Functions;  GeneticPopulation (const std::vector< TMVA::Interval * > &ranges, Int_t size, UInt_t seed=0);  Constructor. ;  ; virtual ~GeneticPopulation ();  destructor ;  ; void AddPopulation (GeneticPopulation &strangers);  add another population (strangers) to the one of this GeneticPopulation ;  ; void AddPopulation (GeneticPopulation *strangers);  add another population (strangers) to the one of this GeneticPopulation ;  ; Double_t GetFitness () const;  ; std::vector< TMVA::GeneticGenes > & GetGenePool ();  ; const std::vector< TMVA::GeneticGenes > & GetGenePool () const;  ; GeneticGenes * GetGenes (Int_t index);  gives back the ""Genes"" of the population with the given index. ;  ; Int_t GetPopulationSize () const;  ; std::vector< TMVA::GeneticRange * > & GetRanges ();  ; const std::vector< TMVA::GeneticRange * > & GetRanges () const;  ; void GiveHint (std::vector< Double_t > &hint, Double_t fitness=0);  add an individual (a set of variables) to the population if there is a set of variables which is known to perform good, they can be given as a hint to the population ;  ; virtual TClass * IsA () const;  ; void MakeChildren ();  Creates children out of members of the current generation. ;  ; void MakeCopies (int number);  Produces offspring which is are copies of their parents. ;  ; void Mutate (Double_t probability=20, Int_t startIndex=0, Bool_t near=kFALSE, Double_t spread=0.1, Bool_t mirror=kFALSE);  Mutates the individuals in the genePool. ;  ; void NextGeneration ();  ; void Print (Int_t untilIndex=-1);  make a little printout of the individuals up to index ""untilIndex"" this means, . ;  ; void Print (std::ostream &out, Int_t utilIndex=-1);  make a little printout to the stream ""out"" of the individuals up to index ""untilIndex"" this means, . ;  ; void SetRandomSeed (UInt_t seed=0);  the random seed of the random generator ;  ; void Sort ();  sort the genepool according to the fitness of the individuals ;  ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticPopulation.html:1472,perform,perform,1472,doc/master/classTMVA_1_1GeneticPopulation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticPopulation.html,1,['perform'],['perform']
Performance,"t line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Forward calls to existing cache elements and save configuration of cache mode optimization so that it ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9427,cache,cache,9427,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,3,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"t line 58 of file TSpectrum.h. ◆ GetPositionY(). Double_t * TSpectrum::GetPositionY ; (; ); const. inline . Definition at line 59 of file TSpectrum.h. ◆ IsA(). TClass * TSpectrum::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 78 of file TSpectrum.h. ◆ operator=(). TSpectrum & TSpectrum::operator= ; (; const TSpectrum & ; ). private . ◆ Print(). void TSpectrum::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the array of positions. ; Reimplemented from TNamed.; Definition at line 212 of file TSpectrum.cxx. ◆ Search(). Int_t TSpectrum::Search ; (; const TH1 * ; hin, . Double_t ; sigma = 2, . Option_t * ; option = """", . Double_t ; threshold = 0.05 . ). virtual . One-dimensional peak search function. ; This function searches for peaks in source spectrum in hin The number of found peaks and their positions are written into the members fNpeaks and fPositionX. The search is performed in the current histogram range.; Parameters:. hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than threshold*highest_peak are discarded. 0<threshold<1. By default, the background is removed before deconvolution. Specify the option ""nobackground"" to not remove the background.; By default the ""Markov"" chain algorithm is used. Specify the option ""noMarkov"" to disable this algorithm Note that by default the source spectrum is replaced by a new spectrum; By default a polymarker object is created and added to the list of functions of the histogram. The histogram is drawn with the specified option and the polymarker object drawn on top of the histogram. The polymarker coordinates correspond to the npeaks peaks found in the histogram.; A pointer to the polymarker object can be retrieved later via: TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm = (TPolyMarker*)funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:53621,perform,performed,53621,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['perform'],['performed']
Performance,"t line 6107 of file TProof.cxx. ◆ SetRealTimeLog(). void TProof::SetRealTimeLog ; (; Bool_t ; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. ◆ SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus ; rst). inlineprivate . Definition at line 672 of file TProof.h. ◆ SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList * ; wrks, . Bool_t ; increasingpool = kFALSE . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at line 7396 of file TProof.cxx. ◆ ShowDataSet(). void TProof::ShowDataSet ; (; const char * ; dataset = """", . const char * ; opt = ""filter:SsCc"" . ). display meta-info for given dataset usi ; Definition at line 10977 of file TProof.cxx. ◆ ShowDataSetCache(). void TProof::ShowDataSetCache ; (; const char * ; dataset = 0). virtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TProofLite.; Definition at line 10914 of file TProof.cxx. ◆ ShowDataSetQuota(). void TProof::ShowDataSetQuota ; (; Option_t * ; opt = 0). shows the quota and usage of all groups if opt contai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:147958,cache,caches,147958,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['caches']
Performance,"t line 868 of file TList.cxx. ◆ RemoveLast(). void TList::RemoveLast ; (; ). overridevirtual . Remove the last object of the list. ; Reimplemented from TSeqCollection.; Definition at line 907 of file TList.cxx. ◆ Sort(). void TList::Sort ; (; Bool_t ; order = kSortAscending). virtual . Sort linked list. ; Real sorting is done in private function DoSort(). The list can only be sorted when is contains objects of a sortable class. ; Reimplemented in TSortedList.; Definition at line 935 of file TList.cxx. ◆ Streamer(). void TList::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection.; Reimplemented in TQCommand, TQUndoManager, TQConnection, TSortedList, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TParallelCoordSelect.; Definition at line 1189 of file TList.cxx. ◆ StreamerNVirtual(). void TList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 112 of file TList.h. Friends And Related Symbol Documentation. ◆ TListIter. friend class TListIter. friend . Definition at line 40 of file TList.h. Member Data Documentation. ◆ fAscending. Bool_t TList::fAscending. protected . cache to speedup sequential calling of Before() and After() functions ; Definition at line 49 of file TList.h. ◆ fCache. TObjLinkWeakPtr_t TList::fCache. protected . pointer to last entry in linked list ; Definition at line 48 of file TList.h. ◆ fFirst. TObjLinkPtr_t TList::fFirst. protected . Definition at line 46 of file TList.h. ◆ fLast. TObjLinkPtr_t TList::fLast. protected . pointer to first entry in linked list ; Definition at line 47 of file TList.h. Libraries for TList:. [legend]; The documentation for this class was generated from the following files:; core/cont/inc/TList.h; core/cont/src/TList.cxx. TList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:56 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList.html:38857,cache,cache,38857,doc/master/classTList.html,https://root.cern,https://root.cern/doc/master/classTList.html,1,['cache'],['cache']
Performance,"t matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:40683,cache,cache,40683,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,2,['cache'],['cache']
Performance,t method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23563,perform,performance,23563,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['perform'],['performance']
Performance,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPShapeRef.html:1521,perform,perform,1521,root/html528/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html528/TGLPShapeRef.html,1,['perform'],['perform']
Performance,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLPShapeRef.html:1521,perform,perform,1521,root/html530/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html530/TGLPShapeRef.html,1,['perform'],['perform']
Performance,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLPShapeRef.html:1521,perform,perform,1521,root/html532/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html532/TGLPShapeRef.html,2,['perform'],['perform']
Performance,"t object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnums.html:13757,load,loaded,13757,root/html604/TListOfEnums.html,https://root.cern,https://root.cern/root/html604/TListOfEnums.html,2,['load'],['loaded']
Performance,"t of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:39628,load,load,39628,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,2,['load'],['load']
Performance,"t of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:37422,load,load,37422,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,2,['load'],['load']
Performance,"t of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place. */; 12540 DEBUG_ASSERT(body_len >= header_len);; 12541 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12542 mop = buf[0]; /* current mask and opcode */; 12543 /* Overflow case */; 12544 len = body_len - header_len;; 12545 memcpy(data, buf + header_len, len);; 12546 error = 0;; 12547 while ((uint64_t)len < data_len) {; 12548 n = pull_inner(NULL,; 12549 conn,; 12550 (char *)(data + len),; 12551 (int)(data_len - len),; 12552 timeout);; 12553 if (n <= -2) {; 12554 error = 1;; 12555 break;; 12556 } else if (n > 0) {; 12557 len += (size_t)n;; 12558 } else {; 12559 /* Timeout: should retry */; 12560 /* TODO: retry condition */; 12561 }; 12562 }; 12563 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:365303,queue,queue,365303,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place. */; 12541 DEBUG_ASSERT(body_len >= header_len);; 12542 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12543 mop = buf[0]; /* current mask and opcode */; 12544 /* Overflow case */; 12545 len = body_len - header_len;; 12546 memcpy(data, buf + header_len, len);; 12547 error = 0;; 12548 while ((uint64_t)len < data_len) {; 12549 n = pull_inner(NULL,; 12550 conn,; 12551 (char *)(data + len),; 12552 (int)(data_len - len),; 12553 timeout);; 12554 if (n <= -2) {; 12555 error = 1;; 12556 break;; 12557 } else if (n > 0) {; 12558 len += (size_t)n;; 12559 } else {; 12560 /* Timeout: should retry */; 12561 /* TODO: retry condition */; 12562 }; 12563 }; 12564 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:365336,queue,queue,365336,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableWrappers(bool value = true); Enable call wrappers (also known as stubs) if value is true;; disable if value is false. void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:20022,load,loading,20022,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,2,['load'],"['loaded', 'loading']"
Performance,"t of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.; 493 // However, the cache checks if the nset was already cached **by content**,; 494 // and not by RooArgSet instance! So it can happen that the normalization; 495 // set object is different, but the integral object is the same, in which; 496 // case it would be wrong to not adjust the proxies. They always have to be; 497 // adjusted when the nset changed, which is always the case when; 498 // `syncNormalization()` is called.; 499 if (adjustProxies) {; 500 // Update dataset pointers of proxies; 501 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 502 }; 503 ; 504 return nintChanged ;; 505 }; 506 ; 507 // Update dataset pointers of proxies; 508 if (adjustProxies) {; 509 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 510 }; 511 ; 512 RooArgSet depList;; 513 getObservables(nset, depList);; 514 ; 515 if (_verboseEval>0) {; 516 if (!selfNormalized()) {; 517 cxcoutD(Tracing) << ClassName() << ""::syncNormalization("" << GetName(); 518 << "") recreating normalization integral "" << endl ;; 519 depList.printStream(ccoutD(Tracing),kName|kValue|kArgs,kSingleLine) ;; 520 } else {; 521 cxcoutD(Tracing) << ClassName() << ""::syncNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:18653,cache,cache,18653,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"t of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataHist& hdata,		 const RooCmdArg& arg1,const RooCmdArg& arg2,const RooCmdArg& arg3,		 const RooCmdArg& arg4,const RooCmdArg& arg5,const RooCmdArg& arg6,		 const RooCmdArg& arg7,const RooCmdArg& arg8,const RooCmdArg& arg9); RooChi2Var constructor. Optional arguments taken. DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:36467,cache,cache,36467,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,1,['cache'],['cache']
Performance,"t of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:36733,cache,cache,36733,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,1,['cache'],['cache']
Performance,"t of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:34761,cache,cache,34761,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"t of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:23961,Load,LoadBuffer,23961,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,2,['Load'],"['Load', 'LoadBuffer']"
Performance,"t of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressLog.html:23754,Load,LoadBuffer,23754,root/html532/TProofProgressLog.html,https://root.cern,https://root.cern/root/html532/TProofProgressLog.html,2,['Load'],"['Load', 'LoadBuffer']"
Performance,"t only first 8 columns.; 2439/// - If varexp = ""*"" print all columns.; 2440/// - Otherwise a columns selection can be made using ""var1:var2:var3"".; 2441/// See TTreePlayer::Scan for more information.; 2442 ; 2443Long64_t TChain::Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 2444{; 2445 if (LoadTree(firstentry) < 0) {; 2446 return 0;; 2447 }; 2448 return TTree::Scan(varexp, selection, option, nentries, firstentry);; 2449}; 2450 ; 2451////////////////////////////////////////////////////////////////////////////////; 2452/// Set the global branch kAutoDelete bit.; 2453///; 2454/// When LoadTree loads a new Tree, the branches for which; 2455/// the address is set will have the option AutoDelete set; 2456/// For more details on AutoDelete, see TBranch::SetAutoDelete.; 2457 ; 2458void TChain::SetAutoDelete(bool autodelete); 2459{; 2460 if (autodelete) {; 2461 SetBit(kAutoDelete, true);; 2462 } else {; 2463 SetBit(kAutoDelete, false);; 2464 }; 2465}; 2466 ; 2467Int_t TChain::SetCacheSize(Long64_t cacheSize); 2468{; 2469 // Set the cache size of the underlying TTree,; 2470 // See TTree::SetCacheSize.; 2471 // Returns 0 cache state ok (exists or not, as appropriate); 2472 // -1 on error; 2473 ; 2474 Int_t res = 0;; 2475 ; 2476 // remember user has requested this cache setting; 2477 fCacheUserSet = true;; 2478 ; 2479 if (fTree) {; 2480 res = fTree->SetCacheSize(cacheSize);; 2481 } else {; 2482 // If we don't have a TTree yet only record the cache size wanted; 2483 res = 0;; 2484 }; 2485 fCacheSize = cacheSize; // Record requested size.; 2486 return res;; 2487}; 2488 ; 2489////////////////////////////////////////////////////////////////////////////////; 2490/// Reset the addresses of the branch.; 2491 ; 2492void TChain::ResetBranchAddress(TBranch *branch); 2493{; 2494 TChainElement* element = (TChainElement*) fStatus->FindObject(branch->GetName());; 2495 if (element) {; 2496 element->SetBaddress(nullptr);; 2497 }; 2498",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:89007,cache,cacheSize,89007,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParametricStepFunction&operator=(const RooParametricStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParametricStepFunction.html:23987,optimiz,optimizeCacheMode,23987,root/html602/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html602/RooParametricStepFunction.html,8,['optimiz'],['optimizeCacheMode']
Performance,"t pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundamental object with our properties. The new; object will be created without any fit limits. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& analDeps, 			 const RooArgProxy& a); Utility function for use in getAnalyticalIntegral(). If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:55918,cache,cache,55918,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['cache'],['cache']
Performance,"t pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundamental object with our properties. The new; object will be created without any fit limits. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Utility function for use in getAnalyticalIntegral(). If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:56637,cache,cache,56637,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['cache'],['cache']
Performance,"t py); virtual Double_tRooSimultaneous::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooSimultaneous::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooSimultaneous::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataHist*RooSimultaneous::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:11766,cache,cacheList,11766,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,6,['cache'],['cacheList']
Performance,"t query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TStringfSandboxPROOF sandbox root dir; TStringfSelectionInternal variable to pass drawing options; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; TStringfVarExpInternal variable to pass drawing options; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:24407,cache,cache,24407,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,3,['cache'],['cache']
Performance,"t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual Bool_timportWorkspaceHook(RooWorkspace& ws); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:35930,optimiz,optimizeDirtyHook,35930,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"t reported number of bytes read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 16:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterTree.html:7888,cache,cache,7888,root/html534/TEventIterTree.html,https://root.cern,https://root.cern/root/html534/TEventIterTree.html,4,"['Load', 'cache']","['Load', 'cache']"
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above in,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:39281,cache,cache,39281,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:39663,cache,cache,39663,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['cache'],['cache']
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:37657,cache,cache,37657,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,1,['cache'],['cache']
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProjectedPdf.html:38039,cache,cache,38039,root/html528/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html528/RooProjectedPdf.html,2,['cache'],['cache']
Performance,"t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixT_double_.html:20346,Perform,Perform,20346,root/html532/TMatrixT_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html,1,['Perform'],['Perform']
Performance,"t scale, RooAbsReal& blindValue); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:24156,cache,cache,24156,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,4,['cache'],['cache']
Performance,"t sequence. ; Reimplemented from RooAbsArg.; Definition at line 350 of file RooNumConvolution.cxx. ◆ profileData(). const TH2 * RooNumConvolution::profileData ; (; ); const. inline . Definition at line 52 of file RooNumConvolution.h. ◆ redirectServersHook(). bool RooNumConvolution::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. ; Reimplemented from RooAbsReal.; Definition at line 262 of file RooNumConvolution.cxx. ◆ setCallProfiling(). void RooNumConvolution::setCallProfiling ; (; bool ; flag, . Int_t ; nbinX = 40, . Int_t ; nbinCall = 40, . Int_t ; nCallHigh = 1000 . ). Activate call profile if flag is set to true. ; A 2-D histogram is kept that stores the required number of function calls versus the value of x, the convolution variable; All clones of RooNumConvolution objects will keep logging to the histogram of the original class so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating are all logged in a single place.; Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor; Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram ; Definition at line 324 of file RooNumConvolution.cxx. ◆ setCallWarning(). void RooNumConvolution::setCallWarning ; (; Int_t ; threshold = 2000). Activate warning messages if number of function calls needed for evaluation of convolution integral exceeds given threshold. ; Definition at line 302 of file RooNumConvolution.cxx. ◆ setConvolutionWindow(). void RooNumConvolution::setConvolutionWindow ; (; RooAbsReal & ; centerParam, . RooAbsReal & ; widthParam, . double ; widthScaleFactor = 1 . ). Restrict convolution integral to finite range [ x - C - S*W, x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:69551,perform,performance,69551,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['perform'],['performance']
Performance,"t silent=kFALSE) constTROOT; GetClipboard() constTROOTinline; GetColor(Int_t color) constTROOT; GetConfigFeatures() constTROOTinline; GetConfigOptions() constTROOTinline; GetCutClassName() constTROOTinline; GetDataDir()TROOTstatic; GetDefCanvasName() constTROOTinline; GetDirectory(const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch() constTROOTinline; GetGitCommit() constTROOTinline; GetGitDate()TROOT; GetGlobal(const char *name, Bool_t load=kFALSE) constTROOT; GetGlobal(const TObject *obj, Bool_t load=kFALSE) constTROOT; GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)TROOT; GetGlobalFunctions()TROOTprotected; GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)TROOT; GetIconName() constTObjectvirtual; GetIconPath()TROOTstatic; GetIncludeDir()TROOTstatic; GetInterpreter() constTROOTinline; GetKey(const char *, Short_t=9999) constTDirectoryinlinevirtual; GetLibDir()TROOTstatic; GetList() constTDirectoryinlinevirtual; GetListOfBrowsables() constTROOTinline; GetListOfBrowsers() constTROOTinline; GetListOfCanvases() constTROOTinline; GetListOfClasses() constTROOTinline; GetListOfClassGenerators() constTROOTinline; GetListOfCleanups() constTROOTinline; GetListOfClosedObjects() constTROOTinline; GetListOfColors() constTROOTinline; GetListOfDataSets() constTROOTinline; GetListOfEnums(Bool_t load=kFALSE)TROOT; GetListOfFiles() constTROOTinline; GetLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:7354,load,load,7354,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidRooSimultaneous::initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:37440,optimiz,optimizeDirtyHook,37440,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"t statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); Constructor of data weighted average of given p.d.f over given data. If nCPU>1 the calculation is parallelized; over multuple processes. If showProgress is true a progress indicator pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:41539,cache,cache,41539,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance,"t statistics to use; boolfTmpDoExtended; boolfUsePriorPdfuse a prior for nuisance parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridCalculatorOriginal(const char* name = 0); constructor with name and title; set default parameters. HybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor without specifying a data set; the user need to specify the models in the S+B case and B-only case,; the list of observables of the model(s) (for MC-generation), the list of parameters; that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor for performing hypotesis test; the user need to specify the data set, the models in the S+B case and B-only case.; In case of treatment of nuisance parameter, the user need to specify the; the list of parameters that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Constructor with a ModelConfig object representing the signal + background model and; another model config representig the background only model; a Prior pdf for the nuiscane parameter of the signal and background can be specified in; the s+b model or the b model. If it is specified in the s+b model, the one of the s+b model will be used. ~HybridCalculatorOriginal(); HybridCalculatorOriginal destructor. void SetNullModel(const RooStats::ModelConfig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html:12077,perform,performing,12077,root/html602/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html,4,['perform'],['performing']
Performance,"t textsizeDefinition TGWin32VirtualXProxy.cxx:58; gPad#define gPadDefinition TVirtualPad.h:308; If the text precision is equal to 3, the text size doesn't depend on the pad's dimensions. A given textsize value always generates the same absolute size. The text size (charheight) is given in pixels:; charheight = textsize;; Note that to scale fonts to the same size as the old True Type package a scale factor of 0.93376068 is apply to the text size before drawing.; The text size of any class inheriting from TAttText can be changed using the method SetTextSize and retrieved using the method GetTextSize. Text Font and Precision; The text font code is combination of the font number and the precision. Text font code = 10*fontnumber + precision; fontnumberOption_t Option_t fontnumberDefinition TGWin32VirtualXProxy.cxx:60; Font numbers must be between 1 and 14.; The precision can be:. precision = 0 fast hardware fonts (steps in the size); precision = 1 scalable and rotatable hardware fonts (see below); precision = 2 scalable and rotatable hardware fonts; precision = 3 scalable and rotatable hardware fonts. Text size is given in pixels. The text font and precision of any class inheriting from TAttText can be changed using the method SetTextFont and retrieved using the method GetTextFont. Font quality and speed; When precision 0 is used, only the original non-scaled X11 system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behaviour depending if the True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotatable fonts. These days TTF fonts are rendered fast enough and can be used in all cases. How to use True Type Fonts; TTF fonts are used by default. They can be deactivated via the following line in the .rootrc file:; Unix.*.Root.UseTTFonts: false. Lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttText.html:8078,scalab,scalable,8078,doc/master/classTAttText.html,https://root.cern,https://root.cern/doc/master/classTAttText.html,3,['scalab'],['scalable']
Performance,"t the parameter values (return values from TF1) ; Implements ROOT::Math::IBaseParam.; Definition at line 100 of file WrappedMultiTF1.h. ◆ SetAndCopyFunction(). template<class T > . void ROOT::Math::WrappedMultiTF1Templ< T >::SetAndCopyFunction ; (; const TF1 * ; f = nullptr). method to set a new function pointer and copy it inside. ; By calling this method the class manages now the passed TF1 pointer ; Definition at line 399 of file WrappedMultiTF1.h. ◆ SetDerivPrecision(). template<class T > . void ROOT::Math::WrappedMultiTF1Templ< T >::SetDerivPrecision ; (; double ; eps). static . precision value used for calculating the derivative step-size h = eps * |x|. ; The default is 0.001, give a smaller in case function changes rapidly ; Definition at line 387 of file WrappedMultiTF1.h. ◆ SetParameters(). template<class T > . void ROOT::Math::WrappedMultiTF1Templ< T >::SetParameters ; (; const double * ; p). inlineoverridevirtual . set parameter values (only the cached one in this class,leave unchanges those of TF1) ; Implements ROOT::Math::IBaseParam.; Definition at line 107 of file WrappedMultiTF1.h. Member Data Documentation. ◆ fDim. template<class T > . unsigned int ROOT::Math::WrappedMultiTF1Templ< T >::fDim. private . Definition at line 188 of file WrappedMultiTF1.h. ◆ fFunc. template<class T > . TF1* ROOT::Math::WrappedMultiTF1Templ< T >::fFunc. private . Definition at line 187 of file WrappedMultiTF1.h. ◆ fLinear. template<class T > . bool ROOT::Math::WrappedMultiTF1Templ< T >::fLinear. private . Definition at line 184 of file WrappedMultiTF1.h. ◆ fOwnFunc. template<class T > . bool ROOT::Math::WrappedMultiTF1Templ< T >::fOwnFunc. private . Definition at line 186 of file WrappedMultiTF1.h. ◆ fPolynomial. template<class T > . bool ROOT::Math::WrappedMultiTF1Templ< T >::fPolynomial. private . Definition at line 185 of file WrappedMultiTF1.h. hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathWrappedMultiTF1Templ. ROOT master - Reference Guide Generated on Tue Nov 5 2024 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html:13557,cache,cached,13557,doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,1,['cache'],['cached']
Performance,"t the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270780,optimiz,optimization,270780,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimization']
Performance,"t this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:159689,load,load,159689,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"t this class (as v5 was doing),; 4260 // instead this function must only be called if the definition is (about); 4261 // to be unloaded.; 4262 ; 4263 ResetCaches();; 4264 ; 4265 // We got here because the definition Decl is about to be unloaded.; 4266 if (fState != TClass::kHasTClassInit) {; 4267 if (fStreamerInfo->GetEntries() != 0) {; 4268 fState = TClass::kEmulated;; 4269 } else {; 4270 fState = TClass::kForwardDeclared;; 4271 }; 4272 } else {; 4273 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Resets the menu list to it's standard value.; 4309 ; 4310void TClass::ResetMenuList(); 4311{; 4312 if (fClassMenuList); 4313 fClassMenuList->Delete();; 4314 else; 4315 fClassMenuList = new TList();; 4316 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4317}; 4318 ; 4319////////////////////////////////////////////////////////////////////////////////; 4320/// The ls function lists the contents of a class on stdout. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:162440,load,load,162440,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCacheElement.html:2306,optimiz,optimizeCacheMode,2306,root/html602/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html,10,"['cache', 'optimiz']","['cache', 'cacheList', 'optimization', 'optimizeCacheMode']"
Performance,"t tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TProofLite(const TProofLite& ). void operator=(const TProofLite& ). TProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:31229,cache,cache,31229,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cache']
Performance,"t tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:31692,cache,cache,31692,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,3,['cache'],['cache']
Performance,"t trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. calls ""Method::Train()"" for different parameter setttings and; keeps in mind the ""optimal one""... and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Factory.html:19119,Optimiz,OptimizeAllMethods,19119,root/html532/TMVA__Factory.html,https://root.cern,https://root.cern/root/html532/TMVA__Factory.html,2,['Optimiz'],['OptimizeAllMethods']
Performance,"t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGFrameElementPack.html:5355,cache,cached,5355,root/html534/TGFrameElementPack.html,https://root.cern,https://root.cern/root/html534/TGFrameElementPack.html,2,['cache'],['cached']
Performance,"t use of gROOT *after* the end of the; 367 // TROOT constructor.; 368 ; 369 // So to delay until after the start of main, we also made sure that none; 370 // of the ROOT code (mostly the dictionary code) used during library loading; 371 // is using gROOT (directly or indirectly).; 372 ; 373 // In practice, the initialization of the interpreter is now delayed until; 374 // the first use gROOT (or gInterpreter) after the start of main (but user; 375 // could easily break this by using gROOT in their library initialization; 376 // code).; 377 ; 378 extern TROOT *gROOTLocal;; 379 ; 380 TROOT *GetROOT1() {; 381 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const static bool loadSuccess = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")? false : 0 <= gSystem->Load(""libImt"");; 404 if (loadSuccess) {; 405 if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {; 406 return sym;; 407 } else {; 408 Error(""GetSymInLibImt"", ""Cannot get symbol %s."", funcname);; 409 }; 410 }; 411 return nullptr;; 412 }; 413 ; 414 //////////////////////////////////////////////////////////////////////////////; 415 /// Globally enables the parallel branch processing, which is a case of; 416 /// implicit multi-threading (IMT) in ROOT, activating the required locks.; 417 /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; 418 /// each branch of the tree. Therefore, a task takes care of the reading,; 419 /// decompression and deserialisation of a given branch.; 420 void EnablePa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:13931,load,loadSuccess,13931,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['loadSuccess']
Performance,"t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:23337,cache,cache,23337,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,2,['cache'],['cache']
Performance,"t values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD*_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TVectorD*_mref; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo1DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:32760,cache,cache,32760,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_t n)Expand or shrink the array to n elements and create the clone objects by calling their default ctor.Definition TClonesArray.cxx:558; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollection::Classstatic TClass * Class(); TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:285526,load,load,285526,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['load']
Performance,"t will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeler is smarter than that and create for each volume some optimization structures called voxels (see Voxelization) to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway loose a lot in your tracking performance.; The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation : instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties. ; Definition at line 43 of file TGeoVolume.h. Public Types; enum  EGeoVolumeTypes { ;   kVolumeReplicated = (1ULL << ( 14 )); , kVolumeSelected = (1ULL << ( 15 )); , kVolumeDiv = (1ULL << ( 16 )); , kVolumeOverlap = (1ULL << ( 17 )); , ;   kVolumeImportNodes = (1ULL << ( 18 )); , kVolumeMulti = (1ULL << ( 19 )); , kVoxelsXYZ = (1ULL << ( 20 )); , kVoxelsCyl = (1ULL << ( 21 ));",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:10691,optimiz,optimization,10691,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"t with for above integral; TIterator*_obsIter! Iterator over lowSet; RooListProxy_obsSetLow-side variation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooJeffreysPrior.html:39610,cache,cache,39610,root/html528/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html528/RooJeffreysPrior.html,2,['cache'],['cache']
Performance,"t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. XImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. void MapGCFont(GContext_t gc, FontStruct_t font); Map the XftFont with the Graphics Context using it. Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font prope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:27840,load,loading,27840,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,4,['load'],"['load', 'loading']"
Performance,"t! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:40089,cache,cache,40089,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,2,['cache'],['cache']
Performance,"t! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimultaneous.html:41086,cache,cache,41086,root/html534/RooSimultaneous.html,https://root.cern,https://root.cern/root/html534/RooSimultaneous.html,5,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"t! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExtendedTerm.html:40087,cache,cache,40087,root/html534/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html534/RooExtendedTerm.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"t"") {; 439 eng = new TCivetweb(kFALSE);; 440 sarg = ""x""; // civetweb require x before socket name; 441 sarg.Append(arg);; 442 arg = sarg.Data();; 443#endif; 444 } else if (clname == ""https"") {; 445 eng = new TCivetweb(kTRUE);; 446 } else if (clname == ""fastcgi"") {; 447 eng = new TFastCgi();; 448 }; 449 ; 450 if (!eng) {; 451 // ensure that required engine class exists before we try to create it; 452 TClass *engine_class = gROOT->LoadClass(clname.Data());; 453 if (!engine_class); 454 return kFALSE;; 455 ; 456 eng = (THttpEngine *)engine_class->New();; 457 if (!eng); 458 return kFALSE;; 459 }; 460 ; 461 eng->SetServer(this);; 462 ; 463 if (!eng->Create(arg)) {; 464 delete eng;; 465 return kFALSE;; 466 }; 467 ; 468 fEngines.Add(eng);; 469 ; 470 return kTRUE;; 471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Create timer which will invoke ProcessRequests() function periodically; 475///; 476/// Timer is required to perform all actions in main ROOT thread; 477/// Method arguments are the same as for TTimer constructor; 478/// By default, sync timer with 100 ms period is created; 479///; 480/// It is recommended to always use sync timer mode and only change period to; 481/// adjust server reaction time. Use of async timer requires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:15348,perform,perform,15348,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['perform'],['perform']
Performance,"t"");; ; /***; ; ## Setup Dataset(s); ; Define input data file and signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; // loader.SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:51731,load,loader,51731,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"t"",""Track.h;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myheader.h"");. To generate the dictionary from a Makefile, you can use the following rule to generate a dictionary for the headers $(HEADERS) and a library containing the dictionary and the compiled $(SOURCES):. MyDict.cxx: $(HEADERS) Linkdef.h; [TAB] rootcint -f $@ -c $(CXXFLAGS) -p $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g++ -shared -o$@ `root-config --ldflags` $(CXXFLAGS) -I$(ROOTSYS)/include $^. See Interacting with Shared Libraries: rootcint for more details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:3693,load,loader,3693,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['load'],['loader']
Performance,"t& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsPdf.html:6342,Cache,CacheModeRooAbsArg,6342,root/html604/RooAbsPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsPdf.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"t& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*RooAbsCachedReal::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:25870,cache,cacheFunc,25870,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,3,['cache'],['cacheFunc']
Performance,"t& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree struct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:30944,perform,perform,30944,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"t& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent, const char* filename, const char* namePat, RooAbsArg* client); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent, const char* namePat, RooAbsArg* client); Print tree structure of expression tree on give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:30741,perform,perform,30741,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"t& slicePosition) const; Fill a slice of cachePdf with the output of the FFT convolution calculation. Double_t* scanPdf(RooRealVar& obs, RooAbsPdf& pdf, const RooDataHist& hist, const RooArgSet& slicePos, Int_t& N, Int_t& N2, Int_t& zeroBin, Double_t shift) const; Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos'; N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins; The return value is an array of doubles of length N2 with the sampled values. The caller takes ownership; of the array. RooArgSet* actualObservables(const RooArgSet& nset) const; Return the observables to be cached given the normalization set nset. If the cache observables is in nset then this is; - the convolution observable plus; - any member of nset that is either a RooCategory,; - or was previously specified through setCacheObservables(). In case the cache observable is _not_ in nset, then it is; - the convolution observable plus; - all member of nset are observables of this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters on which the cache depends given normalization; set nset. For this p.d.f these are the parameters of the input p.d.f.; but never the convolution variable, it case it is not part of nset. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; Return p.d.f. observable (which can be a function) to substitute given; p.d.f. observable. Substitute x by xprime if xprime is set. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create appropriate generator context for this convolution. If both input p.d.f.s support; internal generation, if it is safe to use them and if no observables other than the convolution; observable are requested for generation, use the specialized convolution generator context; which implements a smearing strategy in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:48825,cache,cache,48825,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,11,['cache'],['cache']
Performance,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsGenContext.html:7579,load,load,7579,root/html528/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html528/RooAbsGenContext.html,1,['load'],['load']
Performance,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsGenContext.html:7741,load,load,7741,root/html530/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html,1,['load'],['load']
Performance,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsGenContext.html:7842,load,load,7842,root/html532/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html532/RooAbsGenContext.html,1,['load'],['load']
Performance,"t&operator=(const TGText&); Bool_tSetCurrentRow(Long_t row); TGText(const TGText&). Data Members; protected:. Long_tfColCountnumber of columns in current line; TGTextLine*fCurrentcurrent line; Long_tfCurrentRowcurrent row number; TStringfFilenamename of opened file ("""" if open buffer); TGTextLine*fFirstfirst line of text; Bool_tfIsSavedfalse if text needs to be saved; Long_tfLongestLinelength of longest line; Long_tfRowCountnumber of rows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGText(const TGText& ); copy constructor. TGText& operator=(const TGText& ); assignment operator. void Init(); Common initialization method. TGText(); Create default (empty) text buffer. TGText(TGText* text); Create text buffer and initialize with other text buffer. TGText(const char* string); Create text buffer and initialize with single line string. ~TGText(); Destroy text buffer. void Clear(); Clear text buffer. Bool_t Load(const char* fn, Long_t startpos = 0, Long_t length = -1); Load text from file fn. Startpos is the begin from where to; load the file and length is the number of characters to read; from the file. Bool_t LoadBuffer(const char* txtbuf); Load a 0 terminated buffer. Lines will be split at '\n'. Bool_t Save(const char* fn); Save text buffer to file fn. Bool_t Append(const char* fn); Append buffer to file fn. Bool_t DelChar(TGLongPosition pos); Delete character at specified position pos. Bool_t InsChar(TGLongPosition pos, char c); Insert character c at the specified position pos. char GetChar(TGLongPosition pos); Get character a position pos. If charcater not valid return -1. Bool_t DelText(TGLongPosition start, TGLongPosition end); Delete text between start and end positions. Returns false in; case of failure (start and end not being within bounds). Bool_t InsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); Insert src text from start_src to end_src into text at position ins_pos.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGText.html:2992,Load,Load,2992,root/html602/TGText.html,https://root.cern,https://root.cern/root/html602/TGText.html,4,['Load'],['Load']
Performance,"t' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every render. void PostRender(); Restore state set in PreRender().; Called after every render. void DoDraw(Bool_t swap_buffers = kTRUE); Draw out the viewer. void DoDrawMono(Bool_t swap_buffers); Draw out in monoscopic mode. void DoDrawStereo(Bool_t swap_buffers); Draw out in stereoscopic mode. Bool_t SavePicture(); Save current image using the defualt file name which can be set; via SetPictureFileName() and defaults to ""viewer.jpg"".; Really useful for the files ending with 'gif+'. Bool_t SavePicture(const TString& fileName); Save current image in various formats (gif, gif+, jpg, png, eps, pdf).; 'gif+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewer.html:23982,Perform,Perform,23982,root/html532/TGLViewer.html,https://root.cern,https://root.cern/root/html532/TGLViewer.html,1,['Perform'],['Perform']
Performance,"t' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every render. void Render(); Normal rendering, used by mono and stereo rendering. void PostRender(); Restore state set in PreRender().; Called after every render. void DoDraw(Bool_t swap_buffers = kTRUE); Draw out the viewer. void DoDrawMono(Bool_t swap_buffers); Draw out in monoscopic mode. void DoDrawStereo(Bool_t swap_buffers); Draw out in stereoscopic mode. Bool_t SavePicture(); Save current image using the default file name which can be set; via SetPictureFileName() and defaults to ""viewer.jpg"".; Really useful for the files ending with 'gif+'. Bool_t SavePicture(const TString& fileName); Save curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewer.html:24463,Perform,Perform,24463,root/html534/TGLViewer.html,https://root.cern,https://root.cern/root/html534/TGLViewer.html,3,['Perform'],['Perform']
Performance,"t','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called by the TClass constructor when replacing an emulated class by the real class ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerString.html:3215,cache,cache,3215,doc/master/classTStreamerString.html,https://root.cern,https://root.cern/doc/master/classTStreamerString.html,1,['cache'],['cache']
Performance,"t()) { ... } ; Definition at line 216 of file TTreeReader.h. ◆ Notify(). bool TTreeReader::Notify ; (; ). overridevirtual . Notify director and values of a change in tree. ; Called from TChain and TTree's LoadTree. TTreeReader registers its fNotify data member with the TChain/TTree which in turn leads to this method being called upon the execution of LoadTree. ; Reimplemented from TObject.; Definition at line 323 of file TTreeReader.cxx. ◆ RegisterValueReader(). bool TTreeReader::RegisterValueReader ; (; ROOT::Internal::TTreeReaderValueBase * ; reader). protected . Add a value reader for this tree. ; Definition at line 858 of file TTreeReader.cxx. ◆ Restart(). void TTreeReader::Restart ; (; ). Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set). ; Definition at line 571 of file TTreeReader.cxx. ◆ SetEntriesRange(). TTreeReader::EEntryStatus TTreeReader::SetEntriesRange ; (; Long64_t ; beginEntry, . Long64_t ; endEntry . ). Set the range of entries to be loaded by Next(); end will not be loaded. ; If end <= begin, end is ignored (set to -1, i.e. will run on all entries from begin onwards).; Example:; reader.SetEntriesRange(3, 5);; while (reader.Next()) {; // Will load entries 3 and 4.; }; Note that if a TEntryList is present, beginEntry and endEntry refer to the beginEntry-th/endEntry-th entries of the TEntryList (or the main TEntryList in case it has sub-entrylists). In other words, SetEntriesRange can be used to only loop over part of the TEntryList, but not to further restrict the actual TTree/TChain entry numbers considered.; Parameters. beginEntryThe first entry to be loaded by Next(). ; endEntryThe entry where Next() will return false, not loading it. . Definition at line 533 of file TTreeReader.cxx. ◆ SetEntry(). EEntryStatus TTreeReader::SetEntry ; (; Long64_t ; entry). inline . Set the next entry (or index of the TEntryList if that is set). ; Parameters. entryIf not TEntryList is set, the entry is a global entry (i.e. not the entry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:31408,load,loaded,31408,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,2,['load'],['loaded']
Performance,"t(). void TFileCacheRead::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; The format is: ******TreeCache statistics for file: cms2.root ****** Reading............................: 72761843 bytes in 7 transactions Readahead..........................: 256000 bytes with overhead = 0 bytes Average transaction................: 10394.549000 Kbytes Number of blocks in current cache..: 210, total size: 6280352; If option = ""a"" the list of blocks in the cache is printed NB: this function is automatically called by TTreeCache::Print ; Reimplemented from TObject.; Reimplemented in TTreeCache, and TTreeCacheUnzip.; Definition at line 326 of file TFileCacheRead.cxx. ◆ ReadBuffer(). Int_t TFileCacheRead::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read buffer at position pos. ; If pos is in the list of prefetched blocks read from fBuffer, otherwise need to make a normal read from file. Returns -1 in case of read error, 0 in case not in cache, 1 in case read from cache. ; Reimplemented in TTreeCache.; Definition at line 364 of file TFileCacheRead.cxx. ◆ ReadBufferExt(). Int_t TFileCacheRead::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). virtual . Reimplemented in TTreeCacheUnzip.; Definition at line 382 of file TFileCacheRead.cxx. ◆ ReadBufferExtNormal(). Int_t TFileCacheRead::ReadBufferExtNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). virtual . Base function for ReadBuffer. ; Also gives out the position of the block in the internal buffer. This helps TTreeCacheUnzip to avoid doing twice the binary search. ; Definition at line 454 of file TFileCacheRead.cxx. ◆ ReadBufferExtPrefetch(). Int_t TFileCacheRead::ReadBufferExtPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). virtual . prefetch the first block ; Definition at line 394 of file TFileCacheRead.cxx. ◆ SecondPrefetch(). void TFileCacheRead::SecondPref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:21931,cache,cache,21931,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,2,['cache'],['cache']
Performance,"t(); ; frame3 = x.frame(); data.plotOn(frame3); modelsum.plotOn(frame3); modelsum.plotOn(frame3, VisualizeError=r3); modelsum.paramOn(frame3, Label=""S+B fit with RooAddPdf"", Layout=(0.3, 0.95)); frame3.Draw(); ; c.Draw(); ; c.SaveAs(""rf204b_extendedLikelihood_rangedFit.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'RIGHT' created with bounds [60,100]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [10,100]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_extmodel_modelData' created with bounds [10,20]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(extmodel) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_extmodel_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::N = 3395.66 +/- 58.2751 L(0 - 20000) ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x|LEFT,RIGHT]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x|LEFT,RIGHT]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimizati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:8087,optimiz,optimization,8087,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,2,['optimiz'],['optimization']
Performance,"t(); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(const RooExpensiveObjectCache::ExpensiveObject&); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); virtual TClass*IsA() const; Bool_tmatches(TClass* tc, const RooArgSet& params); RooExpensiveObjectCache::ExpensiveObject&operator=(const RooExpensiveObjectCache::ExpensiveObject&); const char*ownerName() const; const TObject*payload() const; TObject*payload(); voidprint(); voidsetPayload(TObject* obj); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tuid() const. Data Members; protected:. map<TString,Int_t>_catRefParamsNames and values of discrete-valued reference parameters ; TString_ownerNameName of RooAbsArg object that is associated to cache contents; TObject*_payloadPayload; map<TString,Double_t>_realRefParamsNames and values of real-valued reference parameters; Int_t_uidUnique element ID ;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); Construct ExpensiveObject oject for inPayLoad and store reference values; for all RooAbsReal and RooAbsCategory parameters in params. ExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other). ~ExpensiveObject(). Bool_t matches(TClass* tc, const RooArgSet& params); Check object type ;. void print(). ExpensiveObject(); { _payload = 0 ; }. ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter). Int_t uid() const; { return _uid ; }. const TObject* payload(); { return _payload ; }. TObject* payload(); { return _payload ; }. void setPayload(TObject* obj); { _payload = obj ; }. const char* ownerName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache__ExpensiveObject.html:1831,cache,cache,1831,root/html526/RooExpensiveObjectCache__ExpensiveObject.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache__ExpensiveObject.html,1,['cache'],['cache']
Performance,"t();; 449 }; 450 ; 451 // If not create it now; 452 RooArgSet depList;; 453 getObservables(iset, depList);; 454 ; 455 // Normalization is always over all pdf components. Overriding the global; 456 // component selection temporarily makes all RooRealIntegrals created during; 457 // that time always include all components.; 458 GlobalSelectComponentRAII globalSelComp(true);; 459 RooAbsReal* norm = std::unique_ptr<RooAbsReal>{createIntegral(depList,*nset, *getIntegratorConfig(), RooNameReg::str(rangeName))}.release();; 460 ; 461 // Store it in the cache; 462 _normMgr.setObj(nset,iset,new CacheElem(*norm),rangeName) ;; 463 ; 464 // And return the newly created integral; 465 return norm ;; 466}; 467 ; 468 ; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Verify that the normalization integral cached with this PDF; 472/// is valid for given set of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.; 493 // However, the cache checks if the nset was already cached **by content**,; 494 // and not by RooArgSet instance! So it can happen that the normalization; 495 // set object is different, but the integral object is the same, in which; 496 // ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:17839,cache,cached,17839,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"t();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263443,load,loads,263443,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loads']
Performance,"t(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf104_classfactory.py. tutorialsroofitrf104_classfactory.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8py.html:4005,optimiz,optimization,4005,doc/master/rf104__classfactory_8py.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html,4,['optimiz'],['optimization']
Performance,"t(TH1::kNoStats);; 1150 for (Int_t i=0;i<5000;i++) {; 1151 double x,y;; 1152 gRandom->Rannor(x,y);; 1153 if(x>0 && y>0) h1->Fill(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:47642,perform,performance,47642,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['perform'],['performance']
Performance,"t(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxDepth(Int_t d); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNodeMinEvents(Int_t d); voidSetNodePurityLimit(Double_t l); voidSetNTrees(Int_t d); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:15191,tune,tuneParameters,15191,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:5727,load,loadopts,5727,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,4,['load'],['loadopts']
Performance,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:5948,load,loadopts,5948,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,8,['load'],['loadopts']
Performance,"t(i);; 8637 branch = (TBranch*)leaf->GetBranch();; 8638 if (!branch->TestBit(kDoNotProcess)) {; 8639 leafcount = leaf->GetLeafCount();; 8640 if (leafcount) {; 8641 bcount = leafcount->GetBranch();; 8642 bcount->ResetBit(kDoNotProcess);; 8643 }; 8644 } else {; 8645 //Int_t nbranches = branch->GetListOfBranches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:337799,cache,cache,337799,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"t) const. protected:. virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:16875,optimiz,optimizeDirtyHook,16875,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t) const. protected:. voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidRooAbsString::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsString::attachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsString::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringRooAbsString::evaluate() const; virtual voidRooAbsString::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsString::isValid() const; virtual Bool_tRooAbsString::isValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsString::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsString::syncCache(const RooArgSet* nset = 0); const char*RooAbsString::traceEval() const; virtual Bool_tRooAbsString::traceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:17129,optimiz,optimizeDirtyHook,17129,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"t)!; 1503 return (oldClass->GetCollectionType() == newClass->GetCollectionType());; 1504 }; 1505 return kFALSE;; 1506 }; 1507 ; 1508 TClass *FindAlternate(TClass *context, const std::string &i_name, std::string& newName); 1509 {; 1510 // Return a class whose has the name as oldClass and can be found; 1511 // within the scope of the class 'context'.; 1512 ; 1513 // First strip any 'const ' prefix or trailing '*'.; 1514 std::string name(i_name);; 1515 newName.clear();; 1516 if (name.compare(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:58956,load,load,58956,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['load']
Performance,"t). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:33331,perform,performs,33331,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,4,['perform'],['performs']
Performance,"t).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the caceh information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:28370,cache,caches,28370,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,4,['cache'],['caches']
Performance,"t).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:32367,cache,caches,32367,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,2,['cache'],['caches']
Performance,"t); Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset); Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset); Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset); Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:42567,cache,cache,42567,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"t)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:38742,multi-thread,multi-threads,38742,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['multi-thread'],['multi-threads']
Performance,"t)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3215; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3151; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3098; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:38741,multi-thread,multi-threads,38741,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['multi-thread'],['multi-threads']
Performance,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100442,load,loading,100442,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,8,['load'],['loading']
Performance,"t* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidvalidateAbsMin() const. Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. Double_t_absMinabsolute minimum of -log(L); Bool_t_absMinValidflag if absmin is up-to-date; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:31776,Cache,CacheMode,31776,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,1,['Cache'],['CacheMode']
Performance,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34048,cache,cache,34048,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,30,['cache'],['cache']
Performance,"t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tTEventIter::LoadDir(); voidTObject::MakeZombie(). private:. TTree*GetTrees(TDSetElement* elem); TTree*Load(TDSetElement* elem, Bool_t& localfile). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tTEventIter::fCurcurrent entry; TDSet*TEventIter::fDSetdata set over which to iterate; TDirectory*TEventIter::fDirdirectory containing the objects or the TTree; TDSetElement*TEventIter::fElemCurrent Element; Long64_tTEventIter::fElemCurcurrent entry for this element; Long64_tTEventIter::fElemFirstfirst entry to process for this element; Long64_tTEventIter::fElemNumnumber of entries to process for this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEventIterTree.html:5374,Load,Load,5374,root/html532/TEventIterTree.html,https://root.cern,https://root.cern/root/html532/TEventIterTree.html,1,['Load'],['Load']
Performance,"t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tSetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoFlush(Long64_t autof = -30000000); virtual voidSetAutoSave(Long64_t autos = -300000000); virtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tSetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual voidSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:26019,cache,cachesize,26019,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cachesize']
Performance,"t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); -- Resets the state of this chain. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TChain.html:45514,load,loads,45514,root/html530/TChain.html,https://root.cern,https://root.cern/root/html530/TChain.html,1,['load'],['loads']
Performance,"t* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. Int_t AddNavigator(TGeoNavigator* navigator); Add a navigator in the list of navigators. If it is the first one make it; current navigator. Bool_t SetCurrentNavigator(Int_t index); Switch to another navigator. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:37754,cache,cache,37754,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,2,['cache'],['cache']
Performance,"t* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:36003,optimiz,optimizeDirtyHook,36003,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,204,['optimiz'],['optimizeDirtyHook']
Performance,"t*); virtual Int_tTNetFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCastorFile.html:12855,cache,cache,12855,root/html530/TCastorFile.html,https://root.cern,https://root.cern/root/html530/TCastorFile.html,1,['cache'],['cache']
Performance,"t*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tagFlav; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBMixDecay.html:42036,cache,cache,42036,root/html530/RooBMixDecay.html,https://root.cern,https://root.cern/root/html530/RooBMixDecay.html,2,['cache'],['cache']
Performance,"t*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFunctor1DPdfBinding.html:40601,cache,cache,40601,root/html532/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html532/RooFunctor1DPdfBinding.html,4,['cache'],['cache']
Performance,"t*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFunctorBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionMultiDim& f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorBinding.html:36490,cache,cache,36490,root/html602/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorBinding.html,8,['cache'],['cache']
Performance,"t*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,double,double>&operator=(const RooCFunction3PdfBinding<double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html:23584,optimiz,optimizeCacheMode,23584,root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,8,['optimiz'],['optimizeCacheMode']
Performance,"t, Architecture_t>;; 1171 ; 1172 bool debug = Log().GetMinType() == kDEBUG;; 1173 ; 1174 ; 1175 // set the random seed for weight initialization; 1176 Architecture_t::SetRandomSeed(fRandomSeed);; 1177 ; 1178 ///split training data in training and validation data; 1179 // and determine the number of training and testing examples; 1180 ; 1181 size_t nValidationSamples = GetNumValidationSamples();; 1182 size_t nTrainingSamples = GetEventCollection(Types::kTraining).size() - nValidationSamples;; 1183 ; 1184 const std::vector<TMVA::Event *> &allData = GetEventCollection(Types::kTraining);; 1185 const std::vector<TMVA::Event *> eventCollectionTraining{allData.begin(), allData.begin() + nTrainingSamples};; 1186 const std::vector<TMVA::Event *> eventCollectionValidation{allData.begin() + nTrainingSamples, allData.end()};; 1187 ; 1188 size_t trainingPhase = 1;; 1189 ; 1190 for (TTrainingSettings &settings : this->GetTrainingSettings()) {; 1191 ; 1192 size_t nThreads = 1; // FIXME threads are hard coded to 1, no use of slave threads or multi-threading; 1193 ; 1194 ; 1195 // After the processing of the options, initialize the master deep net; 1196 size_t batchSize = settings.batchSize;; 1197 this->SetBatchSize(batchSize);; 1198 // Should be replaced by actual implementation. No support for this now.; 1199 size_t inputDepth = this->GetInputDepth();; 1200 size_t inputHeight = this->GetInputHeight();; 1201 size_t inputWidth = this->GetInputWidth();; 1202 size_t batchDepth = this->GetBatchDepth();; 1203 size_t batchHeight = this->GetBatchHeight();; 1204 size_t batchWidth = this->GetBatchWidth();; 1205 ELossFunction J = this->GetLossFunction();; 1206 EInitialization I = this->GetWeightInitialization();; 1207 ERegularization R = settings.regularization;; 1208 EOptimizer O = settings.optimizer;; 1209 Scalar_t weightDecay = settings.weightDecay;; 1210 ; 1211 //Batch size should be included in batch layout as well. There are two possibilities:; 1212 // 1. Batch depth = batch size one w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:45850,multi-thread,multi-threading,45850,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54703,optimiz,optimizerParams,54703,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerParams']
Performance,"t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumRunningInt.html:27206,cache,cacheFunc,27206,root/html532/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html532/RooNumRunningInt.html,2,['cache'],['cacheFunc']
Performance,"t, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3825,cache,cache,3825,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,2,['cache'],['cache']
Performance,"t, Scalar_t learningRate=0.01, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdagrad ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:2112,optimiz,optimization,2112,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['optimiz'],['optimization']
Performance,"t, TVirtualPad, TTask, TNode, and TGeometry.; Definition at line 574 of file TObject.cxx. ◆ MakeZombie(). void TObject::MakeZombie ; (; ). inlineprotected . Definition at line 53 of file TObject.h. ◆ MayNotUse(). void TObject::MayNotUse ; (; const char * ; method); const. Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ; Definition at line 1040 of file TObject.cxx. ◆ Notify(). Bool_t TObject::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented in TSelEvent, TXSocketHandler, TProofMgrInterruptHandler, TXProofServSigPipeHandler, TXProofServTerminationHandler, TXProofServSegViolationHandler, TXProofServInputHandler, TXSlaveInterruptHandler, TXSocketPingHandler, TMessageHandler, TNotifyLink< Type >, TNotifyLink< RNoCleanupNotifierHelper >, TNotifyLink< ROOT::Detail::TBranchProxy >, TNotifyLink< TTreeReader >, TFileHandler, TSignalHandler, TStdExceptionHandler, TProcessEventTimer, TTimer, TIdleTimer, TSingleShotCleaner, TCollection, TRefTable, TBrowserTimer, TInterruptHandler, TTermInputHandler, TThreadTimer, TGLRedrawTimer, TViewTimer, TGContainerKeyboardTimer, TGContainerScrollTimer, TGInputHandler, TViewUpdateTimer, TPopupDelayTimer, TRepeatTimer, TSBRepeatTimer, TGTextEditHist, TInsCharCom, TDelCharCom, TBreakLineCom, TInsTextCom, TDelTextCom, TBlinkTimer, TTipDelayTimer, TGuiBldDragMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:74636,load,load,74636,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,2,['load'],['load']
Performance,"t, TVirtualPad, TTask, TNode, and TGeometry.; Definition at line 579 of file TObject.cxx. ◆ MakeZombie(). void TObject::MakeZombie ; (; ). inlineprotected . Definition at line 53 of file TObject.h. ◆ MayNotUse(). void TObject::MayNotUse ; (; const char * ; method); const. Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ; Definition at line 1046 of file TObject.cxx. ◆ Notify(). Bool_t TObject::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented in TSelEvent, TMessageHandler, TNotifyLink< Type >, TNotifyLink< RNoCleanupNotifierHelper >, TNotifyLink< ROOT::Detail::TBranchProxy >, TNotifyLink< TTreeReader >, TFileHandler, TSignalHandler, TStdExceptionHandler, TProcessEventTimer, TTimer, TIdleTimer, TSingleShotCleaner, TCollection, TRefTable, TBrowserTimer, TInterruptHandler, TTermInputHandler, TThreadTimer, TGLRedrawTimer, TViewTimer, TGContainerKeyboardTimer, TGContainerScrollTimer, TGInputHandler, TViewUpdateTimer, TPopupDelayTimer, TRepeatTimer, TSBRepeatTimer, TGTextEditHist, TInsCharCom, TDelCharCom, TBreakLineCom, TInsTextCom, TDelTextCom, TBlinkTimer, TTipDelayTimer, TGuiBldDragManagerRepeatTimer, TARInterruptHandler, TASLogHandler, TASInterruptHandler, TASSigPipeHandler, TASInputHandler, TSocketHandler, TTimeOutTimer, TProofInterruptHandler, TProofInputHandler, TProofServLogHandle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:74124,load,load,74124,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,2,['load'],['load']
Performance,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:20470,optimiz,optimizeCacheMode,20470,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1Binding<double,double>&operator=(const RooCFunction1Binding<double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html:19838,optimiz,optimizeCacheMode,19838,root/html602/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::LinInterpVar&operator=(const RooStats::HistFactory::LinInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:19813,optimiz,optimizeCacheMode,19813,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,4,['optimiz'],['optimizeCacheMode']
Performance,"t, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenProdProj.html:29900,optimiz,optimizeDirtyHook,29900,root/html534/RooGenProdProj.html,https://root.cern,https://root.cern/root/html534/RooGenProdProj.html,6,['optimiz'],['optimizeDirtyHook']
Performance,"t, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenProdProj.html:27602,optimiz,optimizeDirtyHook,27602,root/html528/RooGenProdProj.html,https://root.cern,https://root.cern/root/html528/RooGenProdProj.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"t, const RooArgSet* iset, const TNamed* rangeName) const; 444{; 445 // Check normalization is already stored; 446 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset,iset,nullptr,rangeName)) ;; 447 if (cache) {; 448 return cache->_norm.get();; 449 }; 450 ; 451 // If not create it now; 452 RooArgSet depList;; 453 getObservables(iset, depList);; 454 ; 455 // Normalization is always over all pdf components. Overriding the global; 456 // component selection temporarily makes all RooRealIntegrals created during; 457 // that time always include all components.; 458 GlobalSelectComponentRAII globalSelComp(true);; 459 RooAbsReal* norm = std::unique_ptr<RooAbsReal>{createIntegral(depList,*nset, *getIntegratorConfig(), RooNameReg::str(rangeName))}.release();; 460 ; 461 // Store it in the cache; 462 _normMgr.setObj(nset,iset,new CacheElem(*norm),rangeName) ;; 463 ; 464 // And return the newly created integral; 465 return norm ;; 466}; 467 ; 468 ; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Verify that the normalization integral cached with this PDF; 472/// is valid for given set of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:17729,cache,cached,17729,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"t, const char* opt, Long64_t fst, TDSet* dset, const char* selec); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. Long64_t DrawSelect(TDSet* dset, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files, TList* wrks = 0); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible ass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:31037,cache,cache,31037,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,4,['cache'],['cache']
Performance,"t, one can conclude that the; technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields of the various species.; The fit relies on discriminating variables  uncorrelated with a control variable :; the later is therefore totally absent from the fit. The weights are calculated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . Error bars per bin are given by Eq. (6). The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit:; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:5224,perform,performed,5224,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,4,['perform'],['performed']
Performance,"t, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim);  Pases the layer string and creates the appropriate max pool layer. ;  ; template<typename Architecture_t , typename Layer_t > ; void ParseRecurrentLayer (ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim);  Pases the layer string and creates the appropriate rnn layer. ;  ; template<typename Architecture_t , typename Layer_t > ; void ParseReshapeLayer (DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim);  Pases the layer string and creates the appropriate reshape layer. ;  ; template<typename Architecture_t > ; std::vector< Double_t > PredictDeepNet (Long64_t firstEvt, Long64_t lastEvt, size_t batchSize, Bool_t logProgress);  perform prediction of the deep neural network using batches (called by GetMvaValues) ;  ; void ProcessOptions ();  ; template<typename Architecture_t > ; void TrainDeepNet ();  train of deep neural network using the defined architecture ;  . Private Attributes; TString fArchitectureString;  The string defining the architecture: CPU or GPU. ;  ; size_t fBatchDepth;  The depth of the batch used to train the deep net. ;  ; size_t fBatchHeight;  The height of the batch used to train the deep net. ;  ; TString fBatchLayoutString;  The string defining the layout of the batch. ;  ; size_t fBatchWidth;  The width of the batch used to train the deep net. ;  ; bool fBuildNet;  Flag to control whether to build fNet, the stored network used for the evaluation. ;  ; TString fErrorStrategy;  The string defining the error strategy for training. ;  ; TString fInputLayoutString;  The string defining the layout of the input. ;  ; std::vector< size_t > fInputShape;  Contains the batch size (no. ;  ; TString fLayoutString;  The string defining t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:31021,perform,perform,31021,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['perform'],['perform']
Performance,"t,cached_end,&cached_config);; 1622 }; 1623 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1624 if (config->fNeedRepeat) {; 1625 b.SetBufferOffset(bufpos);; 1626 }; 1627 return 0;; 1628 }; 1629 ; 1630 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorLoop(TBuffer &b, void *start, const void *end, const TLoopConfiguration *loopconf, const TConfiguration *conf); 1631 {; 1632 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1633 ; 1634 Int_t bufpos = b.Length();; 1635 TVirtualArray *cached = b.PeekDataCache();; 1636 if (cached==0) {; 1637 TStreamerElement *aElement = config->fCompInfo->fElem;; 1638 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1639 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1640 char *ptr = (char*)start;; 1641 UInt_t n = (((char*)end)-((char*)start))/((TVectorLoopConfig*)loopconf)->fIncrement;; 1642 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1643 } else {; 1644 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1645 void *cached_start = (*cached)[0];; 1646 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1647 config->fAction(b,cached_start,cached_end,&cached_config);; 1648 }; 1649 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1650 if (config->fNeedRepeat) {; 1651 b.SetBufferOffset(bufpos);; 1652 }; 1653 return 0;; 1654 }; 1655 ; 1656 INLINE_TEMPLATE_ARGS Int_t UseCacheGenericCollection(TBuffer &b, void *, const void *, const TLoopConfiguration *loopconfig, const TConfiguration *conf); 1657 {; 1658 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1659 ; 1660 Int_t bufpos = b.Length();; 1661 TVirtualArray *cached = b.PeekDataCache();; 1662 if (cached==0) {; 1663 TStreamerElement *aElement = config->fCompInfo->fElem;; 1664 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1665 ; 1666 TVirtualColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:68225,cache,cached,68225,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,3,['cache'],['cached']
Performance,"t->GetN();; Long64_t chainEntries = ch->GetEntries();; Int_t treenum = 0;; ch->SetEntryList(myelist);; for (entry=start;entry < end;entry++) {; entryNumber = treechain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = fTree->LoadTree(entryNumber);; if (localEntry < 0) break;; // then either call branch->GetEntry(localEntry);; // or entryNumber->GetEntry(entryNumber);; // In the later case the LoadTree is then somewhat redudant.; }; }. When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:. Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);. to obtain the entry number within the chain you need to add to it the value; of; treeEntry+ch->GetTreeOffset()[treenum]; such that the loop in the previous example can also be written as:; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum]; ; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }. TSelectors; To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to ; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ; Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList()); while the TTree::SetEntryList() function is only setting the TTree::fEntryList; data member, the same function in TChain also finds correspondance between; the TTrees of this TChain and the sub-lists of this TEntryList.; TEntryList and the current directory; TEntryList objects are automatically added to the current directory (like TTrees).; However, in case of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryList.html:7957,Load,LoadTree,7957,root/html534/TEntryList.html,https://root.cern,https://root.cern/root/html534/TEntryList.html,1,['Load'],['LoadTree']
Performance,"t->GetN();; Long64_t chainEntries = ch->GetEntries();; Int_t treenum = 0;; ch->SetEntryList(myelist);; for (entry=start;entry < end;entry++) {; entryNumber = treechain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = fTree->LoadTree(entryNumber);; if (localEntry < 0) break;; // then either call branch->GetEntry(localEntry);; // or entryNumber->GetEntry(entryNumber);; // In the later case the LoadTree is then somewhat redudant.; }; }. When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:. Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);. to obtain the entry number within the chain you need to add to it the value; of; treeEntry+ch->GetTreeOffset()[treenum]; such that the loop in the previous example can also be written as:; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }. TSelectors; To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed.; Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList()); while the TTree::SetEntryList() function is only setting the TTree::fEntryList; data member, the same function in TChain also finds correspondance between; the TTrees of this TChain and the sub-lists of this TEntryList.; TEntryList and the current directory; TEntryList objects are automatically added to the current directory (like TTrees).; However, in case of a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryList.html:7918,Load,LoadTree,7918,root/html602/TEntryList.html,https://root.cern,https://root.cern/root/html602/TEntryList.html,2,['Load'],['LoadTree']
Performance,"t. ;  ; ROOT::DesFunc_t GetDestructor () const;  Return the wrapper around the destructor. ;  ; ROOT::DirAutoAdd_t GetDirectoryAutoAdd () const;  Return the wrapper around the directory auto add function. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; Short_t GetImplFileLine () const;  ; const char * GetImplFileName () const;  ; UInt_t GetInstanceCount () const;  ; TVirtualIsAProxy * GetIsAProxy () const;  Return the proxy implementing the IsA functionality. ;  ; TVirtualStreamerInfo * GetLastReadInfo () const;  ; TList * GetListOfAllPublicDataMembers (Bool_t load=kTRUE);  Returns a list of all public data members of this class and its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ;  ; TList * GetListOfBases ();  Return list containing the TBaseClass(es) of a class. ;  ; TList * GetListOfDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of a class. ;  ; TList * GetListOfEnums (Bool_t load=kTRUE);  Return a list containing the TEnums of a class. ;  ; TList * GetListOfFunctionTemplates (Bool_t load=kTRUE);  Return TListOfFunctionTemplates for a class. ;  ; TCollection * GetListOfMethodOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TList * GetListOfMethods (Bool_t load=kTRUE);  Return list containing the TMethods of a class. ;  ; TList * GetListOfRealData () const;  ; TList * GetListOfUsingDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of using declarations of a class. ;  ; void GetMenuItems (TList *listitems);  Returns list of methods accessible by context menu. ;  ; TList * GetMenuList () const;  Return the list of menu items associated with the class. ;  ; ROOT::MergeFunc_t GetMerge () const;  Return the wrapper around Merge. ;  ; TMethod * GetMethod (const char *method, const char *params, Bool_t objectIs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:13303,load,load,13303,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['load'],['load']
Performance,"t. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26727,concurren,concurrent,26727,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"t. This is equivalent to make install for Unix systems. ; It is possible to set a different install prefix at installation time by invoking the cmake_install.cmake script generated in the build directory:; $ cmake -DCMAKE_INSTALL_PREFIX=/tmp/root -P cmake_install.cmake. Build Options; Each build option is a boolean variable that can be turned ON or OFF. The current value is recorded in the CMake cache (CMakeCache.txt file on the build directory) and therefore it is not needed to be specified on the cmake command each time. Please note that some of the options might be turned OFF automatically for some platforms or if the required external library or component can not be satisfied. The user can view and edit the full list of options using the ccmake utility or cmake-gui for Windows. Note that some of the options are not yet implemented.; The user can set any CMake variable or option that controls the build process from the cmake command line. The command using the option -D <var>:<type>=<value> creates an entry in the CMake cache. This is the list of the ROOT specific CMake options:. option name; default value; description. afdsmgrd; OFF; Dataset manager for PROOF-based analysis facilities. afs; OFF; AFS support, requires AFS libs and objects. alien; ON; AliEn support, requires libgapiUI from ALICE. all; OFF; Enable all optional components. asimage; ON; Image processing support, requires libAfterImage. astiff; ON; Include tiff support in image processing. bonjour; ON; Bonjour support, requires libdns_sd and/or Avahi. builtin_afterimage; ON; Built included libAfterImage, or use system libAfterImage. builtin_fftw3; OFF; Built the FFTW3 library internally (downloading tarfile from the Web) (ROOT 6 only). builtin_ftgl; ON; Built included libFTGL, or use system libftgl. builtin_freetype; OFF; Built included libfreetype, or use system libfreetype. builtin_glew; ON; Built included libGLEW, or use system libGLEW. builtin_pcre; OFF; Built included libpcre, or use system libpc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:6889,cache,cache,6889,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance,"t. void SetDeclAttr(TInterpreter::DeclId_t , const char* ). DeclId_t GetDataMember(ClassInfo_t* cl, const char* name) const. DeclId_t GetDataMemberAtAddr(const void* addr) const. DeclId_t GetDataMemberWithValue(const void* ptrvalue) const. DeclId_t GetEnum(TClass* cl, const char* name) const. TEnum* CreateEnum(void* VD, TClass* cl) const. void UpdateEnumConstants(TEnum* enumObj, TClass* cl) const. void LoadEnums(TListOfEnums& cl) const. DeclId_t GetFunction(ClassInfo_t* cl, const char* funcname). DeclId_t GetFunctionWithPrototype(ClassInfo_t* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch). DeclId_t GetFunctionWithValues(ClassInfo_t* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). DeclId_t GetFunctionTemplate(ClassInfo_t* cl, const char* funcname). void GetFunctionOverloads(ClassInfo_t* cl, const char* funcname, vector<TInterpreter::DeclId_t>& res) const. void LoadFunctionTemplates(TClass* cl) const. void CallFunc_Delete(CallFunc_t* ) const; CallFunc interface. {;}. void CallFunc_Exec(CallFunc_t* , void* ) const; {;}. void CallFunc_Exec(CallFunc_t* , void* , TInterpreterValue& ) const; {;}. void CallFunc_ExecWithReturn(CallFunc_t* , void* , void* ) const; {;}. void CallFunc_ExecWithArgsAndReturn(CallFunc_t* , void* , const void*[] = 0, int = 0, void* = 0) const; {}. Long_t CallFunc_ExecInt(CallFunc_t* , void* ) const; {return 0;}. Long64_t CallFunc_ExecInt64(CallFunc_t* , void* ) const; {return 0;}. Double_t CallFunc_ExecDouble(CallFunc_t* , void* ) const; {return 0;}. CallFunc_t * CallFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_IgnoreExtraArgs(CallFunc_t* , bool ) const; {;}. void CallFunc_Init(CallFunc_t* ) const; {;}. Bool_t CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. CallFuncIFacePtr_t CallFunc_IFacePtr(C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:32764,Load,LoadFunctionTemplates,32764,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Load'],['LoadFunctionTemplates']
Performance,"t.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooClassFactory::makePdfstatic bool makePdf(std::string const &name, std::string const &realArgNames="""", std::string const &catArgNames="""", std::string const &expression=""1.0"", bool hasAnaInt=false, bool hasIntGen=false, std::string const &intExpression="""")Write code for a RooAbsPdf implementation with class name 'name'.Definition RooClassFactory.cxx:335; RooClassFactory::makePdfInstancestatic RooAbsPdf * makePdfInstance(std::string const &className, std::string const &name, std::string const &expression, const RooArgList &vars, std::string const &intExpression="""")Write, compile and load code and instantiate object for a RooAbsPdf implementation with class name 'n...Definition RooClassFactory.cxx:320; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8C.html:6646,load,load,6646,doc/master/rf104__classfactory_8C.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html,1,['load'],['load']
Performance,t.cxx. ◆ inputBaseName(). const char * RooNumRunningInt::inputBaseName ; (; ); const. overrideprotectedvirtual . Return unique name for RooAbsCachedPdf cache components constructed from input function name. ; Implements RooAbsCachedReal.; Definition at line 88 of file RooNumRunningInt.cxx. ◆ IsA(). TClass * RooNumRunningInt::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 63 of file RooNumRunningInt.h. ◆ payloadUniqueSuffix(). const char * RooNumRunningInt::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 55 of file RooNumRunningInt.h. ◆ Streamer(). void RooNumRunningInt::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedReal. ◆ StreamerNVirtual(). void RooNumRunningInt::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooNumRunningInt.h. Friends And Related Symbol Documentation. ◆ RICacheElem. friend class RICacheElem. friend . Definition at line 46 of file RooNumRunningInt.h. Member Data Documentation. ◆ _binningName. std::string RooNumRunningInt::_binningName. protected . Name of binning to be used for cache histogram. ; Definition at line 59 of file RooNumRunningInt.h. ◆ func. RooRealProxy RooNumRunningInt::func. protected . Proxy to functions whose running integral is calculated. ; Definition at line 57 of file RooNumRunningInt.h. ◆ x. RooRealProxy RooNumRunningInt::x. protected . Integrated observable. ; Definition at line 58 of file RooNumRunningInt.h. Libraries for RooNumRunningInt:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooNumRunningInt.h; roofit/roofitcore/src/RooNumRunningInt.cxx. RooNumRunningInt. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:03 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:67924,cache,cache,67924,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"t1, . TEntryList & ; elist2 . ). friend . Definition at line 1385 of file TEntryList.cxx. Member Data Documentation. ◆ fBlocks. TObjArray* TEntryList::fBlocks. protected . blocks with indices of passing events (TEntryListBlocks) ; Definition at line 35 of file TEntryList.h. ◆ fCurrent. TEntryList* TEntryList::fCurrent. protected . ! currently filled entry list ; Definition at line 32 of file TEntryList.h. ◆ fDirectory. TDirectory* TEntryList::fDirectory. protected . ! Pointer to directory holding this tree ; Definition at line 48 of file TEntryList.h. ◆ fEntriesToProcess. Long64_t TEntryList::fEntriesToProcess. protected . used on proof to set the number of entries to process in a packet ; Definition at line 37 of file TEntryList.h. ◆ fFileName. TString TEntryList::fFileName. protected . name of the file, where the tree is ; Definition at line 39 of file TEntryList.h. ◆ fLastIndexQueried. Long64_t TEntryList::fLastIndexQueried. protected . ! used to optimize GetEntry() function from a loop ; Definition at line 44 of file TEntryList.h. ◆ fLastIndexReturned. Long64_t TEntryList::fLastIndexReturned. protected . ! used to optimize GetEntry() function from a loop ; Definition at line 45 of file TEntryList.h. ◆ fLists. TList* TEntryList::fLists. protected . a list of underlying entry lists for each tree of a chain ; Definition at line 31 of file TEntryList.h. ◆ fN. Long64_t TEntryList::fN. protected . number of entries in the list ; Definition at line 36 of file TEntryList.h. ◆ fNBlocks. Int_t TEntryList::fNBlocks. protected . number of TEntryListBlocks ; Definition at line 34 of file TEntryList.h. ◆ fReapply. bool TEntryList::fReapply. protected . If true, TTree::Draw will 'reapply' the original cut. ; Definition at line 49 of file TEntryList.h. ◆ fShift. bool TEntryList::fShift. protected . ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ; Definition at line 46 of file TEntryList.h. ◆ fStringHash. ULong_t TEntryList::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:42709,optimiz,optimize,42709,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['optimiz'],['optimize']
Performance,"t: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:10410,optimiz,optimization,10410,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['optimiz'],['optimization']
Performance,"t: filename - name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; re-runs the script even if output PNGs exist that are newer; than the script. If kCompiledOutput is passed, the script is; run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:29940,cache,cached,29940,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,1,['cache'],['cached']
Performance,"t::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:2157,Cache,CacheModeRooAbsArg,2157,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"t::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetCommentStringvirtual const char * GetCommentString()Returns a comment string from the class declaration.Definition TMethod.cxx:107; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::SubstituteInt_t Substitute(TString &s, const TString &r, Bool_t doDollarSubst=kTRUE)Substitute matching part of s with r, dollar back-ref substitution is performed if doDollarSubst is t...Definition TPRegexp.cxx:963; TQClassDefinition TQClass.h:33; TQConnectionListTQConnectionList is the named list of connections, see also TQConnection class.Definition TQObject.cxx:309; TQConnectionList::lsvoid ls(Option_t *option="""") const overrideList signal name and list all connections in this signal list.Definition TQObject.cxx:378; TQConnectionList::TQConnectionListTQConnectionList(const char *name, Int_t nsigargs)Definition TQObject.cxx:315; TQConnectionList::DisconnectBool_t Disconnect(void *receiver=nullptr, const char *slot_name=nullptr)Remove connection from the list.Definition TQObject.cxx:344; TQConnectionList::GetNargsInt_t GetNargs() constDefinition TQObject.cxx:320; TQConnectionList::fSignalArgsInt_t fSignalArgsDefinition TQObject.cxx:312; TQConnectionList::~TQConnectionListvirtual ~TQConnectionList()Destructor.Definition TQObject.cxx:327; TQConnectionTQConnection clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:42289,perform,performed,42289,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['perform'],['performed']
Performance,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TEntryListFromFile(const TEntryListFromFile&); TEntryListFromFile&operator=(const TEntryListFromFile&). Data Members; public:. enum { kBigNumber; };; enum TEntryList::[unnamed] { kBlockSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; TFile*fFilecurrently open file; TStringTEntryList::fFileNamename of the file, where the tree is; TObjArray*fFileNames! points to the fFiles data member of the corresponding chain; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TStringfListFileNamefrom this string names of all files can be found; TStringfListNamename of the list; Long64_t*fListOffset[fNFiles] numbers of entries in ind. lists; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; Int_tfNFilestotal number of files; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryListFromFile.html:8912,optimiz,optimize,8912,root/html534/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html534/TEntryListFromFile.html,4,['optimiz'],['optimize']
Performance,"t::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofBenchDataSet.html:6127,cache,cache,6127,root/html604/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html604/TProofBenchDataSet.html,2,['cache'],['cache']
Performance,"t::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBenchDataSet.html:6127,cache,cache,6127,root/html602/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html602/TProofBenchDataSet.html,2,['cache'],['cache']
Performance,"t::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheWrite.html:6407,cache,cache,6407,root/html528/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html528/TFileCacheWrite.html,6,['cache'],['cache']
Performance,"t::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:23032,cache,cache,23032,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,2,['cache'],['cache']
Performance,"t::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); Bool_tsetBinIntegrator(RooArgSet& allVars); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpCode(RooAbsReal& param, int code); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidsetPositiveDefinite(bool flag = true); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:23362,cache,cache,23362,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2010-09-23 20:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveEventManager.html:19736,load,loaded,19736,root/html528/TEveEventManager.html,https://root.cern,https://root.cern/root/html528/TEveEventManager.html,1,['load'],['loaded']
Performance,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveEventManager.html:20102,load,loaded,20102,root/html530/TEveEventManager.html,https://root.cern,https://root.cern/root/html530/TEveEventManager.html,1,['load'],['loaded']
Performance,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveEventManager.html:20102,load,loaded,20102,root/html532/TEveEventManager.html,https://root.cern,https://root.cern/root/html532/TEveEventManager.html,2,['load'],['loaded']
Performance,"t::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQConnection. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQConnection.html:14256,cache,cache,14256,root/html602/TQConnection.html,https://root.cern,https://root.cern/root/html602/TQConnection.html,4,['cache'],['cache']
Performance,"t::kIsReferenced; static TFormula::(anonymous)kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TFormula::(anonymous)kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function; TStringTNamed::fTitleobject title; static TFormula::(anonymous)kAdd; static TFormula::(anonymous)kAnd; static TFormula::(anonymous)kBinary; static TFormula::(anonymous)kBitAnd; static TFormula::(anonymous)kBitOr; static TFormula::(anonymous)kBoolOptimize; static TFormula::(anonymous)kBoolOptimizeAnd; static TFormula::(an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFormula.html:12307,cache,cache,12307,root/html602/TFormula.html,https://root.cern,https://root.cern/root/html602/TFormula.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"t::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static RooExpensiveObjectCache*_instance!; map<TString,RooExpensiveObjectCache::ExpensiveObject*>_map; Int_t_nextUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache.html:7412,cache,cache,7412,root/html602/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache.html,8,['cache'],"['cache', 'cacheObject']"
Performance,"t; 3263/// - option of transform type; 3264/// - ""R2C"" - real to complex transforms - default; 3265/// - ""R2HC"" - real to halfcomplex (special format of storing output data,; 3266/// results the same as for R2C); 3267/// - ""DHT"" - discrete Hartley transform; 3268/// real to real transforms (sine and cosine):; 3269/// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; 3270/// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; 3271/// To specify the type of each dimension of a 2-dimensional real to real; 3272/// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; 3273/// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; 3274/// - option of transform flag; 3275/// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; 3276/// performance; 3277/// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; 3278/// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; 3279/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 3280/// This option should be chosen depending on how many transforms of the same size and; 3281/// type are going to be done. Planning is only done once, for the first transform of this; 3282/// size and type. Default is ""ES"".; 3283///; 3284/// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""; 3285 ; 3286TH1* TH1::FFT(TH1* h_output, Option_t *option); 3287{; 3288 ; 3289 Int_t ndim[3];; 3290 ndim[0] = this->GetNbinsX();; 3291 ndim[1] = this->GetNbinsY();; 3292 ndim[2] = this->GetNbinsZ();; 3293 ; 3294 TVirtualFFT *fft;; 3295 TString opt = option;; 3296 opt.ToUpper();; 3297 if (!opt.Contains(""2R"")){; 3298 if (!opt.Contains(""2C"") && !opt.Contains(""2HC"") && !opt.Contains(""DHT"")) {; 3299 //no type specified, ""R2C"" by default; 3300 opt.Append(""R2C"");; 3301 }; 3302 fft = TVirtualFFT::FFT(this->GetDimension(), ndim, opt.Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:130969,perform,performance,130969,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['performance']
Performance,"t; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. void useHorizontalMorphing(bool val); { _useHorizMorph = val; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Tue Jun 2 15:32:12 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMomentMorph.html:46885,Cache,CacheElem,46885,root/html604/RooMomentMorph.html,https://root.cern,https://root.cern/root/html604/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"t; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); RooAbsRealLValue&operator=(const RooAbsRealLValue&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:22931,optimiz,optimizeCacheMode,22931,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,4,['optimiz'],['optimizeCacheMode']
Performance,"t; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:35792,load,load,35792,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,8,['load'],"['load', 'loading']"
Performance,"t; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfFunctions(const TListOfFunctions& ). TListO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctions.html:14813,Load,Load,14813,root/html604/TListOfFunctions.html,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html,2,['Load'],['Load']
Performance,"t; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:6084,load,load,6084,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"t; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:6073,load,load,6073,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"t; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:5043,load,load,5043,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,2,['load'],['load']
Performance,"t; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamembe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:4446,load,load,4446,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"t; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPython.html:1348,Load,Load,1348,root/html532/TPython.html,https://root.cern,https://root.cern/root/html532/TPython.html,2,['Load'],['Load']
Performance,"t; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the Cling side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPython.html:1349,Load,Load,1349,root/html602/TPython.html,https://root.cern,https://root.cern/root/html602/TPython.html,2,['Load'],['Load']
Performance,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2010-11-25 07:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Minimizer.html:10297,perform,perform,10297,root/html528/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Minimizer.html:11140,perform,perform,11140,root/html530/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Minimizer.html:11140,perform,perform,11140,root/html532/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html,2,['perform'],['perform']
Performance,"t; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html:33054,cache,cache,33054,root/html532/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html,4,['cache'],['cache']
Performance,"t; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree *t, const RooFormulaVar* select, const char* /*rangeName*/, Int_t /*nStart*/, Int_t /*nStop*/); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore *ads, const RooFormulaVar* select, 				 const char* rangeName, Int_t nStart, Int_t nStop); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:13755,load,loadValues,13755,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,1,['load'],['loadValues']
Performance,"t; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FumiliFCNBase(). Default Constructor. Need in this case to create when implementing EvaluateAll the Gradient and Hessian vectors with the right size. {}. FumiliFCNBase(unsigned int npar). Constructor which initializes the class with the function provided by the; user for modeling the data. @param npar the number of parameters. {}. virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id$ » Last ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FumiliFCNBase.html:3503,cache,cached,3503,root/html602/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FumiliFCNBase.html,4,['cache'],['cached']
Performance,"t; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsGlobal() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTVirtualPadEditor::LineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*TVirtualPadEditor::LoadEditor(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTVirtualPadEditor::MarkerAttributes(Int_t, Int_t, Float_t); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedEditor.html:13645,Load,LoadEditor,13645,root/html532/TGedEditor.html,https://root.cern,https://root.cern/root/html532/TGedEditor.html,2,['Load'],['LoadEditor']
Performance,"t; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsGlobal() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTVirtualPadEditor::LineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*TVirtualPadEditor::LoadEditor(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTVirtualPadEditor::MarkerAttributes(Int_t, Int_t, Float_t); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedEditor.html:13573,Load,LoadEditor,13573,root/html602/TGedEditor.html,https://root.cern,https://root.cern/root/html602/TGedEditor.html,2,['Load'],['LoadEditor']
Performance,"t; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePlot3DGL.html:1823,cache,cached,1823,root/html528/TEvePlot3DGL.html,https://root.cern,https://root.cern/root/html528/TEvePlot3DGL.html,4,['cache'],['cached']
Performance,"t; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooDataProjBinding&operator=(const RooDataProjBinding&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooDataProjBinding(const RooDataProjBinding&); RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooRealBinding::_clipInvalid; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; const RooAbsData*_dataDataset used for projection; UInt_tRooAbsFunc::_dimensionNumber of observables; Bool_t_firstBit indicating if operator() has been called yet; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set for real function; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; const RooAbsReal*_realReal function to be projected; RooSuperCategory*_superCatSupercategory constructed from _data's category variables; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataProjBinding.html:1945,load,loadValues,1945,root/html602/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html602/RooDataProjBinding.html,4,['load'],['loadValues']
Performance,"t; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:25050,optimiz,optimizeCacheMode,25050,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:12688,cache,cachedVars,12688,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,10,"['cache', 'optimiz']","['cacheArgs', 'cacheClone', 'cacheList', 'cachedVars', 'optimizeReadingWithCaching']"
Performance,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:12135,cache,cachedVars,12135,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,15,"['cache', 'optimiz']","['cacheArgs', 'cacheClone', 'cacheList', 'cachedVars', 'optimizeReadingWithCaching']"
Performance,"t; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGridJobStatusList.html:10207,cache,cache,10207,root/html602/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html602/TGridJobStatusList.html,2,['cache'],['cache']
Performance,"t; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGridJobStatusList.html:10207,cache,cache,10207,root/html604/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html604/TGridJobStatusList.html,2,['cache'],['cache']
Performance,"t; virtual voidwriteToStream(ostream& os, Bool_t compact) const. protected:. voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringevaluate() const; virtual voidfillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tisValid() const; virtual Bool_tisValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* nset = 0); const char*traceEval() const; virtual Bool_ttraceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:16190,optimiz,optimizeDirtyHook,16190,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t; voidTObject::MakeZombie(). private:. TEveVSD(const TEveVSD&); TEveVSD&operator=(const TEveVSD&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TEveClusterfC; TEveRecCascadefCC; TEveMCRecCrossReffGI; TEveHitfH; TEveMCTrackfK; TEveRecKinkfKK; TEveRecTrackfR; TTree*fTreeC! Clusters.; TTree*fTreeCC! Cascades.; TTree*fTreeGI! Sim-Rec cross references.; TTree*fTreeH! Hits.; TTree*fTreeK! Kinematics.; TTree*fTreeKK! Kinks.; TTree*fTreeR! Reconstructed tracks.; TTree*fTreeV0! VO's.; TEveRecV0fV0; TEveCluster*fpC!; TEveRecCascade*fpCC!; TEveMCRecCrossRef*fpGI!; TEveHit*fpH!; TEveMCTrack*fpK!; TEveRecKink*fpKK!; TEveRecTrack*fpR!; TEveRecV0*fpV0!. protected:. Int_tfBuffSize!; TDirectory*fDirectory!; TFile*fFile!; Int_tfVerbose!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveVSD(const char* name = ""TEveVSD"", const char* title = """"); Constructor. ~TEveVSD(); Destructor. void SetDirectory(TDirectory* dir); Set directory in which the trees are (or will be) created. void CreateTrees(); Create internal trees. void DeleteTrees(); Delete interal trees. void CreateBranches(); Create internal VSD branches. void SetBranchAddresses(); Set branche addresses of internal trees. void WriteTrees(); Does nothing here ... reimplemented in sub-classes. void LoadTrees(); Load internal trees from directory. void DisableTObjectStreamersForVSDStruct(); Disble TObject streamers for those VSD structs that inherit from; TObject directly. TEveVSD(const TEveVSD& ). TEveVSD& operator=(const TEveVSD& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveVSD.html:6647,Load,LoadTrees,6647,root/html534/TEveVSD.html,https://root.cern,https://root.cern/root/html534/TEveVSD.html,2,['Load'],"['Load', 'LoadTrees']"
Performance,"t;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TProofDraw; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEntryList.html:10720,load,loaded,10720,doc/master/classTProofDrawEntryList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEntryList.html,9,['load'],['loaded']
Performance,"t;  ; Int_t fTcpWindowSize;  ; TString fUrl;  ; TList * fUUIDs;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TSocket; static ULong64_t fgBytesRecv = 0;  ; static ULong64_t fgBytesSent = 0;  ; static Int_t fgClientProtocol = 17;  . #include <TPServerSocket.h>. Inheritance diagram for TPServerSocket:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TPServerSocket() [1/3]. TPServerSocket::TPServerSocket ; (; const TPServerSocket & ; ). privatedelete . ◆ TPServerSocket() [2/3]. TPServerSocket::TPServerSocket ; (; Int_t ; port, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object on a specified port. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 49 of file TPServerSocket.cxx. ◆ TPServerSocket() [3/3]. TPServerSocket::TPServerSocket ; (; const char * ; service, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object for a named service. ; Set re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:20098,queue,queue,20098,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,1,['queue'],['queue']
Performance,"t;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void * GetDirPtr () const;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags. ;  ; virtual const char * GetFlagsOpt () const;  Return the optimization flags. ;  ; virtual TString GetFromPipe (const char *command);  Execute command and return output in TString. ;  ; virtual const char * GetIncludePath ();  Get the list of include path. ;  ; virtual const char * GetLibraries (const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE);  Return a space separated list of loaded shared libraries. ;  ; virtual const char * GetLinkdefSuffix () const;  Return the linkdef suffix chosen by the user for ACLiC. ;  ; virtual const char * GetLinkedLibs () const;  Return the list of library linked to this executable. ;  ; virtual TSeqCollection * GetListOfFileHandlers () const;  ; virtual TSeqCollection * GetListOfSignalHandlers () const;  ; virtual TSeqCollection * GetListOfStdExceptionHandlers () const;  ; virtual TList * GetListOfTimers () const;  ; virtual const char * GetMakeExe () const;  Return the command line use to make an executable. ;  ; virtual const char * GetMakeSharedLib () const;  Return the command line use to make a shared library. ;  ; virtual const char * GetObjExt () const;  Get the object file extension. ;  ; int GetPathInfo (const char *path, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Get info about a file: id, size, flags, modification time. ;  ; int GetPathInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:15781,load,loaded,15781,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['load'],['loaded']
Performance,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:103350,load,load,103350,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"t;; 2800 offset += baseclass->Size();; 2801 } else if (element->IsA() == TStreamerSTL::Class()) {; 2802 TStreamerSTL *base = (TStreamerSTL*)element;; 2803 TClass *baseclass = base->GetClassPointer();; 2804 if (!baseclass) return -1;; 2805 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2806 if (subOffset == -2) return -2;; 2807 if (subOffset != -1) return offset+subOffset;; 2808 offset += baseclass->Size();; 2809 ; 2810 } else {; 2811 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2812 }; 2813 }; 2814 }; 2815 return -1;; 2816 }; 2817 }; 2818 ; 2819 TClass *c;; 2820 Int_t off;; 2821 TBaseClass *inh;; 2822 TObjLink *lnk = nullptr;; 2823 if (fBase.load() == nullptr); 2824 lnk = GetListOfBases()->FirstLink();; 2825 else; 2826 lnk = fBase.load()->FirstLink();; 2827 ; 2828 // otherwise look at inheritance tree; 2829 while (lnk) {; 2830 inh = (TBaseClass *)lnk->GetObject();; 2831 //use option load=kFALSE to avoid a warning like:; 2832 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2833 //We can not afford to not have the class if it exist, so we; 2834 //use kTRUE.; 2835 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2836 if (c) {; 2837 if (cl == c) {; 2838 if ((inh->Property() & kIsVirtualBase) != 0); 2839 return -2;; 2840 return inh->GetDelta();; 2841 }; 2842 off = c->GetBaseClassOffsetRecurse(cl);; 2843 if (off == -2) return -2;; 2844 if (off != -1) {; 2845 return off + inh->GetDelta();; 2846 }; 2847 }; 2848 lnk = lnk->Next();; 2849 }; 2850 return -1;; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// - Return data member offset to the base class ""cl"".; 2855/// - Returns -1 in case ""cl"" is not a base class.; 2856/// Takes care of multiple inheritance.; 2857 ; 2858Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2859{; 2860 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:106101,load,load,106101,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"t;; 5138}; 5139 ; 5140 ; 5141FUNCTION_MAY_BE_UNUSED; 5142static struct dirent *; 5143mg_readdir(DIR *dir); 5144{; 5145 struct dirent *result = 0;; 5146 ; 5147 if (dir) {; 5148 if (dir->handle != INVALID_HANDLE_VALUE) {; 5149 result = &dir->result;; 5150 (void)WideCharToMultiByte(CP_UTF8,; 5151 0,; 5152 dir->info.cFileName,; 5153 -1,; 5154 result->d_name,; 5155 sizeof(result->d_name),; 5156 NULL,; 5157 NULL);; 5158 ; 5159 if (!FindNextFileW(dir->handle, &dir->info)) {; 5160 (void)FindClose(dir->handle);; 5161 dir->handle = INVALID_HANDLE_VALUE;; 5162 }; 5163 ; 5164 } else {; 5165 SetLastError(ERROR_FILE_NOT_FOUND);; 5166 }; 5167 } else {; 5168 SetLastError(ERROR_BAD_ARGUMENTS);; 5169 }; 5170 ; 5171 return result;; 5172}; 5173 ; 5174 ; 5175#if !defined(HAVE_POLL); 5176#undef POLLIN; 5177#undef POLLPRI; 5178#undef POLLOUT; 5179#undef POLLERR; 5180#define POLLIN (1) /* Data ready - read will not block. */; 5181#define POLLPRI (2) /* Priority data ready. */; 5182#define POLLOUT (4) /* Send queue not full - write will not block. */; 5183#define POLLERR (8) /* Error event */; 5184 ; 5185FUNCTION_MAY_BE_UNUSED; 5186static int; 5187poll(struct mg_pollfd *pfd, unsigned int n, int milliseconds); 5188{; 5189 struct timeval tv;; 5190 fd_set rset;; 5191 fd_set wset;; 5192 fd_set eset;; 5193 unsigned int i;; 5194 int result;; 5195 SOCKET maxfd = 0;; 5196 ; 5197 memset(&tv, 0, sizeof(tv));; 5198 tv.tv_sec = milliseconds / 1000;; 5199 tv.tv_usec = (milliseconds % 1000) * 1000;; 5200 FD_ZERO(&rset);; 5201 FD_ZERO(&wset);; 5202 FD_ZERO(&eset);; 5203 ; 5204 for (i = 0; i < n; i++) {; 5205 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5206 if (pfd[i].events & POLLIN) {; 5207 FD_SET(pfd[i].fd, &rset);; 5208 }; 5209 if (pfd[i].events & POLLOUT) {; 5210 FD_SET(pfd[i].fd, &wset);; 5211 }; 5212 /* Check for errors for any FD in the set */; 5213 FD_SET(pfd[i].fd, &eset);; 5214 }; 5215 pfd[i].revents = 0;; 5216 ; 5217 if (pfd[i].fd > maxfd) {; 5218 maxfd = pfd[i].fd;; 5219 }; 5220 }; 522",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:154289,queue,queue,154289,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t;; 5139}; 5140 ; 5141 ; 5142FUNCTION_MAY_BE_UNUSED; 5143static struct dirent *; 5144mg_readdir(DIR *dir); 5145{; 5146 struct dirent *result = 0;; 5147 ; 5148 if (dir) {; 5149 if (dir->handle != INVALID_HANDLE_VALUE) {; 5150 result = &dir->result;; 5151 (void)WideCharToMultiByte(CP_UTF8,; 5152 0,; 5153 dir->info.cFileName,; 5154 -1,; 5155 result->d_name,; 5156 sizeof(result->d_name),; 5157 NULL,; 5158 NULL);; 5159 ; 5160 if (!FindNextFileW(dir->handle, &dir->info)) {; 5161 (void)FindClose(dir->handle);; 5162 dir->handle = INVALID_HANDLE_VALUE;; 5163 }; 5164 ; 5165 } else {; 5166 SetLastError(ERROR_FILE_NOT_FOUND);; 5167 }; 5168 } else {; 5169 SetLastError(ERROR_BAD_ARGUMENTS);; 5170 }; 5171 ; 5172 return result;; 5173}; 5174 ; 5175 ; 5176#if !defined(HAVE_POLL); 5177#undef POLLIN; 5178#undef POLLPRI; 5179#undef POLLOUT; 5180#undef POLLERR; 5181#define POLLIN (1) /* Data ready - read will not block. */; 5182#define POLLPRI (2) /* Priority data ready. */; 5183#define POLLOUT (4) /* Send queue not full - write will not block. */; 5184#define POLLERR (8) /* Error event */; 5185 ; 5186FUNCTION_MAY_BE_UNUSED; 5187static int; 5188poll(struct mg_pollfd *pfd, unsigned int n, int milliseconds); 5189{; 5190 struct timeval tv;; 5191 fd_set rset;; 5192 fd_set wset;; 5193 fd_set eset;; 5194 unsigned int i;; 5195 int result;; 5196 SOCKET maxfd = 0;; 5197 ; 5198 memset(&tv, 0, sizeof(tv));; 5199 tv.tv_sec = milliseconds / 1000;; 5200 tv.tv_usec = (milliseconds % 1000) * 1000;; 5201 FD_ZERO(&rset);; 5202 FD_ZERO(&wset);; 5203 FD_ZERO(&eset);; 5204 ; 5205 for (i = 0; i < n; i++) {; 5206 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5207 if (pfd[i].events & POLLIN) {; 5208 FD_SET(pfd[i].fd, &rset);; 5209 }; 5210 if (pfd[i].events & POLLOUT) {; 5211 FD_SET(pfd[i].fd, &wset);; 5212 }; 5213 /* Check for errors for any FD in the set */; 5214 FD_SET(pfd[i].fd, &eset);; 5215 }; 5216 pfd[i].revents = 0;; 5217 ; 5218 if (pfd[i].fd > maxfd) {; 5219 maxfd = pfd[i].fd;; 5220 }; 5221 }; 522",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:154321,queue,queue,154321,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t=0.55); ; # Add box with data statistics; # -------------------------------------------------------; ; # X size of box is from 55% to 99% of Xaxis range, of box is at 80% of; # Yaxis range); data.statOn(frame, Layout=(0.55, 0.99, 0.8)); ; # Add text and arrow; # -----------------------------------; ; # Add text to frame; txt = ROOT.TText(2, 100, ""Signal""); txt.SetTextSize(0.04); txt.SetTextColor(ROOT.kRed); frame.addObject(txt); ; # Add arrow to frame; arrow = ROOT.TArrow(2, 100, -1, 50, 0.01, ""|>""); arrow.SetLineColor(ROOT.kRed); arrow.SetFillColor(ROOT.kRed); arrow.SetLineWidth(3); frame.addObject(arrow); ; # Persist frame with all decorations in ROOT file; # ---------------------------------------------------------------------------------------------; ; f = ROOT.TFile(""rf106_plotdecoration.root"", ""RECREATE""); frame.Write(); f.Close(); ; # To read back and plot frame with all decorations in clean root session do; # root> ROOT.TFile f(""rf106_plotdecoration.root""); # root> xframe.Draw(); ; c = ROOT.TCanvas(""rf106_plotdecoration"", ""rf106_plotdecoration"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf106_plotdecoration.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf106_plotdecoration.py. tutorialsroofitrf106_plotdecoration.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf106__plotdecoration_8py.html:2829,optimiz,optimization,2829,doc/master/rf106__plotdecoration_8py.html,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8py.html,2,['optimiz'],['optimization']
Performance,"t>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3586,cache,cache,3586,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,4,['cache'],['cache']
Performance,"t>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i].Data());; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Here the preparation phase begins; ; // Create a new root output file; TString outfileName( ""TMVAReg.root"" );; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory will; // then run the performance analysis for you.; //; // The first argument is the base of the name of all the; // weightfiles in the directory weight/; //; // The second argument is the output file for the training results; // All TMVA output can be suppressed by removing the ""!"" (not) in; // front of the ""Silent"" argument in the option string; TMVA::Factory *factory = new TMVA::Factory( ""TMVARegression"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:AnalysisType=Regression"" );; ; ; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""datasetreg"");; // If you wish to modify default settings; // (please check ""src/Config.h"" to see all available global options); //; // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; ; // Define the input variables that shall be used for the MVA training; // note that you may also use variable expressions, such as: ""3*var1/var2*abs(var3)""; // [all types of expressions that can also be pars",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:137382,perform,performance,137382,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,"tA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolManagerA manager for the scheduler behind ROOT multithreading o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:200509,perform,performance,200509,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['perform'],['performance']
Performance,"tA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolPlayer;  CTPoolProcessor;  CTPoolWorkerThis class works togethe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:175227,perform,performance,175227,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performance']
Performance,"tA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPosixCondition;  CTPosixMutex;  CTPosixThread;  CTPosixThreadCleanU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:184477,perform,performance,184477,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,3,['perform'],['performance']
Performance,"tArrays(). void TSelectorDraw::InitArrays ; (; Int_t ; newsize). protectedvirtual . Initialization of the primitive type arrays if the new size is bigger than the available space. ; Definition at line 1092 of file TSelectorDraw.cxx. ◆ IsA(). TClass * TSelectorDraw::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 121 of file TSelectorDraw.h. ◆ Notify(). bool TSelectorDraw::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 1154 of file TSelectorDraw.cxx. ◆ operator=(). TSelectorDraw & TSelectorDraw::operator= ; (; const TSelectorDraw & ; ). private . ◆ Process(). bool TSelectorDraw::Process ; (; Long64_t ; ). inlineoverridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector.; Definition at line 111 of file TSelectorDraw.h. ◆ ProcessFill(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorDraw.html:24328,load,loaded,24328,doc/master/classTSelectorDraw.html,https://root.cern,https://root.cern/doc/master/classTSelectorDraw.html,1,['load'],['loaded']
Performance,tBigFile; static TFile::EFileTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringTWebFile::fBasicUrlbasic url without authentication and options; TStringTWebFile::fBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tTWebFile::fHTTP11true if server support HTTP/1.1; Bool_tTWebFile::fHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initial,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:22511,cache,cache,22511,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,12,['cache'],['cache']
Performance,"tBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spuri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:113278,load,loaded,113278,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"tBit(kUnloading))) return cl;; 3059 ; 3060 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3061 ; 3062 // Now that we got the write lock, another thread may have constructed the; 3063 // TClass while we were waiting, so we need to do the checks again.; 3064 ; 3065 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3066 if (cl) {; 3067 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3068 ; 3069 // We could speed-up some of the search by adding (the equivalent of); 3070 //; 3071 // if (cl->GetState() == kInterpreter) return cl; 3072 //; 3073 // In this case, if a ROOT dictionary was available when the TClass; 3074 // was first requested it would have been used and if a ROOT dictionary is; 3075 // loaded later on TClassTable::Add will take care of updating the TClass.; 3076 // So as far as ROOT dictionary are concerned, if the current TClass is; 3077 // in interpreted state, we are sure there is nothing to load.; 3078 //; 3079 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3080 // by a user provided TClassGenerator. We have no way of knowing whether; 3081 // those do (or even can) behave the same way as the ROOT dictionary and; 3082 // have the 'dictionary is now available for use' step informs the existing; 3083 // TClass that their dictionary is now available.; 3084 ; 3085 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3086 load = kTRUE;; 3087 }; 3088 ; 3089 if (TClassEdit::IsArtificial(name)) {; 3090 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3091 // from an already normalized name for the purpose of supporting schema evolution.; 3092 // There is no dictionary or interpreter information about this kind of class, the only; 3093 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3094 // auto-loading or auto-parsing based on the scope of the name.; 3095 return cl;; 3096 }; 3097 ; 3098 // To avoid spuri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:116029,load,loaded,116029,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"tBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::BranchTBranch * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:70183,cache,cache,70183,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,"tBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:38492,cache,cache,38492,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"tCache & ; other). inline . Definition at line 28 of file RooExpensiveObjectCache.h. ◆ ~RooExpensiveObjectCache(). RooExpensiveObjectCache::~RooExpensiveObjectCache ; (; ). override . Destructor. ; Definition at line 45 of file RooExpensiveObjectCache.cxx. Member Function Documentation. ◆ Class(). static TClass * RooExpensiveObjectCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooExpensiveObjectCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooExpensiveObjectCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ clearAll(). void RooExpensiveObjectCache::clearAll ; (; ). Clear all cache elements. ; Definition at line 164 of file RooExpensiveObjectCache.cxx. ◆ clearObj(). bool RooExpensiveObjectCache::clearObj ; (; Int_t ; uniqueID). Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ; Definition at line 131 of file RooExpensiveObjectCache.cxx. ◆ DeclFileName(). static const char * RooExpensiveObjectCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ empty(). bool RooExpensiveObjectCache::empty ; (; ); const. inline . Definition at line 44 of file RooExpensiveObjectCache.h. ◆ getObj(). const TObject * RooExpensiveObjectCache::getObj ; (; Int_t ; uniqueID). Retrieve payload object of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:13024,cache,cache,13024,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,2,['cache'],['cache']
Performance,"tCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:7342,cache,cache,7342,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,20,['cache'],"['cache', 'cacheObject']"
Performance,"tCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:33813,optimiz,optimizeDirtyHook,33813,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,9,['optimiz'],['optimizeDirtyHook']
Performance,"tCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObject, . const RooArgSet & ; params . ). Register object associated with given name and given associated parameters with given values in cache. ; The cache will take ownership_of_object and is indexed under the given name (which does not need to be the name of cacheObject and with given set of dependent parameters with validity for the current values of those parameters. It can be retrieved later by callin retrieveObject() ; Definition at line 71 of file RooExpensiveObjectCache.cxx. ◆ retrieveObject(). const TObject * RooExpensiveObjectCache::retrieveObject ; (; const char * ; name, . TClass * ; tc, . const RooArgSet & ; params . ). Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ; The return object is owned by the cache instance. ; Definition at line 93 of file RooExpensiveObjectCache.cxx. ◆ setObj(). bool RooExpensiveObjectCache::setObj ; (; Int_t ; uid, . TObject * ; obj . ). Place new payload object in cache element with given unique ID. ; Cache will take ownership of provided object! ; Definition at line 148 of file RooExpensiveObjectCache.cxx. ◆ size(). Int_t RooExpensiveObjectCache::size ; (; ); const. inline . Definition at line 43 of file RooExpensiveObjectCache.h. ◆ Streamer(). void RooExpensiveObjectCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooExpensiveObjectCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 81 of file RooExpensiveObjectCache.h. Member Data Documentation. ◆ _map. std::map<TString,ExpensiveObject*> RooExpensiveObjectCache::_map. protected . Definition at line 78 of file RooExpensiveObjectCache.h. ◆ _nextUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:15494,cache,cache,15494,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"tClientFilter provides QOject event filter to map Qt and ROOT events; (see: http://doc.trolltech.com/4.3/qobject.html#installEventFilter ). Function Members (Methods); public:. TQtClientFilter(); virtual~TQtClientFilter(); voidAppendButtonGrab(TQtClientWidget*); static TClass*Class(); static TQtClientWidget*GetButtonGrabber(); static TQtClientWidget*GetPointerGrabber(); static voidGrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); virtual TClass*IsA() const; static TQtPointerGrabber*PointerGrabber(); voidRemoveButtonGrab(QObject*); static voidSetButtonGrabber(TQtClientWidget* grabber); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidAddKeyEvent(const int& event, TQtClientWidget* widget); booleventFilter(QObject* o, QEvent* e); static Bool_tIsGrabSelected(UInt_t selectEventMask); TQtEventQueue*Queue(); voidRestoreLostGrabbing(Event_t& event); static Bool_tSelectGrab(Event_t& event, UInt_t selectEventMask, int& me); voidSetKeyGrabber(TQtClientWidget* grabber); voidUnSetKeyGrabber(TQtClientWidget* grabber). private:. TQtClientFilter(const TQtClientFilter&); voidoperator=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t IsGrabSelected(UInt_t selectEventMask); return the selection by ""grabButton"" / ""grabPointer"". ~TQtClientFilter(). void AddKeyEvent(const int& event, TQtClientWidget* widget); Map and and to the ROOT event queue Qt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQtClientFilter.html:1284,Queue,Queue,1284,root/html532/TQtClientFilter.html,https://root.cern,https://root.cern/root/html532/TQtClientFilter.html,1,['Queue'],['Queue']
Performance,"tClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification of the original tree and the input file name.; - Definition of an analysis class (data members and member functions).; - The following mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100784,Load,LoadTree,100784,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['Load'],['LoadTree']
Performance,"tConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; static const char**&GetExtraInterpreterArgs(); virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TFunctionTemplate*GetFunctionTemplate(const char* name); TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name) const; TCollection*GetListOfFunctions() const; TCollection*GetListOfFunctionTemplates(); TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:6304,load,load,6304,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"tCoordinateSystemTag> . CoordSystem ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Coordinates ; (; ); const. inline . Retrieve a copy of the coordinates object. ; Definition at line 182 of file DisplacementVector3D.h. ◆ Cross() [1/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const DisplacementVector3D< OtherCoords, OtherTag > & ; ); const. private . ◆ Cross() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const DisplacementVector3D< OtherCoords, Tag > & ; v); const. inline . Return vector (cross) product of two displacement vectors, as a vector in the coordinate system of this class. ; It is possible to perform the product for any type of vector coordinates, but they must have the same coordinate system tag ; Definition at line 423 of file DisplacementVector3D.h. ◆ Cross() [3/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherVector > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const OtherVector & ; v); const. inline . Return vector (cross) product of two vectors, as a vector in the coordinate system of this class. ; It is possible to perform the product for any classes implementing X(), Y() and Z() member functions ; Definition at line 437 of file DisplacementVector3D.h. ◆ Dimension(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . unsigned int ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dimension ; (; ); const. inline . Dimension. ; Definition at line 273 of file DisplacementVector3D.h. ◆ Dot() [1/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . Scalar ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html:14531,perform,perform,14531,doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,1,['perform'],['perform']
Performance,"tDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:27114,load,loaded,27114,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['loaded']
Performance,"tDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning pha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:27198,load,loaded,27198,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['load'],['loaded']
Performance,"tDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _printScientific;  ; static Int_t _printSigDigits;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:70866,cache,cache,70866,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance,"tDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:8951,load,load,8951,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['load'],['load']
Performance,"tDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:14170,cache,cache,14170,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,1,['cache'],['cache']
Performance,"tEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:29154,cache,cache,29154,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"tFile. private . Definition at line 209 of file RNTupleImporter.hxx. ◆ fDestFileName. std::string ROOT::Experimental::RNTupleImporter::fDestFileName. private . Definition at line 207 of file RNTupleImporter.hxx. ◆ fEntry. std::unique_ptr<REntry> ROOT::Experimental::RNTupleImporter::fEntry. private . Definition at line 225 of file RNTupleImporter.hxx. ◆ fFieldModifier. FieldModifier_t ROOT::Experimental::RNTupleImporter::fFieldModifier. private . Definition at line 222 of file RNTupleImporter.hxx. ◆ fImportBranches. std::vector<RImportBranch> ROOT::Experimental::RNTupleImporter::fImportBranches. private . Definition at line 226 of file RNTupleImporter.hxx. ◆ fImportFields. std::vector<RImportField> ROOT::Experimental::RNTupleImporter::fImportFields. private . Definition at line 227 of file RNTupleImporter.hxx. ◆ fImportTransformations. std::vector<std::unique_ptr<RImportTransformation> > ROOT::Experimental::RNTupleImporter::fImportTransformations. private . The list of transformations to be performed for every entry. ; Definition at line 231 of file RNTupleImporter.hxx. ◆ fIsQuiet. bool ROOT::Experimental::RNTupleImporter::fIsQuiet = false. private . No standard output, conversely if set to false, schema information and progress is printed. ; Definition at line 220 of file RNTupleImporter.hxx. ◆ fLeafCountCollections. std::map<std::string, RImportLeafCountCollection> ROOT::Experimental::RNTupleImporter::fLeafCountCollections. private . Maps the count leaf to the information about the corresponding untyped collection. ; Definition at line 229 of file RNTupleImporter.hxx. ◆ fMaxEntries. std::int64_t ROOT::Experimental::RNTupleImporter::fMaxEntries = -1. private . The maximum number of entries to import. When this value is -1 (default), import all entries. ; Definition at line 217 of file RNTupleImporter.hxx. ◆ fModel. std::unique_ptr<RNTupleModel> ROOT::Experimental::RNTupleImporter::fModel. private . Definition at line 224 of file RNTupleImporter.hxx. ◆ fNTupleName. st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html:13291,perform,performed,13291,doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,1,['perform'],['performed']
Performance,"tFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:16011,load,loaded,16011,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,10,['load'],['loaded']
Performance,"tFromFile::Enter ; (; Long64_t ; , . const char * ; , . const char * ;  . ). inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 66 of file TEntryListFromFile.h. ◆ Enter() [2/2]. bool TEntryListFromFile::Enter ; (; Long64_t ; entry, . TTree * ; tree . ). inlineoverridevirtual . Add entry #entry to the list. . When tree = 0, adds to the current list; When tree != 0, finds the list, corresponding to this tree; When tree is a chain, the entry is assumed to be global index and the local entry is recomputed from the treeoffset information of the chain . Reimplemented from TEntryList.; Definition at line 65 of file TEntryListFromFile.h. ◆ GetCurrentList(). TEntryList * TEntryListFromFile::GetCurrentList ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 67 of file TEntryListFromFile.h. ◆ GetEntries(). Long64_t TEntryListFromFile::GetEntries ; (; ). virtual . Returns the total number of entries in the list. ; If some lists have not been loaded, loads them. ; Definition at line 166 of file TEntryListFromFile.cxx. ◆ GetEntriesFast(). virtual Long64_t TEntryListFromFile::GetEntriesFast ; (; ); const. inlinevirtual . Definition at line 73 of file TEntryListFromFile.h. ◆ GetEntry(). Long64_t TEntryListFromFile::GetEntry ; (; Long64_t ; index). overridevirtual . Returns entry #index See also Next() for a faster alternative. ; Reimplemented from TEntryList.; Definition at line 90 of file TEntryListFromFile.cxx. ◆ GetEntryAndTree(). Long64_t TEntryListFromFile::GetEntryAndTree ; (; Long64_t ; index, . Int_t & ; treenum . ). overridevirtual . Return the entry corresponding to the index parameter and the number of the tree, where this entry is. ; Reimplemented from TEntryList.; Definition at line 155 of file TEntryListFromFile.cxx. ◆ GetEntryList(). TEntryList * TEntryListFromFile::GetEntryList ; (; const char * ; treename, . const char * ; filename, . Option_t * ; opt . ). inlineoverridevirtual . Return the entry list, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:23879,load,loaded,23879,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,2,['load'],"['loaded', 'loads']"
Performance,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawPolygon(const TGeoPolygon* poly); Draw a polygon in 3D. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPainter.html:15780,load,loaded,15780,root/html534/TGeoPainter.html,https://root.cern,https://root.cern/root/html534/TGeoPainter.html,12,['load'],"['load', 'loaded']"
Performance,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); Execute mouse actions on a given volume. void ExecuteShapeEvent(TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPainter.html:15610,load,loaded,15610,root/html530/TGeoPainter.html,https://root.cern,https://root.cern/root/html530/TGeoPainter.html,6,['load'],"['load', 'loaded']"
Performance,"tGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:6832,load,load,6832,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"tGlobalPwHash ; (; Bool_t ; pwhash). static . Set global passwd hash flag to be used for authentication to rootd or proofd. ; Definition at line 1323 of file TAuthenticate.cxx. ◆ SetGlobalSRPPwd(). void TAuthenticate::SetGlobalSRPPwd ; (; Bool_t ; srppwd). static . Set global SRP passwd flag to be used for authentication to rootd or proofd. ; Definition at line 1331 of file TAuthenticate.cxx. ◆ SetGlobalUser(). void TAuthenticate::SetGlobalUser ; (; const char * ; user). static . Set global user name to be used for authentication to rootd or proofd. ; Definition at line 1295 of file TAuthenticate.cxx. ◆ SetGlobusAuthHook(). void TAuthenticate::SetGlobusAuthHook ; (; GlobusAuth_t ; func). static . Set Globus authorization function. ; Automatically called when libGlobusAuth is loaded. ; Definition at line 1411 of file TAuthenticate.cxx. ◆ SetKrb5AuthHook(). void TAuthenticate::SetKrb5AuthHook ; (; Krb5Auth_t ; func). static . Set kerberos5 authorization function. ; Automatically called when libKrb5Auth is loaded. ; Definition at line 1402 of file TAuthenticate.cxx. ◆ SetPromptUser(). void TAuthenticate::SetPromptUser ; (; Bool_t ; promptuser). static . Set global PromptUser flag. ; Definition at line 1385 of file TAuthenticate.cxx. ◆ SetReadHomeAuthrc(). void TAuthenticate::SetReadHomeAuthrc ; (; Bool_t ; readhomeauthrc). static . Set flag controlling the reading of $HOME/.rootauthrc. ; In PROOF the administrator may want to switch off private settings. Always true, may only be set false via option to proofd. ; Definition at line 1341 of file TAuthenticate.cxx. ◆ SetRSAInit(). void TAuthenticate::SetRSAInit ; (; Int_t ; init = 1). static . Static method setting RSA initialization flag. ; Definition at line 1228 of file TAuthenticate.cxx. ◆ SetRSAKeyType(). void TAuthenticate::SetRSAKeyType ; (; Int_t ; key). inline . Definition at line 148 of file TAuthenticate.h. ◆ SetRSAPublic(). Int_t TAuthenticate::SetRSAPublic ; (; const char * ; rsaPubExport, . Int_t ; klen . ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:39593,load,loaded,39593,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['load'],['loaded']
Performance,"tHelperArgs> &snapHelperArgs,; 259 const unsigned int nSlots, std::shared_ptr<PrevNodeType> prevNode, ActionTags::Snapshot,; 260 const RColumnRegister &colRegister); 261{; 262 const auto &filename = snapHelperArgs->fFileName;; 263 const auto &dirname = snapHelperArgs->fDirName;; 264 const auto &treename = snapHelperArgs->fTreeName;; 265 const auto &outputColNames = snapHelperArgs->fOutputColNames;; 266 const auto &options = snapHelperArgs->fOptions;; 267 ; 268 auto sz = sizeof...(ColTypes);; 269 std::vector<bool> isDefine(sz);; 270 for (auto i = 0u; i < sz; ++i); 271 isDefine[i] = colRegister.IsDefineOrAlias(colNames[i]);; 272 ; 273 std::unique_ptr<RActionBase> actionPtr;; 274 if (!ROOT::IsImplicitMTEnabled()) {; 275 // single-thread snapshot; 276 using Helper_t = SnapshotHelper<ColTypes...>;; 277 using Action_t = RAction<Helper_t, PrevNodeType>;; 278 actionPtr.reset(; 279 new Action_t(Helper_t(filename, dirname, treename, colNames, outputColNames, options, std::move(isDefine)),; 280 colNames, prevNode, colRegister));; 281 } else {; 282 // multi-thread snapshot; 283 using Helper_t = SnapshotHelperMT<ColTypes...>;; 284 using Action_t = RAction<Helper_t, PrevNodeType>;; 285 actionPtr.reset(new Action_t(; 286 Helper_t(nSlots, filename, dirname, treename, colNames, outputColNames, options, std::move(isDefine)),; 287 colNames, prevNode, colRegister));; 288 }; 289 return actionPtr;; 290}; 291 ; 292// Book with custom helper type; 293template <typename... ColTypes, typename PrevNodeType, typename Helper_t>; 294std::unique_ptr<RActionBase>; 295BuildAction(const ColumnNames_t &bl, const std::shared_ptr<Helper_t> &h, const unsigned int /*nSlots*/,; 296 std::shared_ptr<PrevNodeType> prevNode, ActionTags::Book, const RColumnRegister &colRegister); 297{; 298 using Action_t = RAction<Helper_t, PrevNodeType, TTraits::TypeList<ColTypes...>>;; 299 return std::make_unique<Action_t>(Helper_t(std::move(*h)), bl, std::move(prevNode), colRegister);; 300}; 301 ; 302/****** end BuildAndBoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:11886,multi-thread,multi-thread,11886,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"tHub based build system.; Bugs and Issues fixed in this release; More than 200 items were addressed for this release. The full list is:. [#15621] - Buffer overflow in TBranch::Init; [#15610] - Memory leak in TTree getattr pythonization; [#15590] - Infinite recursion in TFile::Open; [#15460] - TEnum::GetEnum(“B”)->GetUnderlyingType() does not following typedefs; [#15413] - Fails to build with cuDNN version 9; [#15406] - TEnum::GetEnum does not seem to see ‘through’ using statements.; [#15399] - Memory leak with jitted nodes if the execution is never triggered; [#15396] - [TMVA] Pymva test (Keras) failing on 632 and main; [#15370] - Broken link in HS3 printout; [#15340] - Webgraphics: canvas displayed, but many error printed; [#15253] - C++ standard not propagated via CMake anymore; [#15197] - RBDT does not support xgboost inference; [#15156] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; [#15139] - cmake option -Dall=YES breaks the cmake; [#15118] - jsoninterface does not build if provided with RapidYAML; [#15108] - Turn off clang-format for Linkdef files; [#15090] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:26047,cache,cacheread,26047,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['cache'],['cacheread']
Performance,"tLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:111743,tune,tune,111743,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['tune'],['tune']
Performance,"tListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctionTemplates.html:14780,Load,Load,14780,root/html604/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html,2,['Load'],['Load']
Performance,"tListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-30 15:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:14780,Load,Load,14780,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,2,['Load'],['Load']
Performance,"tListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:315502,load,load,315502,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"tListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1727; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7363; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:603; TClass::SetNewArrayvoid SetNewArray(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:318140,load,load,318140,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"tListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:117312,load,loadedcl,117312,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['loadedcl']
Performance,"tListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3153// if (altcl && normalizedName != altcl->GetName()); 3154// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3155// altcl->GetName(), name, normalizedName.c_str());; 3156// }; 3157 ; 3158 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3159 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3160 // and we want to make that the TClass for the pair goes through the regular creation; 3161 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3162 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3163 // will be used to create the TProtoClass (if one is requested for the pair).; 3164 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3165 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3166 ; 3167 TClass *loadedcl = nullptr;; 3168 if (checkTable) {; 3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be pertinent to the normalization of the name.; 3174 // For example it might contain or be a typedef for which we don't; 3175 // have a forward declaration (eg. typedef to instance of class; 3176 // template with default parameters). So let's redo the normalization; 3177 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3178 // lead to a different value.; 3179 {; 3180 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:120063,load,loadedcl,120063,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['loadedcl']
Performance,"tListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Mon Dec 7 13:48:29 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumCdf.html:34124,cache,cache,34124,root/html526/RooNumCdf.html,https://root.cern,https://root.cern/root/html526/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"tListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Mon Jul 4 15:23:32 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumCdf.html:34948,cache,cache,34948,root/html530/RooNumCdf.html,https://root.cern,https://root.cern/root/html530/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"tListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Thu Nov 3 20:08:49 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumCdf.html:35327,cache,cache,35327,root/html532/RooNumCdf.html,https://root.cern,https://root.cern/root/html532/RooNumCdf.html,8,['cache'],"['cache', 'cacheFunc']"
Performance,"tLoadedMissvoid SetLoadedMiss(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:147; TTreePerfStats::SetRealTimevirtual void SetRealTime(Double_t rtime)Definition TTreePerfStats.h:140; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::SetDiskTimevirtual void SetDiskTime(Double_t t)Definition TTreePerfStats.h:129; TTreePerfStats::SetBytesReadvoid SetBytesRead(Long64_t nbytes) overrideDefinition TTreePerfStats.h:126; TTreePerfStats::SetNleavesvirtual void SetNleaves(Int_t nleaves)Definition TTreePerfStats.h:136; TTreePerfStats::GetGraphIOTGraphErrors * GetGraphIO()Definition TTreePerfStats.h:99; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:21241,cache,cache,21241,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['cache'],['cache']
Performance,"tMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tTEntryList::Merge(TCollection* list); virtual Long64_tTEntryList::Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTEntryList::OptimizeStorage(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(const Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static Int_tTEntryList::Relocate(const char* fn, const char* newroot, const char* oldroot = 0, const char* enlnm = 0); virtual Int_tTEntryList::RelocatePaths(const char* newloc, const char* oldloc = 0); virtual Bool_tRemove(Long64_t entry, TTree* tree = 0); virtual Bool_tRemove(Long64_t entry, TTree* tree, Long64_t subentry); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); static Int_tTEntryList::Scan(const char* fn, TList* roots); virtual Int_tTEntryList::ScanPaths(TList* roots, Bool_t notify = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListArray.html:6838,Optimiz,OptimizeStorage,6838,root/html602/TEntryListArray.html,https://root.cern,https://root.cern/root/html602/TEntryListArray.html,2,['Optimiz'],['OptimizeStorage']
Performance,"tMapped"", Int_t defCatIdx = NoCatIdx); virtual~RooMappedCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMappedCategory.html:1558,cache,cacheUniqueSuffix,1558,root/html534/RooMappedCategory.html,https://root.cern,https://root.cern/root/html534/RooMappedCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tMapped"", Int_t defCatIdx = NoCatIdx); virtual~RooMappedCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFund",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMappedCategory.html:1558,cache,cacheUniqueSuffix,1558,root/html532/RooMappedCategory.html,https://root.cern,https://root.cern/root/html532/RooMappedCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tMapped"", Int_t defCatIdx = NoCatIdx); virtual~RooMappedCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMappedCategory.html:1558,cache,cacheUniqueSuffix,1558,root/html528/RooMappedCategory.html,https://root.cern,https://root.cern/root/html528/RooMappedCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tMaxVal() const. void SetPhiWithRng(Float_t x, Float_t r); Set phi range. Float_t GetTransitionTheta() const; Get transition angle between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionEta() const; Get transition eta between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionThetaForward() const; Get transition angle between barrel and forward end-cap cells. Float_t GetTransitionEtaForward() const; Get transition eta between barrel and forward end-cap cells. Float_t GetTransitionThetaBackward() const; Get transition angle between barrel and backward end-cap cells. Float_t GetTransitionEtaBackward() const; Get transition eta between barrel and backward end-cap cells. void SetData(TEveCaloData* d); Set calorimeter event data. void DataChanged(); Update setting and cache on data changed.; Called from TEvecaloData::BroadcastDataChange(). Bool_t AssertCellIdCache() const; Assert cell id cache is ok.; Returns true if the cache has been updated. Bool_t CellInEtaPhiRng(TEveCaloData::CellData_t& ) const; Returns true if given cell is in the ceta phi range. void AssignCaloVizParameters(TEveCaloViz* cv); Assign paramteres from given model. void SetPalette(TEveRGBAPalette* p); Set TEveRGBAPalette object pointer. Float_t GetValToHeight() const; Get transformation factor from E/Et to height. TEveRGBAPalette* AssertPalette(); Make sure the TEveRGBAPalette pointer is not null.; If it is not set, a new one is instantiated and the range is set; to current min/max signal values. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveCalo2D class. void SetupColorHeight(Float_t value, Int_t slice, Float_t& height) const; Set color and height for a given value and slice using slice color or TEveRGBAPalette. TEveCaloViz& operator=(const TEveCaloViz& ). void BuildCellIdCache(). void CellSele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCaloViz.html:24390,cache,cache,24390,root/html534/TEveCaloViz.html,https://root.cern,https://root.cern/root/html534/TEveCaloViz.html,2,['cache'],['cache']
Performance,"tMaxVal() const. void SetPhiWithRng(Float_t x, Float_t r); Set phi range. Float_t GetTransitionTheta() const; Get transition angle between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionEta() const; Get transition eta between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionThetaForward() const; Get transition angle between barrel and forward end-cap cells. Float_t GetTransitionEtaForward() const; Get transition eta between barrel and forward end-cap cells. Float_t GetTransitionThetaBackward() const; Get transition angle between barrel and backward end-cap cells. Float_t GetTransitionEtaBackward() const; Get transition eta between barrel and backward end-cap cells. void SetData(TEveCaloData* d); Set calorimeter event data. void DataChanged(); Update setting and cache on data changed.; Called from TEvecaloData::BroadcastDataChange(). Bool_t AssertCellIdCache() const; Assert cell id cache is ok.; Returns true if the cache has been updated. Bool_t CellInEtaPhiRng(TEveCaloData::CellData_t& ) const; Returns true if given cell is in the ceta phi range. void AssignCaloVizParameters(TEveCaloViz* cv); Assign paramteres from given model. void SetPalette(TEveRGBAPalette* p); Set TEveRGBAPalette object pointer. Float_t GetValToHeight() const; Get transformation factor from E/Et to height. TEveRGBAPalette* AssertPalette(); Make sure the TEveRGBAPalette pointer is not null.; If it is not set, a new one is instantiated and the range is set; to current min/max signal values. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveCalo2D class. void SetupColorHeight(Float_t value, Int_t slice, Float_t& height) const; Set color and height for a given value and slice using slice color or TEveRGBAPalette. TEveCaloViz(const TEveCaloViz& ). TEveCaloViz& operator=(const TEveCaloViz& ). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloViz.html:25540,cache,cache,25540,root/html602/TEveCaloViz.html,https://root.cern,https://root.cern/root/html602/TEveCaloViz.html,4,['cache'],['cache']
Performance,"tMessageTypes.h:59; kCT_ITEMDBLCLICK@ kCT_ITEMDBLCLICKDefinition WidgetMessageTypes.h:55; kC_CONTAINER@ kC_CONTAINERDefinition WidgetMessageTypes.h:53; GET_SUBMSGInt_t GET_SUBMSG(Long_t val)Definition WidgetMessageTypes.h:111; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TAxisClass to manage histogram axis.Definition TAxis.h:31; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetListOfBranchesTObjArray * GetListOfBranches()Definition TBranch.h:246; TBranch::GetNleavesInt_t GetNleaves() constDefinition TBranch.h:249; TBranch::GetListOfLeavesTObjArray * GetListOfLeaves()Definition TBranch.h:247; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TContextMenu::Actionvirtual void Action(TObject *object, TMethod *method)Action to be performed when this menu item is selected.Definition TContextMenu.cxx:93; TContextMenu::Popupvirtual void Popup(Int_t x, Int_t y, TObject *obj, TVirtualPad *c=nullptr, TVirtualPad *p=nullptr)Popup context menu at given location in canvas c and pad p for selected object.Definition TContextMenu.cxx:411; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::cdvirtual Bool_t cd()Change current directory to ""this"" directory.Definition TDirectory.cxx:53",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:115499,perform,performed,115499,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['perform'],['performed']
Performance,"tMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.py. tutorialsroofitrf702_efficiencyfit_2D.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:4656,optimiz,optimization,4656,doc/master/rf702__efficiencyfit__2D_8py.html,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html,2,['optimiz'],['optimization']
Performance,"tMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptDriveOptimization switch =1,2 for variance or maximum weight optimization; Int_tfOptPRDOption switch for predefined division, for quick check; Int_tfOptRejSwitch =0 for weighted events; =1 for unweighted events in MC; Double_t*fPrimAcu[fNoAct] Array of cumulative probability of all active cells; Double_tfPrimePrimary integral R' (R=R'<wt>); TRandom*fPseRanPointer to user-defined generator of pseudorandom numbers; Int_tfRNmaxMaximum No. of the rand. numb. requested at once; TFoamIntegrand*fRho! Pointer to the user-defined integrand function/distribution; Double_t*fRvec[fRNmax] random number vector from r.n. generator fDim+1 maximum elements; Double_tfSumOveTotal Sum of overveighted events; Double_tfSumWt; Double_tfSumWt2Total sum of wt and wt^2; TStringfVersionActual version of the FOAM like (1.01m); Double_tfWtMax; Double_tfWtMinMaximum/Minimum MC weight; TFoamVect**fXdivPRD! Lists of division values encoded in one vector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoam.html:13009,optimiz,optimization,13009,root/html528/TFoam.html,https://root.cern,https://root.cern/root/html528/TFoam.html,6,['optimiz'],['optimization']
Performance,"tMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptDriveOptimization switch =1,2 for variance or maximum weight optimization; Int_tfOptPRDOption switch for predefined division, for quick check; Int_tfOptRejSwitch =0 for weighted events; =1 for unweighted events in MC; Double_t*fPrimAcu[fNoAct] Array of cumulative probability of all active cells; Double_tfPrimePrimary integral R' (R=R'<wt>); TRandom*fPseRanPointer to user-defined generator of pseudorandom numbers; Int_tfRNmaxMaximum No. of the rand. numb. requested at once; TFoamIntegrand*fRho! Pointer to the user-defined integrand function/distribution; Double_t*fRvec[fRNmax] random number vector from r.n. generator fDim+1 maximum elements; Double_tfSumOveTotal Sum of overveighted events; Double_tfSumWtTotal sum of wt and wt^2; Double_tfSumWt2Total sum of wt and wt^2; TStringfVersionActual version of the FOAM like (1.01m); Double_tfWtMaxMaximum/Minimum MC weight; Double_tfWtMinMaximum/Minimum MC weight; TFoamVect**fXdivPRD! Lists of division values encoded in one vector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFoam.html:13637,optimiz,optimization,13637,root/html602/TFoam.html,https://root.cern,https://root.cern/root/html602/TFoam.html,4,['optimiz'],['optimization']
Performance,"tMutexStatevoid ForgetMutexState() finalDefinition TCling.cxx:9618; TCling::MethodInfo_Nextint MethodInfo_Next(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9083; TCling::ClassInfo_ClassPropertyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:439386,load,load,439386,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__FeldmanCousins.html:3879,perform,perform,3879,root/html602/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html,8,['perform'],['perform']
Performance,"tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector&); Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; static Bool_tTPRegexp::GetThrowAtCompileError(); Bool_tTPRegexp::IsValid() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); TObjArray*TPRegexp::MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); voidTPRegexp::Optimize(); UInt_tTPRegexp::ParseMods(const TString& mods) const; Int_tTPRegexp::ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; static voidTPRegexp::SetThrowAtCompileError(Bool_t throwp); Int_tTPRegexp::SubstituteInternal(TString& s, const TString& replace, Int_t start, Int_t nMaxMatch0, Bool_t doDollarSubst). private:. TPMERegexp&operator=(const TPMERegexp&). Data Members; public:. enum TPRegexp::[unnamed] { kPCRE_GLOBAL; kPCRE_OPTIMIZE; kPCRE_DEBUG_MSGS; kPCRE_INTMASK; };. protected:. void*fAddressOfLastStringused for checking for change of TString in global match; Int_tfLastGlobalPositionend of last match when kPCRE_GLOBAL is set; TStringfLastStringMatchedcopy of the last TString matched; TArrayIfMarkerslast set of indexes of matches; Int_tfNMatchesnumber of matches returned from last pcre_exec call; Int_tfNMaxMatchesmaximum number of matches; UInt_tTPR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPMERegexp.html:2150,Optimiz,Optimize,2150,root/html534/TPMERegexp.html,https://root.cern,https://root.cern/root/html534/TPMERegexp.html,1,['Optimiz'],['Optimize']
Performance,"tNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstraintSum(); Default constructor. RooConstraintSum(const char* name, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConstraintSum.html:34816,cache,cache,34816,root/html534/RooConstraintSum.html,https://root.cern,https://root.cern/root/html534/RooConstraintSum.html,4,['cache'],['cache']
Performance,"tNbytesFree() constDefinition TFile.h:249; TFile::IsArchivevirtual Bool_t IsArchive() constDefinition TFile.h:258; TFile::CurrentFilestatic TFile *& CurrentFile()Return the current ROOT file if any.Definition TFile.cxx:1067; TFile::SetENDvirtual void SetEND(Long64_t last)Definition TFile.h:287; TFile::SetCompressionAlgorithmvirtual void SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)See comments for function SetCompressionSettings.Definition TFile.cxx:2305; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::fNbytesFreeInt_t fNbytesFreeNumber of bytes for free segments structure.Definition TFile.h:85; TFile::fDInt_t fDFile descriptor.Definition TFile.h:82; TFile::ResetErrnovirtual void ResetErrno() constMethod resetting the errno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::SetOptionvirtual void SetOption(Option_t *option="">"")Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:40326,cache,cache,40326,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"tNumber(TStreamerElement *elem, Int_t comp_type) = 0;; 142 virtual void DecrementLevel(TVirtualStreamerInfo*) = 0;; 143 ; 144 virtual void ClassBegin(const TClass*, Version_t = -1) = 0;; 145 virtual void ClassEnd(const TClass*) = 0;; 146 virtual void ClassMember(const char*, const char * = nullptr, Int_t = -1, Int_t = -1) = 0;; 147 virtual TVirtualStreamerInfo *GetInfo() = 0;; 148 ; 149 virtual TVirtualArray *PeekDataCache() const;; 150 virtual TVirtualArray *PopDataCache();; 151 virtual void PushDataCache(TVirtualArray *);; 152 ; 153 virtual TClass *ReadClass(const TClass *cl = nullptr, UInt_t *objTag = nullptr) = 0;; 154 virtual void WriteClass(const TClass *cl) = 0;; 155 ; 156 virtual TObject *ReadObject(const TClass *cl) = 0;; 157 virtual void WriteObject(const TObject *obj, Bool_t cacheReuse) = 0;; 158 ; 159 template <class T> Int_t WriteObject(const T *objptr, Bool_t cacheReuse = kTRUE);; 160 ; 161 virtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse = kTRUE) = 0;; 162 ; 163 virtual UShort_t GetPidOffset() const = 0;; 164 virtual void SetPidOffset(UShort_t offset) = 0;; 165 virtual Int_t GetBufferDisplacement() const = 0;; 166 virtual void SetBufferDisplacement() = 0;; 167 virtual void SetBufferDisplacement(Int_t skipped) = 0;; 168 ; 169 // basic types and arrays of basic types; 170 virtual void ReadFloat16 (Float_t *f, TStreamerElement *ele = nullptr) = 0;; 171 virtual void WriteFloat16(Float_t *f, TStreamerElement *ele = nullptr) = 0;; 172 virtual void ReadDouble32 (Double_t *d, TStreamerElement *ele = nullptr) = 0;; 173 virtual void WriteDouble32(Double_t *d, TStreamerElement *ele = nullptr) = 0;; 174 virtual void ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;; 175 virtual void ReadWithNbits(Float_t *ptr, Int_t nbits) = 0;; 176 virtual void ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue) = 0;; 177 virtual void ReadWithNbits(Double_t *ptr, Int_t nbits) = 0;; 178 ; 179 virtual Int_t Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:7300,cache,cacheReuse,7300,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,1,['cache'],['cacheReuse']
Performance,"tObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t /* silent */); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t /* silent */); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassGenerator.html:5745,load,load,5745,root/html526/TClassGenerator.html,https://root.cern,https://root.cern/root/html526/TClassGenerator.html,4,['load'],['load']
Performance,"tOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsCategoryLValue::volume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:17694,cache,cache,17694,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,2,['cache'],['cache']
Performance,"tPadStyle (std::shared_ptr< RStyle > &&style);  Assign style for the pad. ;  ;  Public Member Functions inherited from ROOT::Experimental::RDisplayItem;  RDisplayItem ()=default;  ;  RDisplayItem (bool dummy);  ; virtual ~RDisplayItem ();  ; virtual void BuildFullId (const std::string &prefix);  Build full id, including prefix and object index. ;  ; unsigned GetIndex () const;  ; std::string GetObjectID () const;  ; void SetIndex (unsigned indx);  ; void SetObjectID (const std::string &id);  ; void SetObjectIDAsPtr (const void *ptr);  Assign id using arbitrary pointer value Typically drawable pointer should be used here. ;  ; void SetStyle (RStyle *style);  . Protected Attributes; const RAttrMap * fAttr {nullptr};  temporary pointer on attributes ;  ; PadPrimitives_t fPrimitives;  display items for all primitives in the pad ;  ; std::vector< std::shared_ptr< RStyle > > fStyles;  ! locked styles of the objects and pad until streaming is performed ;  ;  Protected Attributes inherited from ROOT::Experimental::RDisplayItem; bool fDummy {false};  if true, just placeholder for drawable which does not changed ;  ; unsigned fIndex {0};  ! index inside current pad, used to produce fully-qualified id, not send to client ;  ; std::string fObjectID;  unique object identifier ;  ; RStyle * fStyle {nullptr};  style object ;  . Additional Inherited Members;  Static Public Member Functions inherited from ROOT::Experimental::RDisplayItem; static std::string ObjectIDFromPtr (const void *ptr);  Construct fillid using pointer value. ;  . #include <ROOT/RPadDisplayItem.hxx>. Inheritance diagram for ROOT::Experimental::RPadBaseDisplayItem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ PadPrimitives_t. using ROOT::Experimental::RPadBaseDisplayItem::PadPrimitives_t = std::vector<std::unique_ptr<RDisplayItem> >. Definition at line 31 of file RPadDisplayItem.hxx. Constructor & Destructor Documentation. ◆ RPadBa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RPadBaseDisplayItem.html:2039,perform,performed,2039,doc/master/classROOT_1_1Experimental_1_1RPadBaseDisplayItem.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RPadBaseDisplayItem.html,1,['perform'],['performed']
Performance,"tParameter (const char *par, Int_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long64_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long_t value);  Set an input list parameter. ;  ; void SetPerfTree (const char *pf=""perftree.root"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; virtual void ShowCache (Bool_t all=kFALSE);  List contents of file cache. ;  ; virtual void ShowData ();  List contents of the data directory in the sandbox. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; virtual void ShowDataSetCache (const char *dataset=0);  Display the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; virtual void ShowDataSets (const char *uri="""", const char *optStr="""");  Shows datasets in locations that match the uri. ;  ; void ShowEnabledPackages (Bool_t all=kFALSE);  List which packages are enabled. ;  ; void ShowFeedback () const;  Show items in feedback list. ;  ; void ShowLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary log file. ;  ; void ShowMissingFiles (TQueryResult *qr=0);  Show information about missing files during query described by 'qr' or the last query if qr is null (default). ;  ; void ShowPackages (Bool_t all=kFALSE, Bool_t redirlog=kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:19605,cache,cache,19605,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['cache'],['cache']
Performance,"tPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TCondition*fNewBlockAddedsignal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending blocks to be read; TCondition*fReadBlockAddedsignal the addition of a new red block; TList*fReadBlockslist of blocks read; TSemaphore*fSemChangeFilesemaphore used when changin a file in TChain; TSemaphore*fSemMasterWorkersemaphore used to kill the consumer thread; TSemaphore*fSemWorkerMastersemaphore used to notify the master that worker is killed; Bool_tfThreadJoinedmark if async thread was joined; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFilePrefetch.html:6579,cache,cache,6579,root/html602/TFilePrefetch.html,https://root.cern,https://root.cern/root/html602/TFilePrefetch.html,4,['cache'],['cache']
Performance,"tProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Long64_t ); This method is called before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process(). WARNING when a selector is used with a TChain:; in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call GetEntry(entry).; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use fChain->GetTree()->GetEntry(entry);. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:10148,load,loaded,10148,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,6,['load'],['loaded']
Performance,"tProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kTRUE; }. const char * GetOption() const; { return fOption; }. Long64_t GetStatus() const; { return fStatus; }. Int_t GetEntry(Long64_t , Int_t = 0); { return 0; }. Bool_t ProcessCut(Long64_t ); { return kTRUE; }. void ProcessFill(Long64_t ); { }. Bool_t Process(Long64_t ); { return kFALSE; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. void SetInputList(TList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:10024,load,loaded,10024,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,4,['load'],['loaded']
Performance,"tProcess.Definition TBranch.cxx:2947; TBranch::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Reset a Branch.Definition TBranch.cxx:2598; TBranch::ReadLeaves0Implvoid ReadLeaves0Impl(TBuffer &b)Read zero leaves without the overhead of a loop.Definition TBranch.cxx:2472; TBranch::SupportsBulkReadbool SupportsBulkRead() constReturns true if this branch supports bulk IO, false otherwise.Definition TBranch.cxx:1431; TBranch::ResetReadEntryvirtual void ResetReadEntry()Definition TBranch.h:269; TBranch::GetRealFileNameTString GetRealFileName() constGet real file name.Definition TBranch.cxx:2068; TBranch::FindBranchvirtual TBranch * FindBranch(const char *name)Find the immediate sub-branch with passed name.Definition TBranch.cxx:1035; TBranch::TBranchTBranch(const TBranch &)=delete; TBranch::fDirectoryTDirectory * fDirectory! Pointer to directory where this branch buffers are storedDefinition TBranch.h:148; TBranch::PrintCacheInfovoid PrintCacheInfo() constPrint the information we have about which basket is currently cached and whether they have been 'used...Definition TBranch.cxx:2445; TBranch::fBasketsTObjArray fBaskets-> List of baskets of this branchDefinition TBranch.h:140; TBranch::SetAddressImplvirtual void SetAddressImpl(void *addr, bool)Definition TBranch.h:179; TBranch::LoadBasketsvirtual Int_t LoadBaskets()Baskets associated to this branch are forced to be in memory.Definition TBranch.cxx:2309; TBranch::SetIOFeaturesvoid SetIOFeatures(TIOFeatures &features)Definition TBranch.h:283; TBranch::fMotherTBranch * fMother! Pointer to top-level parent branch in the tree.Definition TBranch.h:145; TBranch::GetTotBytesLong64_t GetTotBytes(Option_t *option="""") constReturn total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub...Definition TBranch.cxx:2220; TBranch::fParentTBranch * fParent! Pointer to parent branch.Definition TBranch.h:146; TBranch::WriteBasketInt_t WriteBasket(TBasket *basket, Int_t where)Definition TBra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8h_source.html:35067,cache,cached,35067,doc/master/TBranch_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html,1,['cache'],['cached']
Performance,"tProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _cdfBoundaries = false;  Use boundary conditions for CDFs. ;  ; RooAICRegistry _codeReg;  ! Auxiliary class keeping tracking of analytical integration code ;  ; RooDataHist * _dataHist = nullptr;  Unowned pointer to underlying histogram. ;  ; RooSetProxy _depList;  List of observables mapped onto histogram observables. ;  ; RooArgSet _histObsList;  List of observables defining dimensions of histogram. ;  ; Int_t _intOrder = 0;  Interpolation order. ;  ; std::unique_ptr< RooDataHist > _ownedDataHist;  ! Owned pointer to underlying histogram ;  ; double _totVolume = 0.0;  ! Total volume of space (product of ranges of observables) ;  ; bool _unitNorm = false;  ! Assume contents is unit normalized (for use as pdf cache) ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:57259,cache,cache,57259,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['cache'],['cache']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. RooBlindTools_blindEngine; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindOffset.html:31991,Cache,CacheMode,31991,root/html534/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html534/RooUnblindOffset.html,2,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. RooBlindTools_blindEngineBlinding engine; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindPrecision.html:32130,Cache,CacheMode,32130,root/html534/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html534/RooUnblindPrecision.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. RooListProxy_actualVarsActual parameters used by formula engine; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:32120,Cache,CacheMode,32120,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. RooRealProxy_asym; RooBlindTools_blindEngine; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindCPAsymVar.html:31987,Cache,CacheMode,31987,root/html534/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html534/RooUnblindCPAsymVar.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<Int_t,Int_t>_binMap; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:31922,Cache,CacheMode,31922,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> >RooAbsCachedReal::_anaIntMap! Map for analytical integration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:32631,Cache,CacheMode,32631,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,2,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> >RooAbsCachedReal::_anaIntMap! Map for analytical integration codes; stringRooNumRunningInt::_binningNameName of binning to be used for cache histogram; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumCdf.html:32529,Cache,CacheMode,32529,root/html534/RooNumCdf.html,https://root.cern,https://root.cern/root/html534/RooNumCdf.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> >RooAbsCachedReal::_anaIntMap! Map for analytical integration codes; string_binningNameName of binning to be used for cache histogram; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumRunningInt.html:32618,Cache,CacheMode,32618,root/html534/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html534/RooNumRunningInt.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> >_anaIntMap! Map for analytical integration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:32500,Cache,CacheMode,32500,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<std::string,std::vector<BarlowCache> >_barlowCache; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:31542,Cache,CacheMode,31542,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,1,['Cache'],['CacheMode']
Performance,"tProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:31512,Cache,CacheMode,31512,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,46,['Cache'],['CacheMode']
Performance,"tProxy _flags;  ; std::vector< std::vector< std::string > > _nonInterfering;  ; RooListProxy _observables;  ; RooSetProxy _operators;  ; RooListProxy _physics;  ; std::map< std::string, int > _sampleMap;  ; double _scale = 1.0;  The cache manager. ;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:61049,cache,cached,61049,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,2,['cache'],"['cache', 'cached']"
Performance,"tPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::SaveGraph ; (; NodeType ; node, . const std::string & ; outputFile . ). Create a graphviz representation of the dataframe computation graph, write it to the specified file. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. ; [in]outputFilefile where to save the representation. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:15331,optimiz,optimized,15331,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['optimiz'],['optimized']
Performance,"tPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:407; ROOT::RDF::RResultPtr::beginRIterationHelper< T >::Iterator_t begin()Return an iterator to the beginning of the contained object if this makes sense, throw a compilation ...Definition RResultPtr.hxx:257; ROOT::RDF::RResultPtr::Value_tT Value_tConvenience alias to simplify access to proxied type.Definition RResultPtr.hxx:206; ROOT::RDF::RResultPtr::GetT * Get()Get the pointer to the encapsulated result.Definition RResultPtr.hxx:186; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr &)=default; ROOT::RDF::RResultPtr::operator*T & operator*()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:240; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(const RResultPtr &)=default; ROOT::RDF::RResultPtr::OnPartialResultSlotRResultPtr< T > & OnPartialResultSlot(ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==friend bool operator==(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:401; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr< T2 > &r)Convert a RResultPtr<T2> to a RResultPtr<T>.Definition RResultPtr.hxx:222; ROOT::RDF::RResultPtr::fActionPtrstd::shared_ptr< RDFInternal::RActionBase > fActionPtrOwning pointer to the action that will produce this result.Definition RResultPtr.hxx:178; ROOT::RDF::RResultPtr::SPT_tstd::shared_ptr< T > SPT_tDefinition RResultPtr.hxx:121; ROOT::RDF::RResultPtr::operator->T * operator->()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:249; ROOT::RDF::RResultPtr::fObjPtrSPT_t fObjPt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:24590,concurren,concurrently,24590,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"tPythia6 common block Pybins ;  CPydat1_tPythia6 common block Pydat1 ;  CPydat2_tPythia6 common block Pydat2 ;  CPydat3_tPythia6 common block Pydat3 ;  CPydat4_tPythia6 common block Pydat4 ;  CPydatr_tPythia6 common block Pydatr ;  CPyint1_tPythia6 common block Pyint1 ;  CPyint2_tPythia6 common block Pyint2 ;  CPyint3_tPythia6 common block Pyint3 ;  CPyint4_tPythia6 common block Pyint4 ;  CPyint5_tPythia6 common block Pyint5 ;  CPyint6_tPythia6 common block Pyint6 ;  CPyint7_tPythia6 common block Pyint7 ;  CPyint8_tPythia6 common block Pyint8 ;  CPyint9_tPythia6 common block Pyint9 ;  CPyints_tPythia6 common block Pyints ;  CPyjets_tPythia6 common block Pyjets ;  CPymssm_tPythia6 common block Pymssm ;  CPypars_tPythia6 common block Pypars ;  CPyssmt_tPythia6 common block Pyssmt ;  CPysubs_tPythia6 common block Pysubs ;  CQuad;  CQuartzImage;  CQuartzPixmap;  CQuartzView;  CQuartzWindow;  CRectangle_t;  CRedirectHandle_t;  Credirguard;  Crng_state_st;  CRoo1DMomentMorphFunction1-dimensional morph function between a list of input functions (varlist) as a function of one input parameter (m) ;  CRoo1DTableRoo1DTable implements a one-dimensional table ;  CRoo2DKeysPdfTwo-dimensional kernel estimation PDF ;  ►CRoo2DMomentMorphFunction2-dimensional morph function between a list of function-numbers as a function of two input parameters (m1 and m2) ;  CSorterL2H;  ►CRooAbsAnaConvPdf;  CCacheElemIterator over _convNormSet ;  CRooAbsArgRooAbsArg is the common abstract base class for objects that represent a value (of arbitrary type) and ""shape"" that in general depends on (is a client of) other RooAbsArg subclasses ;  CRooAbsBinningRooAbsBinning is the abstract base class for RooRealVar binning definitions This class defines the interface to retrieve bin boundaries, ranges etc ;  CRooAbsCacheRooAbsCache is the abstract base class for data members of RooAbsArgs that cache other (composite) RooAbsArg expressions ;  ►CRooAbsCachedPdfRooAbsCachedPdf is the abstract base class for p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:75569,cache,cache,75569,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['cache'],['cache']
Performance,"tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:18465,cache,cache,18465,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,1,['cache'],['cache']
Performance,"tReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStreamerInfo(); ; Definition at line 3732 of file TFile.cxx. ◆ ShowStreamerInfo(). void TFile::ShowStreamerInfo ; (; ). virtual . Show the StreamerInfo of all classes written to this file. ; Definition at line 3750 of file TFile.cxx. ◆ ShrinkCacheFileDir(). Bool_t TFile::ShrinkCacheFileDir ; (; Long64_t ; shrinksize, . Long_t ; cleanupinterval = 0 . ). static . Try to shrink the cache to the desired size. ; With the clenupinterval you can specify the minimum amount of time after the previous cleanup before the cleanup operation is repeated in the cache directory ; Definition at line 4666 of file TFile.cxx. ◆ Sizeof(). Int_t TFile::Sizeof ; (; ); const. overridevirtual . Return the size in bytes of the file header. ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2397 of file TFile.cxx. ◆ Streamer(). void TFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TDirectoryFile.; Reimplemented in TMemFile, TSQLFile, TXMLFile, TNetFile, TParallelMergingFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 2405 of file TFile.cxx. ◆ StreamerNVirtual(). void TFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 344 of file TFile.h. ◆ SumBuffer(). void TFile::SumBuffer ; (; Int_t ; bufsize). Increment statistics for buffer sizes of objects in this file. ; Definition at line 2417 of file TFile.cxx. ◆ SysClose(). Int_t TFile::SysClose ; (; Int_t ; f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:96464,cache,cache,96464,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['cache'],['cache']
Performance,"tReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStreamerInfo(); ; Definition at line 3732 of file TFile.cxx. ◆ ShowStreamerInfo(). void TFile::ShowStreamerInfo ; (; ). virtual . Show the StreamerInfo of all classes written to this file. ; Definition at line 3750 of file TFile.cxx. ◆ ShrinkCacheFileDir(). Bool_t TFile::ShrinkCacheFileDir ; (; Long64_t ; shrinksize, . Long_t ; cleanupinterval = 0 . ). static . Try to shrink the cache to the desired size. ; With the clenupinterval you can specify the minimum amount of time after the previous cleanup before the cleanup operation is repeated in the cache directory ; Definition at line 4666 of file TFile.cxx. ◆ Sizeof(). Int_t TFile::Sizeof ; (; ); const. overridevirtual . Return the size in bytes of the file header. ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2397 of file TFile.cxx. ◆ Streamer(). void TFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TDirectoryFile.; Reimplemented in TXNetFile, TMemFile, TSQLFile, TXMLFile, TNetFile, TParallelMergingFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 2405 of file TFile.cxx. ◆ StreamerNVirtual(). void TFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 344 of file TFile.h. ◆ SumBuffer(). void TFile::SumBuffer ; (; Int_t ; bufsize). Increment statistics for buffer sizes of objects in this file. ; Definition at line 2417 of file TFile.cxx. ◆ SysClose(). Int_t TFile::SysClose ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:96620,cache,cache,96620,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance,"tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; RooRealProxy_xfX*F ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMoment.html:33079,cache,cache,33079,root/html530/RooMoment.html,https://root.cern,https://root.cern/root/html530/RooMoment.html,1,['cache'],['cache']
Performance,"tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Binding_double_double_int_int_.html:35290,cache,cache,35290,root/html534/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Binding_double_double_int_int_.html,4,['cache'],['cache']
Performance,"tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html:36892,cache,cache,36892,root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,8,['cache'],['cache']
Performance,"tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_nllInput -log(L) function; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; map<std::string,bool>_paramFixedParameter constant status at last time of use; RooAbsPdf*_pdf; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; set<std::string>_statUncertParams; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBarlowBeestonLL(); _obs(""paramOfInterest"",""Parameters of intere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:35096,cache,cache,35096,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,4,['cache'],['cache']
Performance,"tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMoment&operator=(const RooMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:19331,optimiz,optimizeCacheMode,19331,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,4,['optimiz'],['optimizeCacheMode']
Performance,"tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumCdf&operator=(const RooNumCdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumCdf.html:19751,optimiz,optimizeCacheMode,19751,root/html602/RooNumCdf.html,https://root.cern,https://root.cern/root/html602/RooNumCdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:23588,optimiz,optimizeCacheMode,23588,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,2,['optimiz'],['optimizeCacheMode']
Performance,"tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:42264,cache,cache,42264,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,5,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSpHarmonic.html:33088,cache,cache,33088,root/html528/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html528/RooSpHarmonic.html,4,['cache'],['cache']
Performance,"tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:39251,cache,cache,39251,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,4,['cache'],['cache']
Performance,"tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:2787,Cache,CacheModeRooAbsArg,2787,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4268,cache,cache,4268,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,4,['cache'],['cache']
Performance,"tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooEffProd.html:39428,cache,cache,39428,root/html530/RooEffProd.html,https://root.cern,https://root.cern/root/html530/RooEffProd.html,1,['cache'],['cache']
Performance,"tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_pidPID of child process; Int_t_pipeToClient[2]Pipe to client process; Int_t_pipeToServer[2]Pipe to server process; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:34153,cache,cache,34153,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,4,['cache'],['cache']
Performance,"tServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMoment.html:25037,cache,cache,25037,root/html532/RooMoment.html,https://root.cern,https://root.cern/root/html532/RooMoment.html,2,['cache'],['cache']
Performance,"tSet, const RooArgSet& paramSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:24381,cache,cache,24381,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,4,['cache'],['cache']
Performance,"tSet3DGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPointSet3DGL.html:1782,cache,cached,1782,root/html528/TPointSet3DGL.html,https://root.cern,https://root.cern/root/html528/TPointSet3DGL.html,4,['cache'],['cached']
Performance,"tStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TVirtualFitter (const TVirtualFitter &tvf);  copy constructor ;  ; TVirtualFitter & operator= (const TVirtualFitter &tvf);  assignment operator ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fCache;  [fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words) ;  ; Int_t fCacheSize;  Size of the fCache array. ;  ; void(* fFCN )(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  ; TMethodCall * fMethodCall;  Pointer to MethodCall in case of interpreted function. ;  ; Int_t fNpoints;  Number of points to fit. ;  ; TObject * fObjectFit;  Pointer to object being fitted. ;  ; Foption_t fOption;  Struct with the fit options. ;  ; Int_t fPointSize;  Number of words per point in the cache. ;  ; TObject * fUserFunc;  Pointer to user theoretical function (a TF1*) ;  ; Int_t fXfirst;  First bin on X axis. ;  ; Int_t fXlast;  Last bin on X axis. ;  ; Int_t fYfirst;  First bin on Y axis. ;  ; Int_t fYlast;  Last bin on Y axis. ;  ; Int_t fZfirst;  First bin on Z axis. ;  ; Int_t fZlast;  Last bin on Z axis. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TVirtualFitter.h>. Inheritance diagram for TVirtualFitter:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ FCNFunc_t. typedef void(* TVirtualFitter::FCNFunc_t) (Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag). Definition at line 71 of file TVirtualFitter.h. Constructor & Destructor Documentation. ◆ TVirtualFitter() [1/2]. TVirtualFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFitter.html:16274,cache,cache,16274,doc/master/classTVirtualFitter.html,https://root.cern,https://root.cern/doc/master/classTVirtualFitter.html,1,['cache'],['cache']
Performance,"tStatus(). void TProof::SendDataSetStatus ; (; const char * ; msg, . UInt_t ; n, . UInt_t ; tot, . Bool_t ; st . ). Send or notify data set status. ; Definition at line 9336 of file TProof.cxx. ◆ SendFile(). Int_t TProof::SendFile ; (; const char * ; file, . Int_t ; opt = (kBinary | kForward | kCp | kCpBin), . const char * ; rfile = 0, . TSlave * ; wrk = 0 . ). protected . Send a file to master or slave servers. ; Returns number of slaves the file was sent to, maybe 0 in case master and slaves have the same file system image, -1 in case of error. If defined, send to worker 'wrk' only. If defined, the full path of the remote path will be rfile. If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox (to copy to the cache on a different name use rfile = ""cache:newname""). The mask 'opt' is an or of ESendFileOpt: kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Definition at line 6894 of file TProof.cxx. ◆ SendGroupView(). Int_t TProof::SendGroupView ; (; ). private . Send to all active slaves servers the current slave group size and their unique id. ; Returns number of active slaves. Returns -1 in case of error. ; Definition at line 6460 of file TProof.cxx. ◆ SendingLogToWindow(). Bool_t TProof::SendingLogToWindow ; (; ); const. inline . Definition at line 1016 of file TProof.h. ◆ SendInitialState(). Int_t TProof::SendInitialState ; (; ). private . Transfer the initial (i.e. ; current) state of the master to all slave",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:138830,cache,cache,138830,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['cache']
Performance,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheWrite.html:6009,cache,cached,6009,root/html528/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html528/TFileCacheWrite.html,12,['cache'],"['cache', 'cached']"
Performance,"tTClassinline; GetDeclFileName() constTClass; GetDeclIdMap()TClassprivatestatic; GetDelete() constTClass; GetDeleteArray() constTClass; GetDestructor() constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDicti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9470,load,load,9470,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"tTEveElement::SetRnrState(Bool_t rnr); voidSetScale(Double_t scale); voidSetScaleCenter(Float_t x, Float_t y, Float_t z); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveScalableStraightLineSet(const char* n = ""ScalableStraightLineSet"", const char* t = """"); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveStraightLineSet::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveScalableStraightLineSet.html:21009,Scalab,ScalableStraightLineSet,21009,root/html602/TEveScalableStraightLineSet.html,https://root.cern,https://root.cern/root/html602/TEveScalableStraightLineSet.html,2,['Scalab'],['ScalableStraightLineSet']
Performance,"tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPconEditor.html:22662,Perform,Perform,22662,root/html604/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html604/TGeoPconEditor.html,1,['Perform'],['Perform']
Performance,"tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPconEditor.html:22662,Perform,Perform,22662,root/html602/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html602/TGeoPconEditor.html,1,['Perform'],['Perform']
Performance,"tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScenePad.html:13794,cache,cache,13794,root/html528/TGLScenePad.html,https://root.cern,https://root.cern/root/html528/TGLScenePad.html,1,['cache'],['cache']
Performance,"tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrepareBasket(Long64_t entry); virtual voidTKey::Print(Option_t* option = """") const; virtual Int_tTKey::Read(TObject* obj); virtual Int_tReadBasketBuffers(Long64_t pos, Int_t len, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBasketSQL.html:4083,Load,LoadBasketBuffers,4083,root/html532/TBasketSQL.html,https://root.cern,https://root.cern/root/html532/TBasketSQL.html,1,['Load'],['LoadBasketBuffers']
Performance,"tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrepareBasket(Long64_t entry); virtual voidTKey::Print(Option_t* option = """") const; virtual Int_tTKey::Read(TObject* obj); virtual Int_tReadBasketBuffers(Long64_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBasketSQL.html:4083,Load,LoadBasketBuffers,4083,root/html534/TBasketSQL.html,https://root.cern,https://root.cern/root/html534/TBasketSQL.html,1,['Load'],['LoadBasketBuffers']
Performance,"tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrepareBasket(Long64_t entry); virtual voidTKey::Print(Option_t* option = """") const; virtual Int_tTKey::Read(TObject* obj); virtual Int_tReadBasketBuffers(Long64_t pos, Int_t len, TFile* file)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBasketSQL.html:3929,Load,LoadBasketBuffers,3929,root/html602/TBasketSQL.html,https://root.cern,https://root.cern/root/html602/TBasketSQL.html,2,['Load'],['LoadBasketBuffers']
Performance,"tTObject::IsOnHeap() const; Bool_tTVirtualStreamerInfo::IsOptimized() const; Int_tTVirtualStreamerInfo::IsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidTVirtualStreamerInfo::Optimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; voidPrintValueClones(const char* name, TClonesArray* clones, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; voidPrintValueSTL(const char* name, TVirtualCollectionProxy* cont, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; virtual Int_tTObject::Read(const char* name); Int_tReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset); Int_tReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerInfo.html:7335,Optimiz,Optimize,7335,root/html532/TStreamerInfo.html,https://root.cern,https://root.cern/root/html532/TStreamerInfo.html,1,['Optimiz'],['Optimize']
Performance,"tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:18010,optimiz,optimizeCacheMode,18010,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,4,['optimiz'],['optimizeCacheMode']
Performance,"tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:18628,optimiz,optimized,18628,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,8,"['cache', 'optimiz']","['cache', 'optimized']"
Performance,"tTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.d.f. or extended p.d.f?; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSetRooAbsOptTestStatistic::_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of ser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChi2Var.html:35557,cache,cache,35557,root/html530/RooChi2Var.html,https://root.cern,https://root.cern/root/html530/RooChi2Var.html,2,['cache'],['cache']
Performance,"tTopLevelModule();; 580 need = ""lib"" + M->Name + gLibraryExtension;; 581 } else {; 582 std::string qual_name;; 583 RScanner::GetDeclQualName(recordDecl, qual_name);; 584 ; 585 need = gAutoloads[qual_name];; 586 }; 587 ; 588 if (need.length() && gLibsNeeded.find(need) == string::npos) {; 589 gLibsNeeded += "" "" + need;; 590 }; 591}; 592 ; 593////////////////////////////////////////////////////////////////////////////////; 594 ; 595void CheckClassNameForRootMap(const std::string &classname, map<string, string> &autoloads); 596{; 597 if (classname.find(':') == std::string::npos) return;; 598 ; 599 // We have a namespace and we have to check it first; 600 int slen = classname.size();; 601 for (int k = 0; k < slen; ++k) {; 602 if (classname[k] == ':') {; 603 if (k + 1 >= slen || classname[k + 1] != ':') {; 604 // we expected another ':'; 605 break;; 606 }; 607 if (k) {; 608 string base = classname.substr(0, k);; 609 if (base == ""std"") {; 610 // std is not declared but is also ignored by CINT!; 611 break;; 612 } else {; 613 autoloads[base] = """"; // We never load namespaces on their own.; 614 }; 615 ++k;; 616 }; 617 } else if (classname[k] == '<') {; 618 // We do not want to look at the namespace inside the template parameters!; 619 break;; 620 }; 621 }; 622}; 623 ; 624////////////////////////////////////////////////////////////////////////////////; 625/// Parse the rootmap and add entries to the autoload map; 626 ; 627void ParseRootMapFile(ifstream &file, map<string, string> &autoloads); 628{; 629 std::string classname;; 630 std::string line;; 631 while (file >> line) {; 632 ; 633 if (line.find(""Library."") != 0) continue;; 634 ; 635 int pos = line.find("":"", 8);; 636 classname = line.substr(8, pos - 8);; 637 ; 638 ROOT::TMetaUtils::ReplaceAll(classname, ""@@"", ""::"");; 639 ROOT::TMetaUtils::ReplaceAll(classname, ""-"", "" "");; 640 ; 641 getline(file, line, '\n');; 642 while (line[0] == ' ') line.replace(0, 1, """");; 643 ; 644 CheckClassNameForRootMap(classname, autoloads);; 645 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:21357,load,load,21357,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['load'],['load']
Performance,"tTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:30836,cache,cache,30836,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,10,['cache'],['cache']
Performance,"tTrainingEfficiency (const TString &);  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; virtual const std::vector< Float_t > & GetTrainingHistory (const char *);  ; UInt_t GetTrainingROOTVersionCode () const;  ; TString GetTrainingROOTVersionString () const;  calculates the ROOT version string from the training version code on the fly ;  ; UInt_t GetTrainingTMVAVersionCode () const;  ; TString GetTrainingTMVAVersionString () const;  calculates the TMVA version string from the training version code on the fly ;  ; Double_t GetTrainTime () const;  ; TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true);  ; const TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true) const;  ; TString GetWeightFileName () const;  retrieve weight file name ;  ; Double_t GetXmax (Int_t ivar) const;  ; Double_t GetXmin (Int_t ivar) const;  ; Bool_t HasMVAPdfs () const;  ; void InitIPythonInteractive ();  ; Bool_t IsModelPersistence () const;  ; virtual Bool_t IsSignalLike ();  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event would be selected as signal or background ;  ; virtual Bool_t IsSignalLike (Double_t mvaVal);  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event with this mva output value would be selected as signal or background ;  ; Bool_t IsSilentFile () const;  ; virtual void MakeClass (const TString &classFileName=TString("""")) const;  create reader class for method (classification only at present) ;  ; TDirectory * MethodBaseDir () const;  returns the ROOT directory where all instances of the corresponding MVA method are stored ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  call the Optimizer with the set of parameters and ranges that are meant to be tuned.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBayesClassifier.html:8554,tune,tuned,8554,doc/master/classTMVA_1_1MethodBayesClassifier.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBayesClassifier.html,26,['tune'],['tuned']
Performance,"tTypeDefinition HFitInterface.h:48; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; ROOT::Fit::InitExpovoid InitExpo(const ROOT::Fit::BinData &data, TF1 *f1)compute initial parameter for an exponential function given the fit data Set the constant and slope a...Definition HFitInterface.cxx:267; ROOT::Fit::InitGausvoid InitGaus(const ROOT::Fit::BinData &data, TF1 *f1)compute initial parameter for gaussian function given the fit data Set the sigma limits for zero top ...Definition HFitInterface.cxx:306; ROOT::Fit::EChisquareTypeEChisquareTypeDefinition HFitInterface.h:53; ROOT::Fit::EChisquareType::kPLikeRatio@ kPLikeRatio; ROOT::Fit::EChisquareType::kNeyman@ kNeyman; ROOT::Fit::EChisquareType::kPearson@ kPearson; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::EExecutionPolicy::kSequential@ kSequential; ROOT::EExecutionPolicy::kMultiThread@ kMultiThread; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; Foption_tDefinition Foption.h:24; Foption_t::Rangeint RangeDefinition Foption.h:39; Foption_t::Nographint NographDefinition Foption.h:42; Foption_t::Quietint QuietDefinition Foption.h:29; Foption_t::Likeint LikeDefinition Foption.h:34; Foption_t::W1int W1Definition Foption.h:36; Foption_t::Gradientint GradientDefinition Foption.h:40; Foption_t::ExecPolicyROOT::EExecutionPolicy ExecPolicyDefinition Foption.h:52; Foption_t::StoreResultint StoreResultDefinition Foption.h:49; Foption_t::Nochisqint NochisqDefinition Foption.h:45; Foption_t::Robus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:62834,multi-thread,multi-threading,62834,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"tUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodBDTMethodBDT(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodBDTMethodBDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* parent); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:13278,Optimiz,OptimizeTuningParameters,13278,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"tUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification of the original tree and the input file name.; - Definition of an analysis cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100687,Load,LoadTree,100687,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['Load'],['LoadTree']
Performance,"tValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsCachedPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetBufferFraction(Double_t frac); voidsetBufferStrategy(RooFFTConvPdf::BufStrat bs); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheObservables(const RooArgSet& obs); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidsetShift(Double_t val1, Double_t val2); voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:31745,cache,cache,31745,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,1,['cache'],['cache']
Performance,"tValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; TStringevalUserFunc(RooArgSet* vars); virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:18935,optimiz,optimizeDirtyHook,18935,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"tVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:19068,optimiz,optimizeCacheMode,19068,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,4,['optimiz'],['optimizeCacheMode']
Performance,"tVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:2724,cache,cacheUniqueSuffix,2724,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:2724,cache,cacheUniqueSuffix,2724,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,2,['cache'],['cacheUniqueSuffix']
Performance,"t_iterator iArg = clingArgsStorage.begin(),; 1482 eArg = clingArgsStorage.end(); iArg != eArg; ++iArg); 1483 interpArgs.push_back(iArg->c_str());; 1484 ; 1485 // Activate C++ modules support. If we are running within rootcling, it's up; 1486 // to rootcling to set this flag depending on whether it wants to produce; 1487 // C++ modules.; 1488 TString vfsArg;; 1489 if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.so"" export * } where ROOT's; 1501 // facilities use the link directive to dynamically load the relevant; 1502 // library. So, we need to suppress clang's default autolink behavior.; 1503 interpArgs.push_back(""-fno-autolink"");; 1504 }; 1505 ; 1506#ifdef R__FAST_MATH; 1507 // Same setting as in rootcling_impl.cxx.; 1508 interpArgs.push_back(""-ffast-math"");; 1509#endif; 1510 ; 1511 TString llvmResourceDir = TROOT::GetEtcDir() + ""/cling"";; 1512 // Add statically injected extra arguments, usually coming from rootcling.; 1513 for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();; 1514 extraArgs && *extraArgs; ++extraArgs) {; 1515 if (!strcmp(*extraArgs, ""-resource-dir"")) {; 1516 // Take the next arg as the llvm resource directory.; 1517 llvmResourceDir = *(++extraArgs);; 1518 } else {; 1519 interpArgs.push_back(*extraArgs);; 1520 }; 1521 }; 1522 ; 1523 std::vector<std::string> _empty;; 1524 auto args = TROOT::AddExtraInterpreterArgs(_empty);; 1525 for (const auto &arg: args); 1526 interpArgs.emplace_back(arg.c_str());; 1527 ; 1528 // Add the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:55493,load,load,55493,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,t_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Private Member Functions;  TFileCacheRead (const TFileCacheRead &)=delete;  ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:13555,cache,cached,13555,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cached']
Performance,t_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of en,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:31179,cache,cached,31179,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cached']
Performance,t_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:23874,cache,cached,23874,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cached']
Performance,"t_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TAttLineLine Attributes class.Definition TAttLine.h:18; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TVirtualStreamerInfo::lsvirtual void ls(Option_t *="""") const override=0List TNamed name and title.; lineTLine * lineDefinition entrylistblock_figure1.C:235; For I/O implementations (eg. XML) , one has to know the original name of the data member. This function can be used to return a pointer to the original TStreamerElement object corresponding to the j-th element of a compressed array in fElems. Parameters description:; i: the serial number in array fElem; j: the element number in the array of consecutive types In the above example the class TAttLine has 3 consecutive data members of the same type ""short"". Compile makes one single array of 3 elements. To access the TStreamerElement for the second element of this array, one can call: auto el = GetStreamerElementReal(0,1);; auto membername = el->GetName();; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:54362,load,load,54362,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['load'],['load']
Performance,"t_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 41101 2011-10-03 16:23:48Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23398,cache,cache,23398,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['cache'],['cache']
Performance,"t_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*RooNumRunningInt::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*RooNumRunningInt::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooNumRunningInt::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual const char*RooNumRunningInt::inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumCdf.html:28629,cache,cacheFunc,28629,root/html602/RooNumCdf.html,https://root.cern,https://root.cern/root/html602/RooNumCdf.html,4,['cache'],['cacheFunc']
Performance,"t_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*RooNumRunningInt::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*RooNumRunningInt::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooNumRunningInt::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual const char*RooNumRunningInt::inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumCdf.html:28673,cache,cacheFunc,28673,root/html534/RooNumCdf.html,https://root.cern,https://root.cern/root/html534/RooNumCdf.html,2,['cache'],['cacheFunc']
Performance,"t_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:6403,cache,cacheObservables,6403,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,4,['cache'],['cacheObservables']
Performance,"t_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tHandle(const char* dset, TObject* type); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchDataSet.html:5666,cache,cache,5666,root/html534/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html534/TProofBenchDataSet.html,2,['cache'],['cache']
Performance,"t_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAlwaysStartFromMin(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProfileLL.html:23414,cache,cache,23414,root/html532/RooProfileLL.html,https://root.cern,https://root.cern/root/html532/RooProfileLL.html,2,['cache'],['cache']
Performance,"t_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:4716,cache,cache,4716,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"t_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidRooAbsCategoryLValue::setIndexFast(Int_t index); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); Bool_tsetType(const RooCatType* type, Bool_t prinError = kTRUE); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSuperCategory.html:19202,optimiz,optimizeDirtyHook,19202,root/html532/RooSuperCategory.html,https://root.cern,https://root.cern/root/html532/RooSuperCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Thu Sep 23 20:00:26 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:4596,optimiz,optimizeCacheMode,4596,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,15,"['cache', 'optimiz', 'perform']","['cache', 'optimization', 'optimizeCacheMode', 'perform']"
Performance,"t_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveUtil.html:2371,load,loaded,2371,root/html528/TEveUtil.html,https://root.cern,https://root.cern/root/html528/TEveUtil.html,5,"['Load', 'load']","['Load', 'loaded']"
Performance,"t_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE); TPMERegexp(); TPMERegexp(const TPMERegexp& r); TPMERegexp(const TString& s, const TString& opts = """", Int_t nMatchMax = 10); TPMERegexp(const TString& s, UInt_t opts, Int_t nMatchMax = 10). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; static Bool_tTPRegexp::GetThrowAtCompileError(); Bool_tTPRegexp::IsValid() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0) const; TObjArray*TPRegexp::MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); voidTPRegexp::Optimize(); UInt_tTPRegexp::ParseMods(const TString& mods) const; Int_tTPRegexp::ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; static voidTPRegexp::SetThrowAtCompileError(Bool_t throwp); Int_tTPRegexp::SubstituteInternal(TString& s, const TString& replace, Int_t start, Int_t nMaxMatch0, Bool_t doDollarSubst) const. private:. TPMERegexp&operator=(const TPMERegexp&). Data Members; protected:. void*fAddressOfLastStringused for checking for change of TString in global match; Int_tfLastGlobalPositionend of last match when kPCRE_GLOBAL is set; TStringfLastStringMatchedcopy of the last TString matched; TArrayIfMarkerslast set of indexes of matches; Int_tfNMatchesnumber of matches returned from last pcre_exec call; Int_tfNMaxMatchesmaximum number of matches; UInt_tTPRegexp::fPCREOpts; TStringTPRegexp::fPattern; PCREPriv_t*TPRegexp::fPriv; static Bool_tTPRegexp::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPMERegexp.html:2167,Optimiz,Optimize,2167,root/html602/TPMERegexp.html,https://root.cern,https://root.cern/root/html602/TPMERegexp.html,2,['Optimiz'],['Optimize']
Performance,"t_t nelements); constructor. TGeoElementTable(const TGeoElementTable& ); copy constructor. TGeoElementTable& operator=(const TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoElementTable.html:7611,optimiz,optimized,7611,root/html528/TGeoElementTable.html,https://root.cern,https://root.cern/root/html528/TGeoElementTable.html,1,['optimiz'],['optimized']
Performance,"t_t nelements); constructor. TGeoElementTable(const TGeoElementTable& ); copy constructor. TGeoElementTable& operator=(const TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoElementTable.html:7680,optimiz,optimized,7680,root/html530/TGeoElementTable.html,https://root.cern,https://root.cern/root/html530/TGeoElementTable.html,1,['optimiz'],['optimized']
Performance,"t_t nelements); constructor. TGeoElementTable(const TGeoElementTable& ); copy constructor. TGeoElementTable& operator=(const TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoElementTable.html:7680,optimiz,optimized,7680,root/html532/TGeoElementTable.html,https://root.cern,https://root.cern/root/html532/TGeoElementTable.html,2,['optimiz'],['optimized']
Performance,"t_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetCacheAlpha(Bool_t flag); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegralMorph.html:31484,cache,cache,31484,root/html530/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html530/RooIntegralMorph.html,1,['cache'],['cache']
Performance,"t_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Double_t> &TMatrixT<Double_t> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment operato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixT_float_.html:21025,Perform,Perform,21025,root/html602/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixT_float_.html,2,['Perform'],['Perform']
Performance,"t_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TClass.h 37287 2010-12-05 04:14:11Z pcanal $ » Last generated: 2010-12-10 21:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:48094,perform,performance,48094,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['perform'],['performance']
Performance,"t_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TClass.h 39694 2011-06-13 21:10:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:49455,perform,performance,49455,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,2,['perform'],['performance']
Performance,"t_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TClass.h 39695 2011-06-13 21:17:59Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:48909,perform,performance,48909,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,1,['perform'],['performance']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fArgs;  ! [fNvar] Array of variables ;  ; Int_t fNvar;  Number of columns. ;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtupleD.html:41153,cache,cache,41153,doc/master/classTNtupleD.html,https://root.cern,https://root.cern/doc/master/classTNtupleD.html,1,['cache'],['cache']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t * fArgs;  ! [fNvar] Array of variables ;  ; Int_t fNvar;  Number of columns. ;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:41192,cache,cache,41192,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,1,['cache'],['cache']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:58952,cache,cache,58952,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool fBranchChecked;  ; Int_t fCurrentEntry;  ; TString fDB;  ; TString fInsertQuery;  ; TString fQuery;  ; TSQLResult * fResult;  ; TSQLRow * fRow;  ; TSQLServer * fServer;  ; TString fTable;  ; TSQLTableInfo * fTableInfo;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:41135,cache,cache,41135,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['cache'],['cache']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool fCanDeleteRefs;  ! If true, TProcessIDs are deleted when closing a file ;  ; TFile * fFile;  ! Pointer to current file (We own the file). ;  ; TObjArray * fFiles;  -> List of file names containing the trees (TChainElement, owned) ;  ; bool fGlobalRegistration;  ! if true, bypass use of global lists ;  ; Int_t fNtrees;  Number of trees. ;  ; TChain * fProofChain;  ! chain proxy when going to be processed by PROOF ;  ; TList * fStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:45041,cache,cache,45041,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['cache'],['cache']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Attributes inherited from TTree; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . #include <THbookTree.h>. Inheritance diagram for THbookTree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THbookTree() [1/2]. THbookTree::THbookTree ; (; ). defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:48586,cache,cache,48586,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['cache'],['cache']
Performance,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Attributes inherited from TTree; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . #include <TProofChain.h>. Inheritance diagram for TProofChain:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkOwnsChain . Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:53234,cache,cache,53234,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['cache'],['cache']
Performance,"t_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveUtil.html:2522,load,loaded,2522,root/html528/TEveUtil.html,https://root.cern,https://root.cern/root/html528/TEveUtil.html,5,"['Load', 'load']","['LoadMacro', 'loaded']"
Performance,"t_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TEntryList::Entervirtual bool Enter(Long64_t entry, TTree *tree=nullptr)Add entry #entry to the list.Definition TEntryList.cxx:631; TEntryList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEntryList.h:49; TEntryList::fLastIndexQueriedLong64_t fLastIndexQueried! used to optimize GetEntry() function from a loopDefinition TEntryList.h:44; TEntryList::GetEntryListvirtual TEntryList * GetEntryList(const char *treename, const char *filename, Option_t *opt="""")Return the entry list, corresponding to treename and filename By default, the filename is first tried...Definition TEntryList.cxx:889; TEntryList::fEntriesToProcessLong64_t fEntriesToProcessused on proof to set the number of entries to process in a packetDefinition TEntryList.h:37; TEntryList::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TEntryList.h:81; TEntryList::fFileNameTString fFileNamename of the file, where the tree isDefinition TEntryList.h:39; TEntryList::OptimizeStoragevirtual void OptimizeStorage()Checks if the array representation is more economical and if so, switches to it.Definition TEntryList.cxx:1085; TEntryList::GetListsvirtual TList * GetLists() constDefinition TEntryList.h:76; TEntryList::Containsvirtual Int_t Contains(Long64_t entry, TTree *tree=nullptr)Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8h_source.html:7891,optimiz,optimize,7891,doc/master/TEntryList_8h_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html,1,['optimiz'],['optimize']
Performance,"t_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:31616,cache,cache,31616,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"t_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return composite MVA response. void Train(); performs classifier training. const Ranking* CreateRanking(); create ranking. UInt_t GetMethodIndex(); { return fMethodIndex; }. IMethod* GetLastMethod(); { return fMethods.back(); }. IMethod* GetPreviousMethod(); { return (fMethodIndex>0)?fMethods[fMethodIndex-1]:0; }. IMethod* GetCurrentMethod(); { return (fMethodIndex>0)?fMethods[fMethodIndex]:0; }. void DeclareOptions(). void ProcessOptions(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCompositeBase.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCompositeBase.html:17047,perform,performs,17047,root/html532/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCompositeBase.html,2,['perform'],['performs']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:20428,optimiz,optimizeCacheMode,20428,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,3,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChangeTracker.html:18683,optimiz,optimizeCacheMode,18683,root/html530/RooChangeTracker.html,https://root.cern,https://root.cern/root/html530/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:18272,optimiz,optimizeCacheMode,18272,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,1,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:18890,optimiz,optimizeCacheMode,18890,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:18692,optimiz,optimizeCacheMode,18692,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,122,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:18356,optimiz,optimizeCacheMode,18356,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,6,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:18828,optimiz,optimizeCacheMode,18828,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,3,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:18405,optimiz,optimizeCacheMode,18405,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,6,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChangeTracker.html:18755,optimiz,optimizeCacheMode,18755,root/html530/RooChangeTracker.html,https://root.cern,https://root.cern/root/html530/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen!; RooArgSet*_optCacheObservables! current optCacheObservables; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:4279,cache,cache,4279,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,8,['cache'],['cache']
Performance,"t_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tRecover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:12715,cache,cacheDir,12715,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['cache'],['cacheDir']
Performance,"t_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgMaxDaughters! Maximum number of daughters; static Int_tfgMaxLevel! Maximum level in geometry; static Int_tfgMaxXtruVert! Maximum number of Xtru vertices; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes provid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:32979,load,loaded,32979,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,2,['load'],['loaded']
Performance,"t_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum { kBigNumber; };; enum TEntryList::[unnamed] { kBlockSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; TFile*fFilecurrently open file; TStringTEntryList::fFileNamename of the file, where the tree is; TObjArray*fFileNames! points to the fFiles data member of the corresponding chain; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TStringfListFileNamefrom this string names of all files can be found; TStringfListNamename of the list; Long64_t*fListOffset[fNFiles] numbers of entries in ind. lists; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; Int_tfNFilestotal number of files; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListFromFile.html:8466,optimiz,optimize,8466,root/html528/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html528/TEntryListFromFile.html,8,['optimiz'],['optimize']
Performance,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:47302,cache,cache,47302,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,4,['cache'],['cache']
Performance,"t_t_nevalNumber evaluations used in last minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:33217,cache,cache,33217,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,1,['cache'],['cache']
Performance,"t_t_nevalNumber evaluations used in last minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject iden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:37322,cache,cache,37322,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,4,['cache'],['cache']
Performance,"t_tfTimeStamp! timestamp; Float_tfVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); Bool_tfWasArcBalledset when arc-ball rotation is used; static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLCamera(); Default base camera constructor. TGLCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); Default base camera constructor. ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLCamera.html:12385,cache,cached,12385,root/html602/TGLCamera.html,https://root.cern,https://root.cern/root/html602/TGLCamera.html,4,['cache'],['cached']
Performance,"t_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called by the TClass constructor when replacing an emulated class by the real class ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerLoop.html:3589,cache,cache,3589,doc/master/classTStreamerLoop.html,https://root.cern,https://root.cern/doc/master/classTStreamerLoop.html,1,['cache'],['cache']
Performance,"t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t inhibitDirty() const; { return _inhibitDirty && !_localNoInhibitDirty; }. RooAbsArg(); Default constructor. RooAbsArg(const char* name, const char* title); Create an object with the specified name and descriptive title.; The newly created object has no clients or servers and has its; dirty flags set. RooAbsArg(const RooAbsArg& other, const char* name = 0); Copy constructor transfers all boolean and string properties of the original; object. Transient properties and client-server links are not copied. ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:21031,cache,cache,21031,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,4,['cache'],['cache']
Performance,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf604__constraints_8py.html:2983,optimiz,optimization,2983,doc/master/rf604__constraints_8py.html,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html,6,['optimiz'],['optimization']
Performance,"ta h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; VirtualIntegrator.h; WrappedFunction.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IBaseFunctionOneDim::Clonevirtual IBaseFunctionOneDim * Clone() const =0Clone a function.; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::Integratorstd::string Integrator() const overridename of 1D integratorDefinition IntegratorOptions.cxx:203; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::SetAbsTolerancevoid SetAbsTolerance(double absTolerance)set the desired absolute ErrorDefinition Integrator.h:441; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(const IGenFunction &f, bool copy=false)set one dimensional function for 1D integrationDefinition Integrator.h:202; ROOT::Math::IntegratorOneDim::Integraldouble Integral(const IGenFunction &f)evaluate the Integral of a function f over the infinite interval (-inf,+inf)Definition Integrator.h:258; ROOT::Math::IntegratorOneDim::IntegratorOneDimIntegratorOneDim(IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, unsigned int rule=0)Constructor of one dimensional Integrator, defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:23085,perform,performing,23085,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['perform'],['performing']
Performance,"ta master version is important; 1223 // it allows to detect if streamer info was modified; 1224 const char *parname = fSniffer->IsStreamerInfoItem(arg->fPathName.Data()) ? ""BVersion"" : ""MVersion"";; 1225 arg->AddHeader(parname, TString::Format(""%u"", (unsigned)fSniffer->GetStreamerInfoHash()).Data());; 1226 }; 1227 ; 1228 // try to avoid caching on the browser; 1229 arg->AddNoCacheHeader();; 1230 ; 1231 // potentially add cors headers; 1232 if (IsCors()); 1233 arg->AddHeader(""Access-Control-Allow-Origin"", GetCors());; 1234 if (IsCorsCredentials()); 1235 arg->AddHeader(""Access-Control-Allow-Credentials"", GetCorsCredentials());; 1236}; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Register object in folders hierarchy; 1240///; 1241/// See TRootSniffer::RegisterObject() for more details; 1242 ; 1243Bool_t THttpServer::Register(const char *subfolder, TObject *obj); 1244{; 1245 return fSniffer->RegisterObject(subfolder, obj);; 1246}; 1247 ; 1248////////////////////////////////////////////////////////////////////////////////; 1249/// Unregister object in folders hierarchy; 1250///; 1251/// See TRootSniffer::UnregisterObject() for more details; 1252 ; 1253Bool_t THttpServer::Unregister(TObject *obj); 1254{; 1255 return fSniffer->UnregisterObject(obj);; 1256}; 1257 ; 1258////////////////////////////////////////////////////////////////////////////////; 1259/// Register WS handler to the THttpServer; 1260///; 1261/// Only such handler can be used in multi-threaded processing of websockets; 1262 ; 1263void THttpServer::RegisterWS(std::shared_ptr<THttpWSHandler> ws); 1264{; 1265 std::lock_guard<std::mutex> grd(fWSMutex);; 1266 fWSHandlers.emplace_back(ws);; 1267}; 1268 ; 1269////////////////////////////////////////////////////////////////////////////////; 1270/// Unregister WS handler to the THttpServer; 1271 ; 1272void THttpServer::UnregisterWS(std::shared_ptr<THttpWSHandler> ws); 1273{; 1274 std::lock_guard<std::mutex> grd(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:40294,multi-thread,multi-threaded,40294,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['multi-thread'],['multi-threaded']
Performance,"ta members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(Bool_t savememvalues = kFALSE); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:19849,optimiz,optimizing,19849,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,4,['optimiz'],['optimizing']
Performance,ta sets; TDataSetManager*fDataSetManagerdataset manager; TDataSetManagerFile*fDataSetStgReporepository for staging requests; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:18578,latency,latency,18578,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['latency'],['latency']
Performance,"ta* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:20674,optimiz,optimizeCacheMode,20674,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ta* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDataWeightedAverage&operator=(const RooDataWeightedAverage&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:20364,optimiz,optimizeCacheMode,20364,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:55033,optimiz,optimizerParams,55033,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerParams']
Performance,"taFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows: #include <ROOT/RLogger.hxx>; ; // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; RLogger.hxx; ROOT::Experimental::RLogScopedVerbosityChange the verbosity level (global or specific to the RLogChannel passed to the constructor) for the ...Definition RLogger.hxx:243; ROOT::Detail::RDF::RDFLogChannelROOT::Experimental::RLogChannel & RDFLogChannel()Definition RDFUtils.cxx:37; ROOT::Experimental::ELogLevel::kInfo@ kInfoInformational messages; used for instance for tracing.; or in Python: import ROOT; ; verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); More information (e.g. start and end of each multi-thread task) is printed using ELogLevel.kDebug and even more (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using ELogLevel.kDebug+10. Creating an RDataFrame from a dataset specification file; RDataFrame can be created using a dataset specification JSON file:; import ROOT; ; df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1729; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:76128,multi-thread,multi-thread,76128,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-thread']
Performance,"taFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows: #include <ROOT/RLogger.hxx>; ; // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; RLogger.hxx; ROOT::Experimental::RLogScopedVerbosityChange the verbosity level (global or specific to the RLogChannel passed to the constructor) for the ...Definition RLogger.hxx:243; ROOT::Detail::RDF::RDFLogChannelROOT::Experimental::RLogChannel & RDFLogChannel()Definition RDFUtils.cxx:37; ROOT::Experimental::ELogLevel::kInfo@ kInfoInformational messages; used for instance for tracing.; or in Python: import ROOT; ; verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); More information (e.g. start and end of each multi-thread task) is printed using ELogLevel.kDebug and even more (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using ELogLevel.kDebug+10. Creating an RDataFrame from a dataset specification file; RDataFrame can be created using a dataset specification JSON file:; import ROOT; ; df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:77550,multi-thread,multi-thread,77550,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-thread']
Performance,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:15377,multi-thread,multi-thread,15377,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,2,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"taFrame` that wraps the snapshotted dataset.; 1410 ///; 1411 /// This function returns a `RDataFrame` built with the output tree as a source.; 1412 /// The types of the columns are automatically inferred and do not need to be specified.; 1413 ///; 1414 /// See above for a more complete description and example usages.; 1415 RResultPtr<RInterface<RLoopManager>> Snapshot(std::string_view treename, std::string_view filename,; 1416 std::initializer_list<std::string> columnList,; 1417 const RSnapshotOptions &options = RSnapshotOptions()); 1418 {; 1419 ColumnNames_t selectedColumns(columnList);; 1420 return Snapshot(treename, filename, selectedColumns, options);; 1421 }; 1422 // clang-format on; 1423 ; 1424 ////////////////////////////////////////////////////////////////////////////; 1425 /// \brief Save selected columns in memory.; 1426 /// \tparam ColumnTypes variadic list of branch/column types.; 1427 /// \param[in] columnList columns to be cached in memory.; 1428 /// \return a `RDataFrame` that wraps the cached dataset.; 1429 ///; 1430 /// This action returns a new `RDataFrame` object, completely detached from; 1431 /// the originating `RDataFrame`. The new dataframe only contains the cached; 1432 /// columns and stores their content in memory for fast, zero-copy subsequent access.; 1433 ///; 1434 /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; 1435 /// fits in memory and that will be accessed many times.; 1436 ///; 1437 /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; 1438 /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; 1439 /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; 1440 /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; 1441 ///; 1442 /// ### Example usage:; 1443 ///; 1444 /// **Types and columns specified:*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:79828,cache,cached,79828,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cached']
Performance,"taLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""");  Book a classifier or regression method. ;  ; MethodBase * BookMethod (DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption="""");  Books MVA method. ;  ; void DeleteAllMethods (void);  Delete methods. ;  ; void EvaluateAllMethods (void);  Iterates over all MVAs that have been booked, and calls their evaluation methods. ;  ; void EvaluateAllVariables (DataLoader *loader, TString options="""");  Iterates over all MVA input variables and evaluates them. ;  ; TH1F * EvaluateImportance (DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""");  Evaluate Variable Importance. ;  ; IMethod * GetMethod (const TString &datasetname, const TString &title) const;  Returns pointer to MVA that corresponds to given method title. ;  ; TGraph * GetROCCurve (DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ;  ; TCanvas * GetROCCurve (DataLoader *loader, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Draws ROC curves for all methods booked with the factory for a given class onto a canvas. ;  ; TGraph * GetROCCurve (TString datasetname, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ;  ; TCanvas * GetROCCurve (TString datasetname, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Draws ROC curves for all methods booked with the factory for a given class. ;  ; TMultiGraph * GetROCCurveAsMultiGraph (DataLoader *loader, UInt_t iClass, Types::ETreeType type=Types::kTesting);  Generate a collection of graphs, for all methods for a given class. ;  ; TMultiGraph * GetROCCurveAsMultiGraph (TString datasetname, UInt_t i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:2532,load,loader,2532,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"taStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps! ; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); WVE ownership issue here!! Cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:10485,load,loaded,10485,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,2,['load'],['loaded']
Performance,"taStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps! ; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); Forward recalculate request to all subsets. Bool_t hasFilledCache() const. void forceCacheUpdate(). Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCompositeDataStore.html:10588,load,loaded,10588,root/html534/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html534/RooCompositeDataStore.html,2,['load'],['loaded']
Performance,"table::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const char* newname = 0) const. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsDataStore.html:10807,load,loaded,10807,root/html602/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html,4,['load'],['loaded']
Performance,"table::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useWindowSwitch to activate window convolution; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Int_t_verboseThreshCall count threshold for verbose printing; RooListProxy_windowParamHolder for optional convolution integration window scaling parameter; Double_t_windowScaleScale factor for window parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:36037,cache,cache,36037,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['cache'],['cache']
Performance,"table; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; virtual double evaluate () const =0;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMoment.html:52468,cache,cached,52468,doc/master/classRooAbsMoment.html,https://root.cern,https://root.cern/doc/master/classRooAbsMoment.html,2,['cache'],"['cache', 'cached']"
Performance,"table; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:50930,cache,cached,50930,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,8,['cache'],"['cache', 'cached']"
Performance,"tain additional unrelated info: in such a case the field delimited by the prefix ""opt:"" is analyzed, e.g. ;  ; Bool_t ParseUri (const char *uri, TString *dsGroup=0, TString *dsUser=0, TString *dsName=0, TString *dsTree=0, Bool_t onlyCurrent=kFALSE, Bool_t wildcards=kFALSE);  Parses a (relative) URI that describes a DataSet on the cluster. ;  ; virtual Int_t RegisterDataSet (const char *uri, TFileCollection *dataSet, const char *opt);  Register a dataset, perfoming quota checkings, if needed. ;  ; virtual Bool_t RemoveDataSet (const char *uri);  Removes the indicated dataset. ;  ; Int_t ScanDataSet (const char *uri, const char *opt);  Scans the dataset indicated by 'uri' following the 'opts' directives. ;  ; virtual Int_t ScanDataSet (const char *uri, UInt_t option=kReopen|kDebug);  Scans the dataset indicated by <uri> and returns the number of missing files. ;  ; void SetScanCounters (Int_t t=-1, Int_t o=-1, Int_t d=-1);  Update scan counters. ;  ; virtual Int_t ShowCache (const char *uri);  Show cached information matching uri. ;  ; virtual void ShowDataSets (const char *uri=""*"", const char *opt="""");  Prints formatted information about the dataset 'uri'. ;  ; virtual void ShowQuota (const char *opt);  Display quota information. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:4762,cache,cached,4762,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['cache'],['cached']
Performance,"tain the description on how to compile and link a shared lib. ; This description can be any valid shell command, including the use of ';' to separate several instructions. However, shell specific construct should be avoided. In particular this description can contain environment variables, like $ROOTSYS (or ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; extensionconst char * extensionDefinition civetweb.c:8025; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; e.g.: gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");; ; gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:89229,optimiz,optimization,89229,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimization']
Performance,"taining on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::SetValuevoid SetValue(double val)set the valueDefinition ParameterSett",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:48492,perform,perform,48492,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['perform'],['perform']
Performance,"taining the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TList*fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:23092,load,loading,23092,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,2,['load'],['loading']
Performance,"tainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::GetFromPipevirtual TString GetFromPipe(const char *command)Execute command and return output in TString.Definition TSystem.cxx:680; TTextBase class for several text objects.Definition TText.h:22; TText::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a string.Definition TText.cxx:144; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::GetCachedBranchesconst TObjArray * GetCachedBranches() constDefinition TTreeCache.h:139; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfStats::fNleavesInt_t fNleavesNumber of leaves in the tree.Definition TTreePerfStats.h:52; TTreePerfStats::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TTreePerfStats.cxx:208; TTreePerfStats::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:277; TTreePerfStats::fRealNormDouble_t fRealNormReal time scale factor for fGraphTime.Definition TTreePerfStats.h:57; TTreePerfStats::GetBasketInfoBasketInfo & GetBasketInfo(TBranch *b, size_t basketNumber)Return the BasketInfo corr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:38938,perform,performance,38938,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['perform'],['performance']
Performance,"tal size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:25880,cache,cache,25880,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,4,['cache'],['cache']
Performance,"tamp_t fSendStamp; ///<! last server operation, always used from window thread; 81 bool fActive{false}; ///<! flag indicates if connection is active; 82 unsigned fWSId{0}; ///<! websocket id; 83 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 84 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 85 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 86 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 87 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 88 int fClientCredits{0}; ///<! number of credits received from client; 89 bool fDoingSend{false}; ///<! true when performing send operation; 90 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 91 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 92 std::queue<QueueItem> fQueue; ///<! output queue; 93 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 94 WebConn() = default;; 95 WebConn(unsigned connid) : fConnId(connid) {}; 96 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 97 WebConn(unsigned connid, bool headless_mode, const std::string &key); 98 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 99 {; 100 ResetStamps();; 101 }; 102 ~WebConn();; 103 ; 104 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 105 ; 106 void ResetData(); 107 {; 108 fActive = false;; 109 fWSId = 0;; 110 fReady = 0;; 111 fDoingSend = false;; 112 fSendCredits = 0;; 113 fClientCredits = 0;; 114 fRecvSeq = 0;; 115 fSendSeq = 1;; 116 while (!fQueue.empty()); 117 fQueue.pop();; 118 }; 119 };; 120 ; 121 struct MasterConn {; 122 unsigned connid{0};; 123 int channel{-1};; 124 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 125 };; 126 ; 127 enum E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:3840,perform,performed,3840,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,4,"['perform', 'queue']","['performed', 'performing', 'queue']"
Performance,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:39073,queue,queue,39073,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,6,['queue'],['queue']
Performance,"tance(); TMVA.PyMethodBase.PyInitialize(); ; output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); ; # Run training, test and evaluation; factory.TrainAllMethods(); factory.TestAllMethods(); factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefiniti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py.html:1669,optimiz,optimizer,1669,doc/master/ClassificationKeras_8py.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html,1,['optimiz'],['optimizer']
Performance,"tance, the image below can be generated with the following command:; 1423~~~{.sh}; 1424$ dot -Tpng computation_graph.dot -ocomputation_graph.png; 1425~~~; 1426 ; 1427\image html RDF_Graph2.png; 1428 ; 1429\anchor rdf-logging; 1430### Activating RDataFrame execution logs; 1431 ; 1432RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; 1433~~~{.cpp}; 1434#include <ROOT/RLogger.hxx>; 1435 ; 1436// this increases RDF's verbosity level as long as the `verbosity` variable is in scope; 1437auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; 1438~~~; 1439 ; 1440or in Python:; 1441~~~{.python}; 1442import ROOT; 1443 ; 1444verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); 1445~~~; 1446 ; 1447More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; 1448(e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`.; 1449 ; 1450\anchor rdf-from-spec; 1451### Creating an RDataFrame from a dataset specification file; 1452 ; 1453RDataFrame can be created using a dataset specification JSON file: ; 1454 ; 1455~~~{.python}; 1456import ROOT; 1457 ; 1458df = ROOT.RDF.Experimental.FromSpec(""spec.json""); 1459~~~; 1460 ; 1461The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; 1462their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; 1463required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1464sample in the ""metadata"" key.; 1465 ; 1466A simple example for the formatting of the specification in the JSON file is the following:; 1467 ; 1468~~~{.cpp}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:83187,multi-thread,multi-thread,83187,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"tance, the image below can be generated with the following command:; 1463~~~{.sh}; 1464$ dot -Tpng computation_graph.dot -ocomputation_graph.png; 1465~~~; 1466 ; 1467\image html RDF_Graph2.png; 1468 ; 1469\anchor rdf-logging; 1470### Activating RDataFrame execution logs; 1471 ; 1472RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; 1473~~~{.cpp}; 1474#include <ROOT/RLogger.hxx>; 1475 ; 1476// this increases RDF's verbosity level as long as the `verbosity` variable is in scope; 1477auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; 1478~~~; 1479 ; 1480or in Python:; 1481~~~{.python}; 1482import ROOT; 1483 ; 1484verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); 1485~~~; 1486 ; 1487More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; 1488(e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`.; 1489 ; 1490\anchor rdf-from-spec; 1491### Creating an RDataFrame from a dataset specification file; 1492 ; 1493RDataFrame can be created using a dataset specification JSON file: ; 1494 ; 1495~~~{.python}; 1496import ROOT; 1497 ; 1498df = ROOT.RDF.Experimental.FromSpec(""spec.json""); 1499~~~; 1500 ; 1501The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; 1502their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; 1503required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1504sample in the ""metadata"" key.; 1505 ; 1506A simple example for the formatting of the specification in the JSON file is the following:; 1507 ; 1508~~~{.cpp}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:84867,multi-thread,multi-thread,84867,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"tance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:13772,cache,cache,13772,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,2,['cache'],['cache']
Performance,"tance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:12841,cache,cache,12841,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,4,['cache'],['cache']
Performance,"tandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Bool_t_forcedUpdate! Request for forced cache update ; Int_t_nCat; Int_t_nEntries; Int_t_nReal; Int_t_nRealF; vector<RealVector*>_realStoreList; vector<RealFullVector*>_realfStoreList; Double_t_sumWeight; Double_t_sumWeightCarry; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooVectorDataStore(). RooVectorDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). void setAllBuffersNative(). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:10691,cache,cache,10691,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,6,"['Cache', 'Optimiz', 'cache']","['Cache', 'Optimization', 'cache']"
Performance,"tant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), which is slow and does error checking. ;  . Friends; class AddCacheElem;  ; class BatchInterfaceAccessor;  ; class RooAddHelpers;  ; class RooAddModel;  ; class RooAddPdf;  ; class RooFit::EvalContext;  ; class RooRealBinding;  ; class RooRealSumFunc;  ; class RooRealSumPdf;  ; class RooVectorDataStore;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:59520,cache,cache,59520,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['cache']
Performance,"tant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:46863,optimiz,optimizeConstantTerms,46863,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,8,['optimiz'],"['optimization', 'optimizeConstantTerms']"
Performance,"tant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:39279,optimiz,optimizeConstantTerms,39279,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,6,['optimiz'],"['optimization', 'optimizeConstantTerms']"
Performance,"taset manager is configured to allow so).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. TMap * GetDataSets(const char* uri = """", const char* optStr = """"); Lists all datasets that match given uri.; The 'optStr' can contain a comma-separated list of servers for which the; information is wanted. If ':lite:' (case insensitive) is specified in 'optStr'; only the global information in the TFileCollection is retrieved; useful to only; get the list of available datasets. void ShowDataSets(const char* uri = """", const char* optStr = """"); Shows datasets in locations that match the uri.; By default shows the user's datasets and global ones. Bool_t ExistsDataSet(const char* dataset); Returns kTRUE if 'dataset' exists, kFALSE otherwise. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). TFileCollection * GetDataSet(const char* dataset, const char* optStr = """"); Get a list of TFileInfo objects describing the files of the specified; dataset.; To get the short version (containing only the global meta information); specify optStr = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""M""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Int_t VerifyDataSet(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:82391,cache,cache,82391,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['cache'],['cache']
Performance,"taset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF = const ROOT::RVecF &;; using cRVecI = const ROOT::RVecI &;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, cRVecF lep_eta, cRVecF lep_phi, cRVecF lep_e, cRVecF trackd0pv, cRVecF tracksigd0pv, cRVecF z0); {; int idx = -1; // Return -1 if no good lepton is found.; for(auto i = 0; i < type.size(); i++) {; if(!goodlep[i]) continue;; if (type[i] == 11 && abs(lep_eta[i]) < 2.47 && (abs(lep_eta[i]) < 1.37 || abs(lep_eta[i]) > 1.52) && abs(trackd0pv[i] / tracksigd0pv[i]) < 5) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; if (type[i] == 13 && abs(lep_eta[i]) < 2.5 && abs(trackd0pv[i] / tracksigd0pv[i]) < 3) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:3487,perform,performing,3487,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['perform'],['performing']
Performance,"tate permutations of a list of categories; RooMultiCategory Product operator for categories; RooMultiGenFunction Export RooAbsReal as functor; RooMultiVarGaussian Multivariate Gaussian PDF with correlations; RooMultiVarGaussian::AnaIntData ; RooMultiVarGaussian::GenData ; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNonCentralChiSquare non-central chisquare pdf; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParamHistFunc Your description goes here...; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:41214,cache,caches,41214,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,"['Cache', 'cache']","['Cache', 'caches']"
Performance,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:26997,cache,cache,26997,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['cache'],['cache']
Performance,"tate fState;  ; Bool_t fValid;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TCondor.h>. Inheritance diagram for TCondor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EState. enum TCondor::EState. EnumeratorkFree ; kSuspended ; kActive . Definition at line 54 of file TCondor.h. Constructor & Destructor Documentation. ◆ TCondor(). TCondor::TCondor ; (; const char * ; pool = """"). Create Condor interface object. ; Uses Condor apps since there is no API yet. ; Definition at line 42 of file TCondor.cxx. ◆ ~TCondor(). TCondor::~TCondor ; (; ). override . Cleanup Condor interface. ; Definition at line 75 of file TCondor.cxx. Member Function Documentation. ◆ Claim() [1/2]. TCondorSlave * TCondor::Claim ; (; const char * ; vmname, . const char * ; cmd . ). Claim virtual machine with name vmname This function does not figure out the image and performance index before returning the condor slave. ; Definition at line 268 of file TCondor.cxx. ◆ Claim() [2/2]. TList * TCondor::Claim ; (; Int_t ; n, . const char * ; cmd . ). Claim n virtual machines This function figures out the image and performance index before returning the list of condor slaves. ; Definition at line 233 of file TCondor.cxx. ◆ ClaimVM(). TCondorSlave * TCondor::ClaimVM ; (; const char * ; vm, . const char * ; cmd . ). protected . Claim a VirtualMachine for PROOF usage. ; Definition at line 101 of file TCondor.cxx. ◆ Class(). static TClass * TCondor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCondor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCondor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 88 of file TCondor.h. ◆ DeclFileName(). static const char * TCondor::DeclFileName ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:11921,perform,performance,11921,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,1,['perform'],['performance']
Performance,"tatic Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSet_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:36256,cache,cache,36256,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"tatic Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; TObject * GetFromTable (Int_t idx) const;  the reference may be in the TRefTable ;  ; Bool_t GetObjectUID (Int_t &uid, TObject *obj, const char *methodname);  Private/static function, check for validity of pid. ;  ; void Init (Int_t s, Int_t lowerBound);  Initialize a TRefArray. ;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t fLast;  ; Int_t fLowerBound;  ; TProcessID * fPID;  ; UInt_t * fUIDs;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Friends; class TRefArrayIter;  . Additional Inherited Members;  Protected Types inherited from TCollection;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefArray.html:22250,perform,perform,22250,doc/master/classTRefArray.html,https://root.cern,https://root.cern/doc/master/classTRefArray.html,1,['perform'],['perform']
Performance,"tatic Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; virtual double evaluate () const =0;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:51363,cache,cached,51363,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,4,['cache'],"['cache', 'cached']"
Performance,"tatic Public Member Functions; static void AddClass (TClass *cl);  static: Add a class to the list and map of classes. ;  ; static void AddClassToDeclIdMap (TDictionary::DeclId_t id, TClass *cl);  static: Add a TClass* to the map of classes. ;  ; static Bool_t AddRule (const char *rule);  Add a schema evolution customization rule. ;  ; static Int_t AutoBrowse (TObject *obj, TBrowser *browser);  Browse external object inherited from TObject. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; template<typename T > ; static TClass * GetClass (Bool_t load=kTRUE, Bool_t silent=kFALSE);  ; static TClass * GetClass (ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE);  Static method returning pointer to TClass of the specified ClassInfo. ;  ; static TClass * GetClass (const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);  ; static TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE);  Static method returning pointer to TClass of the specified class name. ;  ; static TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Return pointer to class with name. ;  ; static Bool_t GetClass (DeclId_t id, std::vector< TClass * > &classes);  ; static DictFuncPtr_t GetDict (const char *cname);  Return a pointer to the dictionary loading function generated by rootcint. ;  ; static DictFuncPtr_t GetDict (const std::type_info &info);  Return a pointer to the dictionary loading function generated by rootcint. ;  ; static Bool_t HasDictionarySelection (const char *clname);  Check whether a class has a dictionary or ROOT can load one. ;  ; static ENewType IsCallingNew ();  Static method returning the defConstructor flag passed to TClass::New(). ;  ; static TClass * Load (TBuffer &b);  Load class description from I/O buffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:34427,load,load,34427,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,4,['load'],['load']
Performance,"tatic ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:15894,optimiz,optimization,15894,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,2,['optimiz'],['optimization']
Performance,"tatic TClass * TWebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TWebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TWebFile.h. ◆ Close(). void TWebFile::Close ; (; Option_t * ; option = """"). overridevirtual . Close a Web file. ; Close the socket connection and delete the cache See also the TFile::Close() function ; Reimplemented from TFile.; Definition at line 412 of file TWebFile.cxx. ◆ DeclFileName(). static const char * TWebFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 95 of file TWebFile.h. ◆ GetFromCache(). Int_t TWebFile::GetFromCache ; (; char * ; buf, . Int_t ; len, . Int_t ; nseg, . Long64_t * ; seg_pos, . Int_t * ; seg_len . ). protectedvirtual . Extract requested segments from the cached content. ; Such cache can be produced when server suddenly returns full data instead of segments Returns -1 in case of error, 0 in case of success ; Definition at line 600 of file TWebFile.cxx. ◆ GetFromWeb(). Int_t TWebFile::GetFromWeb ; (; char * ; buf, . Int_t ; len, . const TString & ; msg . ). protectedvirtual . Read request from web server. ; Returns -1 in case of error, 0 in case of success. ; Definition at line 625 of file TWebFile.cxx. ◆ GetFromWeb10(). Int_t TWebFile::GetFromWeb10 ; (; char * ; buf, . Int_t ; len, . const TString & ; msg, . Int_t ; nseg = 0, . Long64_t * ; seg_pos = nullptr, . Int_t * ; seg_len = nullptr . ). protectedvirtual . Read multiple byte range request from web server. ; Uses HTTP 1.0 daemon wihtout mod-root. Returns -2 in case file does not exist, -1 in case of error and 0 in case of success. ; Definition at line 692 of file TWebFile.cxx. ◆ GetHead(). Int_t TWebFile::GetHead ; (; ). protectedvirtual . Get the HTTP header. ; Dependin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:47093,cache,cached,47093,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cached']
Performance,"tatic TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TGClient*fClientclient for which we keep icon pool; TStringfPathicon search path; THashTable*fPicListhash table containing the icons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPicturePool(const TGPicturePool& ); copy constructor. TGPicturePool& operator=(const TGPicturePool& ); assignment operator. const TGPicture * GetPicture(const char* name); Get a picture from the picture pool. Picture must be freed using; TGPicturePool::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGPicturePool::FreePicture(). If; picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, Pixmap_t pxmap, Pixmap_t mask = 0); Get picture with specified pixmap and mask from pool.; Picture must be freed using TGPicturePool::FreePicture().; If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, char** xpm); Create picture from XPM data.; Picture must be freed using TGPicturePool::FreePicture().; If picture creation failed 0 is returned. void FreePicture(const TGPicture* pic); Remove picture from cache if nobody is using it anymore. ~TGPicturePool(); Delete picture cache. void Print(Option_t* option = """") const; List all pictures in the pool. TGPicturePool(const TGPicturePool& ). const char * GetPath() const; { return fPath; }. » Author: Fons Rademakers 01/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGPicturePool.html:7479,cache,cache,7479,root/html604/TGPicturePool.html,https://root.cern,https://root.cern/root/html604/TGPicturePool.html,4,['cache'],['cache']
Performance,"tatic TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TGClient*fClientclient for which we keep icon pool; TStringfPathicon search path; THashTable*fPicListhash table containing the icons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPicturePool(const TGPicturePool& ); copy constructor. TGPicturePool& operator=(const TGPicturePool& ); assignment operator. const TGPicture * GetPicture(const char* name); Get a picture from the picture pool. Picture must be freed using; TGPicturePool::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGPicturePool::FreePicture(). If; picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, Pixmap_t pxmap, Pixmap_t mask = 0); Get picture with specified pixmap and mask from pool.; Picture must be freed using TGPicturePool::FreePicture().; If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, char** xpm); Create picture from XPM data.; Picture must be freed using TGPicturePool::FreePicture().; If picture creation failed 0 is returned. void FreePicture(const TGPicture* pic); Remove picture from cache if nobody is using it anymore. ~TGPicturePool(); Delete picture cache. void Print(Option_t* option = """") const; List all pictures in the pool. TGPicturePool(const TGPicturePool& ). const char * GetPath() const; { return fPath; }. » Author: Fons Rademakers 01/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPicturePool.html:7479,cache,cache,7479,root/html602/TGPicturePool.html,https://root.cern,https://root.cern/root/html602/TGPicturePool.html,4,['cache'],['cache']
Performance,"tatic TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*fBestFitParamssnapshot of the model parameters with best fit value (managed internally); Double_tfConfidenceLevelRequested confidence level (eg. 0.95 for 95% CL); shared_ptr<RooFunctor>fFunctor! transient pointer to functor class used by the minimizer; RooAbsReal*fLikelihoodRatiolikelihood ratio function used to make contours (managed internally); map<string,double>fLowerLimitsmap with cached lower bound values; shared_ptr<ROOT::Math::IMultiGenFunction>fMinFunc! transient pointer to the minimization function; shared_ptr<ROOT::Math::Minimizer>fMinimizer! transient pointer to minimizer class used to find limits and contour; RooArgSetfParametersparameters of interest for this interval; map<string,double>fUpperLimitsmap with cached upper bound values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LikelihoodInterval(const char* name = 0); Default constructor with name and title. LikelihoodInterval(const char* name, RooAbsReal* , const RooArgSet* , RooArgSet* = 0); Alternate constructor taking a pointer to the profile likelihood ratio, parameter of interest and; optionally a snaphot of best parameter of interest for interval. ~LikelihoodInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const; This is the main method to satisfy the RooStats::ConfInterval interface.; It returns true if the parameter point is in the interval. RooArgSet* GetParameters() const; returns list of param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__LikelihoodInterval.html:8669,cache,cached,8669,root/html602/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__LikelihoodInterval.html,8,['cache'],['cached']
Performance,"tatic TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFunctorPdfBinding.html:43033,cache,cache,43033,root/html534/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html534/RooFunctorPdfBinding.html,2,['cache'],['cache']
Performance,"tatic TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html:44920,cache,cache,44920,root/html602/RooCFunction2PdfBinding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html,4,['cache'],['cache']
Performance,"tatic TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html:44920,cache,cache,44920,root/html602/RooCFunction2PdfBinding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html,4,['cache'],['cache']
Performance,"tatic UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:7178,cache,cache,7178,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,4,['cache'],['cache']
Performance,"tatic UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLCamera.html:11823,cache,cache,11823,root/html534/TGLCamera.html,https://root.cern,https://root.cern/root/html534/TGLCamera.html,2,['cache'],['cache']
Performance,"tatic const char * TBufferIO::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TBufferIO::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 120 of file TBufferIO.h. ◆ DeclFileName(). static const char * TBufferIO::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 120 of file TBufferIO.h. ◆ ForceWriteInfo(). void TBufferIO::ForceWriteInfo ; (; TVirtualStreamerInfo * ; info, . Bool_t ; force . ). overridevirtual . force writing the TStreamerInfo to the file ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 329 of file TBufferIO.cxx. ◆ ForceWriteInfoClones(). void TBufferIO::ForceWriteInfoClones ; (; TClonesArray * ; a). overridevirtual . Make sure TStreamerInfo is not optimized, otherwise it will not be possible to support schema evolution in read mode. ; In case the StreamerInfo has already been computed and optimized, one must disable the option BypassStreamer. ; Implements TBuffer.; Definition at line 341 of file TBufferIO.cxx. ◆ GetBufferDisplacement(). Int_t TBufferIO::GetBufferDisplacement ; (; ); const. inlineoverridevirtual . Implements TBuffer.; Definition at line 81 of file TBufferIO.h. ◆ GetGlobalReadParam(). Int_t TBufferIO::GetGlobalReadParam ; (; ). static . Get default read map size. ; Definition at line 572 of file TBufferIO.cxx. ◆ GetGlobalWriteParam(). Int_t TBufferIO::GetGlobalWriteParam ; (; ). static . Get default write map size. ; Definition at line 580 of file TBufferIO.cxx. ◆ GetLastProcessID(). TProcessID * TBufferIO::GetLastProcessID ; (; TRefTable * ; reftable); const. overridevirtual . Return the last TProcessID in the file. ; Implements TBuffer.; Definition at line 399 of file TBufferIO.cxx. ◆ GetMapCount(). Int_t TBufferIO::GetMapCount ; (; ); const. inlineoverridevirtual . Implements TBuffer.; Definition at line 91 of file TBufferIO.h. ◆ GetMappedObject(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:32641,optimiz,optimized,32641,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['optimiz'],['optimized']
Performance,"tatic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; double evaluate () const override;  Dummy evaluate, it is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Update contents of cache histogram by resampling the input function. ;  ; const char * inputBaseName () const override;  Return base name for caches, i.e. the name of the cached function. ;  ; void operModeHook () override;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:49691,cache,cache,49691,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],"['cache', 'cached']"
Performance,"tatic function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:108228,optimiz,optimize,108228,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,3,['optimiz'],['optimize']
Performance,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:26808,cache,cached,26808,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,6,['cache'],['cached']
Performance,"tatic voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:18822,optimiz,optimizeCacheMode,18822,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,12,['optimiz'],['optimizeCacheMode']
Performance,"tatic voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsCategoryLValue::volume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:17956,cache,cache,17956,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,2,['cache'],['cache']
Performance,"tatic voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*specialIntegratorConfig() const; RooNumIntConfig*specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:23639,cache,cache,23639,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['cache'],['cache']
Performance,"tatic void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Return 1 if x is in range, zero otherwise. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRangeBoolean.html:47978,cache,cached,47978,doc/master/classRooRangeBoolean.html,https://root.cern,https://root.cern/doc/master/classRooRangeBoolean.html,2,['cache'],"['cache', 'cached']"
Performance,"tation3D::SetComponents ; (; const ForeignVector & ; v1, . const ForeignVector & ; v2, . const ForeignVector & ; v3 . ). inline . Set components from three orthonormal vectors (which must have methods x(), y() and z()) which will be used as the columns of the rotation matrix. ; The orthonormality will be checked, and values adjusted so that the result will always be a good rotation matrix. ; Definition at line 235 of file Rotation3D.h. ◆ SetComponents() [2/3]. template<class IT > . void ROOT::Math::Rotation3D::SetComponents ; (; IT ; begin, . IT ; end . ). inline . Set the 9 matrix components given an iterator to the start of the desired data, and another to the end (9 past start). ; Definition at line 264 of file Rotation3D.h. ◆ SetComponents() [3/3]. void ROOT::Math::Rotation3D::SetComponents ; (; Scalar ; xx, . Scalar ; xy, . Scalar ; xz, . Scalar ; yx, . Scalar ; yy, . Scalar ; yz, . Scalar ; zx, . Scalar ; zy, . Scalar ; zz . ). inline . Set the components from nine scalars – UNCHECKED for orthonormaility. ; Definition at line 326 of file Rotation3D.h. ◆ SetRotationMatrix(). template<class ForeignMatrix > . void ROOT::Math::Rotation3D::SetRotationMatrix ; (; const ForeignMatrix & ; m). inline . Set components from a linear algebra matrix of size at least 3x3, which must support operator()(i,j) to obtain elements (0,0) thru (2,2). ; Precondition: The matrix is assumed to be orthonormal. NO checking or re-adjusting is performed. ; Definition at line 303 of file Rotation3D.h. Member Data Documentation. ◆ fM. Scalar ROOT::Math::Rotation3D::fM[9]. private . Definition at line 480 of file Rotation3D.h. Libraries for ROOT::Math::Rotation3D:. [legend]; The documentation for this class was generated from the following files:; math/genvector/inc/Math/GenVector/Rotation3D.h; math/genvector/src/Rotation3D.cxx; math/genvector/src/Rotation3DxAxial.cxx. ROOTMathRotation3D. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Rotation3D.html:19589,perform,performed,19589,doc/master/classROOT_1_1Math_1_1Rotation3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Rotation3D.html,1,['perform'],['performed']
Performance,"tation; RooComplex FastComplexErrFunc(const RooComplex& z). Double_t FastComplexErrFuncRe(const RooComplex& z). Double_t FastComplexErrFuncIm(const RooComplex& z). void cacheCERF(Bool_t flag = kTRUE). RooComplex ComplexErrFunc(Double_t re, Double_t im = 0); Return CERNlib complex error function for Z(re,im). RooComplex ComplexErrFunc(const RooComplex& z); Return CERNlib complex error function. This code is translated from the fortran version in the CERN mathlib.; (see ftp://asisftp.cern.ch/cernlib/share/pro/src/mathlib/gen/c/cwerf64.F). void initFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); Allocate and initialize lookup table for interpolated complex error function; for given grid parameters. void cleanup(). RooComplex ITPComplexErrFunc(const RooComplex& z, Int_t nOrder); Return complex error function interpolated from lookup tabel created; by initFastCERF(). Interpolation is performed in Im and Re plane; to specified order. Double_t ITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); Return real component of complex error function interpolated from; lookup table created by initFastCERF(). Interpolation is performed in; Im and Re plane to specified order. This functions is noticably faster; than ITPComplexErrrFunc().re() because only the real lookup table; is interpolated. Double_t ITPComplexErrFuncIm(const RooComplex& z, Int_t nOrder); Return real component of complex error function interpolated from; lookup table created by initFastCERF(). Interpolation is performed in; Im and Re plane to specified order. This functions is noticably faster; than ITPComplexErrrFunc().im() because only the imaginary lookup table; is interpolated. Double_t interpolate(Double_t* yArr, Int_t nOrder, Double_t x); Interpolate array 'ya' with 'n' elements for 'x' (between 0 and 'n'-1). Double_t interpolate(Double_t* xa, Double_t* ya, Int_t n, Double_t x); Interpolate array 'ya' with 'n' elem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMath.html:3608,perform,performed,3608,root/html526/RooMath.html,https://root.cern,https://root.cern/root/html526/RooMath.html,5,['perform'],['performed']
Performance,"tation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Thu Nov 3 20:06:51 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:20688,cache,cache,20688,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,4,['cache'],"['cache', 'cached']"
Performance,"tatistics. Prints a warning and rounds; any bins with non-integer contents. Use the optional parameter to; specify the confidence level in units of sigma to use for; calculating error bars. The nominal bin width specifies the; default used by addAsymmetryBin(), and is used to set the relative; normalization of bins with different widths. If not set, the; nominal bin width is calculated as range/nbins. RooHist(const RooHist& hist1, const RooHist& hist2, Double_t wgt1 = 1., Double_t wgt2 = 1., RooAbsData::ErrorType etype = RooAbsData::Poisson, Double_t xErrorFrac = 1.); Create histogram as sum of two existing histograms. If Poisson errors are selected the histograms are; added and Poisson confidence intervals are calculated for the summed content. If wgt1 and wgt2 are not; 1 in this mode, a warning message is printed. If SumW2 errors are selectd the histograms are added; and the histograms errors are added in quadrature, taking the weights into account. void initialize(); Perform common initialization for all constructors. Double_t getFitRangeNEvt() const; Return the number of events of the dataset associated with this RooHist.; This is the number of events in the RooHist itself, unless a different; value was specified through setRawEntries(). Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Calculate integral of histogram in given range. Double_t getFitRangeBinW() const; Return (average) bin width of this RooHist. Int_t roundBin(Double_t y); Return the nearest positive integer to the input value; and print a warning if an adjustment is required. void addBin(Axis_t binCenter, Double_t n, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the specified integer bin contents; and using an error bar calculated with Poisson statistics. The bin width; is used to set the relative scale of bins with different widths. void addBinWithError(Axis_t binCenter, Double_t n, Double_t elow, Double_t ehigh, Double_t b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHist.html:22850,Perform,Perform,22850,root/html602/RooHist.html,https://root.cern,https://root.cern/root/html602/RooHist.html,2,['Perform'],['Perform']
Performance,"tatus of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check if given RooRealVar maps to a RooRealVar in this dataset. ;  ; void initializeVars (RooArgSet const &vars);  ; virtual void optimizeReadingWithCaching (RooAbsArg &arg, const RooArgSet &cacheList, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:28238,cache,cachedVars,28238,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,2,['cache'],"['cache', 'cachedVars']"
Performance,"tatusremote return status after kPROOF_CHECKFILE; TVirtualMutex*fCloseMutexAvoid crashes in MarkBad or alike while closing; Float_tfCpuTimeCPU time spent by all slaves during the session; TMonitor*fCurrentMonitorcurrently active monitor; TDSet*fDSetcurrent TDSet being validated; Int_tfDrawQueriesnumber of draw queries during this sessions; TList*fEnabledPackagesOnClientlist of packages enabled on client; Bool_tfEndMastertrue for a master in direct contact only with workers; TList*fFeedbacklist of names to be returned as feedback; map<TString,TProof::MD5Mod_t,less<TString>,allocator<pair<const TString,TProof::MD5Mod_t> > >fFileMapmap keeping track of a file's md5 and mod time; Bool_tfFinalizationRunning; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupPROOF group of this user; TList*fInactiveSlaveslist of inactive slaves (good but not used for processing); TList*fInputDataInput data objects sent over via file; TStringfInputDataFileFile with input data objects; TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfIsWaitingtrue if queries have been enqueued; Int_tfLastAssignedMerger; TList*fLoadedMacrosList of loaded macros (just file names); TStringfLogFileNamename of the temp file for redirected logs; FILE*fLogFileRtemp file to read redirected logs; FILE*fLogFileWtemp file to redirect logs; Int_tfLogLevelserver debug logging level; Bool_tfLogToWindowOnlysend log to window only; TStringfMastermaster server ("""" if a master); used in the browser; Int_tfMaxDrawQueriesmax number of draw queries kept; TProofMergePrgfMergePrgMerging progress; TList*fMergers; Int_tfMergersCount; Bool_tfMergersSetIndicates, if the following variables have been initialized properly; TList*fNonUniqueMasterslist of all active masters with a nonunique file system; Int_tfNotIdleNumber of non-idle sub-nodes; Int_tfOtherQueriesnumber of queries in list from previous sessions; TProofOutputListfOutputListTList implementation filtering ls(.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:29446,load,loaded,29446,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['load'],['loaded']
Performance,"tch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction4Binding_double_double_double_double_int_.html:33409,cache,cache,33409,root/html530/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction4Binding_double_double_double_double_int_.html,1,['cache'],['cache']
Performance,"tches. df102_NanoAODDimuonAnalysis.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; Show how NanoAOD files can be processed with RDataFrame. ; This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1125,multi-thread,multi-threading,1125,doc/master/df102__NanoAODDimuonAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html,1,['multi-thread'],['multi-threading']
Performance,"tching(). virtual Bool_t TFileCacheRead::IsEnablePrefetching ; (; ); const. inlinevirtual . Definition at line 101 of file TFileCacheRead.h. ◆ IsLearning(). virtual Bool_t TFileCacheRead::IsLearning ; (; ); const. inlinevirtual . Reimplemented in TTreeCache.; Definition at line 102 of file TFileCacheRead.h. ◆ LearnBranch(). virtual Int_t TFileCacheRead::LearnBranch ; (; TBranch * ; , . Bool_t ; = kFALSE . ). inlinevirtual . Reimplemented in TTreeCache.; Definition at line 103 of file TFileCacheRead.h. ◆ operator=(). TFileCacheRead & TFileCacheRead::operator= ; (; const TFileCacheRead & ; ). privatedelete . ◆ Prefetch(). void TFileCacheRead::Prefetch ; (; Long64_t ; pos, . Int_t ; len . ). virtual . Add block of length len at position pos in the list of blocks to be prefetched. ; If pos <= 0 the current blocks (if any) are reset. ; Definition at line 202 of file TFileCacheRead.cxx. ◆ Print(). void TFileCacheRead::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; The format is: ******TreeCache statistics for file: cms2.root ****** Reading............................: 72761843 bytes in 7 transactions Readahead..........................: 256000 bytes with overhead = 0 bytes Average transaction................: 10394.549000 Kbytes Number of blocks in current cache..: 210, total size: 6280352; If option = ""a"" the list of blocks in the cache is printed NB: this function is automatically called by TTreeCache::Print ; Reimplemented from TObject.; Reimplemented in TTreeCache, and TTreeCacheUnzip.; Definition at line 326 of file TFileCacheRead.cxx. ◆ ReadBuffer(). Int_t TFileCacheRead::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read buffer at position pos. ; If pos is in the list of prefetched blocks read from fBuffer, otherwise need to make a normal read from file. Returns -1 in case of read error, 0 in case not in cache, 1 in case read from cache. ; Reimplemented in TTreeCache.; Definition at line 364 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:21016,cache,cache,21016,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cache']
Performance,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:88473,load,loaded,88473,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['load'],['loaded']
Performance,"td::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute addition of PDFs in batches. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ;  ; AddCacheElem * getProjCache (const RooArgSet *nset, const RooArgSet *iset=nullptr) const;  Manager of cache with coefficient projections and transformations. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Calculate and return the current value. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  The cache manager. ;  ; void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ;  ; void updateCoefficients (AddCacheElem &cache, const RooArgSet *nset, bool syncCoefValues=true) const;  Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:63278,cache,cache,63278,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"td::string & ; clname, . bool ; with_derived = false . ). static . Assign custom class. ; Definition at line 475 of file TWebCanvas.cxx. ◆ AddCustomFonts(). void TWebCanvas::AddCustomFonts ; (; TPadWebSnapshot & ; master). protected . Add special canvas objects with custom fonts. ; Definition at line 614 of file TWebCanvas.cxx. ◆ AddFont(). Font_t TWebCanvas::AddFont ; (; const char * ; name, . const char * ; ttffile, . Int_t ; precision = 2 . ). static . Add font to static list of fonts supported by the canvas Name specifies name of the font, second is font file with .ttf or .woff2 extension Only True Type Fonts (ttf) are supported by PDF Returns font index which can be used in auto font_indx = TWebCanvas::AddFont(""test"", ""test.ttf"", 2); gStyle->SetStatFont(font_indx);. ; Definition at line 228 of file TWebCanvas.cxx. ◆ AddSendQueue(). void TWebCanvas::AddSendQueue ; (; unsigned ; connid, . const std::string & ; msg . ). protected . Add message to send queue for specified connection If connid == 0, message will be add to all connections. ; Definition at line 1187 of file TWebCanvas.cxx. ◆ AssignStatusBits(). void TWebCanvas::AssignStatusBits ; (; UInt_t ; bits). protected . Assign clients bits. ; Definition at line 1472 of file TWebCanvas.cxx. ◆ BatchImageMode(). void TWebCanvas::BatchImageMode ; (; UInt_t ; n = 100). static . Configure batch image mode for web graphics. ; Allows to process many images with single headless browser invocation and increase performance of image production. When many canvases are stored as image in difference places, they first collected in batch and then processed when at least n images are prepared. Only then headless browser invoked and create all these images at once. This allows to significantly increase performance of image production in web mode ; Definition at line 156 of file TWebCanvas.cxx. ◆ CalculateColorsHash(). UInt_t TWebCanvas::CalculateColorsHash ; (; ). protected . Calculate hash function for all colors and palette. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:20585,queue,queue,20585,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['queue'],['queue']
Performance,"td::string subname = path[pos];; 339 int indx = Browsable::RElement::ExtractItemIndex(subname);; 340 ; 341 auto iter = elem->GetChildsIter();; 342 if (!iter); 343 return nullptr;; 344 ; 345 if (!iter->Find(subname, indx)) {; 346 if (indx < 0); 347 return nullptr;; 348 iter = elem->GetChildsIter();; 349 if (!iter || !iter->Find(subname)); 350 return nullptr;; 351 }; 352 ; 353 elem = iter->GetElement();; 354 ; 355 if (!elem); 356 return nullptr;; 357 ; 358 auto subpath = path;; 359 subpath.resize(pos+1);; 360 fCache.emplace_back(subpath, elem);; 361 pos++; // switch to next element; 362 }; 363 ; 364 return elem;; 365}; 366 ; 367/////////////////////////////////////////////////////////////////////////; 368/// Clear internal objects cache; 369 ; 370void RBrowserData::ClearCache(); 371{; 372 fCache.clear();; 373}; 374 ; 375/////////////////////////////////////////////////////////////////////////; 376/// Remove object from cache; 377/// If nullptr specified - removes no-longer-valid elements; 378/// Returns true if any element was removed; 379 ; 380bool RBrowserData::RemoveFromCache(void *obj); 381{; 382 unsigned pos = 0;; 383 ; 384 bool isany = false;; 385 ; 386 while (pos < fCache.size()) {; 387 if (obj ? !fCache[pos].second->IsObject(obj) : fCache[pos].second->CheckValid()) {; 388 pos++;; 389 continue;; 390 }; 391 ; 392 isany = true;; 393 auto path = fCache[pos].first;; 394 fCache.erase(fCache.begin() + pos);; 395 if (RemoveFromCache(path)); 396 pos = 0; // start scan from the beginning; 397 }; 398 ; 399 return isany;; 400}; 401 ; 402/////////////////////////////////////////////////////////////////////////; 403/// Remove path (and all sub-paths) from cache; 404/// Returns true if any element was removed; 405 ; 406bool RBrowserData::RemoveFromCache(const Browsable::RElementPath_t &path); 407{; 408 if (path.size() == 0); 409 return false;; 410 ; 411 bool isany = false;; 412 unsigned pos = 0;; 413 while (pos < fCache.size()) {; 414 if (Browsable::RElement::ComparePaths(pat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:11571,cache,cache,11571,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['cache'],['cache']
Performance,"td::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:41062,cache,cache,41062,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,200,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"td::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:37400,cache,cache,37400,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],['cache']
Performance,"td::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:33866,cache,cache,33866,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,8,['cache'],['cache']
Performance,"te . ! initial window width and height when displayed, zeros are ignored ; Definition at line 166 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 141 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 164 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 165 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 137 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 138 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 156 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 136 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 154 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 168 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 140 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 149 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event proc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:56706,queue,queue,56706,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"te . ! initial window width and height when displayed, zeros are ignored ; Definition at line 169 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 144 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 167 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 168 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 140 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 141 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 159 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 139 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 157 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 171 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 143 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 152 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event proc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:55590,queue,queue,55590,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"te ; (; ). Definition at line 209 of file TClassTable.cxx. ◆ GetImplicitMTPoolSize(). UInt_t ROOT::GetImplicitMTPoolSize ; (; ). Returns the size of the pool used for implicit multi-threading. ; Definition at line 617 of file TROOT.cxx. ◆ GetMacroPath(). TString & ROOT::GetMacroPath ; (; ). Definition at line 523 of file TROOT.cxx. ◆ GetROOT(). TROOT * ROOT::GetROOT ; (; ). Definition at line 519 of file TROOT.cxx. ◆ GetRuleIncludes(). void ROOT::GetRuleIncludes ; (; std::list< std::string > & ; result). Get the list of includes specified in the shema rules. ; Definition at line 829 of file RConversionRuleParser.cxx. ◆ HasValidDataMembers(). Bool_t ROOT::HasValidDataMembers ; (; SchemaRuleMap_t & ; rule, . MembersTypeMap_t & ; members, . std::string & ; error_string . ). Check if given rule contains references to valid data members. ; Definition at line 435 of file RConversionRuleParser.cxx. ◆ IsImplicitMTEnabled(). bool ROOT::IsImplicitMTEnabled ; (; ). Returns true if the implicit multi-threading in ROOT is enabled. ; Definition at line 610 of file TROOT.cxx. ◆ MakeSeq() [1/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; begin, . T ; end, . T ; step = 1 . ). Definition at line 206 of file TSeq.hxx. ◆ MakeSeq() [2/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; end). Definition at line 200 of file TSeq.hxx. ◆ ParseRule(). Bool_t ROOT::ParseRule ; (; std::string ; rule, . ROOT::Internal::MembersMap_t & ; result, . std::string & ; error_string . ). Parse the schema rule as specified in the LinkDef file. ; Definition at line 91 of file RConversionRuleParser.cxx. ◆ ProcessReadPragma(). void ROOT::ProcessReadPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called when a read pragma is encountered. ; Definition at line 873 of file RConversionRuleParser.cxx. ◆ ProcessReadRawPragma(). void ROOT::ProcessReadRawPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called then a readraw pragma is enco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:24781,multi-thread,multi-threading,24781,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"te ; (; ). Definition at line 209 of file TClassTable.cxx. ◆ GetImplicitMTPoolSize(). UInt_t ROOT::GetImplicitMTPoolSize ; (; ). Returns the size of the pool used for implicit multi-threading. ; Definition at line 618 of file TROOT.cxx. ◆ GetMacroPath(). TString & ROOT::GetMacroPath ; (; ). Definition at line 524 of file TROOT.cxx. ◆ GetROOT(). TROOT * ROOT::GetROOT ; (; ). Definition at line 520 of file TROOT.cxx. ◆ GetRuleIncludes(). void ROOT::GetRuleIncludes ; (; std::list< std::string > & ; result). Get the list of includes specified in the shema rules. ; Definition at line 841 of file RConversionRuleParser.cxx. ◆ HasValidDataMembers(). Bool_t ROOT::HasValidDataMembers ; (; SchemaRuleMap_t & ; rule, . MembersTypeMap_t & ; members, . std::string & ; error_string . ). Check if given rule contains references to valid data members. ; Definition at line 447 of file RConversionRuleParser.cxx. ◆ IsImplicitMTEnabled(). bool ROOT::IsImplicitMTEnabled ; (; ). Returns true if the implicit multi-threading in ROOT is enabled. ; Definition at line 611 of file TROOT.cxx. ◆ MakeSeq() [1/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; begin, . T ; end, . T ; step = 1 . ). Definition at line 206 of file TSeq.hxx. ◆ MakeSeq() [2/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; end). Definition at line 200 of file TSeq.hxx. ◆ ParseRule(). Bool_t ROOT::ParseRule ; (; std::string ; rule, . ROOT::Internal::MembersMap_t & ; result, . std::string & ; error_string . ). Parse the schema rule as specified in the LinkDef file. ; Definition at line 103 of file RConversionRuleParser.cxx. ◆ ProcessReadPragma(). void ROOT::ProcessReadPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called when a read pragma is encountered. ; Definition at line 885 of file RConversionRuleParser.cxx. ◆ ProcessReadRawPragma(). void ROOT::ProcessReadRawPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called then a readraw pragma is enc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:24873,multi-thread,multi-threading,24873,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"te Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. More...;  ; class  RooMoment;  ; class  RooMsgService;  Singleton class that organizes messages generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given conf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:13544,cache,cache,13544,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['cache'],['cache']
Performance,"te `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this class; 6209 // and we are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end up in a situation where the library and thus; 6229 // the dictionary is loaded for ""cls"" but the TClass is; 6230 // not created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:240925,load,load,240925,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,3,['load'],['load']
Performance,"te a new block or recycle an old one. ;  ; char * GetBlockFromCache (const char *, Int_t);  Return a buffer from cache. ;  ; std::condition_variable & GetCondNewBlock ();  ; TFPBlock * GetPendingBlock ();  Safe method to remove a block from the pendingList. ;  ; TThread * GetThread () const;  Return reference to the consumer thread. ;  ; Long64_t GetWaitTime ();  Return the time spent wating for buffer to be read in microseconds. ;  ; TClass * IsA () const override;  ; Bool_t IsPrefetchFinished () const;  ; void ReadAsync (TFPBlock *, Bool_t &);  Read one block and insert it in prefetchBuffers list. ;  ; void ReadBlock (Long64_t *, Int_t *, Int_t);  Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t);  Return a prefetched element. ;  ; void ReadListOfBlocks ();  Get blocks specified in prefetchBlocks. ;  ; void SaveBlockInCache (TFPBlock *);  Save the block content in cache. ;  ; Bool_t SetCache (const char *);  Set the path of the cache directory. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect);  Change the file. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t SumHex (const char *);  Sum up individual hex values to obtain a decimal value. ;  ; Int_t ThreadStart ();  Used to start the consumer thread. ;  ; void WaitFinishPrefetch ();  Killing the async prefetching thread. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:2528,cache,cache,2528,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['cache'],['cache']
Performance,"te all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:43296,cache,cache,43296,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,2,['cache'],['cache']
Performance,te contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:38298,cache,cache,38298,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,te contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_norm,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:38728,cache,cache,38728,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,te contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; TH2*_callHist! Histogram recording number of calls per convolution integral calculation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'Always,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvolution.html:37652,cache,cache,37652,root/html602/RooNumConvolution.html,https://root.cern,https://root.cern/root/html602/RooNumConvolution.html,4,['cache'],['cache']
Performance,"te that this file may contain any kind of ROOT objects, histograms,; 30# pictures, graphics objects, detector geometries, tracks, events, etc..; 31# This file is now becoming the current directory.; 32 ; 33hfile = gROOT.FindObject( 'py-hsimple.root' ); 34if hfile:; 35 hfile.Close(); 36hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); 37 ; 38# Create some histograms, a profile histogram and an ntuple; 39hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); 40hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); 41hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); 42ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); 43 ; 44# Set canvas/frame attributes.; 45hpx.SetFillColor( 48 ); 46 ; 47gBenchmark.Start( 'hsimple' ); 48 ; 49# Initialize random number generator.; 50gRandom.SetSeed(); 51rannor, rndm = gRandom.Rannor, gRandom.Rndm; 52 ; 53# For speed, bind and cache the Fill member functions,; 54histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; 55for name in histos:; 56 exec('%sFill = %s.Fill' % (name,name)); 57 ; 58# Fill histograms randomly.; 59px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); 60kUPDATE = 1000; 61for i in range( 25000 ):; 62 # Generate random values. Use ctypes to pass doubles by reference; 63 rannor( px_ref, py_ref ); 64 # Retrieve the generated values; 65 px = px_ref.value; 66 py = py_ref.value; 67 ; 68 pz = px*px + py*py; 69 random = rndm(1); 70 ; 71 # Fill histograms.; 72 hpx.Fill( px ); 73 hpxpy.Fill( px, py ); 74 hprof.Fill( px, pz ); 75 ntuple.Fill( px, py, pz, random, i ); 76 ; 77 # Update display every kUPDATE events.; 78 if i and i%kUPDATE == 0:; 79 if i == kUPDATE:; 80 hpx.Draw(); 81 ; 82 c1.Modified(); 83 c1.Update(); 84 ; 85 if gSystem.ProcessEvents(): # allow user interrupt; 86 break; 87 ; 88# Destroy member functions cache.; 89for name in histos:; 90 exec('del %sFill' % name); 91del histos; 92 ; 93gBenchmark.Show( 'hsimple' ); 94 ; 95# Save all object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py_source.html:1989,cache,cache,1989,doc/master/hsimple_8py_source.html,https://root.cern,https://root.cern/doc/master/hsimple_8py_source.html,1,['cache'],['cache']
Performance,"te the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The accumulation of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasUpdates;  The accumulation of the square of the past bias updates associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The accumulation of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightUpdates;  The accumulation of the square of the past weight updates associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor2;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Adadelta.h>. Inheritance diagram for TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:3648,optimiz,optimizer,3648,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['optimiz'],['optimizer']
Performance,"te the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:84820,cache,cache,84820,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"te(TProof::ESlaves list = kActive); Transfer the current state of the master to the active slave servers.; The current state includes: the current working directory, etc.; Returns the number of active slaves. Returns -1 in case of error. Int_t SendInitialState(); Transfer the initial (i.e. current) state of the master to all; slave servers. Currently the initial state includes: log level.; Returns the number of active slaves. Returns -1 in case of error. Bool_t CheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); Check if a file needs to be send to the slave. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; The options 'cpopt' define if to copy things from cache to sandbox and what.; To retrieve from the cache the binaries associated with the file TProof::kCpBin; must be set in cpopt; the default is copy everything.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); Send a file to master or slave servers. Returns number of slaves; the file was sent to, maybe 0 in case master and slaves have the same; file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:55761,cache,cache,55761,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['cache'],['cache']
Performance,"te(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(const char* name, Double_t min, Double_t max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Tex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:28613,cache,cache,28613,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,6,['cache'],['cache']
Performance,"te-Analysis classes.; See:. The TMVA Web manual in ROOT Web site; The TMVA Users Guide. Old links, referring to old TMVA versions, but they can still be useful for some of the TMVA methods:. Description of the traditional TMVA Methods; The TMVA Options Reference. . Classes; class  TMVA::AbsoluteDeviationLossFunction;  Absolute Deviation Loss Function. More...;  ; class  TMVA::AbsoluteDeviationLossFunctionBDT;  Absolute Deviation BDT Loss Function. More...;  ; class  TMVA::BDTEventWrapper;  ; class  TMVA::BinarySearchTree;  A simple Binary search tree including a volume search method. More...;  ; class  TMVA::BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  TMVA::BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  TMVA::CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  TMVA::CCTreeWrapper;  ; class  Classification;  Class to perform two class classification. More...;  ; class  ClassificationResult;  Class to save the results of the classifier. More...;  ; class  TMVA::ClassifierFactory;  This is the MVA factory. More...;  ; class  TMVA::ClassInfo;  Class that contains all the information of a class. More...;  ; class  TMVA::Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  TMVA::ConvergenceTest;  Check for convergence. More...;  ; class  TMVA::CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CreateMethodPlugins;  Plugins analysis. More...;  ; class  TMVA::CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  TMVA::CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  TMVA::CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TMVA.html:1189,perform,perform,1189,doc/master/group__TMVA.html,https://root.cern,https://root.cern/doc/master/group__TMVA.html,1,['perform'],['perform']
Performance,"te: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105330,Load,Load,1105330,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,"te:. TFileCacheWrite&operator=(const TFileCacheWrite&); TFileCacheWrite(const TFileCacheWrite&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:6558,cache,cached,6558,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,8,['cache'],"['cache', 'cached']"
Performance,"te; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooMinimizer*_minimizer! Internal minuit instance; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:35262,cache,cache,35262,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"te; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TUrlfEndpointUrlURL of realfile (after possible redirection); Int_tfErrorCodeerror code returned by rootd (matching gRootdErrStr); TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:21434,cache,cache,21434,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"te; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPluginManager.html:10075,Load,LoadHandlersFromPluginDirs,10075,root/html602/TPluginManager.html,https://root.cern,https://root.cern/root/html602/TPluginManager.html,4,['Load'],"['Load', 'LoadHandlersFromPluginDirs']"
Performance,"te; };. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoScale & operator=(const TGeoScale& other); Assignment operator. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScale.html:15411,perform,perform,15411,root/html534/TGeoScale.html,https://root.cern,https://root.cern/root/html534/TGeoScale.html,2,['perform'],['perform']
Performance,"teCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create and return a derived MorphCacheElem. ; Reimplemented from RooAbsCachedPdf.; Definition at line 210 of file RooIntegralMorph.cxx. ◆ DeclFileName(). static const char * RooIntegralMorph::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 110 of file RooIntegralMorph.h. ◆ evaluate(). double RooIntegralMorph::evaluate ; (; ); const. overrideprotectedvirtual . Dummy. ; Implements RooAbsReal.; Definition at line 656 of file RooIntegralMorph.cxx. ◆ fillCacheObject(). void RooIntegralMorph::fillCacheObject ; (; PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache with the interpolated shape. ; Implements RooAbsCachedPdf.; Definition at line 178 of file RooIntegralMorph.cxx. ◆ inputBaseName(). const char * RooIntegralMorph::inputBaseName ; (; ); const. overrideprotectedvirtual . Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ; Implements RooAbsCachedPdf.; Definition at line 165 of file RooIntegralMorph.cxx. ◆ IsA(). TClass * RooIntegralMorph::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 110 of file RooIntegralMorph.h. ◆ preferredObservableScanOrder(). void RooIntegralMorph::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. overridevirtual . Indicate to the RooAbsCachedPdf base class that for the filling of the cache the traversal of the x should be in the innermost loop, to minimize recalculation of the one-dimensional internal cache for a fixed value of alpha. ; Reimplemented from RooAbsReal.; Definition at line 666 of file RooIntegralMorph.cxx. ◆ selfNormalized(). bool RooIntegralMorph::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:84318,cache,cache,84318,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"teCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:2341,Cache,CacheModeRooAbsArg,2341,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"teDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 346 of file RooCompositeDataStore.cxx. ◆ attachBuffers(). void RooCompositeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 435 of file RooCompositeDataStore.cxx. ◆ attachCache(). void RooCompositeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprotectedvirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 411 of file RooCompositeDataStore.cxx. ◆ cacheArgs(). void RooCompositeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 384 of file RooCompositeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooCompositeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 94 of file RooCompositeDataStore.h. ◆ changeObservableName(). bool RooCompositeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 290 of file RooCompositeDataStore.cxx. ◆ Class(). static TClass * RooCompositeDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCompositeDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCompositeDataStore::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 127 of file RooCompositeDataStore.h. ◆ clone() [1/2]. RooAbsDataStore * RooCompositeDataStore::clone ; (; const char * ; newname = nullptr);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:22686,cache,cacheOwner,22686,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['cache'],['cacheOwner']
Performance,"teKey (TDirectory *mother, const void *obj, const TClass *cl, const char *name, Int_t bufsize);  Creates key for object and converts data to buffer. ;  ; void Delete (const char *namecycle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:5323,cache,cache,5323,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['cache'],['cache']
Performance,"teKey (TDirectory *mother, const void *obj, const TClass *cl, const char *name, Int_t bufsize);  Creates key for object and converts data to buffer. ;  ; void Delete (const char *namecycle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:3877,cache,cache,3877,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['cache'],['cache']
Performance,"teNLL(); 975 *; 976 * <tr><th><th> Options to control flow of fit procedure; 977 * <tr><td> `Minimizer(""<type>"", ""<algo>"")` <td> Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface,; 978 * but others can be specified (through RooMinimizer interface).; 979 * <table>; 980 * <tr><th> Type <th> Algorithm; 981 * <tr><td> Minuit <td> migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); 982 * <tr><td> Minuit2 <td> migrad, simplex, minimize, scan; 983 * <tr><td> GSLMultiMin <td> conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; 984 * <tr><td> GSLSimAn <td> -; 985 * </table>; 986 *; 987 * <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 988 * <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization of test statistic during minimization (on by default); 989 * <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 990 * <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, off by default; 991 * <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 992 * <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 993 * <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 to 2, default is 1); 994 * <tr><td> `MaxCalls(int n)` <td> Change maximum number of likelihood function calls from MINUIT (if `n <= 0`, the default of 500 * #%parameters is used); 995 * <tr><td> `EvalErrorWall(bool flag=true)` <td> When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter; 996 * to force it out of that region. This can, however, mean that the fitter gets lost in this region. If; 997 * this happens, try switching it off.; 998 * <tr><td> `RecoverFromUndefinedRegions(double strength)` <td> When PDF is invalid (e.g. parameter in undefined r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:45887,optimiz,optimization,45887,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"teSequence, Int_t index, TCompInfo *compinfo);; 132 ; 133public:; 134 ; 135 /// Status bits; 136 /// See TVirtualStreamerInfo::EStatusBits for the values.; 137 ; 138 /// EReadWrite Enumerator; 139 /// See TVirtualStreamerInfo::EReadWrite for documentation and values.; 140 ; 141 TStreamerInfo();; 142 TStreamerInfo(TClass *cl);; 143 ~TStreamerInfo() override;; 144 void Build(Bool_t isTransient = kFALSE) override;; 145 void BuildCheck(TFile *file = nullptr, Bool_t load = kTRUE) override;; 146 void BuildEmulated(TFile *file) override;; 147 void BuildOld() override;; 148 Bool_t BuildFor( const TClass *cl ) override;; 149 void CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const override;; 150 void Clear(Option_t * = """") override;; 151 TObject *Clone(const char *newname = """") const override;; 152 Bool_t CompareContent(TClass *cl,TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) override;; 153 void Compile() override;; 154 void ComputeSize();; 155 void ForceWriteInfo(TFile *file, Bool_t force = kFALSE) override;; 156 Int_t GenerateHeaderFile(const char *dirname, const TList *subClasses = nullptr, const TList *extrainfos = nullptr) override;; 157 TClass *GetActualClass(const void *obj) const override;; 158 TClass *GetClass() const override { return fClass; }; 159 UInt_t GetCheckSum() const override { return fCheckSum; }; 160 UInt_t GetCheckSum(TClass::ECheckSum code) const;; 161 Int_t GetClassVersion() const override { return fClassVersion; }; 162 Int_t GetDataMemberOffset(TDataMember *dm, TMemberStreamer *&streamer) const;; 163 TObjArray *GetElements() const override {return fElements;}; 164 TStreamerElement *GetElem(Int_t id) const override { return fComp[id].fElem; } // Return the element for the list of optimized elements (max GetNdata()); 165 TStreamerElement *GetElement(Int_t id) const override {return (TStreamerElement*)fElements->At(id);} // Return the element for the complete list of elements (max GetElements()->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:6925,load,load,6925,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['load'],['load']
Performance,"teTClassprivate; fStreamerTClassprivate; fStreamerFuncTClassprivate; fStreamerImplTClassmutableprivate; fStreamerInfoTClassmutableprivate; fStreamerTypeTClassprivate; fTitleTNamedprotected; fTypeInfoTClassprivate; fUniqueIDTObjectprivate; fUpdatingTransactionCountTDictionaryprivate; fUsingDataTClassprivate; fVersionUsedTClassmutableprivate; GetActualClass(const void *object) constTClass; GetAttributeMap() constTDictionaryinline; GetBaseClass(const char *classname)TClass; GetBaseClass(const TClass *base)TClass; GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)TClass; GetBaseClassOffsetRecurse(const TClass *toBase)TClassprivate; GetBaseDataMember(const char *datamember)TClass; GetCheckSum(ECheckSum code=kCurrentCheckSum) constTClass; GetCheckSum(Bool_t &isvalid) constTClass; GetCheckSum(ECheckSum code, Bool_t &isvalid) constTClass; GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size)TClassstatic; GetClass(const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0)TClassstatic; GetClass(ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(DeclId_t id, std::vector< TClass * > &classes)TClassstatic; GetClassInfo() constTClassinline; GetClassMethod(Longptr_t faddr)TClassprivate; GetClassMethod(const char *name, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetClassSize() constTClassinline; GetClassVersion() constTClassinline; GetCollectionProxy() constTClass; GetCollectionType() constTClass; GetContextMenuTitle() constTClassinline; GetConversionStreamerInfo(const char *onfile_classname, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:7160,load,load,7160,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"tected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:1231,perform,performance,1231,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['perform'],['performance']
Performance,"tected Member Functions inherited from TDataSetManager; virtual TMap * GetGroupUsedMap ();  ; Int_t GetNDisapparedFiles () const;  ; Int_t GetNOpenedFiles () const;  ; Int_t GetNTouchedFiles () const;  ; void GetQuota (const char *group, const char *user, const char *dsName, TFileCollection *dataset);  Gets quota information from this dataset. ;  ; virtual TMap * GetUserUsedMap ();  ; void PrintDataSet (TFileCollection *fc, Int_t popt=0);  Formatted printout of the content of TFileCollection 'fc'. ;  ; void PrintUsedSpace ();  Prints the quota. ;  ; Bool_t ReadGroupConfig (const char *cf=0);  Read group config file 'cf'. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; Int_t CheckLocalCache (const char *group, const char *user, const char *dsName=""ls"", UInt_t option=0);  Check if the local cache information for group, user, dsName is up-to-date If not, make the relevant updates Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. ;  ; void InitLocalCache ();  Init the local cache if required. ;  . Private Attributes; Int_t fCacheUpdatePeriod;  ; TString fDataSetDir;  ; TString fDataSetLockFile;  ; Bool_t fIsRemote;  ; TString fListFile;  ; TString fLocalCacheDir;  ; Int_t fLockFileTimeLimit;  ; TString fMSSUrl;  ; Bool_t fOpenPerms;  ; TString fStageOpts;  ; Bool_t fUseCache;  . Additional Inherited Members;  Public Types inherited from TDataSetManager; enum  EDataSetStatusBits { ;   kCheckQuota = (1ULL << ( 15 )); , kAllowRegister = (1ULL << ( 16 )); , kAllowVerify = (1ULL << ( 17 )); , kTrustInfo = (1ULL << ( 18 )); , ;   kIsSandbox = (1ULL << ( 19 )); , kUseCache = (1ULL << ( 20 )); , kDoNotUseCache = (1ULL << ( 21 )). };  ; enum  EDataSetWorkOpts { ;   kDebug = 0x1; , kShowDefault = 0x2; , kPrint = 0x4; , kExport = 0x8; , ;   kQuotaUpdate = 0x10; , kSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:17444,cache,cache,17444,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['cache'],['cache']
Performance,"tected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPullVar.html:32429,cache,cache,32429,root/html534/RooPullVar.html,https://root.cern,https://root.cern/root/html534/RooPullVar.html,13,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:34297,cache,cache,34297,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,26,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"tected; fPluginManagerTROOTprotected; fPrimitiveTROOTprotected; fProofsTROOTprotected; FromPopUp() constTROOTinline; fRootFolderTROOTprotected; fSecContextsTROOTprotected; fSelectPadTROOTprotected; fSocketsTROOTprotected; fSpecialsTROOTprotected; fSpinLockTDirectorymutableprotected; fStreamerInfoTROOTprotected; fStylesTROOTprotected; fTasksTROOTprotected; fTimerTROOTprotected; fTitleTNamedprotected; fTypesTROOTprotected; fUniqueIDTObjectprivate; fUUIDTDirectoryprotected; fUUIDsTROOTprotected; fVersionTROOTprotected; fVersionCodeTROOTprotected; fVersionDateTROOTprotected; fVersionIntTROOTprotected; fVersionTimeTROOTprotected; FwdDeclArgsToKeepCollection_t typedefTROOT; fWebDisplayTROOTprotected; Get(const char *namecycle)TDirectoryvirtual; Get(const char *namecycle)TDirectoryinline; GetApplication() constTROOTinline; GetBinDir()TROOTstatic; GetBufferSize() constTDirectoryinlinevirtual; GetBuiltDate() constTROOTinline; GetBuiltTime() constTROOTinline; GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constTROOT; GetClass(const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) constTROOT; GetClipboard() constTROOTinline; GetColor(Int_t color) constTROOT; GetConfigFeatures() constTROOTinline; GetConfigOptions() constTROOTinline; GetCutClassName() constTROOTinline; GetDataDir()TROOTstatic; GetDefCanvasName() constTROOTinline; GetDirectory(const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:6245,load,load,6245,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"tectedvirtual . Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; Reimplemented from RooAbsReal.; Definition at line 621 of file RooAddModel.cxx. ◆ selfNormalized(). bool RooAddModel::selfNormalized ; (; ); const. inlineoverridevirtual . Model is self normalized when used as p.d.f. ; Reimplemented from RooAbsPdf.; Definition at line 52 of file RooAddModel.h. ◆ Streamer(). void RooAddModel::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooAddModel::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 131 of file RooAddModel.h. ◆ updateCoefficients(). void RooAddModel::updateCoefficients ; (; AddCacheElem & ; cache, . const RooArgSet * ; nset . ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the current use context. ; Definition at line 333 of file RooAddModel.cxx. Friends And Related Symbol Documentation. ◆ RooAddGenContext. friend class RooAddGenContext. friend . Definition at line 89 of file RooAddModel.h. Member Data Documentation. ◆ _allExtendable. bool RooAddModel::_allExtendable = false. protected . Flag indicating if all PDF components are extendable. ; Definition at line 123 of file RooAddModel.h. ◆ _codeReg. RooAICRegistry RooAddModel::_codeReg = 10. mutableprotected . ! Registry of component analytical integration codes ; Definition at line 116 of file RooAddModel.h. ◆ _coefCache. std::vector<double> RooAddModel::_coefCache. mutableprotected . ! Transient cache with transformed values of coefficients ; Definition at line 99 of file RooAddModel.h. ◆ _coefErrCount. Int_t RooAddModel::_coefErrCount. mutableprotected . ! Coefficient error counter ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:90656,cache,cache,90656,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"ted . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:55363,cache,cache,55363,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,ted . viewport (GL coords - origin bottom left) ; Definition at line 105 of file TGLCamera.h. ◆ fInterestFrustum. TGLBoundingBox TGLCamera::fInterestFrustum. private . previous interest box (DEBUG) ; Definition at line 62 of file TGLCamera.h. ◆ fInterestFrustumAsBox. TGLBoundingBox TGLCamera::fInterestFrustumAsBox. private . frustum basis of current interest box - NOT a true BB! (DEBUG) ; Definition at line 63 of file TGLCamera.h. ◆ fLargestSeen. Double_t TGLCamera::fLargestSeen. mutableprotected . the interest box - created in UpdateInterest() ; Definition at line 106 of file TGLCamera.h. ◆ fLastNoPickProjM. TGLMatrix TGLCamera::fLastNoPickProjM. mutableprotected . timestamp ; Definition at line 97 of file TGLCamera.h. ◆ fModVM. TGLMatrix TGLCamera::fModVM. mutableprotected . projection matrix (cached) ; Definition at line 99 of file TGLCamera.h. ◆ fNearClip. Double_t TGLCamera::fNearClip. mutableprotected . current camera center ; Definition at line 86 of file TGLCamera.h. ◆ fPreviousInterestBox. TGLBoundingBox TGLCamera::fPreviousInterestBox. private . Definition at line 61 of file TGLCamera.h. ◆ fProjM. TGLMatrix TGLCamera::fProjM. mutableprotected . no-pick projection matrix (cached) ; Definition at line 98 of file TGLCamera.h. ◆ fTimeStamp. UInt_t TGLCamera::fTimeStamp. mutableprotected . cached items dirty? ; Definition at line 96 of file TGLCamera.h. ◆ fVAxisMinAngle. Float_t TGLCamera::fVAxisMinAngle. protected . Definition at line 92 of file TGLCamera.h. ◆ fViewport. TGLRect TGLCamera::fViewport. protected . frustum planes (cached) ; Definition at line 103 of file TGLCamera.h. ◆ fWasArcBalled. Bool_t TGLCamera::fWasArcBalled. protected . Definition at line 80 of file TGLCamera.h. Libraries for TGLCamera:. [legend]; The documentation for this class was generated from the following files:; graf3d/gl/inc/TGLCamera.h; graf3d/gl/src/TGLCamera.cxx. TGLCamera. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:19 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:44353,cache,cached,44353,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,3,['cache'],['cached']
Performance,"ted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayI; Int_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3I.html:56864,perform,performing,56864,doc/master/classTH3I.html,https://root.cern,https://root.cern/doc/master/classTH3I.html,2,['perform'],['performing']
Performance,ted Attributes; TGRadioButton * fAdd;  set addition mode ;  ; TGCheckButton * fAdd2FuncList;  switch on/off option 'add to list' ;  ; TGCheckButton * fAllWeights1;  switch on/off option 'all weights=1' ;  ; TGCheckButton * fBestErrors;  switch on/off option 'improve errors' ;  ; Bool_t fChangedParams;  ; TGTextButton * fCloseButton;  close the fit panel ;  ; TGRadioButton * fConv;  set convolution mode ;  ; TF1Convolution * fConvFunc;  ! TF1Convolution object ;  ; TGComboBox * fDataSet;  contains list of data set to be fitted ;  ; Int_t fDim;  object dimension ;  ; TGTextButton * fDrawAdvanced;  opens a dialog for advanced draw options ;  ; TGCheckButton * fDrawSame;  switch on/off fit function drawing ;  ; TGCheckButton * fEmptyBinsWghts1;  switch on/off option 'include empry bins' ;  ; TGCheckButton * fEnableRobust;  switch on/off robust option ;  ; TGTextEntry * fEnteredFunc;  contains user function file name ;  ; TGNumberEntryField * fErrorScale;  ; TGTextButton * fFitButton;  performs fitting ;  ; TObject * fFitObject;  selected object to fit ;  ; TGComboBox * fFuncList;  contains function list ;  ; std::vector< FuncParamData_t > fFuncPars;  ; TGCompositeFrame * fGeneral;  general tab ;  ; TGCheckButton * fImproveResults;  switch on/off option 'improve fit results' ;  ; TGCheckButton * fIntegral;  switch on/off option 'integral' ;  ; TGNumberEntryField * fIterations;  ; TGLayoutHints * fLayoutAdd;  layout hints of fAdd radio button ;  ; TGLayoutHints * fLayoutConv;  layout hints of fConv radio button ;  ; TGLayoutHints * fLayoutNone;  layout hints of fNone radio button ;  ; TGLayoutHints * fLayoutNormAdd;  layout hints of fNOrmAdd radio button ;  ; TGRadioButton * fLibFumili;  ; TGRadioButton * fLibGenetics;  ; TGRadioButton * fLibGSL;  ; TGRadioButton * fLibMinuit;  ; TGRadioButton * fLibMinuit2;  ; TGCheckButton * fLinearFit;  switch on/off linear fit option ;  ; TGComboBox * fMethodList;  contains method list ;  ; TGCompositeFrame * fMinimization;  minimizati,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:40201,perform,performs,40201,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['perform'],['performs']
Performance,"ted Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:41962,cache,cache,41962,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,10,['cache'],['cache']
Performance,"ted R package for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTree, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  RRangeCast;  Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:2362,queue,queue,2362,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['queue'],['queue']
Performance,"ted by the function ReadPictureDataFromFile. void SetDashes(GContext_t gc, Int_t offset, const char* dash_list, Int_t n); Sets the dash-offset and dash-list attributes for dashed line styles; in the specified GC. There must be at least one element in the; specified dash_list. The initial and alternating elements (second,; fourth, and so on) of the dash_list are the even dashes, and the; others are the odd dashes. Each element in the ""dash_list"" array; specifies the length (in pixels) of a segment of the pattern. gc - specifies the GC (see GCValues_t structure); offset - the phase of the pattern for the dashed line-style you; want to set for the specified GC.; dash_list - the dash-list for the dashed line-style you want to set; for the specified GC; n - the number of elements in dash_list; (see also the GCValues_t structure). void FreeColor(Colormap_t cmap, ULong_t pixel); Frees color cell with specified pixel value. Int_t EventsPending(); Returns the number of events that have been received from the X server; but have not been removed from the event queue. void Bell(Int_t percent); Sets the sound bell. Percent is loudness from -100% .. 100%. void CopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); Combines the specified rectangle of ""src"" with the specified rectangle; of ""dest"" according to the ""gc"". src_x, src_y - specify the x and y coordinates, which are relative; to the origin of the source rectangle and specify; upper-left corner.; width, height - the width and height, which are the dimensions of both; the source and destination rectangles; dest_x, dest_y - specify the upper-left corner of the destination; rectangle. GC components in use: function, plane-mask, subwindow-mode,; graphics-exposure, clip-x-origin, clip-y-origin, and clip-mask.; (see also the GCValues_t structure). void ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); Changes the attributes of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:45137,queue,queue,45137,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,10,['queue'],['queue']
Performance,"ted from TGraph.; Definition at line 510 of file TGraphErrors.cxx. ◆ CopyPoints(). Bool_t TGraphErrors::CopyPoints ; (; Double_t ** ; arrays, . Int_t ; ibegin, . Int_t ; iend, . Int_t ; obegin . ). overrideprotectedvirtual . Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ; Reimplemented from TGraph.; Definition at line 532 of file TGraphErrors.cxx. ◆ CtorAllocate(). Bool_t TGraphErrors::CtorAllocate ; (; ). protected . Constructor allocate. ; Note: This function should be called only from the constructor since it does not delete previously existing arrays. ; Definition at line 557 of file TGraphErrors.cxx. ◆ DeclFileName(). static const char * TGraphErrors::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGraphErrors.h. ◆ DoMerge(). Bool_t TGraphErrors::DoMerge ; (; const TGraph * ; g). overrideprotectedvirtual . Protected function to perform the merge operation of a graph with errors. ; Reimplemented from TGraph.; Definition at line 573 of file TGraphErrors.cxx. ◆ FillZero(). void TGraphErrors::FillZero ; (; Int_t ; begin, . Int_t ; end, . Bool_t ; from_ctor = kTRUE . ). overrideprotectedvirtual . Set zero values for point arrays in the range [begin, end]. ; Reimplemented from TGraph.; Definition at line 598 of file TGraphErrors.cxx. ◆ GetErrorX(). Double_t TGraphErrors::GetErrorX ; (; Int_t ; bin); const. overridevirtual . It returns the error along X at point i. ; Reimplemented from TGraph.; Definition at line 612 of file TGraphErrors.cxx. ◆ GetErrorXhigh(). Double_t TGraphErrors::GetErrorXhigh ; (; Int_t ; i); const. overridevirtual . It returns the error along X at point i. ; For TGraphErrors this method is the same as GetErrorX. ; Reimplemented from TGraph.; Definition at line 635 of file TGraphErrors.cxx. ◆ GetErrorXlow(). Double_t TGraphErrors::GetErrorXlow ; (; Int_t ; i); const. overridevirtual . It returns the error al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:41124,perform,perform,41124,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['perform'],['perform']
Performance,"ted from TObject.; Definition at line 68 of file TTreeFormulaManager.h. ◆ operator=(). TTreeFormulaManager & TTreeFormulaManager::operator= ; (; const TTreeFormulaManager & ; ). privatedelete . ◆ Remove(). void TTreeFormulaManager::Remove ; (; TTreeFormula * ; adding). virtual . Remove a formula from this manager. ; Definition at line 61 of file TTreeFormulaManager.cxx. ◆ Streamer(). void TTreeFormulaManager::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TTreeFormulaManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TTreeFormulaManager.h. ◆ Sync(). bool TTreeFormulaManager::Sync ; (; ). virtual . Synchronize all the formulae. ; Definition at line 219 of file TTreeFormulaManager.cxx. ◆ UpdateFormulaLeaves(). void TTreeFormulaManager::UpdateFormulaLeaves ; (; ). virtual . This function could be called TTreePlayer::UpdateFormulaLeaves, itself called by TChain::LoadTree when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreePlayer. ; Definition at line 291 of file TTreeFormulaManager.cxx. ◆ UpdateUsedSize(). void TTreeFormulaManager::UpdateUsedSize ; (; Int_t & ; virt_dim, . Int_t ; vsize . ). protectedvirtual . Reload the array sizes. ; Definition at line 308 of file TTreeFormulaManager.cxx. Friends And Related Symbol Documentation. ◆ TTreeFormula. friend class TTreeFormula. friend . Definition at line 47 of file TTreeFormulaManager.h. Member Data Documentation. ◆ fCumulUsedSizes. Int_t TTreeFormulaManager::fCumulUsedSizes[kMAXFORMDIM+1]. private . Accumulated size of lower dimensions as seen for this entry. ; Definition at line 38 of file TTreeFormulaManager.h. ◆ fCumulUsedVarDims. TArrayI* TTreeFormulaManager::fCumulUsedVarDims. private . fCumulUsedSizes(1) for multi variable dimensions case ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormulaManager.html:16620,load,loaded,16620,doc/master/classTTreeFormulaManager.html,https://root.cern,https://root.cern/doc/master/classTTreeFormulaManager.html,1,['load'],['loaded']
Performance,"ted from TProof.; Definition at line 2195 of file TProofLite.cxx. ◆ Class(). static TClass * TProofLite::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofLite::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofLite::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 170 of file TProofLite.h. ◆ CleanupSandbox(). Int_t TProofLite::CleanupSandbox ; (; ). private . Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10) ; Definition at line 1821 of file TProofLite.cxx. ◆ ClearCache(). void TProofLite::ClearCache ; (; const char * ; file = 0). overridevirtual . Remove files from all file caches. ; Reimplemented from TProof.; Definition at line 1519 of file TProofLite.cxx. ◆ ClearDataSetCache(). void TProofLite::ClearDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2282 of file TProofLite.cxx. ◆ CopyMacroToCache(). Int_t TProofLite::CopyMacroToCache ; (; const char * ; macro, . Int_t ; headerRequired = 0, . TSelector ** ; selector = 0, . Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ; If headerRequired is 1, return -1 in case the header is not found. If headerRequired is 0, try to copy header too. If headerRequired is -1, don't look for header, only copy macro. If the selector pionter is not 0, consider the macro to be a selector and try to load the selector and set it to the pointer. The mask 'opt' is an or of ESendFileOpt: kCpBin (0x8) Retrieve from the cache the binaries associated with the file kCp (0x10) Retrieve the files from the cache Return -1 in case of error, 0 otherwise. ; Definition at line 1593 of file TProofLite.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:49133,cache,cache,49133,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"ted in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierachy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:99924,load,loading,99924,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['load'],['loading']
Performance,ted objects. param[in] nset The set of variables to normalize over. param[in] syncCoefValues If the initial values of the coefficients still need to be copied from the _coefList elements to the _coefCache. True by default. ; Definition at line 442 of file RooAddPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddGenContext. friend class RooAddGenContext. friend . Definition at line 115 of file RooAddPdf.h. ◆ RooAddModel. friend class RooAddModel. friend . Definition at line 116 of file RooAddPdf.h. Member Data Documentation. ◆ _allExtendable. bool RooAddPdf::_allExtendable = false. protected . Flag indicating if all PDF components are extendable. ; Definition at line 136 of file RooAddPdf.h. ◆ _codeReg. RooAICRegistry RooAddPdf::_codeReg. mutableprotected . ! Registry of component analytical integration codes ; Definition at line 129 of file RooAddPdf.h. ◆ _coefCache. std::vector<double> RooAddPdf::_coefCache. mutableprotected . ! Transient cache with transformed values of coefficients ; Definition at line 107 of file RooAddPdf.h. ◆ _coefErrCount. Int_t RooAddPdf::_coefErrCount. mutableprotected . ! Coefficient error counter ; Definition at line 139 of file RooAddPdf.h. ◆ _coefList. RooListProxy RooAddPdf::_coefList. protected . List of coefficients. ; Definition at line 132 of file RooAddPdf.h. ◆ _copyOfLastNormSet. std::unique_ptr<const RooArgSet> RooAddPdf::_copyOfLastNormSet = nullptr. mutableprivate . ! ; Definition at line 146 of file RooAddPdf.h. ◆ _haveLastCoef. bool RooAddPdf::_haveLastCoef = false. protected . Flag indicating if last PDFs coefficient was supplied in the constructor. ; Definition at line 135 of file RooAddPdf.h. ◆ _idOfLastUsedNormSet. RooFit::UniqueId<RooArgSet>::Value_t RooAddPdf::_idOfLastUsedNormSet = RooFit::UniqueId<RooArgSet>::nullval. mutableprivate . ! ; Definition at line 145 of file RooAddPdf.h. ◆ _pdfList. RooListProxy RooAddPdf::_pdfList. protected . List of component PDFs. ; Definition at line 131 of file RooAddPdf.h. ◆,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:96781,cache,cache,96781,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"ted. void UnHighlighted(); Virtual method TEveElement::UnHighlighted. TString GetHighlightTooltip(). void FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); Populate set impSelSet with derived / dependant elements. void PrintCellsSelected(); Print selected cells info. void ProcessSelection(TEveCaloData::vCellId_t& sel_cells, TGLSelectRecord& rec); Process newly selected cells with given select-record.; Secondary-select status is set.; CellSelectionChanged() is called if needed. void SetSliceThreshold(Int_t slice, Float_t threshold); Set threshold for given slice. Float_t GetSliceThreshold(Int_t slice) const; Get threshold for given slice. void SetSliceColor(Int_t slice, Color_t col); Set color for given slice. Color_t GetSliceColor(Int_t slice) const; Get color for given slice. void SetSliceTransparency(Int_t slice, Char_t t); Set transparency for given slice. Char_t GetSliceTransparency(Int_t slice) const; Get transparency for given slice. void InvalidateUsersCellIdCache(); Invalidate cell ids cache on back ptr references. void DataChanged(); Tell users (TEveCaloViz instances using this data) that data; has changed and they should update the limits/scales etc.; This is done by calling TEveCaloViz::DataChanged(). void CellSelectionChanged(); Tell users (TEveCaloViz instances using this data) that cell selection; has changed and they should update selection cache if necessary.; This is done by calling TEveCaloViz::CellSelectionChanged(). Float_t EtaToTheta(Float_t eta). TEveCaloData& operator=(const TEveCaloData& ). virtual ~TEveCaloData(); {}. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; { return fCellsSelected; }. vCellId_t& GetCellsHighlighted(); { return fCellsHighlighted; }. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const. Int_t GetNSlices(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloData.html:21230,cache,cache,21230,root/html528/TEveCaloData.html,https://root.cern,https://root.cern/root/html528/TEveCaloData.html,6,['cache'],['cache']
Performance,"ted. void UnHighlighted(); Virtual method TEveElement::UnHighlighted. TString GetHighlightTooltip(). void FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); Populate set impSelSet with derived / dependant elements. void PrintCellsSelected(); Print selected cells info. void ProcessSelection(TEveCaloData::vCellId_t& sel_cells, TGLSelectRecord& rec); Process newly selected cells with given select-record.; Secondary-select status is set.; CellSelectionChanged() is called if needed. void SetSliceThreshold(Int_t slice, Float_t threshold); Set threshold for given slice. Float_t GetSliceThreshold(Int_t slice) const; Get threshold for given slice. void SetSliceColor(Int_t slice, Color_t col); Set color for given slice. Color_t GetSliceColor(Int_t slice) const; Get color for given slice. void SetSliceTransparency(Int_t slice, Char_t t); Set transparency for given slice. Char_t GetSliceTransparency(Int_t slice) const; Get transparency for given slice. void InvalidateUsersCellIdCache(); Invalidate cell ids cache on back ptr references. void DataChanged(); Tell users (TEveCaloViz instances using this data) that data; has changed and they should update the limits/scales etc.; This is done by calling TEveCaloViz::DataChanged(). void CellSelectionChanged(); Tell users (TEveCaloViz instances using this data) that cell selection; has changed and they should update selection cache if necessary.; This is done by calling TEveCaloViz::CellSelectionChanged(). Float_t EtaToTheta(Float_t eta). TEveCaloData(const TEveCaloData& ). TEveCaloData& operator=(const TEveCaloData& ). virtual ~TEveCaloData(); {}. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; { return fCellsSelected; }. vCellId_t& GetCellsHighlighted(); { return fCellsHighlighted; }. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloData.html:22319,cache,cache,22319,root/html602/TEveCaloData.html,https://root.cern,https://root.cern/root/html602/TEveCaloData.html,4,['cache'],['cache']
Performance,"ted:. Long_tfColCountnumber of columns in current line; TGTextLine*fCurrentcurrent line; Long_tfCurrentRowcurrent row number; TStringfFilenamename of opened file ("""" if open buffer); TGTextLine*fFirstfirst line of text; Bool_tfIsSavedfalse if text needs to be saved; Long_tfLongestLinelength of longest line; Long_tfRowCountnumber of rows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGText(const TGText& ); copy constructor. TGText& operator=(const TGText& ); assignment operator. void Init(); Common initialization method. TGText(); Create default (empty) text buffer. TGText(TGText* text); Create text buffer and initialize with other text buffer. TGText(const char* string); Create text buffer and initialize with single line string. ~TGText(); Destroy text buffer. void Clear(); Clear text buffer. Bool_t Load(const char* fn, Long_t startpos = 0, Long_t length = -1); Load text from file fn. Startpos is the begin from where to; load the file and length is the number of characters to read; from the file. Bool_t LoadBuffer(const char* txtbuf); Load a 0 terminated buffer. Lines will be split at '\n'. Bool_t Save(const char* fn); Save text buffer to file fn. Bool_t Append(const char* fn); Append buffer to file fn. Bool_t DelChar(TGLongPosition pos); Delete character at specified position pos. Bool_t InsChar(TGLongPosition pos, char c); Insert character c at the specified position pos. char GetChar(TGLongPosition pos); Get character a position pos. If charcater not valid return -1. Bool_t DelText(TGLongPosition start, TGLongPosition end); Delete text between start and end positions. Returns false in; case of failure (start and end not being within bounds). Bool_t InsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); Insert src text from start_src to end_src into text at position ins_pos.; Returns false in case of failure (start_src, end_src out of range for; src, and ins_pos out of range for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGText.html:3086,load,load,3086,root/html528/TGText.html,https://root.cern,https://root.cern/root/html528/TGText.html,10,['load'],['load']
Performance,"ted:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:38208,cache,cache,38208,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,12,['cache'],"['cache', 'caches']"
Performance,"ted:. static RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::MPMaster; static RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::SimMaster; static RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::Slave; stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_t_extendedIs the input function and extended p.d.f.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:37282,cache,cache,37282,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,20,['cache'],"['cache', 'cached', 'caches']"
Performance,"ted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfArrXArrow X position; Double_tfArrYArrow Y position; Agedge_t*fGVEdgeGraphviz edge; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_t*fNnumber of edge points (GV); TGraphNode*fNode1First node; TGraphNode*fNode2Second node; Double_t*fXX edge points (GV); Double_t*fYX edge points (GV). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphEdge(); Graph Edge default constructor. TGraphEdge(TGraphNode* n1, TGraphNode* n2); Graph Edge normal constructor. ~TGraphEdge(); Graph Edge default destructor. void CreateGVEdge(Agraph_t* gv); Create the GraphViz edge into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an edge. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this edge in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this edge with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& , const char* ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& b). TGraphEdge(). void SetGVEdge(Agedge_t* gve); {fGVEdge = gve;}. Agedge_t * GetGVEdge(); {return fGVEdge;}. TGraphNode * GetNode1(); {return fNode1;}. TGraphNode * GetNode2(); {return fNode2;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TGraphEdge.h 30204 2009-09-16 14:55:06Z couet $ » Last generated: 2010-12-08 11:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphEdge.html:6945,perform,performed,6945,root/html528/TGraphEdge.html,https://root.cern,https://root.cern/root/html528/TGraphEdge.html,1,['perform'],['performed']
Performance,"ted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfArrXArrow X position; Double_tfArrYArrow Y position; Agedge_t*fGVEdgeGraphviz edge; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_t*fNnumber of edge points (GV); TGraphNode*fNode1First node; TGraphNode*fNode2Second node; Double_t*fXX edge points (GV); Double_t*fYX edge points (GV). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphEdge(); Graph Edge default constructor. TGraphEdge(TGraphNode* n1, TGraphNode* n2); Graph Edge normal constructor. ~TGraphEdge(); Graph Edge default destructor. void CreateGVEdge(Agraph_t* gv); Create the GraphViz edge into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an edge. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this edge in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this edge with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& , const char* ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& b). TGraphEdge(). void SetGVEdge(Agedge_t* gve); {fGVEdge = gve;}. Agedge_t * GetGVEdge(); {return fGVEdge;}. TGraphNode * GetNode1(); {return fNode1;}. TGraphNode * GetNode2(); {return fNode2;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TGraphEdge.h 30204 2009-09-16 14:55:06Z couet $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphEdge.html:7045,perform,performed,7045,root/html530/TGraphEdge.html,https://root.cern,https://root.cern/root/html530/TGraphEdge.html,1,['perform'],['performed']
Performance,"ted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfArrXArrow X position; Double_tfArrYArrow Y position; Agedge_t*fGVEdgeGraphviz edge; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_t*fNnumber of edge points (GV); TGraphNode*fNode1First node; TGraphNode*fNode2Second node; Double_t*fXX edge points (GV); Double_t*fYX edge points (GV). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphEdge(); Graph Edge default constructor. TGraphEdge(TGraphNode* n1, TGraphNode* n2); Graph Edge normal constructor. ~TGraphEdge(); Graph Edge default destructor. void CreateGVEdge(Agraph_t* gv); Create the GraphViz edge into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an edge. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this edge in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this edge with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& , const char* ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& b). TGraphEdge(). void SetGVEdge(Agedge_t* gve); {fGVEdge = gve;}. Agedge_t * GetGVEdge(); {return fGVEdge;}. TGraphNode * GetNode1(); {return fNode1;}. TGraphNode * GetNode2(); {return fNode2;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TGraphEdge.h 30204 2009-09-16 14:55:06Z couet $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphEdge.html:7045,perform,performed,7045,root/html532/TGraphEdge.html,https://root.cern,https://root.cern/root/html532/TGraphEdge.html,2,['perform'],['performed']
Performance,"teed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot, e.g. a different element of a list. See here for an example usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other. On many-core architectures it might be desirable to run different event loops concurrently t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:47313,concurren,concurrently,47313,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrently']
Performance,"tegory::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMappedCategory.html:18522,optimiz,optimizeDirtyHook,18522,root/html534/RooMappedCategory.html,https://root.cern,https://root.cern/root/html534/RooMappedCategory.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"tegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:2999,cache,cacheUniqueSuffix,2999,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,1,['cache'],['cacheUniqueSuffix']
Performance,"tegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* oth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:2999,cache,cacheUniqueSuffix,2999,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tegralMorph() [3/3]. RooIntegralMorph::RooIntegralMorph ; (; const RooIntegralMorph & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 119 of file RooIntegralMorph.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Observable to be cached for given choice of normalization. ; Returns the 'x' observable unless doCacheAlpha is set in which case a set with both x and alpha ; Implements RooAbsCachedPdf.; Definition at line 134 of file RooIntegralMorph.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Parameters of the cache. ; Returns parameters of both pdf1 and pdf2 and parameter cache, in case doCacheAlpha is not set. ; Implements RooAbsCachedPdf.; Definition at line 148 of file RooIntegralMorph.cxx. ◆ cacheAlpha(). bool RooIntegralMorph::cacheAlpha ; (; ); const. inline . Definition at line 45 of file RooIntegralMorph.h. ◆ Class(). static TClass * RooIntegralMorph::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooIntegralMorph::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooIntegralMorph::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 110 of file RooIntegralMorph.h. ◆ clone(). TObject * RooIntegralMorph::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 35 of file RooIntegralMorph.h. ◆ createCache(). RooAbsCachedPdf::PdfCacheElem * RooIntegralMorph::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create and return a derived MorphCacheElem. ; Reimplemented from RooAbsCachedPdf.; Definition at line 210 of file RooIntegralMorph.cxx. ◆ DeclFileName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:82561,cache,cacheAlpha,82561,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cacheAlpha']
Performance,"tegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useWindowSwitch to activate window convolution; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Int_t_verboseThreshCall count ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:35484,cache,cache,35484,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['cache'],['cache']
Performance,"tegrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExtendedTerm.html:38977,cache,cache,38977,root/html530/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html530/RooExtendedTerm.html,1,['cache'],['cache']
Performance,"tegration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:40061,cache,cache,40061,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"tegration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:37981,cache,cache,37981,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"tegy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:12398,cache,cachesz,12398,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,1,['cache'],['cachesz']
Performance,"tem.cxx. ◆ GetHostByName(). TInetAddress TSystem::GetHostByName ; (; const char * ; server). virtual . Get Internet Protocol (IP) address of host. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2291 of file TSystem.cxx. ◆ GetIncludePath(). const char * TSystem::GetIncludePath ; (; ). virtual . Get the list of include path. ; Definition at line 3973 of file TSystem.cxx. ◆ GetLastErrorString() [1/2]. TString & TSystem::GetLastErrorString ; (; ). protected . Return the thread local storage for the custom last error message. ; Definition at line 2102 of file TSystem.cxx. ◆ GetLastErrorString() [2/2]. const TString & TSystem::GetLastErrorString ; (; ); const. protected . Return the thread local storage for the custom last error message. ; Definition at line 2111 of file TSystem.cxx. ◆ GetLibraries(). const char * TSystem::GetLibraries ; (; const char * ; regexp = """", . const char * ; options = """", . Bool_t ; isRegexp = kTRUE . ). virtual . Return a space separated list of loaded shared libraries. ; Regexp is a wildcard expression, see TRegexp::MakeWildcard. This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of:; S: shared libraries loaded at the start of the executable, because they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; L: this option is ignored, and available for backward compatibility. . Reimplemented in TWinNTSystem.; Definition at line 2136 of file TSystem.cxx. ◆ GetLinkdefSuffix(). const char * TSystem::GetLinkdefSuffix ; (; ); const. virtual . Return the linkdef suffix chosen by the user for ACLiC. ; See TSystem::CompileMacro for more details. ; Definition at line 4001 of file TSystem.cxx. ◆ GetLinkedLibraries(). const char * TSystem::GetLinkedLibraries ; (; ). protectedvirtual . Get list of shared libraries loaded at the start of the executable. ; Returns 0 in case list cannot be obtained or in case of error. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:61374,load,loaded,61374,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"temTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21876,perform,perform,21876,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"tempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4258 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding to the whole standard list. Once the customizable version is done, one can remove or add elements. ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:103282,load,loading,103282,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loading']
Performance,"tempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4325 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding to the whole standard list. Once the customizable version is done, one can remove or add elements. ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:103283,load,loading,103283,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loading']
Performance,"tems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendedBinding&operator=(const RooExtendedBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedBinding.html:19152,optimiz,optimizeCacheMode,19152,root/html602/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html602/RooExtendedBinding.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ter an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TString _bname;  Name of the binning specification to be used to perform the mapping. ;  ; RooTemplateProxy< RooAbsRealLValue > _inputVar;  Input variable that is mapped. ;  ;  Protected Attributes inherited from RooAbsCategory; value_type _currentIndex {std::numeric_limits<int>::min()};  Current category state. ;  ; std::vector< std::string > _insertionOrder;  Keeps track in which order state numbers have been inserted. Make sure this is updated in recomputeShape(). ;  ; std::map< value_type, std::unique_ptr< RooCatType, std::function< void(RooCatType *)> > > _legacyStates;  ! Map holding pointers to RooCatType instances. Only for legacy interface. Don't use if possible. ;  ; std::map< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:39828,perform,perform,39828,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,1,['perform'],['perform']
Performance,"ter can be used as a speed optimization if one or more of the PDF have sizable regions with very small values, which would pull the entire product of PDFs to zero in those regions.; After each PDF multiplication, the running product is compared with the cutOff parameter. If the running product is smaller than the cutOff value, the product series is terminated and remaining PDFs are not evaluated.; There is no magic value of the cutOff, the user should experiment to find the appropriate balance between speed and precision. If a cutoff is specified, the PDFs most likely to be small should be put first in the product. The default cutOff value is zero. ; Definition at line 108 of file RooProdPdf.cxx. ◆ RooProdPdf() [3/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . const RooArgList & ; inPdfList, . double ; cutOff = 0.0 . ). Constructor from a list of PDFs. ; The optional cutOff parameter can be used as a speed optimization if one or more of the PDF have sizable regions with very small values, which would pull the entire product of PDFs to zero in those regions.; After each PDF multiplication, the running product is compared with the cutOff parameter. If the running product is smaller than the cutOff value, the product series is terminated and remaining PDFs are not evaluated.; There is no magic value of the cutOff, the user should experiment to find the appropriate balance between speed and precision. If a cutoff is specified, the PDFs most likely to be small should be put first in the product. The default cutOff value is zero. ; Definition at line 157 of file RooProdPdf.cxx. ◆ RooProdPdf() [4/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; fullPdfSet, . const RooLinkedList & ; cmdArgList . ). Internal constructor from list of named arguments. ; Definition at line 250 of file RooProdPdf.cxx. ◆ RooProdPdf() [5/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:81742,optimiz,optimization,81742,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['optimiz'],['optimization']
Performance,"ter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be crossed; 79 TGeoNode *fForcedNode; //! current point is supposed to be inside this node; 80 TGeoCacheState *fBackupState; //! backup state; 81 TGeoHMatrix *fCurrentMatrix; //! current stored global matrix; 82 TGeoHMatrix *fGlobalMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Bool_t CheckPath(const char *path) const;; 96 void CdNode(Int_t nodeid);; 97 void CdDown(Int_t index);; 98 void CdDown(TGeoNode *node);; 99 void CdUp();; 100 void CdTop();; 101 void CdNext();; 102 void GetBranchNames(Int_t *names) const;; 103 void GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:4209,cache,cached,4209,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cached']
Performance,"ter range information stored in 'fromtree' to this tree, including the value of fAuto...Definition TTree.cxx:6372; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::fEstimateLong64_t fEstimateNumber of entries to estimate histogram limits.Definition TTree.h:102; TTree::FlushBasketsImplInt_t FlushBasketsImpl() constInternal implementation of the FlushBaskets algorithm.Definition TTree.cxx:5146; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fTreeIndexTVirtualIndex * fTreeIndexPointer to the tree Index (if any)Definition TTree.h:129; TTree::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TTree.cxx:9714; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::BranchImpvirtual TBranch * BranchImp(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch() with added check that addobj matches className.Definition TTree.cxx:1554; TTree::fCacheSizeLong64_t fCacheSize! Maximum size of file buffersDefinition TTree.h:105; TTree::fClonesTList * fClones! List of cloned trees which share our addressesDefinition TTree.h:135; TTree::fTotalBuffersstd::atomic< Long64_t > fTotalBuffers! Total number of bytes in branch buffersDefinition TTree.h:108; TTree::Classstatic TClass * Class(); TTree::kFindBranch@ kFindBranchDefinition TTree.h:212; TTree::kFindLeaf@ kFindLeafDefinition TTree.h:213; TTree::kGetEntryWithIndex@ kGetEntryWithIndexDefinition TTree.h:217; TTree::kPrint@ kPrintDefinition TTree.h:222; TTree::kGetFriend@ kGetFriendDefinition TTree.h:218; TTree::kGetBranch@ kGetBranchDefinition TTree.h:215; TTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:458522,load,loading,458522,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loading']
Performance,"ter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:999848,perform,performed,999848,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performed']
Performance,"ter than the GetAtSlotUnchecked method but the caller is responsible to make sure that the slot exists, to check that the contained object is initialized and that the returned pointer will not outlive the TThreadedObject that returned it, which maintains ownership of the actual object. ; Definition at line 260 of file TThreadedObject.hxx. ◆ GetAtSlotUnchecked(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlotUnchecked ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to a single thread. ; This is in general faster than the GetAtSlot method but it is responsibility of the caller to make sure that the slot exists and to check that the contained object is initialized (and not a nullptr). ; Definition at line 249 of file TThreadedObject.hxx. ◆ GetNSlots(). template<class T > . unsigned ROOT::TThreadedObject< T >::GetNSlots ; (; ); const. inline . Return the number of currently available slot. ; The method is safe to call concurrently to other TThreadedObject methods. Note that slots could be available but contain no data (i.e. a nullptr) if they have not been used yet. ; Definition at line 191 of file TThreadedObject.hxx. ◆ GetThisSlotNumber(). template<class T > . unsigned ROOT::TThreadedObject< T >::GetThisSlotNumber ; (; ). inlineprivate . Get the slot number for this threadID, make a slot if needed. ; Definition at line 338 of file TThreadedObject.hxx. ◆ Merge(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::Merge ; (; TThreadedObjectUtils::MergeFunctionType< T > ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called once: it does not create any new object but destroys the present bookkeping collapsing all objects into the one at slot 0. ; Definition at line 294 of file TThreadedObject.hxx. ◆ operator->(). template<class T > . T * ROOT::TThreadedObject< T >::operator-> ; (; ). inline . Access the wrapped object and a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:7321,concurren,concurrently,7321,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['concurren'],['concurrently']
Performance,"ter this cache in its list of caches. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void wireCache ();  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; RooAbsArg * _owner;  Pointer to owning RooAbsArg. ;  . #include <RooAbsCache.h>. Inheritance diagram for RooAbsCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsCache() [1/2]. RooAbsCache::RooAbsCache ; (; RooAbsArg * ; owner = nullptr). Constructor. Takes owner as argument and register cache with owner. ; Definition at line 39 of file RooAbsCache.cxx. ◆ RooAbsCache() [2/2]. RooAbsCache::RooAbsCache ; (; const RooAbsCache & ; , . RooAbsArg * ; owner = nullptr . ). Copy constructor. Takes owner as argument and registers cache with owne. ; Definition at line 50 of file RooAbsCache.cxx. ◆ ~RooAbsCache(). RooAbsCache::~RooAbsCache ; (; ). virtual . Destructor. Unregisters cache with owner. ; Definition at line 61 of file RooAbsCache.cxx. Member Function Documentation. ◆ Class(). static TClass * RooAbsCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 63 of file RooAbsCache.h. ◆ DeclFileName(). static const char * RooAbsCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooAbsCache.h. ◆ findConstantNodes(). virtual void RooAbsCache::findConstantNodes ; (; const RooArgSet & ; , . RooArgSet & ; , . RooLinkedList & ;  . ). inlinevirtual . Interfa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCache.html:2760,cache,cache,2760,doc/master/classRooAbsCache.html,https://root.cern,https://root.cern/doc/master/classRooAbsCache.html,1,['cache'],['cache']
Performance,ter to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlis,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataWeightedAverage.html:33235,cache,cache,33235,root/html526/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html526/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,ter to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSetRooAbsOptTestStatistic::_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStat,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataWeightedAverage.html:34127,cache,cache,34127,root/html530/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html530/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,ter to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataWeightedAverage.html:33502,cache,cache,33502,root/html528/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html528/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,"ter to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4599 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4709 of file TClass.cxx. ◆ GetStreamerInfoImpl(). TVirtualStreamerInfo * TClass::GetStreamerInfoImpl ; (; Int_t ; version, . Bool_t ; silent . ); const. private . Definition at line 4634 of file TClass.cxx. ◆ GetStreamerInfos(). const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:92479,load,loaded,92479,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loaded']
Performance,"ter to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4666 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4776 of file TClass.cxx. ◆ GetStreamerInfoImpl(). TVirtualStreamerInfo * TClass::GetStreamerInfoImpl ; (; Int_t ; version, . Bool_t ; silent . ); const. private . Definition at line 4701 of file TClass.cxx. ◆ GetStreamerInfos(). const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:92480,load,loaded,92480,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loaded']
Performance,"ter which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:9835,optimiz,optimized,9835,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,3,['optimiz'],['optimized']
Performance,ter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_flatSFInt; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:39281,cache,cache,39281,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,1,['cache'],['cache']
Performance,ter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_flatSFInt; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:39663,cache,cache,39663,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,4,['cache'],['cache']
Performance,ter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:39028,cache,cache,39028,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,ter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedPdf.html:39475,cache,cache,39475,root/html528/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedPdf.html,10,['cache'],['cache']
Performance,"ter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:32193,cache,cache,32193,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cache']
Performance,"ter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 927will never receive the same slot at the same time.; 928This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 929processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 930 ; 931### Parallel execution of multiple RDataFrame event loops; 932A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:53764,concurren,concurrently,53764,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"ter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 967will never receive the same slot at the same time.; 968This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 969processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 970 ; 971### Parallel execution of multiple RDataFrame event loops; 972A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:55404,concurren,concurrently,55404,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"ter. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooAddition Class ReferenceRooFit » RooFit Core. ; Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. ; Definition at line 27 of file RooAddition.h. Classes; class  CacheElem;  . Public Member Functions;  RooAddition ();  ;  RooAddition (const char *name, const char *title, const RooArgList &sumSet);  Constructor with a single set consisting of RooAbsReal. ;  ;  RooAddition (const char *name, const char *title, const RooArgList &sumSet1, const RooArgList &sumSet2);  Constructor with two sets of RooAbsReals. ;  ;  RooAddition (const RooAddition &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Calculate integral internally from appropriate integral cache. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Retrieve bin boundaries if this distribution is binned in obs. ;  ; TObject * clone (const char *newname) const override;  ; double defaultErrorLevel () const override;  Return the default error level for MINUIT error analysis If the addition contains one or more RooNLLVars and no RooChi2Vars, return the defaultErrorLevel() of RooNLLVar. ;  ; void doEval (RooFit::EvalContext &) const override;  Compute addition of PDFs in batches. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &numVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:1124,cache,cache,1124,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['cache'],['cache']
Performance,"ter::Execute(...). ; Definition at line 342 of file TMethodCall.cxx. ◆ IsA(). TClass * TMethodCall::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 128 of file TMethodCall.h. ◆ IsValid(). Bool_t TMethodCall::IsValid ; (; ); const. Return true if the method call has been properly initialized and is usable. ; Definition at line 376 of file TMethodCall.cxx. ◆ operator=(). TMethodCall & TMethodCall::operator= ; (; const TMethodCall & ; rhs). Assignment operator. ; Definition at line 107 of file TMethodCall.cxx. ◆ ResetParam(). void TMethodCall::ResetParam ; (; ). Reset parameter list. To be used before the first call the SetParam(). ; Definition at line 597 of file TMethodCall.cxx. ◆ ReturnType(). TMethodCall::EReturnType TMethodCall::ReturnType ; (; ). Returns the return type of the method. ; Either (unsigned) long, int, short and char, or float and double or anything else. Since finding the return type is expensive the result is cached. ; Definition at line 565 of file TMethodCall.cxx. ◆ SetParam() [1/5]. void TMethodCall::SetParam ; (; Double_t ; d). Add a double method parameter. ; Definition at line 624 of file TMethodCall.cxx. ◆ SetParam() [2/5]. void TMethodCall::SetParam ; (; Float_t ; f). Add a double method parameter. ; Definition at line 615 of file TMethodCall.cxx. ◆ SetParam() [3/5]. void TMethodCall::SetParam ; (; Long64_t ; ll). Add a long long method parameter. ; Definition at line 633 of file TMethodCall.cxx. ◆ SetParam() [4/5]. void TMethodCall::SetParam ; (; Long_t ; l). Add a long method parameter. ; Definition at line 606 of file TMethodCall.cxx. ◆ SetParam() [5/5]. void TMethodCall::SetParam ; (; ULong64_t ; ull). Add a unsigned long long method parameter. ; Definition at line 642 of file TMethodCall.cxx. ◆ SetParamPtrs(). void TMethodCall::SetParamPtrs ; (; void * ; paramArr, . Int_t ; nparam = -1 . ). Set pointers to parameters. ; Parameters. paramArran array cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:27744,cache,cached,27744,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['cache'],['cached']
Performance,"ter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:71; writerDefinition writer.py:1. Definition at line 161 of file RNTupleWriter.hxx. ◆ EnableMetrics(). void ROOT::Experimental::RNTupleWriter::EnableMetrics ; (; ). inline . Definition at line 137 of file RNTupleWriter.hxx. ◆ Fill() [1/2]. std::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; ). inline . The simplest user interface if the default entry that comes with the ntuple model is used. ; ReturnsThe number of uncompressed bytes written. ; Definition at line 105 of file RNTupleWriter.hxx. ◆ Fill() [2/2]. std::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; REntry & ; entry). inline . Multiple entries can have been instantiated from the ntuple model. ; This method will perform a light check whether the entry comes from the ntuple's own model. ReturnsThe number of uncompressed bytes written. ; Definition at line 109 of file RNTupleWriter.hxx. ◆ FillNoFlush(). void ROOT::Experimental::RNTupleWriter::FillNoFlush ; (; REntry & ; entry, . RNTupleFillStatus & ; status . ). inline . Fill an entry into this ntuple, but don't commit the cluster. ; The calling code must pass an RNTupleFillStatus and check RNTupleFillStatus::ShouldFlushCluster. ; Definition at line 112 of file RNTupleWriter.hxx. ◆ FlushCluster(). void ROOT::Experimental::RNTupleWriter::FlushCluster ; (; ). inline . Flush so far filled entries to storage. ; Definition at line 117 of file RNTupleWriter.hxx. ◆ FlushColumns(). void ROOT::Experimental::RNTupleWriter::FlushColumns ; (; ). inline . Flush column data, preparing for CommitCluster or to reduce memory usage. ; This will trigger compression of pages, but not actually write to storage (unless buffered writing is turned off). ; Definition at line 115 of file RNTupleWr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:8534,perform,perform,8534,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['perform'],['perform']
Performance,"terIndex, . RSealedPage & ; sealedPage . ). pure virtual . Read the packed and compressed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ operator=() [1/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; const RPageSource & ; ). delete . ◆ operator=() [2/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; RPageSource && ; ). delete . ◆ PrepareLoadCluster(). void ROOT::Experimental::Internal::RPageSource::PrepareLoadCluster ; (; const RCluster::RKey & ; clusterKey, . ROnDiskPageMap & ; pageZeroMap, . std::function< void(DescriptorId_t, NTupleSize_t, const RClusterDescriptor::RPageRange::RPageInfo &)> ; perPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:17395,load,loading,17395,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['load'],['loading']
Performance,"terIterator (TTree *tree, Long64_t firstEntry);  Regular constructor. ;  . Private Member Functions; Long64_t GetEstimatedClusterSize ();  Estimate the cluster size. ;  . Private Attributes; Int_t fClusterRange;  ; Long64_t fEstimatedSize;  ; Long64_t fNextEntry;  ; Long64_t fStartEntry;  ; TTree * fTree;  . Friends; class TTree;  . #include <TTree.h>; Constructor & Destructor Documentation. ◆ TClusterIterator(). TTree::TClusterIterator::TClusterIterator ; (; TTree * ; tree, . Long64_t ; firstEntry . ). protected . Regular constructor. ; TTree is not set as const, since we might modify if it is a TChain. ; Definition at line 560 of file TTree.cxx. Member Function Documentation. ◆ GetEstimatedClusterSize(). Long64_t TTree::TClusterIterator::GetEstimatedClusterSize ; (; ). private . Estimate the cluster size. ; In almost all cases, this quickly returns the size of the auto-flush in the TTree.; However, in the case where the cluster size was not fixed (old files and case where autoflush was explicitly set to zero), we need estimate a cluster size in relation to the size of the cache.; After this value is calculated once for the TClusterIterator, it is cached and reused in future calls. ; Definition at line 611 of file TTree.cxx. ◆ GetNextEntry(). Long64_t TTree::TClusterIterator::GetNextEntry ; (; ). inline . Definition at line 307 of file TTree.h. ◆ GetStartEntry(). Long64_t TTree::TClusterIterator::GetStartEntry ; (; ). inline . Definition at line 302 of file TTree.h. ◆ Next(). Long64_t TTree::TClusterIterator::Next ; (; ). Move on to the next cluster and return the starting entry of this next cluster. ; Definition at line 650 of file TTree.cxx. ◆ operator()(). Long64_t TTree::TClusterIterator::operator() ; (; ). inline . Definition at line 311 of file TTree.h. ◆ Previous(). Long64_t TTree::TClusterIterator::Previous ; (; ). Move on to the previous cluster and return the starting entry of this previous cluster. ; Definition at line 694 of file TTree.cxx. Friends And ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree_1_1TClusterIterator.html:1883,cache,cache,1883,doc/master/classTTree_1_1TClusterIterator.html,https://root.cern,https://root.cern/doc/master/classTTree_1_1TClusterIterator.html,1,['cache'],['cache']
Performance,"terMissing(""y""); df_valid_col_y = df.FilterMissing(""x""); display_x = df_valid_col_x.Display((""x"",)); display_y = df_valid_col_y.Display((""y"",)); // Assume a dataset made of two files vertically chained together, one has; // column ""x"" and the other has column ""y""; ROOT.RDataFrame df{dataset};; auto df_valid_col_x = df.FilterMissing(""y"");; auto df_valid_col_y = df.FilterMissing(""x"");; auto display_x = df_valid_col_x.Display<int>({""x""});; auto display_y = df_valid_col_y.Display<int>({""y""});; NoteSee FilterAvailable() if you want to discard the entries in case there is a missing value instead. ; Definition at line 388 of file RInterface.hxx. ◆ Foreach(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::Foreach ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:76229,perform,performing,76229,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performing']
Performance,"terProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsMoment.h>. Inheritance diagram for RooAbsMoment:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsMoment() [1/3]. RooAbsMoment::RooAbsMoment ; (; ). default . ◆ RooAbsMoment() [2/3]. RooAbsMoment::RooAbsMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . Int_t ; order = 1, . bool ; takeRoot = false . ). Definition at line 35 of file RooAbsMoment.cxx. ◆ RooAbsMoment() [3/3]. RooAbsMoment::RooAbsMoment ; (; const RooAbsMoment & ; other, . const char * ; name = nullptr . ). Definition at line 49 of file RooAbsMoment.cxx. Member Function Documentation. ◆ central(). bool RooAbsMoment::central ; (; ); const. inline . Definition at line 35 of file R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMoment.html:59809,cache,cache,59809,doc/master/classRooAbsMoment.html,https://root.cern,https://root.cern/doc/master/classRooAbsMoment.html,1,['cache'],['cache']
Performance,"terProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooConvCoefVar.h>. Inheritance diagram for RooConvCoefVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooConvCoefVar() [1/3]. RooConvCoefVar::RooConvCoefVar ; (; ). inline . Default constructor. ; Definition at line 32 of file RooConvCoefVar.h. ◆ RooConvCoefVar() [2/3]. RooConvCoefVar::RooConvCoefVar ; (; const char * ; name, . const char * ; title, . const RooAbsAnaConvPdf & ; input, . Int_t ; coefIdx, . const RooArgSet * ; varList = nullptr . ). Constructor given a RooAbsAnaConvPdf a coefficient index and a set with the convoluted observable(s). ; Definition at line 38 of file RooConvCoefVar.cxx. ◆ RooConvCoefVar() [3/3]. RooConvCoefVar::RooConvCoefVar ; (; const RooConvCoefVar & ; other, . cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConvCoefVar.html:59767,cache,cache,59767,doc/master/classRooConvCoefVar.html,https://root.cern,https://root.cern/doc/master/classRooConvCoefVar.html,1,['cache'],['cache']
Performance,"tered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGaxis.html:18180,optimiz,optimized,18180,root/html528/TGaxis.html,https://root.cern,https://root.cern/root/html528/TGaxis.html,8,['optimiz'],['optimized']
Performance,"terface<ROOT::Detail::RDF::RLoopManager>*>(""; 1489 << RDFInternal::PrettyPrintAddr(&resRDF); 1490 << "") = reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RNodeBase>*>(""; 1491 << RDFInternal::PrettyPrintAddr(&upcastInterface) << "")->Cache<"";; 1492 ; 1493 const auto columnListWithoutSizeColumns = RDFInternal::FilterArraySizeColNames(columnList, ""Cache"");; 1494 ; 1495 const auto validColumnNames =; 1496 GetValidatedColumnNames(columnListWithoutSizeColumns.size(), columnListWithoutSizeColumns);; 1497 const auto colTypes = GetValidatedArgTypes(validColumnNames, fColRegister, fLoopManager->GetTree(), fDataSource,; 1498 ""Cache"", /*vector2RVec=*/false);; 1499 for (const auto &colType : colTypes); 1500 cacheCall << colType << "", "";; 1501 if (!columnListWithoutSizeColumns.empty()); 1502 cacheCall.seekp(-2, cacheCall.cur); // remove the last "",; 1503 cacheCall << "">(*reinterpret_cast<std::vector<std::string>*>("" // vector<string> should be ColumnNames_t; 1504 << RDFInternal::PrettyPrintAddr(&columnListWithoutSizeColumns) << ""));"";; 1505 ; 1506 // book the code to jit with the RLoopManager and trigger the event loop; 1507 fLoopManager->ToJitExec(cacheCall.str());; 1508 fLoopManager->Jit();; 1509 ; 1510 return resRDF;; 1511 }; 1512 ; 1513 ////////////////////////////////////////////////////////////////////////////; 1514 /// \brief Save selected columns in memory.; 1515 /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; 1516 /// \return a `RDataFrame` that wraps the cached dataset.; 1517 ///; 1518 /// The existing columns are matched against the regular expression. If the string provided; 1519 /// is empty, all columns are selected. See the previous overloads for more information.; 1520 RInterface<RLoopManager> Ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:83719,cache,cacheCall,83719,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,['cache'],['cacheCall']
Performance,"terial properties. This task is done by:; TGeoNode *TGeoManager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the deepest node that geometrically contains P (in our case let us suppose it is B_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. Deepest means that B_3 still contains point P (as well as A_1 and TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024136,optimiz,optimizes,1024136,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimizes']
Performance,"termination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; ; -----------------------; Reading data from ASCII; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 0.0174204 L(-10 - 10) ""x""; 2) y = 9.46654 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; ; Original data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; ; Read-back data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[x,y] = 64 entries; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf102_dataimport.C. tutorialsroofitrf102_dataimport.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8C.html:11359,load,loadValues,11359,doc/master/rf102__dataimport_8C.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html,1,['load'],['loadValues']
Performance,"tern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects and must be deleted by the user.; The first entry is the full matched pattern, followed by the subpatterns.; If a pattern was not matched, it will return an empty substring:. TObjArray *subStrL = TPRegexp(""(a|(z))(bc)"").MatchS(""abc"");; for (Int_t i = 0; i < subStrL->GetLast()+1; i++) {; const TString subStr = ((TObjString *)subStrL->At(i))->GetString();; std::cout << ""\"""" << subStr << ""\"" "";; }; std::cout << subStr << std::endl;. produces: ""abc"" ""a"" """" ""bc""; For meaning of mods see ParseMods(). Int_t SubstituteInternal(TString& s, const TString& replace, Int_t start, Int_t nMaxMatch0, Bool_t doDollarSubst) const; Perform pattern substitution with optional back-ref replacement; - protected method. Int_t Substitute(TString& s, const TString& replace, const TString& mods = """", Int_t start = 0, Int_t nMatchMax = 10); Substitute replaces the string s by a new string in which matching; patterns are replaced by the replacePattern string. The number of; substitutions are returned. TString s(""aap noot mies"");; const Int_t nrSub = TPRegexp(""(\\w*) noot (\\w*)"").Substitute(s,""$2 noot $1"");; std::cout << nrSub << "" \"""" << s << ""\"""" <<std::endl;. produces: 2 ""mies noot aap""; For meaning of mods see ParseMods(). Bool_t IsValid() const; Returns true if underlying PCRE structure has been successfully; generated via regexp compilation. Bool_t GetThrowAtCompileError(); Get value of static flag controlling whether exception should be thrown upon an; error during regular expression compilation by the PCRE engine. void SetThrowAtCompileError(Bool_t throwp); Set static flag controlling whether exc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPRegexp.html:5521,Perform,Perform,5521,root/html602/TPRegexp.html,https://root.cern,https://root.cern/root/html602/TPRegexp.html,2,['Perform'],['Perform']
Performance,"ters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }. Assumptions. A few assumptions need to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; temp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:1822,perform,perform,1822,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,6,['perform'],['perform']
Performance,"ters or a list of parameters indicated by the sequence [par_number]; A graph showing the logic to compile and analyze a formula is shown in TFormula::Compile and TFormula::Analyze. Once a formula has been compiled, it can be evaluated for a given set of parameters. see graph in TFormula::EvalPar.; This class is the base class for the function classes TF1,TF2 and TF3. It is also used by the ntuple selection mechanism TNtupleFormula.; In version 7 of TFormula, the usage of fOper has been changed to improve the performance of TFormula::EvalPar. Conceptually, fOper was changed from a simple array of Int_t to an array of composite values. For example a 'ylandau(5)' operation used to be encoded as 4105; it is now encoded as (klandau >> kTFOperShift) + 5 Any class inheriting from TFormula and using directly fOper (which is now a private data member), needs to be updated to take this in consideration. The member functions recommended to set and access fOper are: SetAction, GetAction, GetActionParam For more performant access to the information, see the implementation TFormula::EvalPar. CHANGING DEFAULT SETTINGS; When creating complex formula , it may be necessary to increase some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; This is a frequently asked question. C++ is a strongly typed language. There is no way for TFormula (without recompiling this class) to know about all possible user defined data types. This also apply to the case of a static class function. Because TMath is a special and frequent case, TFormula is aware of all TMath functions. ; Definition at line 65 of file TFormula.h. Public Types; enum  { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:2750,perform,performant,2750,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['perform'],['performant']
Performance,"tes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooNumRunningInt; std::string _binningName;  Name of binning to be used for cache histogram. ;  ; RooRealProxy func;  Proxy to functions whose running integral is calculated. ;  ; RooRealProxy x;  Integrated observable. ;  ;  Protected Attributes inherited from RooAbsCachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:60732,cache,cache,60732,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance,"tes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “The picture is strangely rotated; where are the coordinate axes?”; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see only its content.”; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: “I do not see all volumes in my tree but just something",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1006246,perform,perform,1006246,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"tes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: myTreeOrChain.GetTree()->PrintCacheStats();. Definition at line 32 of file TTreeCache.h. Classes; struct  IOPos;  ; struct  MissCache;  . Public Types; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Pu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:10785,perform,performance,10785,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['perform'],['performance']
Performance,"tes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSpHarmonic.html:34210,cache,cache,34210,root/html534/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html534/RooSpHarmonic.html,2,['cache'],['cache']
Performance,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:36213,cache,cache,36213,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,18,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"tesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw map of objects in this file.Definition TFile.cxx:1128; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::fCacheWriteTFileCacheWrite * fCacheWrite!Pointer to the write cache (if any)Definition TFile.h:100; TFile::fRealNameTString fRealNameEffective real file name (not original url)Definition TFile.h:90; TFile::SetOffsetvirtual void SetOffset(Long64_t offset, ERelativeTo pos=kBeg)Set position from where to start reading.Definition TFile.cxx:2253; TFile::fOffsetLong64_t fOffset!Seek offset cacheDefinition TFile.h:96; TFile::fgBytesWritestatic std::atomic< Long64_t > fgBytesWriteNumber of bytes written by all TFile objects.Definition TFile.h:130; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:226544,cache,cache,226544,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"testing methods ------------------------------; 146 ; 147 // prepare tree branch with the method's discriminating variable; 148 void AddOutput( Types::ETreeType type, Types::EAnalysisType analysisType );; 149 ; 150 // performs classifier training; 151 // calls methods Train() implemented by derived classes; 152 void TrainMethod();; 153 ; 154 // optimize tuning parameters; 155 virtual std::map<TString,Double_t> OptimizeTuningParameters(TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 156 virtual void SetTuneParameters(std::map<TString,Double_t> tuneParameters);; 157 ; 158 virtual void Train() = 0;; 159 ; 160 // store and retrieve time used for training; 161 void SetTrainTime( Double_t trainTime ) { fTrainTime = trainTime; }; 162 Double_t GetTrainTime() const { return fTrainTime; }; 163 ; 164 // store and retrieve time used for testing; 165 void SetTestTime ( Double_t testTime ) { fTestTime = testTime; }; 166 Double_t GetTestTime () const { return fTestTime; }; 167 ; 168 // performs classifier testing; 169 virtual void TestClassification();; 170 virtual Double_t GetKSTrainingVsTest(Char_t SorB, TString opt=""X"");; 171 ; 172 // performs multiclass classifier testing; 173 virtual void TestMulticlass();; 174 ; 175 // performs regression testing; 176 virtual void TestRegression( Double_t& bias, Double_t& biasT,; 177 Double_t& dev, Double_t& devT,; 178 Double_t& rms, Double_t& rmsT,; 179 Double_t& mInf, Double_t& mInfT, // mutual information; 180 Double_t& corr,; 181 Types::ETreeType type );; 182 ; 183 // options treatment; 184 virtual void Init() = 0;; 185 virtual void DeclareOptions() = 0;; 186 virtual void ProcessOptions() = 0;; 187 virtual void DeclareCompatibilityOptions(); // declaration of past options; 188 ; 189 // reset the Method --> As if it was not yet trained, just instantiated; 190 // virtual void Reset() = 0;; 191 //for the moment, I provide a dummy (that would not work) default, just to make; 192 // compilation/running w/o parameter optimisation stil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:5799,perform,performs,5799,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['perform'],['performs']
Performance,testing; : Dataset[dataset] : Multiclass evaluation of DL_CPU on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_MLP : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: PDEFoam; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:21560,perform,performance,21560,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:11936,cache,cacheList,11936,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,9,['cache'],['cacheList']
Performance,"texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:12146,cache,cacheList,12146,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,12,['cache'],['cacheList']
Performance,"texpr Version_t TProcessEventTimer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 262 of file TSystem.h. ◆ DeclFileName(). static const char * TProcessEventTimer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 262 of file TSystem.h. ◆ IsA(). TClass * TProcessEventTimer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 262 of file TSystem.h. ◆ Notify(). Bool_t TProcessEventTimer::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Implements TSysEvtHandler.; Definition at line 260 of file TSystem.h. ◆ ProcessEvents(). Bool_t TProcessEventTimer::ProcessEvents ; (; ). Process events if timer did time out. ; Returns kTRUE if interrupt flag is set (by hitting a key in the canvas or selecting the Interrupt menu item in canvas or some other action). ; Definition at line 92 of file TSystem.cxx. ◆ Streamer(). void TProcessEventTimer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TProcessEventTimer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 262 of file TSystem.h. Libraries for TProcessEventTimer:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TSystem.h; core/base/src/TSystem.cxx. TProcessEventTimer.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProcessEventTimer.html:19197,load,load,19197,doc/master/classTProcessEventTimer.html,https://root.cern,https://root.cern/doc/master/classTProcessEventTimer.html,2,['load'],['load']
Performance,"text & ; ctx); const. overrideprotectedvirtual . Compute multiple values of BreitWigner distribution. ; Reimplemented from RooAbsReal.; Definition at line 64 of file RooBreitWigner.cxx. ◆ evaluate(). double RooBreitWigner::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 56 of file RooBreitWigner.cxx. ◆ getAnalyticalIntegral(). Int_t RooBreitWigner::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 71 of file RooBreitWigner.cxx. ◆ IsA(). TClass * RooBreitWigner::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 51 of file RooBreitWigner.h. ◆ Streamer(). void RooBreitWigner::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooBreitWigner::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 51 of file RooBreitWigner.h. Member Data Documentation. ◆ mean. RooRealProxy RooBreitWigner::mean. protected . Definition at line 39 of file RooBreitWigner.h. ◆ width. RooRealProxy RooBreitWigner::width. protected . Definition at line 40 of file RooBreitWigner.h. ◆ x. RooRealProxy RooBreitWigner::x. protected . Definition at line 38 of file RooBreitWigner.h. Libraries for RooBreitWigner:. [legend",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:76440,perform,performed,76440,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,1,['perform'],['performed']
Performance,"text & ; ctx); const. overrideprotectedvirtual . Compute multiple values of Exponential distribution. ; Reimplemented from RooAbsReal.; Definition at line 71 of file RooExponential.cxx. ◆ evaluate(). double RooExponential::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 60 of file RooExponential.cxx. ◆ getAnalyticalIntegral(). Int_t RooExponential::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 77 of file RooExponential.cxx. ◆ IsA(). TClass * RooExponential::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooExponential.h. ◆ negateCoefficient(). bool RooExponential::negateCoefficient ; (; ); const. inline . Definition at line 39 of file RooExponential.h. ◆ Streamer(). void RooExponential::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooExponential::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 55 of file RooExponential.h. ◆ translate(). void RooExponential::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExponential.html:77568,perform,performed,77568,doc/master/classRooExponential.html,https://root.cern,https://root.cern/doc/master/classRooExponential.html,1,['perform'],['performed']
Performance,"text is drawn with TGX11::DrawText. RXImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. void MapGCFont(GContext_t gc, FontStruct_t font); Map the XftFont with the Graphics Context using it. Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font properties. void DrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); Draw text string. TGX11TTF(const TGX11& org). virtual ~TGX11TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x11ttf:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGX11TTF.html:29167,Load,LoadQueryFont,29167,root/html604/TGX11TTF.html,https://root.cern,https://root.cern/root/html604/TGX11TTF.html,1,['Load'],['LoadQueryFont']
Performance,"text(const RooArgSet& vars, Bool_t verbose = kFALSE) const; virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::grap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:34717,cache,cache,34717,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,6,['cache'],['cache']
Performance,"text, RooGenContext, RooProdGenContext, RooSimGenContext, and RooSimSplitGenContext. ◆ StreamerNVirtual(). void RooAbsGenContext::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 89 of file RooAbsGenContext.h. Member Data Documentation. ◆ _expectedEvents. UInt_t RooAbsGenContext::_expectedEvents. protected . Number of expected events from extended p.d.f. ; Definition at line 80 of file RooAbsGenContext.h. ◆ _extendMode. RooAbsPdf::ExtendMode RooAbsGenContext::_extendMode. protected . Extended mode capabilities of p.d.f. ; Definition at line 83 of file RooAbsGenContext.h. ◆ _genData. RooDataSet* RooAbsGenContext::_genData = nullptr. protected . ! Data being generated ; Definition at line 87 of file RooAbsGenContext.h. ◆ _isValid. bool RooAbsGenContext::_isValid. protected . Is context in valid state? ; Definition at line 78 of file RooAbsGenContext.h. ◆ _nextProtoIndex. Int_t RooAbsGenContext::_nextProtoIndex. protected . Next prototype event to load according to LUT. ; Definition at line 82 of file RooAbsGenContext.h. ◆ _normRange. TString RooAbsGenContext::_normRange. protected . Normalization range of pdf. ; Definition at line 85 of file RooAbsGenContext.h. ◆ _protoOrder. std::vector<Int_t> RooAbsGenContext::_protoOrder. protected . LUT with traversal order of prototype data. ; Definition at line 84 of file RooAbsGenContext.h. ◆ _prototype. const RooDataSet* RooAbsGenContext::_prototype. protected . Pointer to prototype dataset. ; Definition at line 76 of file RooAbsGenContext.h. ◆ _protoVars. RooArgSet RooAbsGenContext::_protoVars. protected . Prototype observables. ; Definition at line 81 of file RooAbsGenContext.h. ◆ _theEvent. RooArgSet RooAbsGenContext::_theEvent. protected . Pointer to observable event being generated. ; Definition at line 77 of file RooAbsGenContext.h. ◆ _verbose. bool RooAbsGenContext::_verbose. protected . Verbose messaging? ; Definition at line 79 of file RooAbsGenContext.h. Libraries for RooAbsG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsGenContext.html:24644,load,load,24644,doc/master/classRooAbsGenContext.html,https://root.cern,https://root.cern/doc/master/classRooAbsGenContext.html,1,['load'],['load']
Performance,"text::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimSplitGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE). void setExpectedData(Bool_t ); Forward to components. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); this method is empty because it is not used by this context. void generateEvent(RooArgSet& theEvent, Int_t remaining); this method is empty because it is not used in this type of context. void setProtoDataOrder(Int_t* lut); this method is empty because proto datasets are not supported by this context. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"). » Last changed: Tue Jun 2 15:33:50 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooSimSplitGenContext.html:10747,Perform,Perform,10747,root/html604/RooSimSplitGenContext.html,https://root.cern,https://root.cern/root/html604/RooSimSplitGenContext.html,1,['Perform'],['Perform']
Performance,"text::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimSplitGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE). void setExpectedData(Bool_t ); Forward to components. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); this method is empty because it is not used by this context. void generateEvent(RooArgSet& theEvent, Int_t remaining); this method is empty because it is not used in this type of context. void setProtoDataOrder(Int_t* lut); this method is empty because proto datasets are not supported by this context. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"). » Last changed: Tue Jun 30 14:35:45 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimSplitGenContext.html:10747,Perform,Perform,10747,root/html602/RooSimSplitGenContext.html,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html,1,['Perform'],['Perform']
Performance,"text::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimSplitGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE). void setExpectedData(Bool_t ); Forward to components. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); this method is empty because it is not used by this context. void generateEvent(RooArgSet& theEvent, Int_t remaining); this method is empty because it is not used in this type of context. void setProtoDataOrder(Int_t* lut); this method is empty because proto datasets are not supported by this context. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"). » Last changed: Tue Mar 10 17:19:08 2015 » Last generated: 2015-03-10 17:19; This page has been automatically generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimSplitGenContext.html:9723,Perform,Perform,9723,root/html534/RooSimSplitGenContext.html,https://root.cern,https://root.cern/root/html534/RooSimSplitGenContext.html,1,['Perform'],['Perform']
Performance,"text::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimSplitGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* generate(Int_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE). void setExpectedData(Bool_t ); Forward to components. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); this method is empty because it is not used by this context. void generateEvent(RooArgSet& theEvent, Int_t remaining); this method is empty because it is not used in this type of context. void setProtoDataOrder(Int_t* lut); this method is empty because proto datasets are not supported by this context. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"). » Last changed: Fri Dec 2 14:27:04 2011 » Last generated: 2011-12-02 14:27; This page has been automatically generated. Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSimSplitGenContext.html:9701,Perform,Perform,9701,root/html532/RooSimSplitGenContext.html,https://root.cern,https://root.cern/root/html532/RooSimSplitGenContext.html,1,['Perform'],['Perform']
Performance,"textMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TFileCacheWrite.h>. Inheritance diagram for TFileCacheWrite:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TFileCacheWrite() [1/3]. TFileCacheWrite::TFileCacheWrite ; (; const TFileCacheWrite & ; ). privatedelete . ◆ TFileCacheWrite() [2/3]. TFileCacheWrite::TFileCacheWrite ; (; ). Default Constructor. ; Definition at line 37 of file TFileCacheWrite.cxx. ◆ TFileCacheWrite() [3/3]. TFileCacheWrite::TFileCacheWrite ; (; TFile * ; file, . Int_t ; buffersize . ). Creates a TFileCacheWrite data structure. ; The write cache will be connected to file. The size of the cache will be buffersize, if buffersize < 10000 a default size of 512 Kbytes is used ; Definition at line 53 of file TFileCacheWrite.cxx. ◆ ~TFileCacheWrite(). TFileCacheWrite::~TFileCacheWrite ; (; ). override . Destructor. ; Definition at line 70 of file TFileCacheWrite.cxx. Member Function Documentation. ◆ Class(). static TClass * TFileCacheWrite::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFileCacheWrite::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFileCacheWrite::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 44 of file TFileCacheWrite.h. ◆ DeclFileName(). static const char * TFileCacheWrite::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 44 of file TFileCacheWrite.h. ◆ Flush(). Bool_t TFileCacheWrite::Flush ; (; ). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:12087,cache,cache,12087,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['cache'],['cache']
Performance,"te” If the directory does not exist, it is creates as in “new”, in addition if the directory does exist, all existing files are deleted before creating the new files.; “update” The new classes are added to the existing directory and the existing classes are replaced with the new definition. If the directory does not exist, it creates it as in “new”.; “+”: This option can be used in combination with the other three. It will create the necessary files to easily build a shared library containing the class definitions.Specifically it will:; Generate a script called MAKE that builds the shared library containing the definition of all classes in the directory.; Generate a LinkDef.hfiles to use with rootcling in MAKE.; Run rootcling to generate a <dirname>ProjectDict.cxx file.; Compile the <dirname>ProjectDict.cxxwith the current options in compiledata.h.; Build a shared library<dirname>.so.; “++”:This option can be used instead of the single “+”. It does everything the single “+” does, and dynamically loads the shared library <dirname>.so. This example makes a directory called MyProject that will contain all class definitions from the atlfast.root file. The necessary makefile to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:510398,load,loads,510398,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loads']
Performance,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:38574,cache,cacheList,38574,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,4,['cache'],"['cacheList', 'cached']"
Performance,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:48326,cache,cacheList,48326,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,18,['cache'],"['cacheList', 'cached']"
Performance,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:48375,cache,cacheList,48375,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,14,['cache'],"['cacheList', 'cached']"
Performance,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:33562,cache,cacheList,33562,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,270,['cache'],"['cacheList', 'cached']"
Performance,"th for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,double>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_double_.html:42968,cache,cache,42968,root/html534/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_double_.html,2,['cache'],['cache']
Performance,"th for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2PdfBinding_double_double_int_.html:39915,cache,cache,39915,root/html530/RooCFunction2PdfBinding_double_double_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2PdfBinding_double_double_int_.html,2,['cache'],['cache']
Performance,"th for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2PdfBinding_double_int_double_.html:39915,cache,cache,39915,root/html530/RooCFunction2PdfBinding_double_int_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2PdfBinding_double_int_double_.html,2,['cache'],['cache']
Performance,th luxury level of 1 (It throws away 202 values for every 12 used) see here ;  CGSLRngRanLuxS2Second generation of Ranlux generator for Single precision with luxury level of 2 (It throws away 397 value for every 12 used) see here ;  CGSLRngRanMarRANMAR generator see here ;  CGSLRngTausTausworthe generator by L'Ecuyer see here ;  CGSLRngWrapperGSLRngWrapper class to wrap gsl_rng structure ;  CGSLRootFdFSolverRoot-Finder with derivatives implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:32194,perform,performing,32194,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['perform'],['performing']
Performance,"th or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23622,Load,Loading,23622,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['Load'],['Loading']
Performance,"th supplied world plane. ; Returns std::pair of bool and vertex. If line intersects; Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 533 of file TGLCamera.cxx. ◆ ViewportPlaneIntersection() [2/2]. std::pair< Bool_t, TGLVertex3 > TGLCamera::ViewportPlaneIntersection ; (; Double_t ; viewportX, . Double_t ; viewportY, . const TGLPlane & ; worldPlane . ); const. Find the intersection of projection of supplied viewport point (a 3D world line - see ViewportToWorld) with supplied world plane. ; Returns std::pair of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex. If line does not intersect (line and plane parallel) std::pair.first (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid.; NOTE: The projection lines is extended for the plane intersection test hence the intersection vertex can lie outside the near/far clip regions (not visible); Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 517 of file TGLCamera.cxx. ◆ ViewportRect() [1/2]. TGLRect TGLCamera::ViewportRect ; (; const TGLBoundingBox & ; box, . const TGLBoundingBox::EFace * ; face = nullptr . ); const. Calculate viewport rectangle which just contains projection of world frame bounding box 'box' onto the viewport. ; If face is null the rect contains the whole bounding box (8 vertices/6 faces). If face is non-null it indicates a box face, and the rect contains the single face (4 vertices). Note use other version of ViewportRect() if you wish to just pass a static EFace enum member (e.g. kFaceLowX); Note:; Rectangle is NOT clipped by viewport limits - so can result in rect with corners outside viewport - negative etc; TGLRect provides int (pixel based) values - not subpixel accurate; Camera must have valid frustum cache - call Apply() after last modification, before calling . Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:36166,cache,cache,36166,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"th::LorentzRotation::operator= ; (; Boost const & ; b). inline . Assign from a pure boost. ; Definition at line 165 of file LorentzRotation.h. ◆ operator=() [3/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; BoostX const & ; b). inline . Definition at line 167 of file LorentzRotation.h. ◆ operator=() [4/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; BoostY const & ; b). inline . Definition at line 169 of file LorentzRotation.h. ◆ operator=() [5/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; BoostZ const & ; b). inline . Definition at line 171 of file LorentzRotation.h. ◆ operator=() [6/13]. template<class ForeignMatrix > . LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; const ForeignMatrix & ; m). inline . Assign from a linear algebra matrix of size at least 4x4, which must support operator()(i,j) to obtain elements (0,3) thru (3,3). ; Precondition: The matrix is assumed to be orthosymplectic. NO checking or re-adjusting is performed. ; Definition at line 199 of file LorentzRotation.h. ◆ operator=() [7/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; EulerAngles const & ; e). inline . Definition at line 181 of file LorentzRotation.h. ◆ operator=() [8/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; LorentzRotation const & ; rhs). inline . Assign from another LorentzRotation. ; Definition at line 153 of file LorentzRotation.h. ◆ operator=() [9/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; Quaternion const & ; q). inline . Definition at line 183 of file LorentzRotation.h. ◆ operator=() [10/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; Rotation3D const & ; r). inline . Assign from a 3-D rotation. ; Definition at line 177 of file LorentzRotation.h. ◆ operator=() [11/13]. LorentzRotation & ROOT::Math::LorentzRotation::operator= ; (; RotationX const & ; r). inline . Definition at line 189 of file LorentzRotation.h. ◆ operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzRotation.html:20049,perform,performed,20049,doc/master/classROOT_1_1Math_1_1LorentzRotation.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzRotation.html,1,['perform'],['performed']
Performance,"th; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:39431,cache,cache,39431,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,2,['cache'],['cache']
Performance,"th_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:429391,cache,cache,429391,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"that can be found in the ROOT include path or the current directory. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual Bool_t ProcessEvents ();  Process pending events (GUI, timers, sockets). ;  ; const char * pwd ();  ; void RemoveOnExit (TObject *obj);  Objects that should be deleted on exit of the OS interface. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual void Run ();  System event loop. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual void SetIncludePath (const char *includePath);  IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ;  ; virtual void SetLinkdefSuffix (const char *suffix);  The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:18489,optimiz,optimized,18489,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['optimiz'],['optimized']
Performance,"that covers only a subset of the fields in the ntuple. The ntuple model is used when reading complete entries. Individual fields can be read as well by instantiating a tree view.; #include <ROOT/RNTupleReader.hxx>; using ROOT::Experimental::RNTupleReader;; ; #include <iostream>; ; auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; RNTupleReader.hxx; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::Experimental::RNTupleReader::Openstatic std::unique_ptr< RNTupleReader > Open(std::string_view ntupleName, std::string_view storage, const RNTupleReadOptions &options=RNTupleReadOptions())Open an RNTuple for reading.Definition RNTupleReader.cxx:94. Definition at line 71 of file RNTupleReader.hxx. Classes; class  RIterator;  . Public Member Functions;  ~RNTupleReader ();  ; RIterator begin ();  ; std::unique_ptr< RNTupleReader > Clone ();  ; void EnableMetrics ();  Enable performance measurements (decompression time, bytes read from storage, etc.) ;  ; RIterator end ();  ; RNTupleCollectionView GetCollectionView (DescriptorId_t fieldId);  ; RNTupleCollectionView GetCollectionView (std::string_view fieldName);  Raises an exception if: ;  ; const RNTupleDescriptor & GetDescriptor ();  Returns a cached copy of the page source descriptor. ;  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (std::string_view fieldName);  ; RNTupleGlobalRange GetEntryRange ();  Returns an iterator over the entry indices of the RNTuple. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel ();  ; NTupleSize_t GetNEntries () const;  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t field",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:1691,perform,performance,1691,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['perform'],['performance']
Performance,"that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:44901,load,load,44901,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,8,['load'],"['load', 'loaded']"
Performance,"that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return _cacheSource ; }. void setCacheSource(Bool_t flag); { _cacheSource = flag ; }. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:39547,cache,cache,39547,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],['cache']
Performance,that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD*_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TVectorD*_mref; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo1DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:32114,cache,cache,32114,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,1,['cache'],['cache']
Performance,that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPGenDecay.html:42155,cache,cache,42155,root/html534/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPGenDecay.html,5,"['Cache', 'cache']","['Cached', 'cache']"
Performance,that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPEffDecay.html:44067,cache,cache,44067,root/html602/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPEffDecay.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:13350,cache,cache,13350,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"the Figure 4.8. Original spectrum before unfolding. Contents of the responses in the original spectrum. Another example where we have used unfolding method is the decomposition of continuum of gamma-ray spectra. Using simulation and interpolation techniques we have synthesized the response matrix (size 3400x3400 channels) of Gammasphere spectrometer (Figure 4.9). Its detail is presented in Figure 4.10. The original spectrum of Co56 before and after continuum decomposition are presented in Figures 4.11, 4.12, respectively. Response matrix (size 3400x3400 channels) of Gammasphere spectrometer. Detail of Figure 4.9. Original spectrum of Co56 before continuum decomposition. Original spectrum of Co56 after continuum decomposition. 4.3 2-DIMENSIONAL SPECTRA; We have extended the method of Gold deconvolution also for 2-dimensional data. Again the goal of the deconvolution methods is to improve the resolution in the spectrum and to decompose multiplets. In detail the method of optimized 2-dimensional deconvolution is described in [8].; Mathematical formulation of 2-dimensional convolution system is as follows; \[ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 \]; Assuming we know the output spectrum y and the response spectrum h,the task is to calculate the matrix x.; The basic function has the form; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; This function calculates deconvolution from source spectrum according to response spectrum. The result is placed in the matrix pointed by source pointer.; Function parameters:. source pointer to the matrix of source spectrum; resp pointer to the matrix of response spectrum; sizex x length of source and response spectra; sizey y length of source and response spectra; number_of_iterations for details see [8]. The example of 2-dimensional spectrum before deconvolution is presented in Figure 4.13. In the process ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:30314,optimiz,optimized,30314,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['optimiz'],['optimized']
Performance,"the PDFs of the discriminating variables . The plots obtained thanks to the TSPlot class are called ; . Some properties and checks. Beside reproducing the true distribution, ; bear remarkable properties:. Each -distribution is properly normalized:. (4). For any event:. (5). That is to say that, summing up the ; ; , one recovers the data sample distribution in , and summing up the number of events entering in a ; for a given species, one recovers the yield of the species, as provided by the fit. The property 4 is implemented in the TSPlot class as a check. the sum of the statistical uncertainties per bin. (6). reproduces the statistical uncertainty on the yield , as provided by the fit: ; .; Because of that and since the determination of the yields is optimal; when obtained using a Likelihood fit, one can conclude that the; technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields of the various species. ; The fit relies on discriminating variables  uncorrelated with a control variable :; the later is therefore totally absent from the fit. . The weights are calculated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . . Error bars per bin are given by Eq. (6). . The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:4390,perform,performed,4390,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,6,['perform'],['performed']
Performance,"the PDFs of the discriminating variables . The plots obtained thanks to the TSPlot class are called ; . Some properties and checks. Beside reproducing the true distribution, ; bear remarkable properties:. Each -distribution is properly normalized:. (4). For any event:. (5). That is to say that, summing up the ; ; , one recovers the data sample distribution in , and summing up the number of events entering in a ; for a given species, one recovers the yield of the species, as provided by the fit. The property 4 is implemented in the TSPlot class as a check. the sum of the statistical uncertainties per bin. (6). reproduces the statistical uncertainty on the yield , as provided by the fit: ; .; Because of that and since the determination of the yields is optimal; when obtained using a Likelihood fit, one can conclude that the; technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields of the various species.; The fit relies on discriminating variables  uncorrelated with a control variable :; the later is therefore totally absent from the fit. The weights are calculated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . Error bars per bin are given by Eq. (6). The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:4413,perform,performed,4413,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,4,['perform'],['performed']
Performance,"the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEntry > fTree->fClusterRangeEnd[fClusterRange]) {; 661 ++fClusterRange;; 662 }; 663 if (fClusterRange == fTree->fNClusterRange) {; 664 // We are looking at the last range which size; 665 // is defined by AutoFlush itself and goes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:24781,cache,cacheSize,24781,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,3,['cache'],['cacheSize']
Performance,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:15713,cache,cache,15713,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,10,['cache'],['cache']
Performance,"the basket has been marked as 'used'. ; Definition at line 76 of file TBranchCacheInfo.h. ◆ IsInCache(). bool ROOT::Internal::TBranchCacheInfo::IsInCache ; (; Int_t ; basketNumber); const. inline . Return true if the basket is currently in the cache. ; Definition at line 86 of file TBranchCacheInfo.h. ◆ IsVetoed(). bool ROOT::Internal::TBranchCacheInfo::IsVetoed ; (; Int_t ; basketNumber); const. inline . Return true if the basket is currently vetoed. ; Definition at line 105 of file TBranchCacheInfo.h. ◆ Print(). void ROOT::Internal::TBranchCacheInfo::Print ; (; const char * ; owner, . Long64_t * ; entries . ); const. inline . Print the info we have for the baskets. ; Definition at line 141 of file TBranchCacheInfo.h. ◆ Reset(). void ROOT::Internal::TBranchCacheInfo::Reset ; (; ). inline . Reset all info. ; Definition at line 134 of file TBranchCacheInfo.h. ◆ SetIsInCache(). void ROOT::Internal::TBranchCacheInfo::SetIsInCache ; (; Int_t ; basketNumber). inline . Mark if the basket is currently in the cache. ; Definition at line 89 of file TBranchCacheInfo.h. ◆ SetState(). void ROOT::Internal::TBranchCacheInfo::SetState ; (; Int_t ; basketNumber, . EStates ; what . ). inlineprivate . Mark if the basket has been marked has the 'what' state. ; Definition at line 68 of file TBranchCacheInfo.h. ◆ SetUsed(). void ROOT::Internal::TBranchCacheInfo::SetUsed ; (; Int_t ; basketNumber). inline . Mark if the basket has been marked as 'used'. ; Definition at line 79 of file TBranchCacheInfo.h. ◆ TestState(). bool ROOT::Internal::TBranchCacheInfo::TestState ; (; Int_t ; basketNumber, . EStates ; what . ); const. inlineprivate . Return true if the basket has been marked as having the 'what' state. ; Definition at line 60 of file TBranchCacheInfo.h. ◆ UpdatePedestal(). void ROOT::Internal::TBranchCacheInfo::UpdatePedestal ; (; Int_t ; basketNumber). inlineprivate . Update the pedestal to be less or equal to basketNumber, shift the bits if needed. ; Definition at line 48 of file TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html:3732,cache,cache,3732,doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,1,['cache'],['cache']
Performance,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t ReadArray(Double_t*& d); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:30566,optimiz,optimize,30566,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,9,['optimiz'],['optimize']
Performance,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:33485,optimiz,optimize,33485,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,10,['optimiz'],['optimize']
Performance,"the class declaration ; Definition at line 184 of file RooAbsMCStudyModule.h. ◆ dependents(). RooArgSet * RooAbsMCStudyModule::dependents ; (; ). inlineprotected . Return fit model observables. ; Definition at line 119 of file RooAbsMCStudyModule.h. ◆ doInitializeInstance(). bool RooAbsMCStudyModule::doInitializeInstance ; (; RooMCStudy & ; study). Initializer method called upon attachment to given RooMCStudy object. ; Store reference to RooMCStudy object that this module relates to and call internal module initialization function. ; Definition at line 61 of file RooAbsMCStudyModule.cxx. ◆ extendedGen(). bool RooAbsMCStudyModule::extendedGen ; (; ). inlineprotected . If true extended mode generation is requested. ; Definition at line 156 of file RooAbsMCStudyModule.h. ◆ finalizeRun(). virtual RooDataSet * RooAbsMCStudyModule::finalizeRun ; (; ). inlinevirtual . Method called at the end of each RooMCStudy run. ; If a RooDataSet is returned, it must have a length equal to the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. ; Reimplemented in RooChi2MCSModule, RooDLLSignificanceMCSModule, RooRandomizeParamMCSModule, and RooStats::UpperLimitMCSModule.; Definition at line 51 of file RooAbsMCStudyModule.h. ◆ fitInitParams(). RooArgSet * RooAbsMCStudyModule::fitInitParams ; (; ). inlineprotected . Return initial value of parameters of fit model. ; Definition at line 134 of file RooAbsMCStudyModule.h. ◆ fitModel(). RooAbsPdf * RooAbsMCStudyModule::fitModel ; (; ). inlineprotected . Return fit model. ; Definition at line 129 of file RooAbsMCStudyModule.h. ◆ fitOptList(). RooLinkedList * RooAbsMCStudyModule::fitOptList ; (; ). inlineprotected . Return list of fit options provided by user. ; Definition at line 151 of file RooAbsMCStudyModule.h. ◆ fitParams(). RooArgSet * RooAbsMCStudyModule::fitParams ; (; ). inlineprotected . Return current value of parameters of fit model. ; Definition at line 139 of file RooAbsMCStudyModule.h. ◆ gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMCStudyModule.html:16944,perform,performed,16944,doc/master/classRooAbsMCStudyModule.html,https://root.cern,https://root.cern/doc/master/classRooAbsMCStudyModule.html,1,['perform'],['performed']
Performance,"the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and Git commit SHA1.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file is downloaded in the current directory or in the directory; specified by 'dstdir'. If a package with the same name already exists; at destination, a check on the MD5 sum is done and the user warned or; prompted for action, depending is the file is equal or different.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); Upload a PROOF archive (PAR file). A PAR file is a compressed; tar file with one special additional directory, PROOF-INF; (blatantly copied from Java's jar format). It must have the extension; .par. A PAR file can be directly a binary or a source with a build; procedure. In the PROOF-INF directory there ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:77887,load,loadopts,77887,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,4,['load'],['loadopts']
Performance,"the color palette: . Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20;; palette[2] = 23;; palette[3] = 30;; palette[4] = 32;; gStyle->SetPalette(5,palette);; f1->Draw(""colz"");; return c1;; }; To define more a complexe palette with a continous gradient of color, one; should use the static function TColor::CreateGradientColorTable().; The following example demostrates how to proceed:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; UInt_t Number = 3;; Double_t Red[Number] = { 1.00, 0.00, 0.00};; Double_t Green[Number] = { 0.00, 1.00, 0.00};; Double_t Blue[Number] = { 1.00, 0.00, 1.00};; Double_t Length[Number] = { 0.00, 0.50, 1.00 };; Int_t nb=50;; TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; f2->SetContour(nb);; f2->Draw(""surf1z"");; return c2;; }; The function TColor::CreateGradientColorTable() performs automatically; a call to gStyle->SetPalette(). So there is not need to add one. After a call to TColor::CreateGradientColorTable() it is sometimes; useful to store the newly create palette for further use. In particular, it is ; recomended to do if one wants to switch between several user define palettes.; To store a palette in an array it is enough to do:. Int_t MyPalette[100];; Double_t r[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t g[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t b[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t stop[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, stop, r, g, b, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;. Later on to reuse the palette MyPalette it will be enough to do. gStyle->SetPalette(100, MyPalette);. As only one palette is active, one need to use TExec to be able to ; display plots using differents palettes on the same pad.; The following macro illu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TColor.html:5131,perform,performs,5131,root/html526/TColor.html,https://root.cern,https://root.cern/root/html526/TColor.html,1,['perform'],['performs']
Performance,"the columns/branches in input to the producer function (excluding slot and entry). . Returnsthe first node of the computation graph for which the new quantity is defined.; This alternative implementation of Define is meant as a helper in writing entry-specific, thread-safe custom columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where T1, T2... are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter is reserved for a ULong64_t representing the current entry being processed by the current thread.; The following two Defines are equivalent, although DefineSlotEntry is slightly more performant: int function(unsigned int, ULong64_t, double, double);; Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); DefineSlotEntry(""x"", function, {""column1"", ""column2""}); ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterface::DefineRInterface< Proxied, DS_t > Define(std::string_view name, F expression, const ColumnNames_t &columns={})Define a new column.Definition RInterface.hxx:441; ROOT::RDF::RInterface::DefineSlotEntryRInterface< Proxied, DS_t > DefineSlotEntry(std::string_view name, F expression, const ColumnNames_t &columns={})Define a new column with a value dependent on the processing slot and the current entry.Definition RInterface.hxx:500; See Define() for more information. ; Definition at line 500 of file RInterface.hxx. ◆ Display() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RResultPtr< RDisplay > ROOT::RDF::RInterface< Proxied, DataSource >::Display ; (; const ColumnNames_t & ; columnList, . size_t ; nRows = 5, . size_t ; nMaxCollectionElements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:60891,perform,performant,60891,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performant']
Performance,"the contents of a .rootrc file (or $ROOTSYS/etc/system.rootrc) at the beginning of the root session. See Environment Setup below for more information.; 2.7 Environment Setup; The behavior of a ROOT session can be tailored with the options in the .rootrc file. At start-up, ROOT looks for a .rootrc file in the following order:. ./.rootrc //local directory; $HOME/.rootrc //user directory; $ROOTSYS/etc/system.rootrc //global ROOT directory. If more than one .rootrc files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:63874,Load,Load,63874,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,"the convolution. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InitializeDataMembers(TF1* function1, TF1* function2, Bool_t useFFT); use copy instead of Clone. TF1Convolution(TF1* function1, TF1* function2, Bool_t useFFT = true); constructor from the two function pointer and a flag is using FFT. TF1Convolution(TF1* function1, TF1* function2, Double_t xmin, Double_t xmax, Bool_t useFFT = true); constructor from the two function pointer and the convolution range. TF1Convolution(TString formula, Double_t xmin = 1., Double_t xmax = 0., Bool_t useFFT = true); constructor from a formula expression as f1 * f2 where f1 and f2 are two functions known to ROOT. TF1Convolution(TString formula1, TString formula2, Double_t xmin = 1., Double_t xmax = 0., Bool_t useFFT = true); constructor from 2 function names where f1 and f2 are two functions known to ROOT; if the function names are not knwon to ROOT then a corresponding. void MakeFFTConv(); perform the FFT of the two functions. Double_t EvalFFTConv(Double_t t). Double_t EvalNumConv(Double_t t); perform numerical convolution; could in principle cache the integral in a Grap[h as it is done for the FFTW. Double_t operator()(Double_t* t, Double_t* p). void SetNofPointsFFT(Int_t n). void SetParameters(Double_t* p). void SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0., Double_t p3 = 0., Double_t p4 = 0., Double_t p5 = 0., Double_t p6 = 0., Double_t p7 = 0.). void SetExtraRange(Double_t percentage). void SetRange(Double_t a, Double_t b). TF1Convolution(TF1* function1, TF1* function2, Bool_t useFFT = true). TF1Convolution(TF1* function1, TF1* function2, Double_t xmin, Double_t xmax, Bool_t useFFT = true). void SetNumConv(Bool_t flag = true); {fFlagFFT=!flag;}. Int_t GetNpar() const; {return (fNofParams1+fNofParams2);}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return fXmax;}. const char * GetParName(Int_t ipar) const; { return fParNames.at(ipar).Data(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1Convolution.html:3881,perform,perform,3881,root/html604/TF1Convolution.html,https://root.cern,https://root.cern/root/html604/TF1Convolution.html,2,['perform'],['perform']
Performance,"the current event from the TTree. After the TSelector has processed the tree it will thus contain the sum of all event sizes.; Bool_t EventSelector::Process(Long64_t entry); {; //... // Tell the TTree reader to get the data for; // the entry number ""entry"" in the current tree:; fReader.SetLocalEntry(entry);. // We can still print some informations about the current event; //printf(""Size of Event %ld = %d Bytes\n"", entry, *fCurrentEventSize);. // compute the total size of all events; dereference the TTreeReaderValue; // using '*' to get the value it refers to, just like an iterator.; fTotalDataSize += *fCurrentEventSize;. return kTRUE;; }. Accessing the Analysis Result; In your selector's Terminate() function, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; void EventSelector::Terminate(); {; // ... int sizeInMB = fTotalDataSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. If, for any reason, you don't manage to get it to work, you can download a working selector file here: CountEventSelector.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEventSelector.C; Note: You will have to use it that way:; EventTree->Process(""CountEventSelector.C""). . ‹ Compiling Your Code (also known as ACLiC); up; Histogramming in a Selector ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:8199,load,load,8199,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['load'],['load']
Performance,"the current node.Definition TGeoNode.cxx:1193; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::GetListOfVolumesTObjArray * GetListOfVolumes() constDefinition TGeoManager.h:473; TGeoManager::SetMatrixReflectionvoid SetMatrixReflection(Bool_t flag=kTRUE)Definition TGeoManager.h:399; TGeoManager::cdvirtual Bool_t cd(const char *path="""")Browse the tree of nodes starting from fTopNode according to pathname.Definition TGeoManager.cxx:1707; TGeoManager::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoManager.h:526; TGeoManager::GetRTmodeInt_t GetRTmode() constDefinition TGeoManager.h:440; TGeoManager::IsClosedBool_t IsClosed() constDefinition TGeoManager.h:297; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:87561,cache,cache,87561,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['cache'],['cache']
Performance,"the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:39751,cache,cache,39751,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,18,['cache'],['cache']
Performance,"the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table. If an entry corresponding to major and minor is not found, the function returns the index of the major,minor pair immediately lower than the requested value, ie it will return -1 if the pair is lower than the first entry in the index.; See also GetEntryNumberWithIndex ; Definition at line 5890 of file TTree.cxx. ◆ GetEntryNumberWithIndex(). Long64_t TTree::GetEntryNumberWithIndex ; (; Long64_t ; major, . Long64_t ; minor = 0 . ); const. virtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table, otherwise it returns -1.; See also GetEntryNumberWithBestIndex ; Definition at line 5910 of file TTree.cxx. ◆ GetEntryWithIndex(). Int_t TTree::GetEntryWithIndex ; (; Int_t ; major, . Int_t ; minor = 0 . ). virtual . Read entry corresponding to major and minor number. ; The function returns the total number of bytes read. If the Tree has friend trees, the corresponding entry with the index values (major,minor) is read. Note that the master Tree and its friend may have different entry serial numbers corresponding to (major,minor). ; Reimplemented in TChain.; Definition at line 5927 of file TTree.cxx. ◆ GetEstimate(). virtual Long64_t TTree::GetEstimate ; (; ); const. inlinevirtual . Definition at line 467 of file TTree.h. ◆ GetEvent(). Int_t TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:155642,perform,performs,155642,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['perform'],['performs']
Performance,"the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table. If an entry corresponding to major and minor is not found, the function returns the index of the major,minor pair immediately lower than the requested value, ie it will return -1 if the pair is lower than the first entry in the index.; See also GetEntryNumberWithIndex ; Definition at line 5890 of file TTree.cxx. ◆ GetEntryNumberWithIndex(). Long64_t TTree::GetEntryNumberWithIndex ; (; Long64_t ; major, . Long64_t ; minor = 0 . ); const. virtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table, otherwise it returns -1.; See also GetEntryNumberWithBestIndex ; Definition at line 5910 of file TTree.cxx. ◆ GetEntryWithIndex(). Int_t TTree::GetEntryWithIndex ; (; Int_t ; major, . Int_t ; minor = 0 . ). virtual . Read entry corresponding to major and minor number. ; The function returns the total number of bytes read. If the Tree has friend trees, the corresponding entry with the index values (major,minor) is read. Note that the master Tree and its friend may have different entry serial numbers corresponding to (major,minor). ; Reimplemented in TChain.; Definition at line 5927 of file TTree.cxx. ◆ GetEstimate(). virtual Long64_t TTree::GetEstimate ; (; ); const. inlinevirtual . Definition at line 507 of file TTree.h. ◆ GetEvent(). Int_t TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:157830,perform,performs,157830,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['perform'],['performs']
Performance,"the data member named 'name' as a target. ;  ;  operator bool ();  . #include <TSchemaRuleSet.h>. Inheritance diagram for ROOT::Detail::TSchemaRuleSet::TMatches:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ GetRuleWithSource(). const TSchemaRule * TSchemaRuleSet::TMatches::GetRuleWithSource ; (; const TString & ; name); const. Return the rule that has 'name' as a source. ; Definition at line 468 of file TSchemaRuleSet.cxx. ◆ GetRuleWithTarget(). const TSchemaRule * TSchemaRuleSet::TMatches::GetRuleWithTarget ; (; const TString & ; name); const. Return the rule that has 'name' as a target. ; Definition at line 479 of file TSchemaRuleSet.cxx. ◆ HasRuleWithSource(). Bool_t TSchemaRuleSet::TMatches::HasRuleWithSource ; (; const TString & ; name, . Bool_t ; needingAlloc . ); const. Return true if the set of rules has at least one rule that has the data member named 'name' as a source. ; If needingAlloc is true, only the rule that requires the data member to be cached will be taken in consideration. ; Definition at line 493 of file TSchemaRuleSet.cxx. ◆ HasRuleWithTarget(). Bool_t TSchemaRuleSet::TMatches::HasRuleWithTarget ; (; const TString & ; name, . Bool_t ; willset . ); const. Return true if the set of rules has at least one rule that has the data member named 'name' as a target. ; If willset is true, only the rule that will set the value of the data member. ; Definition at line 523 of file TSchemaRuleSet.cxx. ◆ operator bool(). ROOT::Detail::TSchemaRuleSet::TMatches::operator bool ; (; ). inline . Definition at line 31 of file TSchemaRuleSet.h. Libraries for ROOT::Detail::TSchemaRuleSet::TMatches:. [legend]; The documentation for this class was generated from the following files:; core/meta/inc/TSchemaRuleSet.h; core/meta/src/TSchemaRuleSet.cxx. ROOTDetailTSchemaRuleSetTMatches. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet_1_1TMatches.html:1959,cache,cached,1959,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet_1_1TMatches.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet_1_1TMatches.html,1,['cache'],['cached']
Performance,"the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void recalculateCache(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& b); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:15556,cache,cache,15556,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,4,"['cache', 'load']","['cache', 'loaded']"
Performance,"the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:16617,cache,cache,16617,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,6,"['cache', 'load']","['cache', 'loaded']"
Performance,"the declaration of this class. ;  ; ROOT::DelFunc_t GetDelete () const;  Return the wrapper around delete ThiObject. ;  ; ROOT::DelArrFunc_t GetDeleteArray () const;  Return the wrapper around delete [] ThiObject. ;  ; ROOT::DesFunc_t GetDestructor () const;  Return the wrapper around the destructor. ;  ; ROOT::DirAutoAdd_t GetDirectoryAutoAdd () const;  Return the wrapper around the directory auto add function. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; Short_t GetImplFileLine () const;  ; const char * GetImplFileName () const;  ; UInt_t GetInstanceCount () const;  ; TVirtualIsAProxy * GetIsAProxy () const;  Return the proxy implementing the IsA functionality. ;  ; TVirtualStreamerInfo * GetLastReadInfo () const;  ; TList * GetListOfAllPublicDataMembers (Bool_t load=kTRUE);  Returns a list of all public data members of this class and its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ;  ; TList * GetListOfBases ();  Return list containing the TBaseClass(es) of a class. ;  ; TList * GetListOfDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of a class. ;  ; TList * GetListOfEnums (Bool_t load=kTRUE);  Return a list containing the TEnums of a class. ;  ; TList * GetListOfFunctionTemplates (Bool_t load=kTRUE);  Return TListOfFunctionTemplates for a class. ;  ; TCollection * GetListOfMethodOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TList * GetListOfMethods (Bool_t load=kTRUE);  Return list containing the TMethods of a class. ;  ; TList * GetListOfRealData () const;  ; TList * GetListOfUsingDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of using declarations of a class. ;  ; void GetMenuItems (TList *listitems);  Returns list of methods accessible by context menu. ;  ; TList * GetMenuList () const;  Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:13087,load,load,13087,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['load'],['load']
Performance,"the executed command (float and double return values will be truncated). ; Definition at line 2423 of file TCling.cxx. ◆ HasASTFileOnDisk(). static bool HasASTFileOnDisk ; (; clang::Module * ; M, . const clang::Preprocessor & ; PP, . std::string * ; FullFileName = nullptr . ). static . Checks if there is an ASTFile on disk for the given module M. ; Definition at line 1065 of file TCling.cxx. ◆ hasParsedRootmapForLibrary(). static bool hasParsedRootmapForLibrary ; (; llvm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:14787,load,loadGlobalModuleIndex,14787,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['load'],['loadGlobalModuleIndex']
Performance,"the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270243,optimiz,optimization,270243,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimization']
Performance,"the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:29304,cache,cache,29304,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"the file containing the class declaration ; Definition at line 227 of file Factory.h. ◆ DeleteAllMethods(). void TMVA::Factory::DeleteAllMethods ; (; void ; ). Delete methods. ; Definition at line 324 of file Factory.cxx. ◆ EvaluateAllMethods(). void TMVA::Factory::EvaluateAllMethods ; (; void ; ). Iterates over all MVAs that have been booked, and calls their evaluation methods. ; Definition at line 1376 of file Factory.cxx. ◆ EvaluateAllVariables(). void TMVA::Factory::EvaluateAllVariables ; (; DataLoader * ; loader, . TString ; options = """" . ). Iterates over all MVA input variables and evaluates them. ; Definition at line 1360 of file Factory.cxx. ◆ EvaluateImportance(). TH1F * TMVA::Factory::EvaluateImportance ; (; DataLoader * ; loader, . VIType ; vitype, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). Evaluate Variable Importance. ; Definition at line 2217 of file Factory.cxx. ◆ EvaluateImportanceAll(). TH1F * TMVA::Factory::EvaluateImportanceAll ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2246 of file Factory.cxx. ◆ EvaluateImportanceRandom(). TH1F * TMVA::Factory::EvaluateImportanceRandom ; (; DataLoader * ; loader, . UInt_t ; nseeds, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2473 of file Factory.cxx. ◆ EvaluateImportanceShort(). TH1F * TMVA::Factory::EvaluateImportanceShort ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2358 of file Factory.cxx. ◆ GetImportance(). TH1F * TMVA::Factory::GetImportance ; (; const int ; nbits, . std::vector< Double_t > ; importances, . std::vector< TString > ; varNames . ). private . Definition at line 2591 of file Factory.cxx. ◆ GetMethod(). TMVA::IMethod * TMVA::Factory::GetMethod ; (; const TString & ; datasetnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:24374,load,loader,24374,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"the fit if all RooAbsArg object in the model support it. . legacy The original likelihood evaluation method. Evaluates the PDF for each single data entry at a time before summing the negative log probabilities. . codegen Experimental - Generates and compiles minimal C++ code for the NLL on-the-fly and wraps it in the returned RooAbsReal. Also generates and compiles the code for the gradient using Automatic Differentiation (AD) with Clad. This analytic gradient is passed to the minimizer, which can result in significant speedups for many-parameter fits, even compared to the cpu backend. However, if one of the RooAbsArg objects in the model does not support the code generation, this backend can't be used. . codegen_no_grad Experimental - Same as codegen, but doesn't generate and compile the gradient code and use the regular numerical differentiation instead. This is expected to be slower, but useful for debugging problems with the analytic gradient. . Optimize(bool flag) Activate constant term optimization (on by default) . SplitRange(bool flag) Use separate fit ranges in a simultaneous fit. Actual range name for each subsample is assumed to be rangeName_indexState, where indexState is the state of the master index category of the simultaneous fit. Using Range(""range""), SplitRange() as switches, different ranges could be set like this: myVariable.setRange(""range_pi0"", 135, 210);; myVariable.setRange(""range_gamma"", 50, 210);; . Constrain(const RooArgSet&pars) For p.d.f.s that contain internal parameter constraint terms (that is usually product PDFs, where one term of the product depends on parameters but not on the observable(s),), only apply constraints to the given subset of parameters. . ExternalConstraints(const RooArgSet& ) Include given external constraints to likelihood by multiplying them with the original likelihood. . GlobalObservables(const RooArgSet&) Define the set of normalization observables to be used for the constraint terms. If none are specified the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:91965,optimiz,optimization,91965,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['optimiz'],['optimization']
Performance,"the following snippet evaluates the root mean square of column ""x"": // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);; ; df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; Notice how we created one double variable for each processing slot and later merged their results via std::accumulate. Dataset joins with friend trees; Vertically concatenating multiple trees that have the same columns (cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:68833,concurren,concurrent,68833,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrent']
Performance,"the friend trees can be referred to by their full name, like in the example above, or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; NoteA common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original one: rows will be mismatched.; Indexed friend trees provide a way to perform simple joins of multiple trees over a common column. When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the ""index"" columns have a value identical to the one in the main one. For example, in Python:; main_tree = ...; aux_tree = ...; ; # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""); ; mainTree.AddFriend(aux_tree); ; df = ROOT.RDataFrame(mainTree); RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats.; RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns and to advance the readers to the desired data entry. Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files: auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:71700,load,loads,71700,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['load'],['loads']
Performance,"the geometry are arbitrary. However, there are certain functionalities that work with the assumption that the used lengths are expressed in centimeters. This is the case for shape capacity or volume weight computation. The same is valid when using the ROOT geometry as navigator for an external transport MC package (e.g. GEANT) via the VMC interface.; Other units in use: All angles used for defining rotation matrices or some shape parameters are expressed in degrees. Material density is expressed in [g/cm3].; 18.3.2 Primitive Shapes; 18.3.2.1 Boxes - TGeoBBox Class; Normally a box has to be built only with 3 parameters: DX,DY,DZ representing the half-lengths on X, Y and Z-axes. In this case, the origin of the box will match the one of its reference frame and the box will range from: -DX to DX on X-axis, from -DY to DY on Y and from -DZ to DZ on Z. On the other hand, any other shape needs to compute and store the parameters of their minimal bounding box. The bounding boxes are essential to optimize navigation algorithms. Therefore all other primitives derive from TGeoBBox. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation (Ox,Oy,Oz). All primitive constructors automatically compute the bounding box parameters. Users should be aware that building a translated box that will represent a primitive shape by itself would affect any further positioning of other shapes inside. Therefore it is highly recommendable to build non-translated boxes as primitives and translate/rotate their corresponding volumes only during positioning stage.; TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);. TGeoBBox class. 18.3.2.2 Parallelepiped - TGeoPara class; A parallelepiped is a shape having 3 pairs of parallel faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis. TGeoPara class. The shape has the center in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:899606,optimiz,optimize,899606,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimize']
Performance,"the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:5758,load,loaded,5758,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,10,['load'],['loaded']
Performance,"the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id: TMinuitMinimizer.h 35643 2010-09-23 12:48:32Z moneta $ » Last generated: 2010-12-10 08:04; This page has been automatically gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuitMinimizer.html:10426,perform,perform,10426,root/html528/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html,1,['perform'],['perform']
Performance,"the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id: TMinuitMinimizer.h 39420 2011-05-26 15:00:28Z moneta $ » Last generated: 2011-07-04 15:35; This page has been automatically gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMinuitMinimizer.html:10756,perform,perform,10756,root/html530/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html530/TMinuitMinimizer.html,1,['perform'],['perform']
Performance,"the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ; Definition at line 43 of file RooFFTConvPdf.h. ◆ bufferStrategy(). BufStrat RooFFTConvPdf::bufferStrategy ; (; ); const. inline . Return the strategy currently used to fill the buffer: 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range 'Flat' means that the buffer is filled with the p.d.f. ; value at the boundary of the observable range 'Mirror' means that the buffer is filled with a mirror image of the p.d.f. around the convolution observable boundary ; Definition at line 52 of file RooFFTConvPdf.h. ◆ cacheObservables(). const RooArgSet & RooFFTConvPdf::cacheObservables ; (; ); const. inline . Definition at line 39 of file RooFFTConvPdf.h. ◆ calcParams(). void RooFFTConvPdf::calcParams ; (; ). protected . (Re)calculate effective parameters of this p.d.f. ; Definition at line 957 of file RooFFTConvPdf.cxx. ◆ Class(). static TClass * RooFFTConvPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFFTConvPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFFTConvPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 124 of file RooFFTConvPdf.h. ◆ clone(). TObject * RooFFTConvPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 34 of file RooFFTConvPdf.h. ◆ createCache(). RooFFTConvPdf::PdfCacheElem * RooFFTConvPdf::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Return specialized cache subclass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:88779,cache,cacheObservables,88779,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cacheObservables']
Performance,"the integral over the function; represented by this histogram. Double_t sum(const RooArgSet& sumSet, const RooArgSet& sliceSet, Bool_t correctForBinSize, Bool_t inverseCorr, const map<const RooAbsArg*,std::pair<Double_t,Double_t> >& ranges); Return the sum of the weights of a multi-dimensional slice of the histogram; by summing only over the dimensions specified in sumSet. The coordinates of all other dimensions are fixed to those given in sliceSet. If correctForBinSize is specified, the sum of weights; is multiplied by the M-dimensional bin volume, (M = N(sumSet)),; or the fraction of it that falls inside the range rangeName,; making the return value the integral over the function; represented by this histogram. If correctForBinSize is not specified, the weights are multiplied by the; fraction of the bin volume that falls inside the range, i.e. a factor or; binVolumeInRange/totalBinVolume. void calculatePartialBinVolume(const RooArgSet& dimSet) const; Fill the transient cache with partial bin volumes with up-to-date; values for the partial volume specified by observables 'dimSet'. Int_t numEntries() const; Return the number of bins. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified); Return the. void reset(); Reset all bin weights to zero. const RooArgSet* get(Int_t masterIdx) const; Return an argset with the bin center coordinates for; bin sequential number 'masterIdx'. For iterative use. const RooArgSet* get(const RooArgSet& coord) const; Return a RooArgSet with center coordinates of the bin; enclosing the point 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:32960,cache,cache,32960,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,2,['cache'],['cache']
Performance,"the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:143153,load,load,143153,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"the language does not allow to add members.; 3827 if (!(*data).IsLoaded()); 3828 (*data).Load();; 3829 ; 3830 } else if (load) (*data).Load();; 3831 return data;; 3832}; 3833 ; 3834////////////////////////////////////////////////////////////////////////////////; 3835/// Return list containing the TDataMembers of a class.; 3836 ; 3837TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3838{; 3839 // Fast path, no lock? Classes load at creation time.; 3840 if (IsClassStructOrUnion()) {; 3841 auto data = fData.load();; 3842 if (data && data->IsLoaded()); 3843 return data;; 3844 } else if (!load && fData); 3845 return fData;; 3846 ; 3847 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3848}; 3849 ; 3850////////////////////////////////////////////////////////////////////////////////; 3851/// Return list containing the TDataMembers of using declarations of a class.; 3852 ; 3853TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3854{; 3855 // Fast path, no lock? Classes load at creation time.; 3856 if ((!load || IsClassStructOrUnion()) && fUsingData); 3857 return fUsingData;; 3858 ; 3859 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3860}; 3861 ; 3862////////////////////////////////////////////////////////////////////////////////; 3863/// Return TListOfFunctionTemplates for a class.; 3864 ; 3865TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3866{; 3867 R__LOCKGUARD(gInterpreterMutex);; 3868 ; 3869 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3870 if (load) fFuncTemplate->Load();; 3871 return fFuncTemplate;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Return list containing the TMethods of a class.; 3876/// If load is true, the list is populated with all the defined function; 3877/// and currently instantiated function template.; 3878 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:145904,load,load,145904,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.; The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly. Clock Adjustment; UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is read and incremented, and then added to the UTC time field of the UUID. Clock Overrun; The 100-nanosecond granularity of time should prove sufficient even for bursts of UUID production in the next generation of high-performance multiprocessors. If a system overruns the clock adjustment by requesting too many UUIDs within a single system clock tick, the UUID generator will stall until the system clock catches up. ; Definition at line 42 of file TUUID.h. Classes; struct  uuid_time_t;  . Public Member Functions;  TUUID ();  Create a UUID. ;  ;  TUUID (const char *uuid_str);  Initialize a TUUID with uuid (which must be in TUUID::AsString() format). ;  ; virtual ~TUUID ();  delete this TUUID ;  ; const char * AsString () const;  Return UUID as string. Copy string immediately since it will be reused. ;  ; Int_t Compare (const TUUID &u) const;  Compare two UUIDs ""lexically"" and return. ;  ; void FillBuffer (char *&buffer);  Stream UUID into output buffer. ;  ; TInetAddress GetHostAddress () const;  Get address of host encoded in UUID. ;  ; TDatime GetTime () const;  Get time from UUID. ;  ; void GetUUID (UChar_t uuid[16]) const;  Return uuid in sp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:4307,perform,performance,4307,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['perform'],['performance']
Performance,"the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitEditor.html:4297,perform,performs,4297,root/html528/TFitEditor.html,https://root.cern,https://root.cern/root/html528/TFitEditor.html,6,['perform'],['performs']
Performance,"the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitEditor.html:4297,perform,performs,4297,root/html602/TFitEditor.html,https://root.cern,https://root.cern/root/html602/TFitEditor.html,4,['perform'],['performs']
Performance,"the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual void SetIncludePath (const char *includePath);  IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ;  ; virtual void SetLinkdefSuffix (const char *suffix);  The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary. ;  ; virtual void SetLinkedLibs (const char *linkedLibs);  LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable. ;  ; virtual void SetMakeExe (const char *directives);  Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable. ;  ; virtual void SetMakeSharedLib (const char *directives);  Directives should contain the description on how to compile and link a shared lib. ;  ; virtual void SetObjExt (const char *objExt);  Set object files extension, should be either .o, .obj, etc. ;  ; virtual void SetSoExt (const char *soExt);  Set shared library extension, should be either .so, .sl, .a, .dll, etc. ;  ; virtual void ShowOutput (RedirectHandle_t *h);  Display the content associated with the redirection described by the opaque handle 'h'. ;  ; virtual TString SplitAcl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:20242,load,loaded,20242,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['load'],['loaded']
Performance,"the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207660,cache,cache,207660,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cache']
Performance,"the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8534 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210151,cache,cache,210151,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['cache'],['cache']
Performance,"the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindings for the ROOT class library in a generic way using the Cling dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, PyROOT can be loaded into the Cling interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefits of PyROOT is through a few examples.; 19.1.1 Glue-ing Applications; The PyQt library, see http://www.riverbankcomputing.co.uk/pyqt, provides Python bindings for the Qt cross-platform GUI framework ( http://www.trolltech.com). With PyROOT and PyQt, adding ROOT application layer code to a Qt GUI, becomes children play. The following example shows how a Python class can be used to have ROOT code respond to a click on a Qt widget.; # Glue-ing Qt and ROOT through Python; import sys, ROOT; from qt import *. theApp = QApplication( sys.argv); box = QVBox(); box.resize(QSize(40,10).expandedTo(box.minimumSizeHint())). class myButton(QPushButton):; def __init__( self,label,master):; QPushButton.__init__(self,label,master); self.setFont( QFont('Times',18,QFont.Bold)). def browse(self):; self.b = ROOT.TBrowser(). bb = myButton('browser',box); QObject.connect( bb,SIGNAL('clicked()'),bb.browse). theA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1042678,load,loaded,1042678,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"the rotation is applied on the alignment variables.; SetRotation and LayoutGlyphs should have been called before. void DrawImage(FT_Bitmap* source, ULong_t fore, ULong_t back, XImage* xim, Int_t bx, Int_t by); Draw FT_Bitmap bitmap to xim image at position bx,by using specified; foreground color. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. XImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:27590,Perform,Perform,27590,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,1,['Perform'],['Perform']
Performance,"the serverList. ; Parameters. serverListTest if one of the elements in this list serves values to this. ; ignoreArgIgnore values served by this object. . ReturnsTrue if values are served. ; Definition at line 108 of file RooAbsArg.h. ◆ expensiveObjectCache(). RooExpensiveObjectCache & RooAbsArg::expensiveObjectCache ; (; ); const. Definition at line 2324 of file RooAbsArg.cxx. ◆ fillTreeBranch(). virtual void RooAbsArg::fillTreeBranch ; (; TTree & ; t). protectedpure virtual . Implemented in RooAbsCategory, RooAbsReal, RooRealVar, and RooStringVar. ◆ findConstantNodes() [1/2]. bool RooAbsArg::findConstantNodes ; (; const RooArgSet & ; observables, . RooArgSet & ; cacheList . ). Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ; Definition at line 1859 of file RooAbsArg.cxx. ◆ findConstantNodes() [2/2]. bool RooAbsArg::findConstantNodes ; (; const RooArgSet & ; observables, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ; Definition at line 1877 of file RooAbsArg.cxx. ◆ findNewServer(). RooAbsArg * RooAbsArg::findNewServer ; (; const RooAbsCollection & ; newSet, . bool ; nameChange . ); const. Find the new server in the specified set that matches the old server. ; Parameters. [in]newSetSearch this set by name for a new server. ; [in]nameChangeIf true, search for an item with the bool attribute ""ORIGNAME:<oldName>"" set. Use <object>.setAttribute(""ORIGNAME:<oldName>"") to set this attribute. . ReturnsPointer to the new server or nullptr if there's no unique match. ; Definition at line 1201 of file RooAbsArg.cxx. ◆ findServer() [1/3]. RooAbsArg * RooAbsArg::findServer ; (; const char * ; name); const. inline . Return server of this with name name. Returns nullptr if not found. ; Definition at line 184 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:59818,cache,cacheList,59818,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cacheList']
Performance,"the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050512,load,loading,1050512,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loading']
Performance,"the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as. (15). where. (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate. (17). The model ; can therefore be written as. The original model ; is therefore identical with; this if. (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5]. Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. Define ; are the 5 dependent; quantities that define a track. Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; . Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; . Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:9982,perform,perform,9982,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['perform'],['perform']
Performance,"the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The two_dim_fit structure has the form of; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:47069,optimiz,optimization,47069,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['optimiz'],['optimization']
Performance,"the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat' CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:27259,perform,performances,27259,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performances']
Performance,"the storage tree from the name and title of this instance. ;  ; void setBranchBufferSize (Int_t size);  ; RooArgSet varsNoWeight (const RooArgSet &allVars, const char *wgtName=nullptr);  Utility function for constructors Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. ;  ; RooRealVar * weightVar (const RooArgSet &allVars, const char *wgtName=nullptr);  Utility function for constructors Return pointer to weight variable if it is defined. ;  . Private Attributes; RooArgSet _attachedBuffers;  ! Currently attached buffers (if different from _varsww) ;  ; const RooAbsArg * _cacheOwner = nullptr;  TTree holding the cached function values. ;  ; TTree * _cacheTree = nullptr;  ; double _curWgt = 1.0;  Buffer for weights in case a batch of values is requested. ;  ; double _curWgtErr = 0.0;  Weight of current event. ;  ; double _curWgtErrHi = 0.0;  Weight of current event. ;  ; double _curWgtErrLo = 0.0;  Weight of current event. ;  ; bool _defCtor = false;  Object owning cache contents. ;  ; const double * _extSumW2Array {nullptr};  ! External sum of weights array ;  ; const double * _extWgtArray {nullptr};  ! External weight array ;  ; const double * _extWgtErrHiArray {nullptr};  ! External weight array - high error ;  ; const double * _extWgtErrLoArray {nullptr};  ! External weight array - low error ;  ; TTree * _tree = nullptr;  ; RooArgSet _varsww;  Was object constructed with default ctor? ;  ; std::unique_ptr< std::vector< double > > _weightBuffer;  ; RooRealVar * _wgtVar = nullptr;  . Static Private Attributes; static Int_t _defTreeBufSize = 10*1024*1024;  . Friends; class RooVectorDataStore;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDepr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:21328,cache,cache,21328,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cache']
Performance,"the system's host name. ;  ; virtual void IgnoreInterrupt (Bool_t ignore=kTRUE);  If ignore is true ignore the interrupt signal, else restore previous behaviour. ;  ; virtual void IgnoreSignal (ESignals sig, Bool_t ignore=kTRUE);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void Openlog (const char *name,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebSystem.html:12170,load,loaded,12170,doc/master/classTWebSystem.html,https://root.cern,https://root.cern/doc/master/classTWebSystem.html,1,['load'],['loaded']
Performance,"the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:50491,load,loaded,50491,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,10,['load'],['loaded']
Performance,"the total estimated memory use for writing. The default values are tuned for a total write memory of around 300 MB per fill context. ; Definition at line 82 of file RNTupleWriteOptions.hxx. ◆ fUseBufferedWrite. bool ROOT::Experimental::RNTupleWriteOptions::fUseBufferedWrite = true. protected . Whether to use buffered writing (with RPageSinkBuf). ; This buffers compressed pages in memory, reorders them to keep pages of the same column adjacent, and coalesces the writes when committing a cluster. ; Definition at line 85 of file RNTupleWriteOptions.hxx. ◆ fUseDirectIO. bool ROOT::Experimental::RNTupleWriteOptions::fUseDirectIO = false. protected . Whether to use Direct I/O for writing. ; Note that this introduces alignment requirements that may very between filesystems and platforms. ; Definition at line 88 of file RNTupleWriteOptions.hxx. ◆ fUseImplicitMT. EImplicitMT ROOT::Experimental::RNTupleWriteOptions::fUseImplicitMT = EImplicitMT::kDefault. protected . Whether to use implicit multi-threading to compress pages. Only has an effect if buffered writing is turned on. ; Definition at line 93 of file RNTupleWriteOptions.hxx. ◆ fWriteBufferSize. std::size_t ROOT::Experimental::RNTupleWriteOptions::fWriteBufferSize = 4 * 1024 * 1024. protected . Buffer size to use for writing to files, must be a multiple of 4096 bytes. ; Testing suggests that 4MiB gives best performance (with Direct I/O) at a reasonable memory consumption. ; Definition at line 91 of file RNTupleWriteOptions.hxx. ◆ kDefaultMaxKeySize. constexpr std::uint64_t ROOT::Experimental::RNTupleWriteOptions::kDefaultMaxKeySize = 0x4000'0000. staticconstexpr . Definition at line 56 of file RNTupleWriteOptions.hxx. Libraries for ROOT::Experimental::RNTupleWriteOptions:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx; tree/ntuple/v7/src/RNTupleWriteOptions.cxx. ROOTExperimentalRNTupleWriteOptions. ROOT master - Reference Guide Generat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:12642,multi-thread,multi-threading,12642,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['multi-thread'],['multi-threading']
Performance,"the tree will be set. It is normally not necessary to make changes to the generated code, but the routine can be extended by the user if needed. Init() will be called many times when running on PROOF (once per file to be processed). ; Reimplemented from TSelector.; Definition at line 129 of file TSelectorEntries.cxx. ◆ IsA(). TClass * TSelectorEntries::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelectorEntries.h. ◆ Notify(). bool TSelectorEntries::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 136 of file TSelectorEntries.cxx. ◆ Process(). bool TSelectorEntries::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 161 of file TSelectorEntries.cxx. ◆ SetObject(). void TSelectorEntries::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelectorEntries.h. ◆ SetOption(). void TSelectorEntries::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:17776,load,loaded,17776,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,1,['load'],['loaded']
Performance,"the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we chang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:16508,cache,cache,16508,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very import",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCacheUnzip.html:14564,cache,cache,14564,root/html532/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html532/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15765,perform,perform,15765,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['perform'],['perform']
Performance,"the vertical layout manager which arranges its widgets vertically in a column.; The next widget we create as a child of the main frame is the horizontal frame hframe:; TGHorizontalFrame *hframe=new TGHorizontalFrame(fMain,200,40);; The first parameter of its constructor is again the address of its parent, fMain. The next ones define the frame width and height in pixels. The name of the class TGHorizontalFrame gives a hint that a horizontal layout will apply on its children widgets. The Draw and Exit buttons will be laid out horizontally. Here are their constructors:; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; hframe ->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate(0)"");; hframe ->AddFrame(exit,new TGLayoutHints(kLHintsCenterX,5,5,3,4));; They are created as objects of the TGTextButton class that represent the command buttons with a text label. When you click on a command button it performs the action shown on its label. These buttons are well known as “push buttons” or just “buttons”. The parent address hframe is passed as first parameter. The second one defines the button label and normally indicates the action to be taken when the button is clicked. It is possible to define a hot key for the button at that point using the hot string for its label. A hot string is a string with a “hot” character underlined. This character we call the button hot key. It shows the assigned keyboard mnemonic for the button choice. Following our example, this means that you can use Alt+D to click on Draw button and Alt+E to click on Exit. There is a possibility to specify a command string as third parameter of the button constructor. We use it to assign the command gApplication->Terminate(0). The application will be terminated when you click on the Exit button.; We call again AddFrame() to add the buttons to their parent widget giving layout hints for each of them. This time we wou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1137643,perform,performs,1137643,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performs']
Performance,"the view widget. void AddLineFast(const char* string); Add a line of text to the view widget.; Fast version. Use it if you are going to add; several lines, than call Update(). void Update(); update the whole window of text view. Long_t ReturnLongestLineWidth(); Return width of longest line. Bool_t Search(const char* string, Bool_t direction, Bool_t caseSensitive); Search for string in text. If direction is true search forward.; Returns true if string is found. void SetFont(FontStruct_t font); Changes text entry font. Long_t ToScrYCoord(Long_t yCoord); Convert line number to screen coordinate. Long_t ToScrXCoord(Long_t xCoord, Long_t line); Convert column number in specified line to screen coordinate. Long_t ToObjYCoord(Long_t yCoord); Convert y screen coordinate to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t Handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextView.html:26028,Load,LoadFile,26028,root/html532/TGTextView.html,https://root.cern,https://root.cern/root/html532/TGTextView.html,8,['Load'],"['Load', 'LoadFile']"
Performance,"the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:17231,cache,cache,17231,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,10,['cache'],['cache']
Performance,"the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:4077,perform,perform,4077,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,6,['perform'],['perform']
Performance,"theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFumili.html:18243,perform,performs,18243,root/html602/TFumili.html,https://root.cern,https://root.cern/root/html602/TFumili.html,4,['perform'],['performs']
Performance,"ther so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:3972,perform,performing,3972,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['perform'],['performing']
Performance,"ther the event has passed the selection (true) or not (false).; 182 /// \param[in] columns Names of the columns/branches in input to the filter function.; 183 /// \param[in] name Optional name of this filter. See `Report`.; 184 /// \return the filter node of the computation graph.; 185 ///; 186 /// Append a filter node at the point of the call graph corresponding to the; 187 /// object this method is called on.; 188 /// The callable `f` should not have side-effects (e.g. modification of an; 189 /// external or static variable) to ensure correct results when implicit; 190 /// multi-threading is active.; 191 ///; 192 /// RDataFrame only evaluates filters when necessary: if multiple filters; 193 /// are chained one after another, they are executed in order and the first; 194 /// one returning false causes the event to be discarded.; 195 /// Even if multiple actions or transformations depend on the same filter,; 196 /// it is executed once per entry. If its result is requested more than; 197 /// once, the cached result is served.; 198 ///; 199 /// ### Example usage:; 200 /// ~~~{.cpp}; 201 /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; 202 /// auto filtered = df.Filter(myCut, {""x"", ""y""});; 203 ///; 204 /// // String: it must contain valid C++ except that column names can be used instead of variable names; 205 /// auto filtered = df.Filter(""x*y > 0"");; 206 /// ~~~; 207 ///; 208 /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; 209 /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; 210 /// ~~~{.cpp}; 211 /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); 212 /// ~~~; 213 /// but instead this will:; 214 /// ~~~{.cpp}; 215 /// df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); 216 /// ~~~; 217 template <typename F, std::enable_if_t<!std::is_convertible<F, std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:8808,cache,cached,8808,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cached']
Performance,ther to send the full entry per each packet. ; Definition at line 100 of file TPerfStats.h. ◆ fNodeHist. TH1D* TPerfStats::fNodeHist. private . histogram of events processed per slave ; Definition at line 81 of file TPerfStats.h. ◆ fNumEvents. Long64_t TPerfStats::fNumEvents. private . total number of events processed ; Definition at line 89 of file TPerfStats.h. ◆ fOutput. TList* TPerfStats::fOutput. private . Saved pointer to the TDSet object. ; Definition at line 106 of file TPerfStats.h. ◆ fPacketsHist. TH1D* TPerfStats::fPacketsHist. private . TPerfEvent used to fill tree. ; Definition at line 78 of file TPerfStats.h. ◆ fPerfEvent. TPerfEvent* TPerfStats::fPerfEvent. private . start time of this run ; Definition at line 77 of file TPerfStats.h. ◆ fProcPcktHist. TH1I* TPerfStats::fProcPcktHist. private . histogram of packets processed per slave ; Definition at line 79 of file TPerfStats.h. ◆ fProcTimeHist. TH2D* TPerfStats::fProcTimeHist. private . histogram of latency due to packet requests ; Definition at line 83 of file TPerfStats.h. ◆ fSlaves. Int_t TPerfStats::fSlaves. private . total number of events to be processed ; Definition at line 90 of file TPerfStats.h. ◆ fTotBytesRead. Long64_t TPerfStats::fTotBytesRead. private . total cpu time of all slaves ; Definition at line 87 of file TPerfStats.h. ◆ fTotCpuTime. Double_t TPerfStats::fTotCpuTime. private . track bytes read of main file ; Definition at line 86 of file TPerfStats.h. ◆ fTotEvents. Long64_t TPerfStats::fTotEvents. private . total bytes read on all slaves ; Definition at line 88 of file TPerfStats.h. ◆ fTrace. TTree* TPerfStats::fTrace. private . Definition at line 75 of file TPerfStats.h. ◆ fTzero. TTimeStamp TPerfStats::fTzero. private . TTree with trace events. ; Definition at line 76 of file TPerfStats.h. proof/proofplayer/inc/TPerfStats.h; proof/proofplayer/src/TPerfStats.cxx. TPerfStats. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:09 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPerfStats.html:26017,latency,latency,26017,doc/master/classTPerfStats.html,https://root.cern,https://root.cern/doc/master/classTPerfStats.html,1,['latency'],['latency']
Performance,"ther); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidexpand(). Data Members; protected:. RooSetPair*_asArr! do not persist; RooHashTable*_htable! do not persist; RooNameSet_name1!; RooNameSet_name2!; Int_t_nreg; Int_t_regSize; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(Int_t regSize = 64); Construct normalization set manager with given initial size; _htable = regSize>16 ? new RooHashTable(regSize,RooHashTable::Intrinsic) : 0 ;. RooNormSetCache(const RooNormSetCache& other); Copy constructor. ~RooNormSetCache(); Destructor. void clear(); Clear contents. void initialize(const RooNormSetCache& other); Initialize cache from contents of given other cache. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. void expand(); Expand registry size by doubling capacity. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _nreg>0?_asArr[_nreg-1]._set1:0 ; }. const RooArgSet* lastSet2() const; { return _nreg>0?_asArr[_nreg-1]._set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNormSetCache.html:2723,cache,cache,2723,root/html530/RooNormSetCache.html,https://root.cern,https://root.cern/root/html530/RooNormSetCache.html,6,['cache'],['cache']
Performance,"ther, . const RooArgSet & ; vars, . const char * ; newname = nullptr . ). inline . Definition at line 42 of file RooAbsDataStore.h. Member Function Documentation. ◆ addColumn(). virtual RooAbsArg * RooAbsDataStore::addColumn ; (; RooAbsArg & ; var, . bool ; adjustRange = true . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ addColumns(). RooArgSet * RooAbsDataStore::addColumns ; (; const RooArgList & ; varList). Definition at line 60 of file RooAbsDataStore.cxx. ◆ append(). virtual void RooAbsDataStore::append ; (; RooAbsDataStore & ; other). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachBuffers(). virtual void RooAbsDataStore::attachBuffers ; (; const RooArgSet & ; extObs). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachCache(). virtual void RooAbsDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cacheArgs(). virtual void RooAbsDataStore::cacheArgs ; (; const RooAbsArg * ; cacheOwner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cachedVars(). const RooArgSet & RooAbsDataStore::cachedVars ; (; ); const. inline . Definition at line 130 of file RooAbsDataStore.h. ◆ cacheOwner(). virtual const RooAbsArg * RooAbsDataStore::cacheOwner ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ changeObservableName(). virtual bool RooAbsDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ checkInit(). virtual void RooAbsDataStore::checkInit ; (; ); con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:18817,cache,cachedVars,18817,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['cache'],['cachedVars']
Performance,therpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tfNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:21915,cache,cache,21915,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,10,['cache'],['cache']
Performance,"these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Mon Jul 4 15:21:25 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:38991,cache,cacheUniqueSuffix,38991,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,1,['cache'],['cacheUniqueSuffix']
Performance,"this class . ◆ Class_Version(). static constexpr Version_t TVirtualFFT::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 132 of file TVirtualFFT.h. ◆ DeclFileName(). static const char * TVirtualFFT::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 132 of file TVirtualFFT.h. ◆ FFT(). TVirtualFFT * TVirtualFFT::FFT ; (; Int_t ; ndim, . Int_t * ; n, . Option_t * ; option . ). static . Returns a pointer to the FFT of requested size and type. ; Parameters. [in]ndimnumber of transform dimensions ; [in]nsizes of each dimension (an array at least ndim long) ; [in]optionconsists of 3 parts - flag option and an option to create a new TVirtualFFT; transform type option: Available transform types are: C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT see class description for details; flag option: choosing how much time should be spent in planning the transform: Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type. option allowing to choose between the global fgFFT and a new TVirtualFFT object """" - default, changes and returns the global fgFFT variable ""K"" (from ""keep"")- without touching the global fgFFT, creates and returns a new TVirtualFFT*. User is then responsible for deleting it. Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. ; Definition at line 131 of file TVirtualFFT.cxx. ◆ GetCurrentTransform(). TVirtualFFT * TVirtualFFT::GetCurrentTransform ; (; ). static . static: ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFFT.html:16984,perform,performance,16984,doc/master/classTVirtualFFT.html,https://root.cern,https://root.cern/doc/master/classTVirtualFFT.html,1,['perform'],['performance']
Performance,this class. ; Definition at line 3463 of file TClass.cxx. ◆ GetDeclIdMap(). DeclIdMap_t * TClass::GetDeclIdMap ; (; ). staticprivate . Definition at line 480 of file TClass.cxx. ◆ GetDelete(). ROOT::DelFunc_t TClass::GetDelete ; (; ); const. Return the wrapper around delete ThiObject. ; Definition at line 7463 of file TClass.cxx. ◆ GetDeleteArray(). ROOT::DelArrFunc_t TClass::GetDeleteArray ; (; ); const. Return the wrapper around delete [] ThiObject. ; Definition at line 7471 of file TClass.cxx. ◆ GetDestructor(). ROOT::DesFunc_t TClass::GetDestructor ; (; ); const. Return the wrapper around the destructor. ; Definition at line 7479 of file TClass.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClass::GetDict ; (; const char * ; cname). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3422 of file TClass.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClass::GetDict ; (; const std::type_info & ; info). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3431 of file TClass.cxx. ◆ GetDirectoryAutoAdd(). ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd ; (; ); const. Return the wrapper around the directory auto add function. ; Definition at line 7487 of file TClass.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TClass::GetFunctionTemplate ; (; const char * ; name). Definition at line 3607 of file TClass.cxx. ◆ GetHeapInstanceCount(). UInt_t TClass::GetHeapInstanceCount ; (; ); const. inline . Definition at line 467 of file TClass.h. ◆ GetIdMap(). IdMap_t * TClass::GetIdMap ; (; ). staticprivate . Definition at line 469 of file TClass.cxx. ◆ GetImplFileLine(). Short_t TClass::GetImplFileLine ; (; ); const. inline . Definition at line 457 of file TClass.h. ◆ GetImplFileName(). const char * TClass::GetImplFileName ; (; ); const. inline . Definition at line 456 of file TClass.h. ◆ GetInstanceCount(). UInt_t TClass::GetInstanceCount ; (; ); const. inline . Definition at line 466 of ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:79603,load,loading,79603,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loading']
Performance,this class. ; Definition at line 3530 of file TClass.cxx. ◆ GetDeclIdMap(). DeclIdMap_t * TClass::GetDeclIdMap ; (; ). staticprivate . Definition at line 480 of file TClass.cxx. ◆ GetDelete(). ROOT::DelFunc_t TClass::GetDelete ; (; ); const. Return the wrapper around delete ThiObject. ; Definition at line 7530 of file TClass.cxx. ◆ GetDeleteArray(). ROOT::DelArrFunc_t TClass::GetDeleteArray ; (; ); const. Return the wrapper around delete [] ThiObject. ; Definition at line 7538 of file TClass.cxx. ◆ GetDestructor(). ROOT::DesFunc_t TClass::GetDestructor ; (; ); const. Return the wrapper around the destructor. ; Definition at line 7546 of file TClass.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClass::GetDict ; (; const char * ; cname). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3489 of file TClass.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClass::GetDict ; (; const std::type_info & ; info). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3498 of file TClass.cxx. ◆ GetDirectoryAutoAdd(). ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd ; (; ); const. Return the wrapper around the directory auto add function. ; Definition at line 7554 of file TClass.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TClass::GetFunctionTemplate ; (; const char * ; name). Definition at line 3674 of file TClass.cxx. ◆ GetHeapInstanceCount(). UInt_t TClass::GetHeapInstanceCount ; (; ); const. inline . Definition at line 467 of file TClass.h. ◆ GetIdMap(). IdMap_t * TClass::GetIdMap ; (; ). staticprivate . Definition at line 469 of file TClass.cxx. ◆ GetImplFileLine(). Short_t TClass::GetImplFileLine ; (; ); const. inline . Definition at line 457 of file TClass.h. ◆ GetImplFileName(). const char * TClass::GetImplFileName ; (; ); const. inline . Definition at line 456 of file TClass.h. ◆ GetInstanceCount(). UInt_t TClass::GetInstanceCount ; (; ); const. inline . Definition at line 466 of ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:79604,load,loading,79604,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loading']
Performance,"this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:24274,cache,cache,24274,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:45012,cache,cached,45012,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,2,['cache'],['cached']
Performance,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:49689,load,loaded,49689,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,16,['load'],['loaded']
Performance,"thline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTChain::fNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*TChain::fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TDSet*fSetTDSet; TList*TChain::fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*TChain::fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTChain::fTreeNumber! Current Tree number in fTreeOffset table; Long64_t*TChain::fTreeOffset[fTreeOffsetLen] Array of variables; Int_tTChain::fTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofChain.html:26324,load,loading,26324,root/html534/TProofChain.html,https://root.cern,https://root.cern/root/html534/TProofChain.html,6,['load'],['loading']
Performance,"thm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1493,perform,performed,1493,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,6,['perform'],['performed']
Performance,"thod(""FindDynamicLibrary"");; 2037 return nullptr;; 2038}; 2039 ; 2040////////////////////////////////////////////////////////////////////////////////; 2041/// Find specific entry point in specified library. Specify ""*"" for lib; 2042/// to search in all libraries.; 2043 ; 2044Func_t TSystem::DynFindSymbol(const char * /*lib*/, const char *entry); 2045{; 2046 return (Func_t) gInterpreter->FindSym(entry);; 2047}; 2048 ; 2049////////////////////////////////////////////////////////////////////////////////; 2050/// Unload a shared library.; 2051 ; 2052void TSystem::Unload(const char *module); 2053{; 2054 char *path;; 2055 if ((path = DynamicPathName(module))) {; 2056 gInterpreter->UnloadFile(path);; 2057 delete [] path;; 2058 }; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// List symbols in a shared library.; 2063 ; 2064void TSystem::ListSymbols(const char *, const char *); 2065{; 2066 AbstractMethod(""ListSymbols"");; 2067}; 2068 ; 2069////////////////////////////////////////////////////////////////////////////////; 2070/// List the loaded shared libraries.; 2071/// `regexp` is a regular expression allowing to filter the list.; 2072///; 2073/// Examples:; 2074///; 2075/// The following line lists all the libraries currently loaded:; 2076/// ~~~ {.cpp}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099/////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:66974,load,loaded,66974,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"thod, . const std::vector< TypeInfo_t * > & ; proto, . Longptr_t * ; Offset, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ); const. finalvirtual . Interface to cling function. ; Implements TInterpreter.; Definition at line 8085 of file TCling.cxx. ◆ CheckClassInfo(). TInterpreter::ECheckClassInfo TCling::CheckClassInfo ; (; const char * ; name, . Bool_t ; autoload, . Bool_t ; isClassOrNamespaceOnly = kFALSE . ). finalvirtual . Checks if an entity with the specified name is defined in Cling. ; Returns kUnknown if the entity is not defined. Returns kWithClassDefInline if the entity exists and has a ClassDefInline Returns kKnown if the entity is defined.; By default, structs, namespaces, classes, enums and unions are looked for. If the flag isClassOrNamespaceOnly is true, classes, structs and namespaces only are considered. I.e. if the name is an enum or a union, the returned value is false.; In the case where the class is not loaded and belongs to a namespace or is nested, looking for the full class name is outputting a lots of (expected) error messages. Currently the only way to avoid this is to specifically check that each level of nesting is already loaded. In case of templates the idea is that everything between the outer '<' and '>' has to be skipped, e.g.: aap<pippo<noot>::klaas>::a_class ; Implements TInterpreter.; Definition at line 4177 of file TCling.cxx. ◆ CheckClassTemplate(). Bool_t TCling::CheckClassTemplate ; (; const char * ; name). finalvirtual . Return true if there is a class template by the given name ... ; Implements TInterpreter.; Definition at line 4349 of file TCling.cxx. ◆ ClassInfo_ClassProperty(). Long_t TCling::ClassInfo_ClassProperty ; (; ClassInfo_t * ; info); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8176 of file TCling.cxx. ◆ ClassInfo_Contains(). Bool_t TCling::ClassInfo_Contains ; (; ClassInfo_t * ; info, . DeclId_t ; declid . ); const. finalvirtual . Return true if the entity pointed to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:67195,load,loaded,67195,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance,"thod; 429 ; 430 // set fDataSetManager if MethodCategory (to enable Category to create datasetinfo objects) // DSMTEST; 431 if (method->GetMethodType() == Types::kCategory) { // DSMTEST; 432 MethodCategory *methCat = (dynamic_cast<MethodCategory *>(im)); // DSMTEST; 433 if (!methCat) { // DSMTEST; 434 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Factory""; 435 << Endl; // DSMTEST; 436 return nullptr;; 437 }; 438 if (fModelPersistence); 439 methCat->SetWeightFileDir(fileDir);; 440 methCat->SetModelPersistence(fModelPersistence);; 441 methCat->fDataSetManager = loader->GetDataSetInfo().GetDataSetManager(); // DSMTEST; 442 methCat->SetFile(fgTargetFile);; 443 methCat->SetSilentFile(IsSilentFile());; 444 } // DSMTEST; 445 ; 446 if (!method->HasAnalysisType(fAnalysisType, loader->GetDataSetInfo().GetNClasses(),; 447 loader->GetDataSetInfo().GetNTargets())) {; 448 Log() << kWARNING << ""Method "" << method->GetMethodTypeName() << "" is not capable of handling "";; 449 if (fAnalysisType == Types::kRegression) {; 450 Log() << ""regression with "" << loader->GetDataSetInfo().GetNTargets() << "" targets."" << Endl;; 451 } else if (fAnalysisType == Types::kMulticlass) {; 452 Log() << ""multiclass classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 453 } else {; 454 Log() << ""classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 455 }; 456 return 0;; 457 }; 458 ; 459 if (fModelPersistence); 460 method->SetWeightFileDir(fileDir);; 461 method->SetModelPersistence(fModelPersistence);; 462 method->SetAnalysisType(fAnalysisType);; 463 method->SetupMethod();; 464 method->ParseOptions();; 465 method->ProcessSetup();; 466 method->SetFile(fgTargetFile);; 467 method->SetSilentFile(IsSilentFile());; 468 ; 469 // check-for-unused-options is performed; may be overridden by derived classes; 470 method->CheckSetup();; 471 ; 472 if (fMethodsMap.find(datasetname) == fMethodsMap.end()) {; 473 MVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:18567,load,loader,18567,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"thodCompositeBaseMethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); TMVA::MethodCompositeBaseMethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodCompositeBase&operator=(const TMVA::MethodCompositeBase&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCompositeBase.html:10293,Optimiz,OptimizeTuningParameters,10293,root/html602/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCompositeBase.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"thodCuts(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodCutsMethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidPrintCuts(Double_t effS) const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCuts.html:11209,Optimiz,OptimizeTuningParameters,11209,root/html532/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCuts.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,thodCuts.h. ◆ fCutRangeMin. Double_t* TMVA::MethodCuts::fCutRangeMin. private . minimum of allowed cut range ; Definition at line 175 of file MethodCuts.h. ◆ fEffBvsSLocal. TH1* TMVA::MethodCuts::fEffBvsSLocal. private . intermediate eff. background versus eff signal histo ; Definition at line 202 of file MethodCuts.h. ◆ fEffMethod. EEffMethod TMVA::MethodCuts::fEffMethod. private . chosen efficiency calculation method ; Definition at line 170 of file MethodCuts.h. ◆ fEffMethodS. TString TMVA::MethodCuts::fEffMethodS. private . chosen efficiency calculation method (string) ; Definition at line 169 of file MethodCuts.h. ◆ fEffRef. Double_t TMVA::MethodCuts::fEffRef. private . reference efficiency ; Definition at line 192 of file MethodCuts.h. ◆ fEffSMax. Double_t TMVA::MethodCuts::fEffSMax. private . used to test optimized signal efficiency ; Definition at line 174 of file MethodCuts.h. ◆ fEffSMin. Double_t TMVA::MethodCuts::fEffSMin. private . used to test optimized signal efficiency ; Definition at line 173 of file MethodCuts.h. ◆ fFitMethod. EFitMethodType TMVA::MethodCuts::fFitMethod. private . chosen fit method ; Definition at line 168 of file MethodCuts.h. ◆ fFitMethodS. TString TMVA::MethodCuts::fFitMethodS. private . chosen fit method (string) ; Definition at line 167 of file MethodCuts.h. ◆ fFitParams. std::vector<EFitParameters>* TMVA::MethodCuts::fFitParams. private . vector for series of fit methods ; Definition at line 171 of file MethodCuts.h. ◆ fgMaxAbsCutVal. const Double_t TMVA::MethodCuts::fgMaxAbsCutVal = 1.0e30. static . Definition at line 130 of file MethodCuts.h. ◆ fMeanB. std::vector<Double_t>* TMVA::MethodCuts::fMeanB. private . means of variables (background) ; Definition at line 198 of file MethodCuts.h. ◆ fMeanS. std::vector<Double_t>* TMVA::MethodCuts::fMeanS. private . means of variables (signal) ; Definition at line 197 of file MethodCuts.h. ◆ fNegEffWarning. Bool_t TMVA::MethodCuts::fNegEffWarning. private . flag risen in case of negati,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:49972,optimiz,optimized,49972,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['optimiz'],['optimized']
Performance,"thodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods not already in the; 3841/// list (also protected and private ones).; 3842/// - once finished, loop over resulting list and remove all private and; 3843/// protected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:145627,load,load,145627,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"thodOverloads(const char* name) const; 3895{; 3896 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3897}; 3898 ; 3899 ; 3900////////////////////////////////////////////////////////////////////////////////; 3901/// Returns a list of all public methods of this class and its base classes.; 3902/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3903/// GetListOfAllPublicMethods()->Delete().; 3904/// Algorithm used to get the list is:; 3905/// - put all methods of the class in the list (also protected and private; 3906/// ones).; 3907/// - loop over all base classes and add only those methods not already in the; 3908/// list (also protected and private ones).; 3909/// - once finished, loop over resulting list and remove all private and; 3910/// protected methods.; 3911 ; 3912const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3913{; 3914 R__LOCKGUARD(gInterpreterMutex);; 3915 ; 3916 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3917 if (load) {; 3918 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3919 fAllPubMethod->Load();; 3920 }; 3921 return fAllPubMethod;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Returns a list of all public data members of this class and its base; 3926/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3927/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3928 ; 3929TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3930{; 3931 R__LOCKGUARD(gInterpreterMutex);; 3932 ; 3933 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3934 if (load) fAllPubData->Load();; 3935 return fAllPubData;; 3936}; 3937 ; 3938////////////////////////////////////////////////////////////////////////////////; 3939/// Returns list of methods accessible b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:148378,load,load,148378,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"thout forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define gROOT   (ROOT::GetROOT());  . Functions; void ROOT::CallRecursiveRemoveIfNeeded (TObject &obj);  call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true. ;  ; void ROOT::DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void ROOT::Internal::DisableParBranchProcessing ();  Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ;  ; void ROOT::EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void ROOT::Internal::EnableParBranchProcessing ();  Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ;  ; void ROOT::EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; TROOT * ROOT::GetROOT ();  ; TROOT * ROOT::Internal::GetROOT2 ();  ; UInt_t ROOT::GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; Bool_t ROOT::IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; Bool_t ROOT::Internal::IsParBranchProcessingEnabled ();  Returns true if parallel branch processing is enabled. ;  ; Bool_t ROOT::Internal::RequiresCleanup (TObject &obj);  ; void ROOT::Internal::SetRequireCleanup (TObject &obj);  . Variables; R__EXTERN TROOT * ROOT::Internal::gROOTLocal = ROOT::GetROOT();  ; R__EXTERN TVirtualMutex * gROOTMutex;  . Macro Definition Documentation. ◆ gROOT. #define gROOT   (ROOT::GetROOT()). Definition at line 406 of file TROOT.h. Variable Documentation. ◆ gROOTMutex. R__EXTERN TVirtualMutex* gROOTMutex. Definition at line 63 of file TROOT.h. corebaseincTROOT.h. ROOT master - Reference Guide Generated on Tue Nov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h.html:1683,multi-thread,multi-threading,1683,doc/master/TROOT_8h.html,https://root.cern,https://root.cern/doc/master/TROOT_8h.html,1,['multi-thread'],['multi-threading']
Performance,"threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:24836,concurren,concurrent,24836,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"threads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21707,concurren,concurrent,21707,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,3,"['concurren', 'load']","['concurrent', 'loading']"
Performance,"threads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21668,concurren,concurrent,21668,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,3,"['concurren', 'load']","['concurrent', 'loading']"
Performance,"threads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:20978,concurren,concurrent,20978,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,3,"['concurren', 'load']","['concurrent', 'loading']"
Performance,"threads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21070,concurren,concurrent,21070,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,3,"['concurren', 'load']","['concurrent', 'loading']"
Performance,"thrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in additio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159516,perform,performance,159516,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['perform'],"['perform', 'performance']"
Performance,"tializer = 'glorot_normal',activation = ""; ""'relu', padding = 'same'))"");; // m.AddLine(""model.add(BatchNormalization())"");; m.AddLine(""model.add(MaxPooling2D(pool_size = (2, 2), strides = (1,1))) "");; m.AddLine(""model.add(Flatten())"");; m.AddLine(""model.add(Dense(256, activation = 'relu')) "");; m.AddLine(""model.add(Dense(2, activation = 'sigmoid')) "");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('model_cnn.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_cnn_model.py"");; // execute; gSystem->Exec(python_exe + "" make_cnn_model.py"");; ; if (gSystem->AccessPathName(""model_cnn.h5"")) {; Warning(""TMVA_CNN_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_CNN_Classification"", ""Booking tf.Keras CNN model"");; factory.BookMethod(; &loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=model_cnn.h5:tf.keras:""; ""FilenameTrainedModel=trained_model_cnn.h5:NumEpochs=10:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; if (usePyTorchCNN) {; ; Info(""TMVA_CNN_Classification"", ""Using Convolutional PyTorch Model"");; TString pyTorchFileName = gROOT->GetTutorialDir() + TString(""/tmva/PyTorch_Generate_CNN_Model.py"");; // check that pytorch can be imported and file defining the model and used later when booking the method is; // existing; if (gSystem->Exec(python_exe + "" -c 'import torch'"") || gSystem->AccessPathName(pyTorchFileName)) {; Warning(""TMVA_CNN_Classification"", ""PyTorch is not installed or model building file is not existing - skip using PyTorch"");; } else {; // book PyTorch method only if PyTorch model could be created; Info(""TMVA_CNN_Classification"", ""Booking PyTorch CNN model"");; TString methodOpt = ""H:!V:VarTransform=None:FilenameModel=PyTorchMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:60019,load,loader,60019,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"tializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. » Last changed: Fri Dec 2 14:27:01 2011 » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:36869,queue,queue,36869,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,4,"['optimiz', 'queue']","['optimize', 'queue']"
Performance,"tic . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file RooCachedPdf.h. ◆ clone(). TObject * RooCachedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooCachedPdf.h. ◆ DeclFileName(). static const char * RooCachedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file RooCachedPdf.h. ◆ evaluate(). double RooCachedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 39 of file RooCachedPdf.h. ◆ fillCacheObject(). void RooCachedPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input p.d.f. ; Note that the cache is filled with normalized p.d.f values so that the RooHistPdf that represents the cache contents can be explicitly declared as self normalized eliminating the need for superfluous numeric calculations of unit normalization.s ; Implements RooAbsCachedPdf.; Definition at line 92 of file RooCachedPdf.cxx. ◆ inputBaseName(). const char * RooCachedPdf::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return the base name for cache objects, in this case the name of the cached p.d.f. ; Implements RooAbsCachedPdf.; Definition at line 33 of file RooCachedPdf.h. ◆ IsA(). TClass * RooCachedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 51 of file RooCachedPdf.h. ◆ payloadUniqueSuffix(). const char * RooCachedPdf::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedPdf.; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:81153,cache,cache,81153,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"tic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:42356,cache,cache,42356,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,4,['cache'],['cache']
Performance,"tic Bool_tevalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tfindRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidfixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidfixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidforceNumInt(Bool_t flag = kTRUE); RooFunctor*functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:10201,cache,cacheList,10201,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['cache'],['cacheList']
Performance,"tic GetModuleHeaderInfoBuffer().; 2534 ; 2535void TROOT::RegisterModule(const char* modulename,; 2536 const char** headers,; 2537 const char** includePaths,; 2538 const char* payloadCode,; 2539 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of executio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:96965,load,loaded,96965,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loaded']
Performance,"tic Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:17399,cache,cache,17399,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,tic RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Int_t_lenLength of _value; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:20355,cache,caches,20355,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,10,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"tic TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; void recomputeShape () override;  Ask server category to recompute shape, and copy its information. ;  ;  Protected Member Functions inherited from RooAbsCategoryLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:38974,cache,cached,38974,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['cache'],['cached']
Performance,"tic TGLOrthoCamera::ETypekXnOY; static TGLOrthoCamera::ETypekXnOZ; static TGLOrthoCamera::ETypekZOY; static TGLOrthoCamera::ETypekZnOY; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBasetranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTranstransformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenterdefault camera center; Double_tTGLCamera::fDollyDefaultdefault distnce from viewing centre; Double_tTGLCamera::fDollyDistanceunit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenterexternal camera center; Bool_tTGLCamera::fExternalCenteruse external center insead of scene center; TGLVector3TGLCamera::fFDCenterfixed default camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenteruse fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); Bool_tTGLCamera::fWasArcBalledset when arc-ball rotation is used; static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize! x, y size of scene from camera view; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoomzoom when dolly is requested; Bool_tfEnableRotateen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLOrthoCamera.html:11161,cache,cached,11161,root/html602/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html,24,['cache'],['cached']
Performance,"tic TObject::(anonymous)TObject::kOverwrite; static TProofChain::(anonymous)kOwnsChain; static TChain::(anonymous)TChain::kProofLite; static TChain::(anonymous)TChain::kProofUptodate; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tTChain::fCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; TChain*fChainmother chain: needed for the browsing list; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofChain.html:24818,cache,cache,24818,root/html604/TProofChain.html,https://root.cern,https://root.cern/root/html604/TProofChain.html,4,['cache'],['cache']
Performance,"tic bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedPdf.h>. Inheritance diagram for RooCachedPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedPdf() [1/4]. RooCachedPdf::RooCachedPdf ; (; ). inline . Definition at line 22 of file RooCachedPdf.h. ◆ RooCachedPdf() [2/4]. RooCachedPdf::RooCachedPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 66 of file RooCachedPdf.cxx. ◆ RooCachedPdf() [3/4]. RooCachedPdf::RooCachedPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. The dimensions of the cache are automatically matched to the number of observables used in each use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:77488,cache,cache,77488,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],['cache']
Performance,"tic const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_t_extendedIs the input function and extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:35628,cache,cache,35628,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,10,['cache'],"['cache', 'cached', 'caches']"
Performance,"tic const char * RooAbsCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooAbsCache.h. ◆ findConstantNodes(). virtual void RooAbsCache::findConstantNodes ; (; const RooArgSet & ; , . RooArgSet & ; , . RooLinkedList & ;  . ). inlinevirtual . Interface for constant term node finding calls. ; Reimplemented in RooObjCacheManager.; Definition at line 52 of file RooAbsCache.h. ◆ IsA(). virtual TClass * RooAbsCache::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 63 of file RooAbsCache.h. ◆ operModeHook(). virtual void RooAbsCache::operModeHook ; (; ). inlinevirtual . Interface for operation mode changes. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 46 of file RooAbsCache.h. ◆ optimizeCacheMode(). virtual void RooAbsCache::optimizeCacheMode ; (; const RooArgSet & ; , . RooArgSet & ; , . RooLinkedList & ;  . ). inlinevirtual . Interface for processing of cache mode optimization calls. ; Reimplemented in RooObjCacheManager.; Definition at line 49 of file RooAbsCache.h. ◆ printCompactTreeHook(). virtual void RooAbsCache::printCompactTreeHook ; (; std::ostream & ; , . const char * ;  . ). inlinevirtual . Interface for printing of cache guts in tree mode printing. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 55 of file RooAbsCache.h. ◆ redirectServersHook(). virtual bool RooAbsCache::redirectServersHook ; (; const RooAbsCollection & ; , . bool ; , . bool ; , . bool ;  . ). inlinevirtual . Interface for server redirect calls. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, RooObjCacheManager, and RooMappedCategoryCache.; Definition at line 40 of file RooAbsCache.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCache.html:4410,optimiz,optimizeCacheMode,4410,doc/master/classRooAbsCache.html,https://root.cern,https://root.cern/doc/master/classRooAbsCache.html,1,['optimiz'],['optimizeCacheMode']
Performance,"tic const char * RooCachedReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 72 of file RooCachedReal.h. ◆ evaluate(). double RooCachedReal::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Dummy evaluate, it is never called. ; Implements RooAbsReal.; Definition at line 55 of file RooCachedReal.h. ◆ fillCacheObject(). void RooCachedReal::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input function. ; Implements RooAbsCachedReal.; Definition at line 117 of file RooCachedReal.cxx. ◆ getCdfBoundaries(). bool RooCachedReal::getCdfBoundaries ; (; ); const. inline . If true the c.d.f boundary mode is active. ; Definition at line 38 of file RooCachedReal.h. ◆ inputBaseName(). const char * RooCachedReal::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return base name for caches, i.e. the name of the cached function. ; Implements RooAbsCachedReal.; Definition at line 48 of file RooCachedReal.h. ◆ IsA(). TClass * RooCachedReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 72 of file RooCachedReal.h. ◆ operModeHook(). void RooCachedReal::operModeHook ; (; ). overrideprotectedvirtual . Reimplemented from RooAbsArg.; Definition at line 184 of file RooCachedReal.cxx. ◆ payloadUniqueSuffix(). const char * RooCachedReal::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 63 of file RooCachedReal.h. ◆ setCacheSource(). void RooCachedReal::setCacheSource ; (; bool ; flag). inline . Definition at line 43 of file RooCachedReal.h. ◆ setCdfBoundaries(). void RooCachedReal::setCdfBoundaries ; (; bool ; flag). inline . If flag is true the RooHistFunc that represent the cache histogram will use special boundary conditions for use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:68236,cache,cached,68236,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cached']
Performance,"tic void *ssllib_dll_handle; /* Store the ssl library handle. */; 16019static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16020 ; 16021#endif /* NO_SSL_DL */; 16022 ; 16023 ; 16024#if defined(SSL_ALREADY_INITIALIZED); 16025static volatile ptrdiff_t cryptolib_users =; 16026 1; /* Reference counter for crypto library. */; 16027#else; 16028static volatile ptrdiff_t cryptolib_users =; 16029 0; /* Reference counter for crypto library. */; 16030#endif; 16031 ; 16032 ; 16033static int; 16034initialize_openssl(char *ebuf, size_t ebuf_len); 16035{; 16036#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16037 int i, num_locks;; 16038 size_t size;; 16039#endif; 16040 ; 16041 if (ebuf_len > 0) {; 16042 ebuf[0] = 0;; 16043 }; 16044 ; 16045#if !defined(NO_SSL_DL); 16046 if (!cryptolib_dll_handle) {; 16047 memset(tls_feature_missing, 0, sizeof(tls_feature_missing));; 16048 cryptolib_dll_handle = load_tls_dll(; 16049 ebuf, ebuf_len, CRYPTO_LIB, crypto_sw, tls_feature_missing);; 16050 if (!cryptolib_dll_handle) {; 16051 mg_snprintf(NULL,; 16052 NULL, /* No truncation check for ebuf */; 16053 ebuf,; 16054 ebuf_len,; 16055 ""%s: error loading library %s"",; 16056 __func__,; 16057 CRYPTO_LIB);; 16058 DEBUG_TRACE(""%s"", ebuf);; 16059 return 0;; 16060 }; 16061 }; 16062#endif /* NO_SSL_DL */; 16063 ; 16064 if (mg_atomic_inc(&cryptolib_users) > 1) {; 16065 return 1;; 16066 }; 16067 ; 16068#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16069 /* Initialize locking callbacks, needed for thread safety.; 16070 * http://www.openssl.org/support/faq.html#PROG1; 16071 */; 16072 num_locks = CRYPTO_num_locks();; 16073 if (num_locks < 0) {; 16074 num_locks = 0;; 16075 }; 16076 size = sizeof(pthread_mutex_t) * ((size_t)(num_locks));; 16077 ; 16078 /* allocate mutex array, if required */; 16079 if (num_locks == 0) {; 16080 /* No mutex array required */; 16081 ssl_mutexes = NULL;; 16082 } else {; 16083 /* Mutex array required - allocate it */; 16084 ssl_mutexes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:474185,load,loading,474185,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['loading']
Performance,"tic void *ssllib_dll_handle; /* Store the ssl library handle. */; 16020static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16021 ; 16022#endif /* NO_SSL_DL */; 16023 ; 16024 ; 16025#if defined(SSL_ALREADY_INITIALIZED); 16026static volatile ptrdiff_t cryptolib_users =; 16027 1; /* Reference counter for crypto library. */; 16028#else; 16029static volatile ptrdiff_t cryptolib_users =; 16030 0; /* Reference counter for crypto library. */; 16031#endif; 16032 ; 16033 ; 16034static int; 16035initialize_openssl(char *ebuf, size_t ebuf_len); 16036{; 16037#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16038 int i, num_locks;; 16039 size_t size;; 16040#endif; 16041 ; 16042 if (ebuf_len > 0) {; 16043 ebuf[0] = 0;; 16044 }; 16045 ; 16046#if !defined(NO_SSL_DL); 16047 if (!cryptolib_dll_handle) {; 16048 memset(tls_feature_missing, 0, sizeof(tls_feature_missing));; 16049 cryptolib_dll_handle = load_tls_dll(; 16050 ebuf, ebuf_len, CRYPTO_LIB, crypto_sw, tls_feature_missing);; 16051 if (!cryptolib_dll_handle) {; 16052 mg_snprintf(NULL,; 16053 NULL, /* No truncation check for ebuf */; 16054 ebuf,; 16055 ebuf_len,; 16056 ""%s: error loading library %s"",; 16057 __func__,; 16058 CRYPTO_LIB);; 16059 DEBUG_TRACE(""%s"", ebuf);; 16060 return 0;; 16061 }; 16062 }; 16063#endif /* NO_SSL_DL */; 16064 ; 16065 if (mg_atomic_inc(&cryptolib_users) > 1) {; 16066 return 1;; 16067 }; 16068 ; 16069#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16070 /* Initialize locking callbacks, needed for thread safety.; 16071 * http://www.openssl.org/support/faq.html#PROG1; 16072 */; 16073 num_locks = CRYPTO_num_locks();; 16074 if (num_locks < 0) {; 16075 num_locks = 0;; 16076 }; 16077 size = sizeof(pthread_mutex_t) * ((size_t)(num_locks));; 16078 ; 16079 /* allocate mutex array, if required */; 16080 if (num_locks == 0) {; 16081 /* No mutex array required */; 16082 ssl_mutexes = NULL;; 16083 } else {; 16084 /* Mutex array required - allocate it */; 16085 ssl_mutexes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:474218,load,loading,474218,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['loading']
Performance,"tic: set the current transfrom to parameter ; Definition at line 361 of file TVirtualFFT.cxx. ◆ SineCosine(). TVirtualFFT * TVirtualFFT::SineCosine ; (; Int_t ; ndim, . Int_t * ; n, . Int_t * ; r2rkind, . Option_t * ; option . ). static . Returns a pointer to a sine or cosine transform of requested size and kind. ; Parameters: Parameters. [in]ndimnumber of transform dimensions ; [in]nsizes of each dimension (an array at least ndim long) ; [in]r2rkindtransform kind for each dimension 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7 . [in]option: consists of 2 parts; flag option and an option to create a new TVirtualFFT; flag option: choosing how much time should be spent in planning the transform: Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type.; option allowing to choose between the global fgFFT and a new TVirtualFFT object. """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT, creates and returns a new TVirtualFFT*. User is then responsible for deleting it. Examples of valid options: ""ES K"", ""EX"", etc . Definition at line 279 of file TVirtualFFT.cxx. ◆ Streamer(). void TVirtualFFT::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TVirtualFFT::StreamerNVirtual ; (; TBuffer & ; ClassDef_Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFFT.html:23575,perform,performance,23575,doc/master/classTVirtualFFT.html,https://root.cern,https://root.cern/doc/master/classTVirtualFFT.html,1,['perform'],['performance']
Performance,"tical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the __call__ member function). The signature of the Python callable should provide for one or two arrays. The first array, which must always be present, shall contain the x, y, z, and t values for the call. The second array, which is optional and its size depends on the number given to the TF1 constructor, contains the values that parameterize the function. For more details, see the TF1 documentation and the examples below.; 19.1.8.1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1065352,perform,perform,1065352,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"tical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:47666,cache,cached,47666,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,6,['cache'],['cached']
Performance,"tical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:44513,cache,cached,44513,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,3,['cache'],['cached']
Performance,"ticalFrame Composite frame with vertical child layout; TGVerticalLayout Vertical layout manager; TGView View widget base class; TGViewFrame Frame containing the actual text; TGViewPort Viewport through which to look at a container frame; TGWidget Widget base class; TGWindow GUI Window base class; TGX11 Interface to X11; TGX11TTF Interface to X11 + TTF font handling; TGXYLayout X / Y - layout manager; TGXYLayoutHints Hits for the X / Y - layout manager; TGaxis Graphics axis; TGedEditor ROOT graphics editor; TGedFrame base editor's frame; TGedMarkerPopup marker select popup; TGedMarkerSelect Marker selection button; TGedNameFrame frame showing the selected object name; TGedPatternFrame pattern frame; TGedPatternPopup Color selector popup; TGedPatternSelect pattern selection check-button; TGedPatternSelector select pattern frame; TGedPopup popup window; TGedSelect selection check-button; TGenCollectionProxy ; TGenCollectionProxy::Method ; TGenCollectionProxy::Value ; TGenPhaseSpace Simple Phase Space Generator; TGenerator Event generator interface abstract baseclass; TGenericTable Generic array of C-structure (a'la STL vector); TGenericTable::iterator ; TGeoArb8 arbitrary trapezoid with 8 vertices; TGeoAtt class for visibility, activity and optimization attributes for volumes/nodes; TGeoBBox box primitive; TGeoBBoxEditor TGeoBBox editor; TGeoBatemanSol Solution for the Bateman equation; TGeoBoolNode a boolean node; TGeoBranchArray ; TGeoBuilder geometry builder singleton; TGeoCacheState class storing the cache state; TGeoChecker a simple geometry checker; TGeoCombiTrans rotation + translation; TGeoCombiTransEditor TGeoCombiTrans editor; TGeoCompositeShape boolean composite shape; TGeoCone conical tube class; TGeoConeEditor TGeoCone editor; TGeoConeSeg conical tube segment class; TGeoConeSegEditor TGeoConeSeg editor; TGeoCtub cut tube segment class; TGeoCtubEditor TGeoCtub editor; TGeoDecayChannel Decay channel for Elements; TGeoElemIter Iterator for radionuclide chains.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:86635,optimiz,optimization,86635,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,8,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"ticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: c52dc6cb225c25e34d388329d41570a484d98ce0 $ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:24536,Load,Load,24536,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,1,['Load'],['Load']
Performance,"tically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:16953,optimiz,optimized,16953,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,16,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"tically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:13460,optimiz,optimized,13460,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,6,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"tice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(); coverity[UNINIT_CTOR]. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:43610,cache,cache,43610,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,['cache'],['cache']
Performance,"ticlass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_DL_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.077270 0.29534 [ -1.1155 1.0914 ]; : var2: 0.068045 0.27981 [ -1.0016 1.0000 ]; : var3: 0.027548 0.24565 [ -0.80459 0.85902 ]; : var4: -0.034157 0.25816 [ -1.0000 0.83435 ]; : -----------------------------------------------------------; TFHandler_DL_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.077270 0.29534 [ -1.1155 1.0914 ]; : var2: 0.068045 0.27981 [ -1.0016 1.0000 ]; : var3: 0.027548 0.24565 [ -0.80459 0.85902 ]; : var4: -0.034157 0.25816 [ -1.0000 0.83435 ]; : -----------------------------------------------------------; : ; : 1-vs-rest performance metrics per class; : -------------------------------------------------------------------------------------------------------; : ; : Considers the listed class as signal and the other classes; : as background, reporting the resulting binary performance.; : A score of 0.820 (0.850) means 0.820 was acheived on the; : test set and 0.850 on the training set.; : ; : Dataset MVA Method ROC AUC Sig eff@B=0.01 Sig eff@B=0.10 Sig eff@B=0.30 ; : Name: / Class: test (train) test (train) test (train) test (train) ; : ; : dataset BDTG ; : ------------------------------; : Signal 0.968 (0.978) 0.508 (0.605) 0.914 (0.945) 0.990 (0.996) ; : bg0 0.910 (0.931) 0.256 (0.288) 0.737 (0.791) 0.922 (0.956) ; : bg1 0.947 (0.954) 0.437 (0.511) 0.833 (0.856) 0.971 (0.971) ; : bg2 0.978 (0.982) 0.585 (0.678) 0.951 (0.956) 0.999 (0.996) ; : ; : dataset MLP ; : ------------------------------; : Signal 0.970 (0.975) 0.596 (0.632) 0.933 (0.938) 0.988 (0.993) ; : bg0 0.929 (0.934) 0.303 (0.298) 0.787 (0.793) 0.949 (0.961) ; : bg1 0.962 (0.967) 0.467 (0.553) 0.881 (0.906) 0.985 (0.992) ; : bg2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:23605,perform,performance,23605,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,2,['perform'],['performance']
Performance,"tidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::Errordouble Error() constreturn the estimate of the absolute Error of the last Integral calculationDefinition Integrator.h:416; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:160926,perform,performing,160926,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['perform'],['performing']
Performance,"ties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMedium;  Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC). More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:12797,perform,performing,12797,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['perform'],['performing']
Performance,"tiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print the state of this object to the specified output stream. ; Reimplemented from RooAbsReal.; Definition at line 1137 of file RooRealIntegral.cxx. ◆ redirectServersHook(). bool RooRealIntegral::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept server redirects and reconfigure internal object accordingly. ; Reimplemented from RooAbsReal.; Definition at line 978 of file RooRealIntegral.cxx. ◆ setAllowComponentSelection(). void RooRealIntegral::setAllowComponentSelection ; (; bool ; allow). Set component selection to be allowed/forbidden. ; Definition at line 1031 of file RooRealIntegral.cxx. ◆ setCacheAllNumeric(). void RooRealIntegral::setCacheAllNumeric ; (; Int_t ; ndim). static . Global switch to cache all integral values that integrate at least ndim dimensions numerically. ; Definition at line 1165 of file RooRealIntegral.cxx. ◆ setCacheNumeric(). void RooRealIntegral::setCacheNumeric ; (; bool ; flag). inline . Definition at line 55 of file RooRealIntegral.h. ◆ Streamer(). void RooRealIntegral::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRealIntegral::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 150 of file RooRealIntegral.h. ◆ sum(). double RooRealIntegral::sum ; (; ); const. protectedvirtual . Perform summation of list of category dependents to be integrated. ; Definition at line 939 of file RooRealIntegral.cxx. ◆ translate(). void RooRealIntegral::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:73832,cache,cache,73832,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance,"timating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:7420,perform,performs,7420,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performs']
Performance,"timating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7637,perform,performs,7637,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['perform'],['performs']
Performance,"time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. Bool_t GetReadStreamerInfo(); static function to get the value of fgReadInfo.; See TFile::SetReadStreamerInfo for more documentation. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:48616,cache,cache,48616,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,4,['cache'],['cache']
Performance,"timeout. ;  ; virtual Bool_t HandleTermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dependent eventloop via gSystem. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:5139,load,loads,5139,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['load'],['loads']
Performance,"timeout. ;  ; virtual Bool_t HandleTermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:4496,load,loads,4496,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['load'],['loads']
Performance,"timeout. ;  ; virtual Bool_t HandleTermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGApplication.html:3133,load,loads,3133,doc/master/classTGApplication.html,https://root.cern,https://root.cern/doc/master/classTGApplication.html,1,['load'],['loads']
Performance,"timeout. ;  ; virtual Bool_t HandleTermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:7766,load,loads,7766,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,2,['load'],['loads']
Performance,"times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMisse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:18243,cache,cache,18243,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,10,['cache'],['cache']
Performance,"time . ). overrideprivatevirtual . Get info about a file: id, size, flags, modification time. ; Parameters. [in]fdignored ; [in]id(statbuf.st_dev << 24) + statbuf.st_ino ; [in]sizeThe file size ; [in]flagsFile type: 0 is regular file, bit 0 set executable, bit 1 set directory, bit 2 set special file (socket, fifo, pipe, etc.) ; [in]modtimeModification time. The function returns 0 in case of success and 1 if the file could not be stat'ed. . Reimplemented from TFile.; Definition at line 531 of file TDCacheFile.cxx. ◆ SysSync(). Int_t TDCacheFile::SysSync ; (; Int_t ; fd). overrideprivatevirtual . Interface to system sync. ; All arguments like in POSIX fsync. dCache always keep it's files sync'ed, so there's no need to sync() them manually. ; Reimplemented from TFile.; Definition at line 506 of file TDCacheFile.cxx. ◆ SysWrite(). Int_t TDCacheFile::SysWrite ; (; Int_t ; fd, . const void * ; buf, . Int_t ; len . ). overrideprivatevirtual . Interface to system write. All arguments like in POSIX write. ; Reimplemented from TFile.; Definition at line 470 of file TDCacheFile.cxx. ◆ WriteBuffer(). Bool_t TDCacheFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). overridevirtual . Write specified byte range to remote file via dCache daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 323 of file TDCacheFile.cxx. Member Data Documentation. ◆ fStatBuffer. struct stat64 TDCacheFile::fStatBuffer. private . ! (transient) Cached file status buffer (for performance) ; Definition at line 29 of file TDCacheFile.h. ◆ fStatCached. Bool_t TDCacheFile::fStatCached. private . ! (transient) is file status cached? ; Definition at line 28 of file TDCacheFile.h. Libraries for TDCacheFile:. [legend]; The documentation for this class was generated from the following files:; io/dcache/inc/TDCacheFile.h; io/dcache/src/TDCacheFile.cxx. TDCacheFile. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:50432,perform,performance,50432,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,2,"['cache', 'perform']","['cached', 'performance']"
Performance,"timizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t GetBkgRejAtSigEff(Double_t sigEff = 0.5); calculate the background rejection for a given signal efficiency. OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Tue Jun 2 16:17:38 2015 » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:5048,tune,tuneParameters,5048,root/html604/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html,5,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'optimizationType', 'tuneParameters']"
Performance,"ting because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:39463,cache,cacheNameSuffix,39463,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,8,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"ting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::GetNodeTGeoNode * GetNode(const char *name) constget the pointer to a daughter nodeDefinition TGeoVolume.cxx:2193; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::DummyMediumstatic TGeoMedium * DummyMedium()Definition TGeoVolume.cxx:445; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetNumberInt_t GetNumber() constDefinition TGeoVolume.h:184; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::SaveAsvoid SaveAs(const char *filename="""", Option_t *option="""") const overrideSave geometry having this as top volume as a C++ macro.Definition TGeoVolume.cxx:1447; TGeoVolume::SetFieldvoid SetField(TObject *field)Definition TGeoVolume.h:231; TGeoVolume::CreateDummyMediumstatic void CreateDummyMedium()Create a dummy medium.Definition TGeoVolume.cxx:412; TGeoVolume::SetLineStylevoid SetLineStyle(Style_t lstyle) overrideSet the line style.Definition TGeoVolume.cxx:2177; TGeoVolume::IsAssemblyvirtual Bool_t IsAssembly() constReturns true if the volume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:236374,optimiz,optimization,236374,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"ting the field. ; Definition at line 239 of file RFieldBase.hxx. ◆ kInvalidTypeVersion. constexpr std::uint32_t ROOT::Experimental::RFieldBase::kInvalidTypeVersion = -1U. staticconstexpr . Definition at line 111 of file RFieldBase.hxx. ◆ kTraitMappable. constexpr int ROOT::Experimental::RFieldBase::kTraitMappable = 0x04. staticconstexpr . A field of a fundamental type that can be directly mapped via RField<T>::Map(), i.e. ; maps as-is to a single column ; Definition at line 119 of file RFieldBase.hxx. ◆ kTraitTriviallyConstructible. constexpr int ROOT::Experimental::RFieldBase::kTraitTriviallyConstructible = 0x01. staticconstexpr . No constructor needs to be called, i.e. ; any bit pattern in the allocated memory represents a valid type A trivially constructible field has a no-op ConstructValue() implementation ; Definition at line 114 of file RFieldBase.hxx. ◆ kTraitTriviallyDestructible. constexpr int ROOT::Experimental::RFieldBase::kTraitTriviallyDestructible = 0x02. staticconstexpr . The type is cleaned up just by freeing its memory. I.e. the destructor performs a no-op. ; Definition at line 116 of file RFieldBase.hxx. ◆ kTraitTrivialType. constexpr int ROOT::Experimental::RFieldBase::kTraitTrivialType = kTraitTriviallyConstructible | kTraitTriviallyDestructible. staticconstexpr . Shorthand for types that are both trivially constructible and destructible. ; Definition at line 123 of file RFieldBase.hxx. ◆ kTraitTypeChecksum. constexpr int ROOT::Experimental::RFieldBase::kTraitTypeChecksum = 0x08. staticconstexpr . The TClass checksum is set and valid. ; Definition at line 121 of file RFieldBase.hxx. Libraries for ROOT::Experimental::RFieldBase:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RFieldBase.hxx; tree/ntuple/v7/inc/ROOT/RField.hxx; tree/ntuple/v7/src/RField.cxx. ROOTExperimentalRFieldBase. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:59121,perform,performs,59121,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['perform'],['performs']
Performance,"tio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22274,cache,cachedbranches,22274,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,4,['cache'],"['cached', 'cachedbranches']"
Performance,"tion & func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:5601,perform,perform,5601,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"tion &f2) : fChi2_1(&f1), fChi2_2(&f2) {}; 47 ; 48 // parameter vector is first background (in common 1 and 2); 49 // and then is signal (only in 2); 50 double operator()(const double *par) const; 51 {; 52 double p1[2];; 53 for (int i = 0; i < 2; ++i); 54 p1[i] = par[iparB[i]];; 55 ; 56 double p2[5];; 57 for (int i = 0; i < 5; ++i); 58 p2[i] = par[iparSB[i]];; 59 ; 60 return (*fChi2_1)(p1) + (*fChi2_2)(p2);; 61 }; 62 ; 63 const ROOT::Math::IMultiGenFunction *fChi2_1;; 64 const ROOT::Math::IMultiGenFunction *fChi2_2;; 65};; 66 ; 67void combinedFit(); 68{; 69 ; 70 TH1D *hB = new TH1D(""hB"", ""histo B"", 100, 0, 100);; 71 TH1D *hSB = new TH1D(""hSB"", ""histo S+B"", 100, 0, 100);; 72 ; 73 TF1 *fB = new TF1(""fB"", ""expo"", 0, 100);; 74 fB->SetParameters(1, -0.05);; 75 hB->FillRandom(""fB"");; 76 ; 77 TF1 *fS = new TF1(""fS"", ""gaus"", 0, 100);; 78 fS->SetParameters(1, 30, 5);; 79 ; 80 hSB->FillRandom(""fB"", 2000);; 81 hSB->FillRandom(""fS"", 1000);; 82 ; 83 // perform now global fit; 84 ; 85 TF1 *fSB = new TF1(""fSB"", ""expo + gaus(2)"", 0, 100);; 86 ; 87 ROOT::Math::WrappedMultiTF1 wfB(*fB, 1);; 88 ROOT::Math::WrappedMultiTF1 wfSB(*fSB, 1);; 89 ; 90 ROOT::Fit::DataOptions opt;; 91 ROOT::Fit::DataRange rangeB;; 92 // set the data range; 93 rangeB.SetRange(10, 90);; 94 ROOT::Fit::BinData dataB(opt, rangeB);; 95 ROOT::Fit::FillData(dataB, hB);; 96 ; 97 ROOT::Fit::DataRange rangeSB;; 98 rangeSB.SetRange(10, 50);; 99 ROOT::Fit::BinData dataSB(opt, rangeSB);; 100 ROOT::Fit::FillData(dataSB, hSB);; 101 ; 102 ROOT::Fit::Chi2Function chi2_B(dataB, wfB);; 103 ROOT::Fit::Chi2Function chi2_SB(dataSB, wfSB);; 104 ; 105 GlobalChi2 globalChi2(chi2_B, chi2_SB);; 106 ; 107 ROOT::Fit::Fitter fitter;; 108 ; 109 const int Npar = 6;; 110 double par0[Npar] = {5, 5, -0.1, 100, 30, 10};; 111 ; 112 // create before the parameter settings in order to fix or set range on them; 113 fitter.Config().SetParamsSettings(6, par0);; 114 // fix 5-th parameter; 115 fitter.Config().ParSettings(4).Fix();; 116 // set limits on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8C_source.html:2338,perform,perform,2338,doc/master/combinedFit_8C_source.html,https://root.cern,https://root.cern/doc/master/combinedFit_8C_source.html,1,['perform'],['perform']
Performance,"tion * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values from TF1). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. const TF1 * GetFunction() const; method to retrieve the internal function pointer. { return fFunc; }. void SetAndCopyFunction(const TF1* f = 0); method to set a new function pointer and copy it inside.; By calling this method the class manages now the passed TF1 pointer. double DoEvalPar(const double* x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(const double* x) const; evaluate function using the cached parameter values (of TF1); re-implement for better efficiency. double DoParameterDerivative(const double* x, const double* p, unsigned int ipar) const; evaluate the partial derivative with respect to the parameter. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedMultiTF1.html:5205,cache,cached,5205,root/html604/ROOT__Math__WrappedMultiTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedMultiTF1.html,2,['cache'],['cached']
Performance,"tion = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExpensiveObjectCache.html:4391,cache,cacheObject,4391,root/html530/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html530/RooExpensiveObjectCache.html,3,['cache'],['cacheObject']
Performance,"tion = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); Int_tsize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::Te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExpensiveObjectCache.html:4391,cache,cacheObject,4391,root/html534/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html534/RooExpensiveObjectCache.html,2,['cache'],['cacheObject']
Performance,"tion = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:114276,load,loading,114276,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['load'],['loading']
Performance,"tion = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:115733,load,loading,115733,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,4,['load'],['loading']
Performance,"tion = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static TThread::VoidRtnFunc_tThreadProc(void*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TCondition*fNewBlockAddedsignal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending blocks to be read; TCondition*fReadBlockAddedsignal the addition of a new red block; TList*fReadBlockslist of blocks read; TSemaphore*fSemChangeFilesemaphore used when changin a file in TChain; TSemaphore*fSemMasterWorkersemaphore used to kill the consumer thread; TSemaphore*fSemWorkerMastersemaphore used to notify the master that worker is killed; Bool_tfThreadJoinedmark if async thread was joined; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFilePrefetch.html:6118,cache,cache,6118,root/html534/TFilePrefetch.html,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html,2,['cache'],['cache']
Performance,"tion Ax=b For example: A is a (10x10) Hilbert matrix which looks deceivingly innocent and simple, A(i,j) = 1/(i+j+1) b(i) = Sum_j A(i,j), so a sum of a row in A; the solution is x(i) = 1. i=0,.,9; However, TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); b#define b(i)Definition RSha256.hxx:100; TMatrixT< Double_t >; TVectorT< Double_t >; mTMarker mDefinition textangle.C:8; gives,; {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}; Looking at the condition number, this is in line with expected the accuracy . The condition number is 3.957e+12 . As a simple rule of thumb, a condition number of 1.0e+n means that you lose up to n digits of accuracy in a solution . Since doubles are stored with 15 digits, we can expect the accuracy to be as small as 3 digits .; Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2) Expressing the determinant this way makes under/over-flow very unlikely .; Decompose(); Here the actually decomposition is performed . One can change the matrix A after the decomposition constructor has been called without effecting the decomposition result; Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with the solution .; TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced with the solution .; MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through the argument and replaced with the solution .; Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument the unit matrix . Note that for a matrix a(m,n) with m > n a pseudo-inverse is calculated . Tolerances and Scaling; The tolerance parameter (which is a member of this base class) plays a crucial role in all operations of the decomposition classes . It gives the user a powerful tool to monitor and steer the operations Its default value is sqrt(epsilon) where 1+epsilon = 1; If you do not want to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompBase.html:1920,perform,performed,1920,doc/master/classTDecompBase.html,https://root.cern,https://root.cern/doc/master/classTDecompBase.html,1,['perform'],['performed']
Performance,"tion DataLoader.cxx:563; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTargetvoid AddTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Types::kFDA@ kFDADefinition Types.h:92; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kPDERS@ kPDERSDefinition Types.h:80; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kPDEFoam@ kPDEFoamDefiniti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:149680,load,loader,149680,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,2,['load'],['loader']
Performance,"tion Documentation. ◆ EStates. enum ROOT::Internal::TBranchCacheInfo::EStates. private . EnumeratorkLoaded ; kUsed ; kVetoed ; kSize . Definition at line 37 of file TBranchCacheInfo.h. Member Function Documentation. ◆ AllUsed(). bool ROOT::Internal::TBranchCacheInfo::AllUsed ; (; ); const. inline . Return true if all the baskets that are marked loaded are also mark as used. ; Definition at line 109 of file TBranchCacheInfo.h. ◆ GetUnused(). void ROOT::Internal::TBranchCacheInfo::GetUnused ; (; std::vector< Int_t > & ; unused). inline . Return a set of unused basket, let's not re-read them. ; Definition at line 122 of file TBranchCacheInfo.h. ◆ HasBeenUsed(). bool ROOT::Internal::TBranchCacheInfo::HasBeenUsed ; (; Int_t ; basketNumber); const. inline . Return true if the basket has been marked as 'used'. ; Definition at line 76 of file TBranchCacheInfo.h. ◆ IsInCache(). bool ROOT::Internal::TBranchCacheInfo::IsInCache ; (; Int_t ; basketNumber); const. inline . Return true if the basket is currently in the cache. ; Definition at line 86 of file TBranchCacheInfo.h. ◆ IsVetoed(). bool ROOT::Internal::TBranchCacheInfo::IsVetoed ; (; Int_t ; basketNumber); const. inline . Return true if the basket is currently vetoed. ; Definition at line 105 of file TBranchCacheInfo.h. ◆ Print(). void ROOT::Internal::TBranchCacheInfo::Print ; (; const char * ; owner, . Long64_t * ; entries . ); const. inline . Print the info we have for the baskets. ; Definition at line 141 of file TBranchCacheInfo.h. ◆ Reset(). void ROOT::Internal::TBranchCacheInfo::Reset ; (; ). inline . Reset all info. ; Definition at line 134 of file TBranchCacheInfo.h. ◆ SetIsInCache(). void ROOT::Internal::TBranchCacheInfo::SetIsInCache ; (; Int_t ; basketNumber). inline . Mark if the basket is currently in the cache. ; Definition at line 89 of file TBranchCacheInfo.h. ◆ SetState(). void ROOT::Internal::TBranchCacheInfo::SetState ; (; Int_t ; basketNumber, . EStates ; what . ). inlineprivate . Mark if the basket ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html:2959,cache,cache,2959,doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,1,['cache'],['cache']
Performance,"tion RooAbsArg.cxx:2528; RooAbsArg::getComponentsRooFit::OwningPtr< RooArgSet > getComponents() constCreate a RooArgSet with all components (branch nodes) of the expression tree headed by this object.Definition RooAbsArg.cxx:802; RooAbsArg::getAttributebool getAttribute(const Text_t *name) constCheck if a named attribute is set. By default, all attributes are unset.Definition RooAbsArg.cxx:245; RooAbsArg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::getCacheRooAbsCache * getCache(Int_t index) constReturn registered cache object by index.Definition RooAbsArg.cxx:2145; RooAbsArg::clientsconst RefCountList_t & clients() constList of all clients of this object.Definition RooAbsArg.h:166; RooAbsArg::isValueDirtybool isValueDirty() constDefinition RooAbsArg.h:393; RooAbsArg::setProxyNormSetvoid setProxyNormSet(const RooArgSet *nset)Forward a change in the cached normalization argset to all the registered proxies.Definition RooAbsArg.cxx:1468; RooAbsArg::branchNodeServerListvoid branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::numCachesInt_t numCaches() constReturn number of registered caches.Definition RooAbsArg.cxx:2136; RooAbsArg::findServerRooAbsArg * findServer(const char *name) constReturn server of this with name name. Returns nullptr if not found.Definition RooAbsArg.h:184; RooAbsArg::operModeOperMode operMode() constQuery the operation mode of this node.Definition RooAbsArg.h:456; RooAbsCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:138245,cache,cached,138245,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"tion TFile.h:103; TFile::DirReadKeysvirtual Int_t DirReadKeys(TDirectory *)Definition TFile.h:168; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)Definition TFile.cxx:4608; TFile::GetClassIndexTArrayC * GetClassIndex() constDefinition TFile.h:226; TFile::fSeekInfoLong64_t fSeekInfoLocation on disk of StreamerInfo record.Definition TFile.h:81; TFile::Paintvoid Paint(Option_t *option="""") overridePaint all objects in the file.Definition TFile.cxx:1698; TFile::GetListOfFreeTList * GetListOfFree() constDefinition TFile.h:237; TFile::GetBestBufferInt_t GetBestBuffer() constReturn the best buffer size of objects on this file.Definition TFile.cxx:1183; TFile::fOpenPhasesTList * fOpenPhases!Time info about open phasesDefinition TFile.h:113; TFile::SetCompressionLevelvirtual void SetCompressionLevel(Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin)See comments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::Copyvoid Copy(TObject &) const overrideC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:31649,cache,cache,31649,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"tion TGWin32VirtualXProxy.cxx:247; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::operator=TChain & operator=(const TChain &); TChain::FindLeafTLeaf * FindLeaf(const char *name) overrideSee TTree::GetReadEntry().Definition TChain.cxx:879; TChain::SetBranchAddressInt_t SetBranchAddress(const char *bname, T **add, TBranch **ptr=nullptr)Definition TChain.h:149; TChain::SetCacheSizeInt_t SetCacheSize(Long64_t cacheSize=-1) overrideSet maximum size of the file cache .Definition TChain.cxx:2467; TChain::CanDeleteRefsvirtual void CanDeleteRefs(bool flag=true)When closing a file during the chain processing, the file may be closed with option ""R"" if flag is se...Definition TChain.cxx:783; TChain::GetListOfBranchesTObjArray * GetListOfBranches() overrideReturn a pointer to the list of branches of the current tree.Definition TChain.cxx:1125; TChain::GetEntryNumberLong64_t GetEntryNumber(Long64_t entry) const overrideReturn entry number corresponding to entry.Definition TChain.cxx:1021; TChain::GetWeightDouble_t GetWeight() const overrideReturn the chain weight.Definition TChain.cxx:1241; TChain::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the global branch kAutoDelete bit.Definition TChain.cxx:2458; TChain::fCanDeleteRefsbool fCanDeleteRefs! If true, TProcessIDs are deleted when closing a fileDefinition TChain.h:40; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8h_source.html:12358,cache,cacheSize,12358,doc/master/TChain_8h_source.html,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"tion TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space.Definition TPolyMarker.h:31; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TSQLResultDefinition TSQLResult.h:31; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::operator!=bool operator!=(const TIterator &) const overrideCompare two iterator objects.Definition TTree.h:738; TTreeFriendLeafIter::GetCollectionconst TCollection * GetCollection() const overrideDefinition TTree.h:734; TTreeFriendLeafIter::fTreeTTree * fTreetree being iteratedDefinition TTree.h:719; TTreeFriendLeafIter::operator*TObject * operator*() const overrideReturn current object or nullptr.Definition TTree.h:746; TTreeFriendLeafIter::Resetvoid Reset() overrideDefinition TTree.h:737; TTreeFriendLeafIter::operator=TIterator & operator=(const TIterator &rhs) overrideOverridden assignment operator. Does",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:48981,cache,cache,48981,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,"tion action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:41490,cache,cache,41490,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,4,['cache'],['cache']
Performance,"tion action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:40661,cache,cache,40661,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,2,['cache'],['cache']
Performance,tion at line 109 of file TFile.h. ◆ fBEGIN. Long64_t TFile::fBEGIN {0}. protected . First used byte in file. ; Definition at line 78 of file TFile.h. ◆ fBytesRead. Long64_t TFile::fBytesRead {0}. protected . Number of bytes read from this file. ; Definition at line 76 of file TFile.h. ◆ fBytesReadExtra. Long64_t TFile::fBytesReadExtra {0}. protected . Number of extra bytes (overhead) read by the readahead buffer. ; Definition at line 77 of file TFile.h. ◆ fBytesWrite. Long64_t TFile::fBytesWrite {0}. protected . Number of bytes written to this file. ; Definition at line 75 of file TFile.h. ◆ fCacheRead. TFileCacheRead* TFile::fCacheRead {nullptr}. protected . !Pointer to the read cache (if any) ; Definition at line 98 of file TFile.h. ◆ fCacheReadMap. TMap* TFile::fCacheReadMap {nullptr}. protected . !Pointer to the read cache (if any) ; Definition at line 99 of file TFile.h. ◆ fCacheWrite. TFileCacheWrite* TFile::fCacheWrite {nullptr}. protected . !Pointer to the write cache (if any) ; Definition at line 100 of file TFile.h. ◆ fClassIndex. TArrayC* TFile::fClassIndex {nullptr}. protected . !Index of TStreamerInfo classes written to this file ; Definition at line 94 of file TFile.h. ◆ fCompress. Int_t TFile::fCompress {0}. protected . Compression level and algorithm. ; Definition at line 84 of file TFile.h. ◆ fD. Int_t TFile::fD {-1}. protected . File descriptor. ; Definition at line 82 of file TFile.h. ◆ fEND. Long64_t TFile::fEND {0}. protected . Last used byte in file. ; Definition at line 79 of file TFile.h. ◆ fFree. TList* TFile::fFree {nullptr}. protected . Free segments linked list table. ; Definition at line 93 of file TFile.h. ◆ fgAsyncOpenRequests. TList * TFile::fgAsyncOpenRequests = nullptr. staticprotected . Definition at line 122 of file TFile.h. ◆ fgBytesRead. std::atomic< Long64_t > TFile::fgBytesRead {0}. staticprotected . Number of bytes read by all TFile objects. ; Definition at line 131 of file TFile.h. ◆ fgBytesWrite. std::atomic< Long64_t > TFil,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:104417,cache,cache,104417,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"tion at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:66988,load,load,66988,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['load'],['load']
Performance,"tion at line 3615 of file TGeoManager.cxx. ◆ cd(). Bool_t TGeoManager::cd ; (; const char * ; path = """"). virtual . Browse the tree of nodes starting from fTopNode according to pathname. ; Changes the path accordingly. ; Definition at line 1707 of file TGeoManager.cxx. ◆ CdDown(). void TGeoManager::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 1690 of file TGeoManager.cxx. ◆ CdNext(). void TGeoManager::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 1698 of file TGeoManager.cxx. ◆ CdNode(). void TGeoManager::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 1655 of file TGeoManager.cxx. ◆ CdTop(). void TGeoManager::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 1672 of file TGeoManager.cxx. ◆ CdUp(). void TGeoManager::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 1681 of file TGeoManager.cxx. ◆ CheckBoundaryErrors(). void TGeoManager::CheckBoundaryErrors ; (; Int_t ; ntracks = 1000000, . Double_t ; radius = -1. . ). Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary. ; If radius is not mentioned the full bounding box will be sampled. ; Definition at line 3752 of file TGeoManager.cxx. ◆ CheckBoundaryReference(). void TGeoManager::CheckBoundaryReference ; (; Int_t ; icheck = -1). Check the boundary errors reference file created by CheckBoundaryErrors method. ; The shape for which the crossing failed is drawn with the starting point in red and the extrapolated point to boundary (+/- failing push/pull) in ye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:73297,cache,cache,73297,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['cache'],['cache']
Performance,"tion at line 38 of file TMethod.h. Public Member Functions;  TMethod (const TMethod &org);  Copy ctor. ;  ;  TMethod (MethodInfo_t *info=nullptr, TClass *cl=nullptr);  Default TMethod ctor. ;  ; virtual ~TMethod ();  Cleanup. ;  ; TObject * Clone (const char *newname="""") const override;  Clone method. ;  ; virtual TDataMember * FindDataMember ();  Tries to guess DataMember from comment string and Method's name <==(only if 1 Argument!). ;  ; TClass * GetClass () const;  ; virtual const char * GetCommentString ();  Returns a comment string from the class declaration. ;  ; virtual TList * GetListOfMethodArgs ();  Returns methodarg list and additionally updates fDataMember in TMethod by calling FindDataMember();. ;  ; virtual const char * Getter () const;  ; virtual TMethodCall * GetterMethod ();  Return call environment for the getter method in case this is a *TOGGLE method (for the context menu). ;  ; TClass * IsA () const override;  ; EMenuItemKind IsMenuItem () const;  ; Bool_t IsValid () override;  Return true if this function object is pointing to a currently loaded function. ;  ; TMethod & operator= (const TMethod &rhs);  Assignment operator. ;  ; virtual void SetMenuItem (EMenuItemKind menuItem);  ; virtual TMethodCall * SetterMethod ();  Return call environment for this method in case this is a *TOGGLE method which takes a single boolean or integer argument. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t Update (MethodInfo_t *info) override;  Update the TMethod to reflect the new info. ;  ;  Public Member Functions inherited from TFunction;  TFunction (const TFunction &orig);  Copy operator. ;  ;  TFunction (MethodInfo_t *info=nullptr);  Default TFunction ctor. ;  ; virtual ~TFunction ();  TFunction dtor deletes adopted CINT MethodInfo. ;  ; Long_t ExtraProperty () const;  Get property description word. For meaning of bits see EProperty. ;  ; DeclId_t GetDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethod.html:1645,load,loaded,1645,doc/master/classTMethod.html,https://root.cern,https://root.cern/doc/master/classTMethod.html,1,['load'],['loaded']
Performance,"tion at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:56037,cache,cache,56037,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"tion at line 569 of file RooAddModel.cxx. ◆ extendMode(). ExtendMode RooAddModel::extendMode ; (; ); const. inlineoverridevirtual . Return extended mode capabilities. ; Reimplemented from RooAbsPdf.; Definition at line 57 of file RooAddModel.h. ◆ fixCoefNormalization(). void RooAddModel::fixCoefNormalization ; (; const RooArgSet & ; refCoefNorm). By default the interpretation of the fraction coefficients is performed in the contextual choice of observables. ; This makes the shape of the p.d.f explicitly dependent on the choice of observables. This method instructs RooAddModel to freeze the interpretation of the coefficients to be done in the given set of observables. If frozen, fractions are automatically transformed from the reference normalization set to the contextual normalization set by ratios of integrals ; Definition at line 185 of file RooAddModel.cxx. ◆ fixCoefRange(). void RooAddModel::fixCoefRange ; (; const char * ; rangeName). By default the interpretation of the fraction coefficients is performed in the default range. ; This make the shape of a RooAddModel explicitly dependent on the range of the observables. To allow a range independent definition of the fraction this function instructs RooAddModel to freeze its interpretation in the given named range. If the current normalization range is different from the reference range, the appropriate fraction coefficients are automatically calculated from the reference fractions using ratios of integrals. ; Definition at line 210 of file RooAddModel.cxx. ◆ forceAnalyticalInt(). bool RooAddModel::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 44 of file RooAddModel.h. ◆ genContext(). RooAbsGenContext * RooAddModel::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:84559,perform,performed,84559,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['perform'],['performed']
Performance,tion at line 63 of file RooNumRunningInt.h. ◆ clone(). TObject * RooNumRunningInt::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooNumRunningInt.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooNumRunningInt::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create custom cache element for running integral calculations. ; Reimplemented from RooAbsCachedReal.; Definition at line 285 of file RooNumRunningInt.cxx. ◆ DeclFileName(). static const char * RooNumRunningInt::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooNumRunningInt.h. ◆ evaluate(). double RooNumRunningInt::evaluate ; (; ); const. overrideprotectedvirtual . Dummy function that is never called. ; Implements RooAbsReal.; Definition at line 294 of file RooNumRunningInt.cxx. ◆ fillCacheObject(). void RooNumRunningInt::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache object by calling its calculate() method. ; Implements RooAbsCachedReal.; Definition at line 248 of file RooNumRunningInt.cxx. ◆ inputBaseName(). const char * RooNumRunningInt::inputBaseName ; (; ); const. overrideprotectedvirtual . Return unique name for RooAbsCachedPdf cache components constructed from input function name. ; Implements RooAbsCachedReal.; Definition at line 88 of file RooNumRunningInt.cxx. ◆ IsA(). TClass * RooNumRunningInt::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 63 of file RooNumRunningInt.h. ◆ payloadUniqueSuffix(). const char * RooNumRunningInt::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 55 of file RooNumRunningInt.h. ◆ Streamer(). void RooNumRunningInt::Streamer ; (; TBuffer & ; R__b). override,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:66433,cache,cache,66433,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"tion at line 720 of file RooVectorDataStore.cxx. ◆ attachBuffers(). void RooVectorDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline . Definition at line 542 of file RooVectorDataStore.h. ◆ changeObservableName(). bool RooVectorDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 595 of file RooVectorDataStore.cxx. ◆ Class(). static TClass * RooVectorDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:27343,cache,cache,27343,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cache']
Performance,"tion at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:208490,cache,cacheSize,208490,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"tion calculates the background spectrum in this histogram.; The background is returned as a histogram.; to be implemented (may be). Int_t ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.050000000000000003); Interface to TSpectrum2::Search; the function finds peaks in this histogram where the width is > sigma; and the peak maximum greater than threshold*maximum bin content of this.; for more detauils see TSpectrum::Search.; note the difference in the default value for option compared to TSpectrum2::Search; option="""" by default (instead of ""goff""). void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this 2-d histogram using kernel algorithms; similar to the ones used in the raster graphics community.; Bin contents in the active range are replaced by their smooth values.; If Errors are defined via Sumw2, they are also scaled and computed.; However, note the resulting errors will be correlated between different-bins, so; the errors should not be used blindly to perform any calculation involving several bins,; like fitting the histogram. One would need to compute also the bin by bin correlation matrix. 3 kernels are proposed k5a, k5b and k3a.; k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); k5b is a bit more stronger in smoothing; k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; via the option argument.; If TAxis::SetRange has been called on the x or/and y axis, only the bins; in the specified range are smoothed.; In the current implementation if the first argument is not used (default value=1). implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun. void Streamer(TBuffer& ); Stream an object of class TH2. Int_t BufferFill(Double_t x, Double_t y, Double_t w). Int_t Fill(Double_t ). TH2& operator=(const TH2& ). void FillN(Int_t , const Double_t* , const Double_t* , Int_t ); {;}. Double_t GetBinCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:57408,perform,perform,57408,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,4,['perform'],['perform']
Performance,"tion does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. TObject* Clone(const char* newname = 0) const; Make a clone of an object bur for performance we are not using the; Streamer facility for TH1 and derived. Instead we rely on the; (required) implementation of Copy. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); Divide this histogram by h1. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. The fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:63449,Perform,Performs,63449,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,1,['Perform'],['Performs']
Performance,"tion h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf401_importttreethxDefinition rf401_importttreethx.py:1; ; RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:7497,load,loadValues,7497,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,"tion in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t loop=0; loop<100000; loop++){; FoamX->MakeEvent(); // generate MC event; FoamX->GetMCvect( MCvect); // get generated vector (x,y); Double_t x=MCvect[0];; Double_t y=MCvect[1];; if(loop<10) cout<<""(x,y) = ( ""<< x <<"", ""<< y <<"" )""<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFoam.html:1533,Load,Load,1533,root/html532/TFoam.html,https://root.cern,https://root.cern/root/html532/TFoam.html,2,['Load'],['Load']
Performance,"tion in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t loop=0; loop<100000; loop++){; FoamX->MakeEvent(); // generate MC event; FoamX->GetMCvect( MCvect); // get generated vector (x,y); Double_t x=MCvect[0];; Double_t y=MCvect[1];; if(loop<10) std::cout<<""(x,y) = ( ""<< x <<"", ""<< y <<"" )""<<std::endl;; hst_xy->Fill(x,y); // fill scattergram; }//",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFoam.html:1533,Load,Load,1533,root/html602/TFoam.html,https://root.cern,https://root.cern/root/html602/TFoam.html,2,['Load'],['Load']
Performance,"tion mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyrlife; RooRealProxyrsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGExpModel.html:43445,cache,cache,43445,root/html532/RooGExpModel.html,https://root.cern,https://root.cern/root/html532/RooGExpModel.html,4,['cache'],['cache']
Performance,"tion mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction4PdfBinding_double_double_double_double_bool_.html:40101,cache,cache,40101,root/html530/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html530/RooCFunction4PdfBinding_double_double_double_double_bool_.html,2,['cache'],['cache']
Performance,tion of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features. More...;  ; class  RooPolyVar;  A RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients. More...;  ; class  RooPrintable;  A 'mix-in' base class that define the standard RooFit plotting and printing methods. More...;  ; class  RooProdGenContext;  Efficient implementation of the generator context specific for RooProdPdf PDFs. More...;  ; class  RooProdPdf;  Efficient implementation of a product of PDFs of the form. More...; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:14845,cache,cache,14845,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['cache'],['cache']
Performance,"tion parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); #",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1477,concurren,concurrent,1477,doc/master/distrdf001__spark__connection_8py.html,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html,1,['concurren'],['concurrent']
Performance,"tion printing to given amount. ;  . Protected Member Functions; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill cache using running integral cache elements calculate() method with specification of cdf-specific boundary conditions. ;  ;  Protected Member Functions inherited from RooNumRunningInt; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:50603,cache,cacheFunc,50603,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"tion routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; virtual double evaluate () const =0;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:65017,cache,cached,65017,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,2,['cache'],['cached']
Performance,"tion routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:69606,cache,cached,69606,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,62,['cache'],['cached']
Performance,"tion set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction4PdfBinding_double_double_double_double_int_.html:39053,cache,cache,39053,root/html526/RooCFunction4PdfBinding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction4PdfBinding_double_double_double_double_int_.html,4,['cache'],['cache']
Performance,"tion switch for component selection; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; RooRealProxy_x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMoment.html:32481,cache,cache,32481,root/html530/RooMoment.html,https://root.cern,https://root.cern/root/html530/RooMoment.html,1,['cache'],['cache']
Performance,"tion switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets ; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:38068,cache,cache,38068,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,2,['cache'],['cache']
Performance,"tion time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 38",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:144209,load,load,144209,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"tion time.; 3856 if ((!load || IsClassStructOrUnion()) && fUsingData); 3857 return fUsingData;; 3858 ; 3859 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3860}; 3861 ; 3862////////////////////////////////////////////////////////////////////////////////; 3863/// Return TListOfFunctionTemplates for a class.; 3864 ; 3865TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3866{; 3867 R__LOCKGUARD(gInterpreterMutex);; 3868 ; 3869 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3870 if (load) fFuncTemplate->Load();; 3871 return fFuncTemplate;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Return list containing the TMethods of a class.; 3876/// If load is true, the list is populated with all the defined function; 3877/// and currently instantiated function template.; 3878 ; 3879TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3880{; 3881 R__LOCKGUARD(gInterpreterMutex);; 3882 ; 3883 if (!fMethod.load()) GetMethodList();; 3884 if (load) {; 3885 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3886 (*fMethod).Load();; 3887 }; 3888 return fMethod;; 3889}; 3890 ; 3891////////////////////////////////////////////////////////////////////////////////; 3892/// Return the collection of functions named ""name"".; 3893 ; 3894TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3895{; 3896 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3897}; 3898 ; 3899 ; 3900////////////////////////////////////////////////////////////////////////////////; 3901/// Returns a list of all public methods of this class and its base classes.; 3902/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3903/// GetListOfAllPublicMethods()->Delete().; 3904/// Algorithm used to get the list is:; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:146960,load,load,146960,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"tion virtual const ROOT::Math::IGenFunction & Function() const ...Definition Minimizer.h:282; ROOT::Math::Minimizer::NDimvirtual unsigned int NDim() const =0this is <= Function().NDim() which is the total number of variables (free+ constrained ones); ROOT::Math::Minimizer::NFreevirtual unsigned int NFree() constnumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition Minimizer.h:240; ROOT::Math::Minimizer::SetVariableLowerLimitvirtual bool SetVariableLowerLimit(unsigned int ivar, double lower)set the lower-limit of an already existing variableDefinition Minimizer.cxx:70; ROOT::Math::Minimizer::IsFixedVariablevirtual bool IsFixedVariable(unsigned int ivar) constquery if an existing variable is fixed (i.e.Definition Minimizer.cxx:102; ROOT::Math::Minimizer::ReleaseVariablevirtual bool ReleaseVariable(unsigned int ivar)release an existing variableDefinition Minimizer.cxx:94; ROOT::Math::Minimizer::Hessevirtual bool Hesse()perform a full calculation of the Hessian matrix for error calculationDefinition Minimizer.cxx:185; ROOT::Math::Minimizer::Contourvirtual bool Contour(unsigned int ivar, unsigned int jvar, unsigned int &npoints, double *xi, double *xj)find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum The c...Definition Minimizer.cxx:211; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoreincMathMinimizer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:32193,perform,perform,32193,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"tion&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3573,cache,cache,3573,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,2,['cache'],['cache']
Performance,"tion. ; Definition at line 81 of file TPSocket.cxx. ◆ TPSocket() [6/7]. TPSocket::TPSocket ; (; const char * ; host, . Int_t ; port, . Int_t ; size, . Int_t ; tcpwindowsize = -1 . ). Create a parallel socket. ; Connect to specified port # on the remote host. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Returns when connection has been accepted by remote side. Use IsValid() to check the validity of the socket. Every socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 98 of file TPSocket.cxx. ◆ TPSocket() [7/7]. TPSocket::TPSocket ; (; const char * ; host, . Int_t ; port, . Int_t ; size, . TSocket * ; sock . ). Create a parallel socket on a connection already opened via TSocket sock. ; This constructor is provided to optimize TNetFile opening when instatiated via a call to TNetXNGFile. Returns when connection has been accepted by remote side. Use IsValid() to check the validity of the socket. Every socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 171 of file TPSocket.cxx. ◆ ~TPSocket(). TPSocket::~TPSocket ; (; ). virtual . Cleanup the parallel socket. ; Definition at line 308 of file TPSocket.cxx. Member Function Documentation. ◆ Class(). static TClass * TPSocket::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TPSocket::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TPSocket::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TPSocket.h. ◆ Close(). void TPSocket::Close ; (; Option_t * ; option = """"). overridevirtual . Close a parallel socket. ; If option is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:22624,optimiz,optimize,22624,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['optimiz'],['optimize']
Performance,"tion. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2390 of file TSystem.cxx. ◆ Closelog(). void TSystem::Closelog ; (; ). virtual . Close connection to system log daemon. ; Reimplemented in TUnixSystem.; Definition at line 1694 of file TSystem.cxx. ◆ ClosePipe(). int TSystem::ClosePipe ; (; FILE * ; pipe). virtual . Close the pipe. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 671 of file TSystem.cxx. ◆ CompileMacro(). int TSystem::CompileMacro ; (; const char * ; filename, . Option_t * ; opt = """", . const char * ; library_specified = """", . const char * ; build_dir = """", . UInt_t ; dirmode = 0 . ). virtual . This method compiles and loads a shared library containing the code from the file ""filename"". ; The return value is true (1) in case of success and false (0) in case of error.; The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file ""library_specified"".soext where soext is the shared library extension for the current platform.; If build_dir is specified, it is used as an alternative 'root' for the generation of the shared library. The library is stored in a sub-directories of 'build_dir' including the full pathname of the script unless a flat directory structure is requested ('-' option). With the '-' option the libraries are created directly in the directory 'build_dir'; in particular this means that 2 scripts with the same name in different source directory will over-write each other's library. See also TSystem::SetBuildDir.; If dirmode is not zero and we need to create the target directory, the file mode bit w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:41281,optimiz,optimized,41281,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,"['load', 'optimiz']","['load', 'optimized']"
Performance,"tion.; For more information, see class TStreamerInfo. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLong64(Long64_t& ll). void ReadULong64(ULong64_t& ll). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:44864,perform,performance,44864,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['perform'],['performance']
Performance,"tion3D const & r ). copy constructor. explicit Rotation3D( AxisAngle const & a ). Construct from an AxisAngle. { gv_detail::convert(a, *this); }. explicit Rotation3D( EulerAngles const & e ). Construct from EulerAngles. { gv_detail::convert(e, *this); }. explicit Rotation3D( RotationZYX const & e ). Construct from RotationZYX. { gv_detail::convert(e, *this); }. explicit Rotation3D( Quaternion const & q ). Construct from a Quaternion. { gv_detail::convert(q, *this); }. explicit Rotation3D( RotationZ const & r ). Construct from an axial rotation. { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationY const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationX const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 3x3,; which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; Precondition: The matrix is assumed to be orthonormal. No checking; or re-adjusting is performed. { SetComponents(m); }. Rotation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3). Construct from three orthonormal vectors (which must have methods; x(), y() and z()) which will be used as the columns of the rotation; matrix. The orthonormality will be checked, and values adjusted; so that the result will always be a good rotation matrix. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz); compil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Rotation3D.html:7201,perform,performed,7201,root/html528/ROOT__Math__Rotation3D.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Rotation3D.html,6,['perform'],['performed']
Performance,"tion::Setting& setting = Linear); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetMode(const Roo1DMomentMorphFunction::Setting& setting); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DMomentMorphFunction.html:24223,cache,cache,24223,root/html602/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo1DMomentMorphFunction.html,4,['cache'],['cache']
Performance,"tion; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiLayerPerceptron.html:24777,Load,Load,24777,root/html532/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html532/TMultiLayerPerceptron.html,4,['Load'],['Load']
Performance,"tion; BayesianCalculator(); default constructor. Need to call the Setter methods afterwards. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPOI,						 const RooArgSet* nuisanceParameters ); TNamed( TString(name), TString(title) ),; constructor from data set, model pdf, set with the parameter of interest; (must contain only one parameter for the moment) and prior pdf; Optionally an additional set of parameters can be specified (nuisance parameters); which will be integrated (marginalized) when creating the posterior pdf.; A default size of 0.05 is used (for 95% CL interval). BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Same constructor but from data and a ModelConfig describing the model pdf and the prior, the parameter; of interest and the nuisance parameters. ~BayesianCalculator(); destructor cleaning all managed objects. void ClearAll() const; clear cached pdf objects (posterior pdf, Likelihood, NLL, etc.). void SetModel(const RooStats::ModelConfig& model); set the model configuration. RooArgSet* GetMode(RooArgSet* parameters) const; return the mode (not yet implemented) but can be easly obtained from; GetPosteriorPdf()->asTF(poi)->GetMaximumX();. RooAbsPdf* GetPosteriorPdf() const; get the posterior pdf as a RooAbsPdf; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters. RooPlot* GetPosteriorPlot() const; return a RooPlot with the posterior PDF and the credibility region. SimpleInterval* GetInterval() const; returns a SimpleInterval with the lower/upper limit on; the scanned variable (the par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__BayesianCalculator.html:8506,cache,cached,8506,root/html526/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__BayesianCalculator.html,1,['cache'],['cached']
Performance,"tion; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Mon Dec 7 13:48:35 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:4553,cache,cache,4553,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,2,['cache'],['cache']
Performance,"tion; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Thu Sep 23 20:00:26 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:4539,cache,cache,4539,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,2,['cache'],['cache']
Performance,"tion; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. » Last changed: Fri Dec 2 14:26:56 2011 » Last gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4972,cache,cache,4972,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,4,['cache'],['cache']
Performance,"tion; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. » Last changed: Mon Jul 4 15:23:37 2011 » Last gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:4636,cache,cache,4636,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,2,['cache'],['cache']
Performance,"tion; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgList& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:36987,cache,cache,36987,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,6,['cache'],['cache']
Performance,tion; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state categor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindCPAsymVar.html:31532,cache,cache,31532,root/html526/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html526/RooUnblindCPAsymVar.html,8,['cache'],['cache']
Performance,tion; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration spec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooUnblindCPAsymVar.html:32199,cache,cache,32199,root/html530/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,tion; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUnblindCPAsymVar.html:32574,cache,cache,32574,root/html532/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html532/RooUnblindCPAsymVar.html,8,['cache'],['cache']
Performance,"tion; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments. TH1D* GetD() const; Returns d vector (for choosing appropriate regularisation). TH1D* GetSV() const; Returns singular values vector. TH2D* GetXtau() const; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVDUnfold.html:11223,Perform,Perform,11223,root/html602/TSVDUnfold.html,https://root.cern,https://root.cern/root/html602/TSVDUnfold.html,2,['Perform'],['Perform']
Performance,tion; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPolynomial.html:37187,cache,cache,37187,root/html526/RooPolynomial.html,https://root.cern,https://root.cern/root/html526/RooPolynomial.html,1,['cache'],['cache']
Performance,tion; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooPolynomial.html:37569,cache,cache,37569,root/html528/RooPolynomial.html,https://root.cern,https://root.cern/root/html528/RooPolynomial.html,4,['cache'],['cache']
Performance,tion; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxy,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooParametricStepFunction.html:38059,cache,cache,38059,root/html526/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html526/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,tion; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooParametricStepFunction.html:38441,cache,cache,38441,root/html528/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html528/RooParametricStepFunction.html,4,['cache'],['cache']
Performance,"tion; TObjectTable(Int_t tableSize = 100); Create an object table. ~TObjectTable(); Delete TObjectTable. void Print(Option_t* option = """") const; Print the object table.; If option =""all"" prints the list of all objects with the format; object number, pointer, class name, object name. void Add(TObject* obj); Add an object to the object table. void AddObj(TObject* obj); Add an object to the global object table gObjectTable. If the global; table does not exist create it first. This member function may only; be used by TObject::TObject. Use Add() to add objects to any other; TObjectTable object. This is a static function. void Delete(Option_t* opt = """"); Delete all objects stored in the TObjectTable. void Remove(TObject* obj); Remove an object from the object table. void RemoveQuietly(TObject* obj); Remove an object from the object table. If op is 0 or not in the table; don't complain. Currently only used by the TClonesArray dtor. Should not; be used anywhere else, except in places where ""special"" allocation and; de-allocation tricks are performed. void Terminate(); Deletes the object table (this static class function calls the dtor). Int_t FindElement(TObject* obj); Find an object in the object table. Returns the slot where to put; the object. To test if the object is actually already in the table; use PtrIsValid(). void FixCollisions(Int_t index); Rehash the object table in case an object has been removed. void Expand(Int_t newsize); Expand the object table. void InstanceStatistics() const; Print the object table. void UpdateInstCount() const; Histogram all objects according to their classes. void * CheckPtrAndWarn(const char* msg, void* vp); Issue a warning in case an object still appears in the table; while it should not. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. Bool_t PtrIsValid(TObject* obj); { return fTable[FindElement(op)] != 0; }. TObjectTable(const TObjectTable& ). TObjectTable& operator=(const TObjectTable& ). Int_t GetSize() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectTable.html:9160,perform,performed,9160,root/html602/TObjectTable.html,https://root.cern,https://root.cern/root/html602/TObjectTable.html,4,['perform'],['performed']
Performance,"tion; TObjectTable(Int_t tableSize = 100); Create an object table. ~TObjectTable(); Delete TObjectTable. void Print(Option_t* option = """") const; Print the object table.; If option =""all"" prints the list of all objects with the format; object number, pointer, class name, object name. void Add(TObject* obj); Add an object to the object table. void AddObj(TObject* obj); Add an object to the global object table gObjectTable. If the global; table does not exist create it first. This member function may only; be used by TObject::TObject. Use Add() to add objects to any other; TObjectTable object. This is a static function. void Delete(Option_t* opt = """"); Delete all objects stored in the TObjectTable. void Remove(TObject* obj); Remove an object from the object table. void RemoveQuietly(TObject* obj); Remove an object from the object table. If op is 0 or not in the table; don't complain. Currently only used by the TClonesArray dtor. Should not; be used anywhere else, except in places where ""special"" allocation and; de-allocation tricks are performed. void Terminate(); Deletes the object table (this static class function calls the dtor). Int_t FindElement(TObject* obj); Find an object in the object table. Returns the slot where to put; the object. To test if the object is actually already in the table; use PtrIsValid(). void FixCollisions(Int_t index); Rehash the object table in case an object has been removed. void Expand(Int_t newsize); Expand the object table. void InstanceStatistics() const; Print the object table. void UpdateInstCount() const; Histogram all objects according to their classes. void * CheckPtrAndWarn(const char* msg, void* vp); Issue a warning in case an object still appears in the table; while it should not. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. Bool_t PtrIsValid(TObject* op); { return fTable[FindElement(op)] != 0; }. TObjectTable(const TObjectTable& ). TObjectTable& operator=(const TObjectTable& ). Int_t GetSize() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectTable.html:8609,perform,performed,8609,root/html528/TObjectTable.html,https://root.cern,https://root.cern/root/html528/TObjectTable.html,6,['perform'],['performed']
Performance,"tion; void GuessObsAndNuisance(const RooAbsData& data); Makes sensible guesses of observables, parameters of interest; and nuisance parameters. Defaults:; observables: determined from data,; global observables = explicit obs - obs from data; parameters of interest: empty,; nuisance parameters: all parameters except parameters of interest. We use NULL to mean not set, so we don't want to fill; with empty RooArgSets. void Print(Option_t* option = """") const; print contents of Model on the default print stream; It can be changed using RooPrintable. void SetWS(RooWorkspace& ws); set a workspace that owns all the necessary components for the analysis. RooWorkspace * GetWS() const; get from TRef. void SetSnapshot(const RooArgSet& set); save snaphot in the workspace; and use values passed with the set. const RooArgSet * GetSnapshot() const; Load the snapshot from ws and return the corresponding set with the snapshot values.; User must delete returned RooArgSet. void LoadSnapshot() const; load the snapshot from ws if it exists. void DefineSetInWS(const char* name, const RooArgSet& set); helper functions to avoid code duplication. void ImportPdfInWS(const RooAbsPdf& pdf); internal function to import Pdf in WS. void ImportDataInWS(RooAbsData& data); internal function to import data in WS. Bool_t SetHasOnlyParameters(const RooArgSet& set, const char* errorMsgPrefix = 0). ModelConfig(RooWorkspace* ws = 0). ModelConfig(const char* name, RooWorkspace* ws = 0). ModelConfig(const char* name, const char* title, RooWorkspace* ws = 0). ModelConfig * Clone(const char* name = """") const; clone. void SetWorkspace(RooWorkspace& ws); alias for SetWS(...). { SetWS(ws); }. void SetProtoData(RooAbsData& data); Set the proto DataSet, add to the the workspace if not already there. SetProtoData(const char* name). void SetPdf(const RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. SetPdf(const char* name). void SetPriorPdf(const RooAbsPdf& pdf); Set the Prior Pdf, add to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ModelConfig.html:9565,load,load,9565,root/html534/RooStats__ModelConfig.html,https://root.cern,https://root.cern/root/html534/RooStats__ModelConfig.html,9,"['Load', 'load']","['LoadSnapshot', 'load']"
Performance,"tionManager::SubImportChildren ; (; TEveElement * ; el, . TEveElement * ; proj_parent . ). virtual . Recursively import children elements of el and apply projection to the newly imported objects. ; The proj_parent argument should be a projected replica of element 'el'. This allows to insert projected children of a given element when they are added after the projection has been already performed on the parent. This is called from TEveElement::ProjectChild().; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 340 of file TEveProjectionManager.cxx. ◆ SubImportElements(). TEveElement * TEveProjectionManager::SubImportElements ; (; TEveElement * ; el, . TEveElement * ; proj_parent . ). virtual . Recursively import elements and apply projection to the newly imported objects. ; The proj_parent argument should be a projected replica of parent of element 'el'. This allows to insert projected children of a given element when they are added after the projection has been already performed on the parent. This is called from TEveElement::ProjectChild().; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 311 of file TEveProjectionManager.cxx. ◆ UpdateDependentElsAndScenes(). void TEveProjectionManager::UpdateDependentElsAndScenes ; (; TEveElement * ; root). protectedvirtual . Update dependent elements' bounding box and mark scenes containing element root or its children as requiring a repaint. ; Definition at line 203 of file TEveProjectionManager.cxx. ◆ UpdateName(). void TEveProjectionManager::UpdateName ; (; ). virtual . Updates name to have consistent information with projection. ; Definition at line 88 of file TEveProjectionManager.cxx. Member Data Documentation. ◆ fCenter. TEveVector TEveProjectionManager::fCenter. protected . Definition at line 31 of file TEveProjectionManager.h. ◆ fCurrentDepth. Float_t TEveProjectionManager::fCurrentDepth. pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionManager.html:44334,perform,performed,44334,doc/master/classTEveProjectionManager.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionManager.html,1,['perform'],['performed']
Performance,"tionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html:2989,cache,cached,2989,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,"tionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual IBaseFunctionMultiDimTempl< T > * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; virtual unsigned int NDim () const =0;  Retrieve the dimension of the function. ;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; virtual T DoEval (const T *x) const;  Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ;  ; virtual T DoEvalPar (const T *x, const double *p) const =0;  Implementation of the evaluation function using the x values and the parameters. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionMultiDimTempl< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. template<class T > . typedef IBaseFunctionMultiDimTempl<T> ROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc. Definition at line 111 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). template<class T > . virtual T ROOT::Math::IParametricFunctionMultiDimTempl< T >::DoEval ; (; const T * ; x); const. inlineprivatevirtual . Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html:2386,cache,cached,2386,doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html,1,['cache'],['cached']
Performance,"tionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; if option = ""a"" the list of blocks in the cache is printed ; Definition at line 7370 of file TTree.cxx. ◆ Process() [1/2]. Long64_t TTree::Process ; (; const char * ; filename, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Process this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:187393,load,loaded,187393,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loaded']
Performance,"tion_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual Int_t Fill ();  Fill all branches. ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to disk all the basket that have not yet been individually written and create an event cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:25498,cache,cache,25498,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,3,['cache'],['cache']
Performance,"tion_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to disk all the basket that have not yet been individually written and create an event cluster boundary (by default). ;  ; virtual const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:8363,cache,cache,8363,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,3,['cache'],['cache']
Performance,"tion_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TChain.html:52646,cache,cache,52646,root/html604/TChain.html,https://root.cern,https://root.cern/root/html604/TChain.html,2,['cache'],['cache']
Performance,"tion_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); voidsetCallWarning(Int_t threshold = 2000); voidsetConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:29462,cache,cache,29462,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"tion_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:12325,tune,tune,12325,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,6,['tune'],['tune']
Performance,"tionary of plots and callbacks with a global callback function:. LiveVisualize(plot_callback_dict, write_to_tfile); NoteThe allowed operations to pass to LiveVisualize are:; Histo1D(), Histo2D(), Histo3D(); Graph(); Profile1D(), Profile2D(). WarningThe Live Visualization feature is only supported for the Dask backend. Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up the execution of its actions. Users have to call ROOT::EnableImplicitMT() before constructing the RDataFrame object to indicate that it should take advantage of a pool of worker threads. Each worker thread processes a distinct subset of entries, and their partial results are merged before returning the final values to the user. There are no guarantees on the order in which threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:45602,multi-thread,multi-thread,45602,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['multi-thread'],['multi-thread']
Performance,"tions have an extended description, in particular:. TStyle::SetLabelFont; TStyle::SetLineStyleString: set the format of dashed lines.; TStyle::SetOptStat; TStyle::SetPalette to change the colors palette; TStyle::SetTitleOffset; TStyle::SetOptDate(Int_t optdate) to support several date formats. If optdate is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: optdate = 10*format+mode; mode = 1 the date is printed in the bottom/left corner; mode = 2 date is printed in the bottom/right corner; mode = 3 date is printed in the top/right corner; format = 0 (default) date format is like: “Wed Sep 25 17:10:35 2002”; format = 1 date format is: “2002-09-25”; format = 2 date format is: “2002-09-25 17:10:35”. 9.13 3D Viewers; ROOT provides several viewers capable of displaying 3D content:. the Pad - simple line drawing using TPad and associated projection class TView;; GL Viewer - high quality and performance viewer(See “The GL Viewer”);; X3D viewer - simple legacy viewer (See “The X3D Viewer”);; GL-in-pad - combination of basic GL viewer in TPad, with no hardware acceleration. The X3D and GL viewers are created as external windows, associated with a pad, and displaying the same content as it. Only these external viewers are detailed here - for Pad (TPad, TView classes) you should refer to “Graphical Containers: Canvas and Pad” and the class definitions.; All viewers use a common architecture to publish 3D objects to the viewer - described in “Common 3D Viewer Architecture” below. In most cases, you will not need to use this, working instead with a package, such as the “The Geometry Package”, which provides comprehensive, high level functionality to create and place objects into complex 3D scenes, and uses the viewer architecture internally to show the result in your chosen viewer.; 9.13.1 Invoking a 3D viewer; A 3D viewer can be created in a script by passing the appropriate option to Draw()when attaching the dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:385489,perform,performance,385489,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performance']
Performance,"tions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumRunningInt.h>. Inheritance diagram for RooNumRunningInt:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNumRunningInt() [1/2]. RooNumRunningInt::RooNumRunningInt ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . RooRealVar & ; _x, . const char * ; bname = ""cache"" . ). Construct running integral of function '_func' over x_print from the lower bound on _x to the present value of _x using a numeric sampling technique. ; The sampling frequency is controlled by the binning named 'bname' and a default second order interpolation is applied to smooth the histogram-based c.d.f. ; Definition at line 51 of file RooNumRunningInt.cxx. ◆ RooNumRunningInt() [2/2]. RooNumRunningInt::RooNumRunningInt ; (; const RooNumRunningInt & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 66 of file RooNumRunningInt.cxx. ◆ ~RooNumRunningInt(). RooNumRunningInt::~RooNumRunningInt ; (; ). override . Destructor. ; Definition at line 79 of file RooNumRunningInt.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooNumRunningInt::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return observable in nset to be cached by RooAbsCachedPdf this is always the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:63341,cache,cache,63341,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate his function value. The order and the position of these parameters is stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:33339,perform,performed,33339,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['perform'],['performed']
Performance,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:29315,perform,performed,29315,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['perform'],['performed']
Performance,"tions o); { fSendOpt = o; }. void SetSessionID(Int_t id). Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSocket.html:14989,queue,queue,14989,root/html534/TXSocket.html,https://root.cern,https://root.cern/root/html534/TXSocket.html,2,['queue'],['queue']
Performance,"tions o); { fSendOpt = o; }. void SetSessionID(Int_t id). Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocket.h 38538 2011-03-21 14:13:29Z ganis $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:15035,queue,queue,15035,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,1,['queue'],['queue']
Performance,"tions o); { fSendOpt = o; }. void SetSessionID(Int_t id). Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocket.h 38538 2011-03-21 14:13:29Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXSocket.html:15035,queue,queue,15035,root/html532/TXSocket.html,https://root.cern,https://root.cern/root/html532/TXSocket.html,2,['queue'],['queue']
Performance,"tions of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& argList); Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot *frame, PlotOpt o); Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:50273,perform,performed,50273,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['perform'],['performed']
Performance,"tions |; Private Member Functions |; Private Attributes |; List of all members ; TMVA::MethodCFMlpANN Class ReferenceTMVA. ; Interface to Clermond-Ferrand artificial neural network. ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are feed-forward networks according to the following propagation schema:. Schema for artificial neural network.; The input layer contains as many neurons as input variables used in the MVA. The output layer contains two neurons for the signal and background event classes. In between the input and output layers are a variable number of k hidden layers with arbitrary numbers of neurons. (While the structure of the input and output layers is determined by the problem, the hidden layers can be configured by the user through the option string of the method booking.); As indicated in the sketch, all neuron inputs to a layer are linear combinations of the neuron output of the previous layer. The transfer from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be zero (deactivated), one (linear), or non-linear. The above example uses a sigmoid activation function. The transfer function of the output layer is usually linear. As a consequence: an ANN without hidden layer should give identical discrimination power as a linear discriminant analysis (Fisher). In case of one hidden layer, the ANN computes a linear combination of sigmoid.; The learning method used by the CFMlpANN is only stochastic. ; Definition at line 95 of file MethodCFMlpANN.h. Public Member Functions;  MethodCFMlpANN (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption=""3000:N-1:N-2"");  standard constructor ;  ;  MethodCFMlpANN (DataSetInfo &theData, const TString &theWeightFile);  constructor from weight file ;  ; virtual ~MethodCFMlpANN (void);  destructor ;  ; void AddWeightsXMLTo (void *parent) const;  write weights to xml f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html:1235,perform,performed,1235,doc/master/classTMVA_1_1MethodCFMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html,1,['perform'],['performed']
Performance,"tions; RooCFunction4PdfBinding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4Ref<double,double,double,double,bool> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,double> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,int> Persistable reference to C function pointer; RooCacheManager<RooAbsCacheElement> Cache Manager class generic objects; RooCacheManager<vector<double> > Cache Manager class generic objects; RooCachedPdf P.d.f class that wraps another p.d.f and caches its output ; RooCachedReal P.d.f class that wraps another p.d.f and caches its output ; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit ; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:32020,cache,caches,32020,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,5,['cache'],['caches']
Performance,"tions; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:56345,perform,performed,56345,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,4,['perform'],['performed']
Performance,"tions; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:51042,perform,performed,51042,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,5,['perform'],['performed']
Performance,"tiplication involves 12 additions and 16 multiplications.; It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications.; ; On the contrary, rotation of a vector by the above formula ( Q*V*Q-1 ) involves 18 additions and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions and 9 multiplications.; ; When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors.; ; More information :. en.wikipedia.org/wiki/Quaternions_and_spatial_rotation .; . en.wikipedia.org/wiki/Quaternion .; ; _______________________________________________; ; This Class represents all quaternions (unit or non-unit); It possesses a Normalize() method to make a given quaternion unit; The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation.; ; A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied.; . Function Members (Methods); public:. TQuaternion(const Double_t*); TQuaternion(const Float_t*); TQuaternion(const TQuaternion&); TQuaternion(const TVector3& vector, Double_t real = 0); TQuaternion(Double_t real = 0, Double_t X = 0, Double_t Y = 0, Double_t Z = 0); virtual~TQuaternion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TQuater",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQuaternion.html:4330,perform,perform,4330,root/html528/TQuaternion.html,https://root.cern,https://root.cern/root/html528/TQuaternion.html,6,['perform'],['perform']
Performance,"tiplication involves 12 additions and 16 multiplications.; It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications.; ; On the contrary, rotation of a vector by the above formula ( Q*V*Q-1 ) involves 18 additions and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions and 9 multiplications.; ; When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors.; ; More information :. en.wikipedia.org/wiki/Quaternions_and_spatial_rotation .; . en.wikipedia.org/wiki/Quaternion .; ; _______________________________________________; ; This Class represents all quaternions (unit or non-unit); It possesses a Normalize() method to make a given quaternion unit; The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation.; ; A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied.; . Function Members (Methods); public:. virtual~TQuaternion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TQuaternionConjugate() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TQuaternion&DivideLeft(const TVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQuaternion.html:4347,perform,perform,4347,root/html602/TQuaternion.html,https://root.cern,https://root.cern/root/html602/TQuaternion.html,4,['perform'],['perform']
Performance,"title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumConvPdf(). RooNumConvPdf(const char* name, const char* title, RooRealVar& convVar, RooAbsPdf& pdf, RooAbsPdf& resmodel); Constructor of convolution operator PDF. convVar : convolution variable (on which both pdf and resmodel should depend); pdf : input 'physics' pdf; resmodel : input 'resultion' pdf. output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx'. RooNumConvPdf(const RooNumConvPdf& other, const char* name = 0); Copy constructor. ~RooNumConvPdf(); Destructor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:43115,optimiz,optimization,43115,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,11,['optimiz'],['optimization']
Performance,"tive mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLorentzVector.html:5138,perform,performs,5138,root/html528/TLorentzVector.html,https://root.cern,https://root.cern/root/html528/TLorentzVector.html,10,['perform'],['performs']
Performance,"tive one-dimensional numerical integration algorithm ;  CRooBinnedGenContextRooBinnedGenContext is an efficient implementation of the generator context specific for binned pdfs ;  CRooBinningClass RooBinning is an implements RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes ;  CRooBinningCategoryClass RooBinningCategory provides a real-to-category mapping defined by a series of thresholds ;  CRooBlindTools;  CRooBMixDecayClass RooBMixDecay is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the effects of B0/B0bar mixing ;  CRooBreitWignerClass RooBreitWigner is a RooAbsPdf implementation that models a non-relativistic Breit-Wigner shape ;  CRooBrentRootFinderImplement the abstract 1-dimensional root finding interface using the Brent-Decker method ;  CRooBukinPdfRooBukinPdf implements the NovosibirskA function ;  CRooCachedPdfRooCachedPdf is an implementation of RooAbsCachedPdf that can cache any external RooAbsPdf input function provided in the constructor ;  CRooCachedRealRooCachedReal is an implementation of RooAbsCachedReal that can cache any external RooAbsReal input function provided in the constructor ;  CRooCacheManagerTemplate class RooCacheManager manages the storage of any type of data indexed on the choice of normalization and optionally the set of integrated observables ;  CRooCategoryRooCategory represents a fundamental (non-derived) discrete value object ;  CRooCategoryProxyRooCategoryProxy is the proxy implementation for RooAbsCategory objects A RooCategoryProxy is the general mechanism to store references to RooAbsCategoriess inside a RooAbsArg ;  CRooCategorySharedPropertiesRooCategorySharedProperties is the container for all properties that are shared between instance of RooCategory objects that are clones of each other ;  CRooCatTypeRooCatType is an auxilary class for RooAbsCategory and defines a a single category state ;  CRooCBShapeP.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:82888,cache,cache,82888,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,10,['cache'],['cache']
Performance,"tle, const char* value, Int_t size = 1024); virtual~RooStringVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:1515,cache,cacheUniqueSuffix,1515,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tle, const char* value, Int_t size = 1024); virtual~RooStringVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:1515,cache,cacheUniqueSuffix,1515,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tle, const char* value, Int_t size = 1024); virtual~RooStringVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:1515,cache,cacheUniqueSuffix,1515,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tle, void* userFunc, RooArgSet& catList); virtual~RooGenCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:1995,cache,cacheUniqueSuffix,1995,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tle, void* userFunc, RooArgSet& catList); virtual~RooGenCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFund",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenCategory.html:1995,cache,cacheUniqueSuffix,1995,root/html532/RooGenCategory.html,https://root.cern,https://root.cern/root/html532/RooGenCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tle, void* userFunc, RooArgSet& catList); virtual~RooGenCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenCategory.html:1995,cache,cacheUniqueSuffix,1995,root/html528/RooGenCategory.html,https://root.cern,https://root.cern/root/html528/RooGenCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsReal&operator=(const RooAbsReal&); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:18760,optimiz,optimizeCacheMode,18760,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:36297,load,load,36297,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,4,['load'],"['load', 'loading']"
Performance,"to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:7215,cache,cached,7215,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,12,['cache'],['cached']
Performance,"to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalSha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:7050,cache,cached,7050,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,8,['cache'],['cached']
Performance,"to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:42288,optimiz,optimized,42288,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,11,['optimiz'],['optimized']
Performance,"to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTSym_double_.html:17858,Perform,Perform,17858,root/html532/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html,2,['Perform'],['Perform']
Performance,"to a multigraph of 3 partly overlapping graphs with different errors ;  fitNormSum.C Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ;  fitpanel_playback.CThis file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit ;  fitslicesy.C Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads ;  FittingDemo.C Example for fitting signal/background ;  graph2dfit.C Fitting a TGraph2D ;  Ifit.C Example of a program to fit non-equidistant data points ;  langaus.C Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ;  line3Dfit.C Fitting of a TGraph2D with a 3D straight line ;  minuit2FitBench.C Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits ;  minuit2FitBench2D.C ;  minuit2GausFit.C Perform fits with different configurations using Minuit2 ;  multidimfit.C Multi-Dimensional Parametrisation and Fitting ;  multifit.C Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:104993,perform,performance,104993,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['perform'],['performance']
Performance,"to a multigraph of 3 partly overlapping graphs with different errors ;  fitNormSum.C Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ;  fitpanel_playback.CThis file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit ;  fitslicesy.C Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads ;  FittingDemo.C Example for fitting signal/background ;  graph2dfit.C Fitting a TGraph2D ;  Ifit.C Example of a program to fit non-equidistant data points ;  langaus.C Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ;  line3Dfit.C Fitting of a TGraph2D with a 3D straight line ;  minuit2FitBench.C Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits ;  minuit2FitBench2D.C ;  minuit2GausFit.C Perform fits with different configurations using Minuit2 ;  multidimfit.C Multi-Dimensional Parametrisation and Fitting ;  multifit.C Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:106631,perform,performance,106631,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['perform'],['performance']
Performance,"to a sink or to a source (not to both); they are owned by the field. ;  ; std::vector< std::reference_wrapper< const ColumnRepresentation_t > > fColumnRepresentatives;  Pointers into the static vector GetColumnRepresentations().GetSerializationTypes() when SetColumnRepresentatives is called. ;  ; std::uint32_t fOnDiskTypeChecksum = 0;  TClass checksum cached from the descriptor after a call to ConnectPageSource(). ;  ; std::uint32_t fOnDiskTypeVersion = kInvalidTypeVersion;  C++ type version cached from the descriptor after a call to ConnectPageSource() ;  ; RFieldBase * fParent;  Sub fields point to their mother field. ;  ; Internal::RColumn * fPrincipalColumn = nullptr;  All fields that have columns have a distinct main column. ;  ; std::vector< ReadCallback_t > fReadCallbacks;  List of functions to be called after reading a value. ;  ; std::vector< std::unique_ptr< RFieldBase > > fSubFields;  Collections and classes own sub fields. ;  ; int fTraits = 0;  Properties of the type that allow for optimizations of collections of that type. ;  ; std::string fTypeAlias;  A typedef or using name that was used when creating the field. ;  . #include <ROOT/RField.hxx>. Inheritance diagram for ROOT::Experimental::RField< T, typename >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RField() [1/2]. template<typename T , typename = void> . ROOT::Experimental::RField< T, typename >::RField ; (; std::string_view ; name). inline . Definition at line 244 of file RField.hxx. ◆ RField() [2/2]. template<typename T , typename = void> . ROOT::Experimental::RField< T, typename >::RField ; (; RField< T, typename > && ; other). default . ◆ ~RField(). template<typename T , typename = void> . ROOT::Experimental::RField< T, typename >::~RField ; (; ). finaldefault . Member Function Documentation. ◆ operator=(). template<typename T , typename = void> . RField & ROOT::Experimental::RField< T, typename >:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:13082,optimiz,optimizations,13082,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['optimiz'],['optimizations']
Performance,"to a sink or to a source (not to both); they are owned by the field. ;  ; std::vector< std::reference_wrapper< const ColumnRepresentation_t > > fColumnRepresentatives;  Pointers into the static vector GetColumnRepresentations().GetSerializationTypes() when SetColumnRepresentatives is called. ;  ; std::uint32_t fOnDiskTypeChecksum = 0;  TClass checksum cached from the descriptor after a call to ConnectPageSource(). ;  ; std::uint32_t fOnDiskTypeVersion = kInvalidTypeVersion;  C++ type version cached from the descriptor after a call to ConnectPageSource() ;  ; RFieldBase * fParent;  Sub fields point to their mother field. ;  ; Internal::RColumn * fPrincipalColumn = nullptr;  All fields that have columns have a distinct main column. ;  ; std::vector< ReadCallback_t > fReadCallbacks;  List of functions to be called after reading a value. ;  ; std::vector< std::unique_ptr< RFieldBase > > fSubFields;  Collections and classes own sub fields. ;  ; int fTraits = 0;  Properties of the type that allow for optimizations of collections of that type. ;  ; std::string fTypeAlias;  A typedef or using name that was used when creating the field. ;  . Private Types; using ReadCallback_t = std::function< void(void *)>;  . Private Member Functions; void CommitCluster ();  Flushes data from active columns to disk and calls CommitClusterImpl. ;  ; void ConnectPageSink (Internal::RPageSink &pageSink, NTupleSize_t firstEntry=0);  Fields and their columns live in the void until connected to a physical page storage. ;  ; void ConnectPageSource (Internal::RPageSource &pageSource);  Connects the field and its sub field tree to the given page source. ;  ; NTupleSize_t EntryToColumnElementIndex (NTupleSize_t globalIndex) const;  Translate an entry index to a column element index of the principal column and viceversa. ;  ; void FlushColumns ();  Flushes data from active columns. ;  ; void InvokeReadCallbacks (void *target);  . Private Attributes; std::string fDescription;  Free text set by the use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:13758,optimiz,optimizations,13758,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['optimiz'],['optimizations']
Performance,"to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionLevel(Int_t level = 1); Set level of compression for this file:; level = 0 objects written to this file will not be compressed.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The link",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:37556,cache,cache,37556,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['cache'],['cache']
Performance,"to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooListProxy _highSet;  High-side variation. ;  ; std::vector< int > _interpCode;  ; RooListProxy _lowSet;  Low-side variation. ;  ; RooRealProxy _nominal;  The nominal value. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; RooListProxy _normSet;  interpolation parameters ;  ; RooArgList _ownedList;  List of owned components. ;  ; RooListProxy _paramSet;  interpolation parameters ;  ; bool _positiveDefinite = false;  protect against negative and 0 bins. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:56642,cache,cache,56642,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"to be processed; TList*fOutput!Saved pointer to the output list ; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPerfStats.html:8401,latency,latency,8401,root/html532/TPerfStats.html,https://root.cern,https://root.cern/root/html532/TPerfStats.html,2,['latency'],['latency']
Performance,"to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Forward calls to existing cache elements and save configuration of cache mode optimization so that it can be applied on new cache elements upon insertion ; Reimplemented from RooAbsCache.; Definition at line 129 of file RooObjCacheManager.cxx. ◆ printCompactTreeHook(). void RooObjCacheManager::printCompactTreeHook ; (; std::ostream & ; os, . const char * ; indent . ). overridevirtual . Add details on cache contents when printing in tree mode. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 194 of file RooObjCacheManager.cxx. ◆ redirectServersHook(). bool RooObjCacheManager::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:10134,optimiz,optimizeCacheMode,10134,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['optimiz'],['optimizeCacheMode']
Performance,"to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.; TBufferJSON a specialized TBuffer to only write objects into JSON format; TBufferSQL Implementation of TBuffer to load and write to a SQL database; TBufferSQL2 a specialized TBuffer to convert data to SQL statements or read data from SQL tables; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TCivetweb http server implementation, based on civetweb embedded server; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:55906,load,load,55906,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['load'],['load']
Performance,"to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.; TBufferJSON a specialized TBuffer to only write objects into JSON format; TBufferSQL Implementation of TBuffer to load and write to a SQL database; TBufferSQL2 a specialized TBuffer to convert data to SQL statements or read data from SQL tables; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCivetweb http server implementation, based on civetweb embedded server; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:52626,load,load,52626,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['load'],['load']
Performance,"to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:49245,load,load,49245,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,2,['load'],['load']
Performance,"to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatena",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:181079,load,load,181079,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['load'],['load']
Performance,"to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a rotation, a translation and a scale. The advantage of this description; 39is that each basic transformation can be represented as a homogenous matrix,; 40composition being performed as simple matrix multiplication.; 41 ; 42 Rotation: Inverse rotation:; 43 ; 44~~~ {.cpp}; 45 r11 r12 r13 0 r11 r21 r31 0; 46 r21 r22 r23 0 r12 r22 r32 0; 47 r31 r32 r33 0 r13 r23 r33 0; 48 0 0 0 1 0 0 0 1; 49~~~; 50 ; 51 Translation: Inverse translation:; 52 ; 53~~~ {.cpp}; 54 1 0 0 tx 1 0 0 -tx; 55 0 1 0 ty 0 1 0 -ty; 56 0 0 1 tz 0 0 1 -tz; 57 0 0 0 1 0 0 0 1; 58~~~; 59 ; 60 Scale: Inverse scale:; 61 ; 62~~~ {.cpp}; 63 sx 0 0 0 1/sx 0 0 0; 64 0 sy 0 0 0 1/sy 0 0; 65 0 0 sz 0 0 0 1/sz 0; 66 0 0 0 1 0 0 0 1; 67~~~; 68 ; 69 where:; 70 - `rij` are the 3x3 rotation matrix components,; 71 - `tx`, `ty`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:2172,perform,performed,2172,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['perform'],['performed']
Performance,"to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad,; the histogram is reset and filled again with the projected contents of the TH3. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D histogram; option = ""yz"" return the y versus z projection into a TH2D histogram; option = ""zy"" return the z versus y projection into a TH2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" origina",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3.html:44050,perform,performing,44050,root/html534/TH3.html,https://root.cern,https://root.cern/root/html534/TH3.html,2,['perform'],['performing']
Performance,"to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::EStatusBitsEStatusBitsTFile status bits. BIT(13) is taken up by TObject.Definition TFile.h:183; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:48450,cache,cache,48450,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:12256,perform,performed,12256,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance,"to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made lazy setting the appropriate flag in the snapshot options. . Queries; These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. Operation Description . Describe() Get useful information describing the dataframe, e.g. columns and their types. . GetColumnNames() Get the names of all the available columns of the dataset. . GetColumnType() Return the type of a given column as a string. . GetColumnTypeNamesList() Return the list of type names of columns in the dataset. . GetDefinedColumnNames() Get the names of all the defined columns. . GetFilterNames() Return the names of all filters in the computation graph. . GetNRuns() Return the number of event loops run by this RDataFrame instance so far. . GetNSlots() Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). . SaveGraph() Store the computation graph of an RDataFrame in DOT format (graphviz) for easy inspection. See the relevant section for details. . Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization. RDataFrame provides methods to perform most common operations required by ROOT analyses; at the same time, users can just as easily specify custom code that will be executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:9697,concurren,concurrency,9697,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrency']
Performance,"to scan through the all the combinations in the parameter space ; Definition at line 149 of file OptimizeConfigParameters.cxx. ◆ GetSeparation(). Double_t TMVA::OptimizeConfigParameters::GetSeparation ; (; ). private . return the separation between the signal and background MVA ouput distribution ; Definition at line 434 of file OptimizeConfigParameters.cxx. ◆ GetSigEffAtBkgEff(). Double_t TMVA::OptimizeConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:9178,optimiz,optimize,9178,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimize']
Performance,"to system seek. All arguments like in POSIX lseek. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Get info about a file: id, size, flags, modification time. ;  ; Int_t SysSync (Int_t fd) override;  Interface to system sync. ;  ; Int_t SysWrite (Int_t fd, const void *buf, Int_t len) override;  Interface to system write. All arguments like in POSIX write. ;  . Private Attributes; struct stat64 fStatBuffer;  ! (transient) Cached file status buffer (for performance) ;  ; Bool_t fStatCached;  ! (transient) is file status cached? ;  . Additional Inherited Members;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:33911,cache,cache,33911,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['cache'],['cache']
Performance,"to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:1162,perform,performed,1162,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['perform'],['performed']
Performance,"to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() function is called, the TEntryList is not owned by the chain; any more and will not be deleted with it. void SetPacketSize(Int_t size = 100); -- Set number of entries per packet for parallel root. void SetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); Enable/Disable PROOF processing on the current default Proof (gProof). ""Draw"" and ""Processed"" commands will be handled by PROOF.; The refresh and gettreeheader are meaningfull only if on == kTRUE.; If refresh is kTRUE the underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:47002,load,loads,47002,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,11,['load'],['loads']
Performance,"to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tTWebFile::fHTTP11true if server support HTTP/1.1; Bool_tTWebFile::fHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringTWebFile::fMsgGetHeadcache GetHead() msg; TStringTWebFile::fMsgReadBuffercache ReadBuffer() msg; TStringTWebFile::fMsgReadBuffer10cache ReadBuffer10() msg; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:23375,Cache,Cached,23375,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['Cache'],['Cached']
Performance,"to this one, use TChain::Add(TChain* chain). ; Definition at line 365 of file TChain.cxx. ◆ Add() [2/2]. Int_t TChain::Add ; (; TChain * ; chain). virtual . Add all files referenced by the passed chain to this chain. ; The function returns the total number of files connected. ; Definition at line 219 of file TChain.cxx. ◆ AddFile(). Int_t TChain::AddFile ; (; const char * ; name, . Long64_t ; nentries = TTree::kMaxEntries, . const char * ; tname = """" . ). virtual . Add a new file to this chain. ; Filename formats are similar to TChain::Add. Wildcards are not applied. urls may also contain query and fragment identifiers where the tree name can be specified in the url fragment.; eg. root://machine/path/file_name[?query[#tree_name]]; root://machine/path/file_name.root[.oext]/tree_name[?query]; If tree_name is given as a part of the file name it is used to as the name of the tree to load from the file. Otherwise if tname argument is specified the chain will load the tree named tname from the file, otherwise the original treename specified in the TChain constructor will be used. Tagging the tree_name with a slash [/tree_name] is only supported for backward compatibility; it requires the file name ot contain the string '.root' and its use is deprecated.; A. If nentries <= 0, the file is opened and the tree header read into memory to get the number of entries.; B. If nentries > 0, the file is not opened, and nentries is assumed to be the number of entries in the file. In this case, no check is made that the file exists nor that the tree exists in the file, nor that the real TTree entries match with the input argument. This second mode is interesting in case the number of entries in the file is already stored in a run database for example. WarningIf you pass nentries > tree_entries, this may lead to silent data corruption in your analysis or undefined behavior in your program. Use the other options if unsure.; C. If nentries == TTree::kMaxEntries (default), the file is not o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:61597,load,load,61597,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['load'],['load']
Performance,"to this one, use TChain::Add(TChain* chain). ; Definition at line 365 of file TChain.cxx. ◆ Add() [2/2]. Int_t TChain::Add ; (; TChain * ; chain). virtual . Add all files referenced by the passed chain to this chain. ; The function returns the total number of files connected. ; Definition at line 219 of file TChain.cxx. ◆ AddFile(). Int_t TChain::AddFile ; (; const char * ; name, . Long64_t ; nentries = TTree::kMaxEntries, . const char * ; tname = """" . ). virtual . Add a new file to this chain. ; Filename formats are similar to TChain::Add. Wildcards are not applied. urls may also contain query and fragment identifiers where the tree name can be specified in the url fragment.; eg. root://machine/path/file_name[?query[#tree_name]]; root://machine/path/file_name.root[.oext]/tree_name[?query]; If tree_name is given as a part of the file name it is used to as the name of the tree to load from the file. Otherwise if tname argument is specified the chain will load the tree named tname from the file, otherwise the original treename specified in the TChain constructor will be used. Tagging the tree_name with a slash [/tree_name] is only supported for backward compatibility; it requires the file name ot contain the string '.root' and its use is deprecated.; A. If nentries <= 0, the file is opened and the tree header read into memory to get the number of entries.; B. If nentries > 0, the file is not opened, and nentries is assumed to be the number of entries in the file. In this case, no check is made that the file exists nor that the tree exists in the file. This second mode is interesting in case the number of entries in the file is already stored in a run database for example.; C. If nentries == TTree::kMaxEntries (default), the file is not opened. The number of entries in each file will be read only when the file is opened to read an entry. This option is the default and very efficient if one processes the chain sequentially. Note that in case GetEntry(entry) is called and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:61424,load,load,61424,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['load']
Performance,"to y=0 at end points of curve . Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. A higher precision will result in more and more densely spaced curve points. A negative precision value will disable adaptive point spacing and restrict sampling to the grid point of points defined by the binning of the plotted observable (recommended for expensive functions such as profile likelihoods) . Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo() . VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate NoteTo include the uncertainty from the expected number of events, the Normalization() argument with ScaleType RooAbsReal::RelativeExpected has to be passed, e.g. pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma . Reimplemented from RooAbsPdf.; Definition at line 133 of file RooAbsPdf.cxx. ◆ plotOn() [5/5]. RooPlot * RooSimultaneous::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. overridevirtual . Back-end for plotOn() implementation on RooSimultaneous which needs special handling because a RooSimultaneous PDF cannot project out its index category via integration. ; plotOn() will abort if this is requested without providing a projection dataset. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:97070,perform,perform,97070,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['perform'],['perform']
Performance,"to y=0 at end points of curve . Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. A higher precision will result in more and more densely spaced curve points. A negative precision value will disable adaptive point spacing and restrict sampling to the grid point of points defined by the binning of the plotted observable (recommended for expensive functions such as profile likelihoods) . Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo() . VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate NoteTo include the uncertainty from the expected number of events, the Normalization() argument with ScaleType RooAbsReal::RelativeExpected has to be passed, e.g. pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma . Reimplemented from RooAbsReal.; Reimplemented in RooSimultaneous, and RooSimultaneous.; Definition at line 1937 of file RooAbsPdf.cxx. ◆ prepareMultiGen(). RooAbsPdf::prepareMultiGen ; (; const RooArgSet & ; whatVars, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {} . ). Prepare GenSpec configuration object for effi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:145394,perform,perform,145394,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['perform']
Performance,"toOrder(Int_t nProto, Int_t nGen, bool resample=false) constRooAbsPdfprotected; Raw enum valueRooAbsReal; Read(const char *name)TObjectvirtual; readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRooAbsRealvirtual; recursiveCheckObservables(const RooArgSet *nset) constRooAbsArg; recursiveRedirectServers(const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true)RooAbsArg; RecursiveRemove(TObject *obj)TObjectvirtual; redirectServers(const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false)RooAbsArg; redirectServers(std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements)RooAbsArg; redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideRooAbsPdfprotectedvirtual; RefCountList_t typedefRooAbsArg; RefCountListLegacyIterator_t typedefRooAbsArg; registerCache(RooAbsCache &cache)RooAbsArg; registerProxy(RooArgProxy &proxy)RooAbsArgprotected; registerProxy(RooSetProxy &proxy)RooAbsArgprotected; registerProxy(RooListProxy &proxy)RooAbsArgprotected; Relative enum valueRooAbsReal; RelativeExpected enum valueRooAbsReal; removeServer(RooAbsArg &server, bool force=false)RooAbsArg; removeStringAttribute(const Text_t *key)RooAbsArg; replaceServer(RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp)RooAbsArg; ResetBit(UInt_t f)TObjectinline; resetDataToken()RooAbsArginline; resetErrorCounters(Int_t resetValue=10)RooAbsPdfvirtual; RooAbsArg()RooAbsArg; RooAbsArg(const char *name, const char *title)RooAbsArg; RooAbsArg(const RooAbsArg &other, const char *name=nullptr)RooAbsArg; RooAbsPdf()RooAbsPdf; RooAbsPdf(const char *name, const char *title=nullptr)RooAbsPdf; RooAbsPdf(const char *name, const char *title, double minVal, double maxVal)RooAbsPdf; RooAbsPdf(const RooAbsPdf &other, const char *name=nullptr)RooAbsPdfprotected; RooAbsRealRooAbsPdff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:33418,cache,cache,33418,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['cache'],['cache']
Performance,"toload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:127124,load,load,127124,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],"['load', 'loading']"
Performance,"toload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3404 // classes; 3405 cl = gInterpreter->GetClass(typeinfo, load);; 3406 ; 3407 return cl; // Can be zero.; 3408}; 3409 ; 3410////////////////////////////////////////////////////////////////////////////////; 3411/// Static method returning pointer to TClass of the specified ClassInfo.; 3412/// If load is true an attempt is made to obtain the class by loading; 3413/// the appropriate shared library (directed by the rootmap file).; 3414/// If silent is 'true', do not warn about missing dictionary for the class.; 3415/// (typically used for class that are used only for transient members); 3416/// Returns 0 in case class is not found.; 3417 ; 3418TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3419{; 3420 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3421 if (!gROOT->GetListOfClasses()) return nullptr;; 3422 ; 3423 // Technically we need the write lock only for the call to ClassInfo_FullName; 3424 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3425 // take the write lock). Since taking/releasing the lock is expensive, let just; 3426 // take the write guard and keep it.; 3427 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3428 ; 3429 // Get the normalized name.; 3430 TString name( gCling->ClassInfo_FullName(info) );; 3431 ; 3432 TClass *cl = (TClass*)gROOT->GetListOfClasses",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:129875,load,load,129875,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],"['load', 'loading']"
Performance,"tomatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, <tab>-completion will usually not be available until after the first use (and hence creation) of a class.; Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see “Using Your Own Classes”).; 19.1.5.2 Access to STL Classes; The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1051465,load,loaded,1051465,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"top-level branches. For other; 1253 /// types of inputs, all columns returned by GetColumnNames() will be written out. If friend trees or chains are; 1254 /// present, by default all friend top-level branches that have names that do not collide with; 1255 /// names of branches in the main TTree/TChain will be written out. Since v6.24, Snapshot will also write out; 1256 /// friend branches with the same names of branches in the main TTree/TChain with names of the form; 1257 /// `<friendname>_<branchname>` in order to differentiate them from the branches in the main tree/chain.; 1258 ///; 1259 /// ### Writing to a sub-directory; 1260 ///; 1261 /// Snapshot supports writing the TTree in a sub-directory inside the TFile. It is sufficient to specify the path to; 1262 /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; 1263 /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; 1264 ///; 1265 /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; 1266 /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; 1267 /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; 1268 /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; 1269 /// error out if such a ""shuffled"" TTree is used in a friendship.; 1270 ///; 1271 /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; 1272 /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; 1273 /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; 1274 ///; 1275 /// \note Snapshot will refuse to process columns with names of the form ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:69587,multi-thread,multi-thread,69587,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['multi-thread'],['multi-thread']
