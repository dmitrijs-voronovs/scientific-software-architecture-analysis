quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,""""""" Tests if single particles at the boundaries and within the domain really fall down. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/release/test_flip.py:82,down,down,82,tests/release/test_flip.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/release/test_flip.py,1,['down'],['down']
Availability,""""""". Args:; scene: `str` or `Tensor`. Scene paths containing the data to plot.; names: Data files to plot for each scene. The file must be located inside the scene directory and have the name `log_<name>.txt`.; reduce: Tensor dimensions along which all curves are plotted in the same diagram.; down: Tensor dimensions along which diagrams are ordered top-to-bottom instead of left-to-right.; smooth: `int` or `Tensor`. Number of data points to average, -1 for all.; smooth_alpha: Opacity of the non-smoothed curves under the smoothed curves.; smooth_linewidth: Line width of the smoothed curves.; size: Figure size in inches.; transform: Function `T(x,y) -> (x,y)` transforming the curves.; tight_layout:; grid:; log_scale:; legend:; x:; xlim:; ylim:; titles:; labels:; xlabel:; ylabel:; colors: Line colors as `str`, `int` or `Tensor`. Integers are interpreted as indices of the default color list. Returns:; MatPlotLib [figure](https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure); """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_scalars.py:294,down,down,294,phi/vis/_matplotlib/_scalars.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_scalars.py,1,['down'],['down']
Availability,"""""""; Compute the differential diffusion term, d·∇²u.; For grids, uses a finite difference scheme specified by `order` and `implicit`.; For FVM, the scheme is specified via `order` and `upwind`. In contrast to `explicit` and `implicit`, accuracy can be increased by using stencils of higher-order rather than calculating sub-steps. Args:; u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or centered `Mesh`.; diffusivity: Dynamic viscosity, i.e. diffusion per time. Constant or varying by cell.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; upwind: For unstructured meshes only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; Differential diffusion as a `Field` on the same geometry.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py:1161,toler,tolerances,1161,phi/physics/diffuse.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py,1,['toler'],['tolerances']
Availability,"""""""; Computes the differential advection term using the differentiation Scheme indicated by `order`, ´implicit´ and `upwind`. For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign. For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A. Args:; u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.; velocity: `Field` that can be sampled at the elements of `u`.; For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.; Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).; Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.; For FVM, the order is used when interpolating centroid values to faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; upwind: Whether to use upwind interpolation. Only supported for FVM at the moment. Returns:; Differential convection term as `Field` on the same geometry.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:1226,toler,tolerances,1226,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['toler'],['tolerances']
Availability,"""""""; Computes the divergence of a grid using finite differences. This function can operate in two modes depending on the type of `field`:. * `CenteredGrid` approximates the divergence at cell centers using central differences; * `StaggeredGrid` exactly computes the divergence at cell centers. Args:; field: vector field as `CenteredGrid` or `StaggeredGrid`; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; upwind: For unstructured meshes only. Whether to use upwind interpolation. Returns:; Divergence field as `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:682,toler,tolerances,682,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['toler'],['tolerances']
Availability,"""""""; Deprecated since version 1.3. Use `phi.field.mask()` or `phi.field.resample()` instead.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_mask.py:50,mask,mask,50,phi/field/_mask.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_mask.py,2,['mask'],['mask']
Availability,"""""""; Determines all frame number for which all existing fields are available.; If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields. See Also:; `Scene.frames`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:67,avail,available,67,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,1,['avail'],['available']
Availability,"""""""; Element-wise where operation.; Picks the value of `field_true` where `mask=1 / True` and the value of `field_false` where `mask=0 / False`. The fields are automatically resampled if necessary, preferring the sample points of `mask`.; At least one of the arguments must be a `Field`. Args:; mask: `Field` or `Geometry` object.; field_true: `Field`; field_false: `Field`. Returns:; `Field`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:75,mask,mask,75,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,4,['mask'],['mask']
Availability,"""""""; Enforces boundary conditions by correcting possible errors of the advection step and shifting particles out of; obstacles or back into the domain. Args:; particles: PointCloud holding particle positions as elements; obstacles: List of `Obstacle` or `Geometry` objects where any particles inside should get shifted outwards; separation: Minimum distance between particles and domain boundary / obstacle surface after particles have been shifted. Returns:; PointCloud where all particles are inside the domain / outside of obstacles.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:57,error,errors,57,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['error'],['errors']
Availability,"""""""; Explicit Euler diffusion with substeps. Simulate a finite-time diffusion process of the form dF/dt = α · ΔF on a given `Field` Field with diffusion coefficient α. Args:; u: CenteredGrid, StaggeredGrid or ConstantField; diffusivity: Diffusion per time. `diffusion_amount = diffusivity * dt`; Can be a number, `phi.Tensor` or `phi.field.Field`.; If a channel dimension is present, it will be interpreted as non-isotropic diffusion.; dt: Time interval. `diffusion_amount = diffusivity * dt`; substeps: number of iterations to use (Default value = 1); order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs a spatially implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; upwind: For unstructured meshes only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; Diffused field of same type as `field`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py:1013,toler,tolerances,1013,phi/physics/diffuse.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py,1,['toler'],['tolerances']
Availability,"""""""; Finite difference spatial_gradient. This function can operate in two modes:. * `type=CenteredGrid` approximates the spatial_gradient at cell centers using central differences; * `type=StaggeredGrid` computes the spatial_gradient at face centers of neighbouring cells. Args:; field: centered grid of any number of dimensions (scalar field, vector field, tensor field); boundary: Boundary conditions of the gradient field.; at: Either `'face'` or `'center'`; dims: Along which dimensions to compute the spatial gradient. Only supported when `type==CenteredGrid`.; stack_dim: Dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.; The `field` must not have a dimension of the same name.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; gradient_extrapolation: Alias for `boundary`.; scheme: For unstructured meshes only. Currently only `'green-gauss'` is supported.; upwind: For unstructured meshes only. Whether to use upwind interpolation. Returns:; spatial_gradient field of type `type`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:1055,toler,tolerances,1055,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['toler'],['tolerances']
Availability,"""""""; Generates points (either uniformly distributed or at the cell centers) according to the given tensor mask. Args:; mask: Tensor with nonzero values at the indices where particles should get generated.; points_per_cell: Number of particles to generate at each marked index; center: Set points to cell centers. If False, points will be distributed using a uniform; distribution within each cell. Returns:; A tensor containing the positions of the generated points.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_point_cloud.py:106,mask,mask,106,phi/field/_point_cloud.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_point_cloud.py,4,['mask'],['mask']
Availability,"""""""; Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.; This approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step. Args:; pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.; velocity: Velocity grid at time `t`.; pressure: Pressure at time `t`.; dt: Time increment to integrate.; pressure_order: spatial order for derivative computations.; For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.; While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.; supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order); pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.; **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time. Returns:; velocity: Velocity at time `t+dt`, same type as `velocity`.; pressure: Pressure grid at time `t+dt`, `CenteredGrid`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:847,error,errors,847,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,2,"['error', 'toler']","['errors', 'tolerances']"
Availability,"""""""; MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.; It then uses that error estimate to correct the field values.; To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup. Args:; field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`; velocity: Vector field, need not be sampled at same locations as `field`.; dt: Time increment; correction_strength: The estimated error is multiplied by this factor before being applied.; The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.; integrator: ODE integrator for solving the movement. Returns:; Advected field of type `type(field)`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:90,error,error,90,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,3,['error'],['error']
Availability,"""""""; Mark a variable as controllable by any GUI created via `view()`. Example:; >>> dt = control(1.0, (0.1, 10), name=""Time increment (dt)""). This will cause a control component (slider, checkbox, text field, drop-down, etc.) to be generated in the user interface.; Changes to that component will immediately be reflected in the Python variable assigned to the control.; The Python variable will always hold a primitive type, such as `int`, `float´, `bool` or `str`. Args:; value: Initial value. Must be either `int`, `float`, `bool` or `str`.; range: (Optional) Specify range of possible values as `(min, max)`. Only for `int`, `float` and `str` values.; description: Human-readable description.; **kwargs: Additional arguments to determine the appearance of the GUI component,; e.g. `rows` for text fields or `log=False` for float sliders. Returns:; `value`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:214,down,down,214,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['down'],['down']
Availability,"""""""; Projects the given velocity field by solving for the pressure and subtracting its spatial_gradient. This method is similar to :func:`field.divergence_free()` but differs in how the boundary conditions are specified. Args:; velocity: Vector field sampled on a grid.; obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.; solve: `Solve` object specifying method and tolerances for the implicit pressure solve.; active: (Optional) Mask for which cells the pressure should be solved.; If given, the velocity may take `NaN` values where it does not contribute to the pressure.; Also, the total divergence will never be subtracted if active is given, even if all values are 1.; order: spatial order for derivative computations.; For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.; While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.; supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order). Returns:; velocity: divergence-free velocity of type `type(velocity)`; pressure: solved pressure field, `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:433,toler,tolerances,433,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,2,"['error', 'toler']","['errors', 'tolerances']"
Availability,"""""""; Registers all available backends and returns them.; This includes only backends for which the minimal requirements are fulfilled. Returns:; `tuple` of `phiml.backend.Backend`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:19,avail,available,19,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['avail'],['available']
Availability,"""""""; Returns a `Field` that masks the inside (or non-zero values when `obj` is a grid) of a physical object.; The mask takes the value 1 inside the object and 0 outside.; For `CenteredGrid` and `StaggeredGrid`, the mask labels non-zero non-NaN entries as 1 and all other values as 0. Returns:; `Grid` type or `PointCloud`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:28,mask,masks,28,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,3,['mask'],"['mask', 'masks']"
Availability,"""""""; Samples a `Field`, `Geometry` or value at the sample points of the field `to`.; The result will approximate `value` on the data structure of `to`.; Unlike `sample()`, this method returns a `Field` object, not a `Tensor`. Aliases:; `value.at(to)`, (and the deprecated `value @ to`). See Also:; `sample()`, `reduce_sample()`, `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields). Args:; value: Object containing values to resample.; This can be; to: `Field` (`CenteredGrid`, `StaggeredGrid` or `PointCloud`) object defining the sample points.; The current values of `to` are ignored.; keep_boundary: Only available if `self` is a `Field`.; If True, the resampled field will inherit the extrapolation from `self` instead of `representation`.; This can result in non-compatible value tensors for staggered grids where the tensor size depends on the extrapolation type.; **kwargs: Sampling arguments, e.g. to specify the numerical scheme.; By default, linear interpolation is used.; Grids also support 6th order implicit sampling at mid-points. Returns:; Field object of same type as `representation`. Examples:; >>> grid = CenteredGrid(x=64, y=32); >>> field.resample(Noise(), to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(1, to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(Box(x=1, y=2), to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(grid, to=grid) == grid; True; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:656,avail,available,656,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['avail'],['available']
Availability,"""""""; Sets the logging level for PhiFlow functions. Args:; level: Logging level, one of `'critical', 'fatal', 'error', 'warning', 'info', 'debug'`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:110,error,error,110,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['error'],['error']
Availability,"""""""; Spatial Laplace operator for scalar grid. For grids, uses a finite difference scheme specified by `order` and `implicit`.; For unstructured meshes, the scheme is specified via `order` and `upwind`. Args:; u: n-dimensional grid or mesh.; axes: The second derivative along these dimensions is summed over; weights: (Optional) Multiply the axis terms by these factors before summation.; Must be a `phi.math.Tensor` or `phi.field.Field` with a single channel dimension that lists all laplace axes by name.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; upwind: FVM only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; laplacian field as `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:1143,toler,tolerances,1143,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['toler'],['tolerances']
Availability,"""""""; Takes 2D simulation case parameters as input and generates wall geometry and specifies boundary condition masks; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom_opt.py:111,mask,masks,111,demos/Top_Opt/geom_opt.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom_opt.py,1,['mask'],['masks']
Availability,"""""""; Takes 3D simulation case parameters as input and generates wall geometry and specifies boundary condition masks; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom_opt.py:111,mask,masks,111,demos/Top_Opt/geom_opt.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom_opt.py,1,['mask'],['masks']
Availability,"""""""; Trace a line until it hits the surface of `geo`.; The surface can be hit either from the outside or the inside. Args:; geo: `Geometry` that implements `approximate_closest_surface`.; origin: Line start location.; direction: Unit vector pointing in the line direction.; side: 'outside' or 'inside' or 'both'.; tolerance: Surface distance tolerance.; max_iter: Maximum number of steps per line.; step_size: Step size factor. This can be set to `1` if the signed distance values of `geo` are exact.; For inexact SDFs, smaller step sizes prevent skipping over surfaces. Returns:; hit: Whether a surface intersection was found for the line.; distance: Distance between the line and the surface.; position: Hit location or point until which the line was traced.; normal: Surface normal at hit location; hit_index: Geometry face index at hit location; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom_functions.py:314,toler,tolerance,314,phi/geom/_geom_functions.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom_functions.py,2,['toler'],['tolerance']
Availability,"""""""; Unifies domain and Obstacle or Geometry objects into a binary StaggeredGrid mask which can be used; to enforce boundary conditions. Args:; not_accessible: blocked region(s) of space specified by geometries; type: class of Grid to create, must be either CenteredGrid or StaggeredGrid; extrapolation: (optional) grid extrapolation, defaults to Domain.boundaries['accessible']. Returns:; Binary mask indicating valid fields w.r.t. the boundary conditions.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py:81,mask,mask,81,phi/physics/_boundaries.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py,2,['mask'],['mask']
Availability,"# --- Load available Matplotlib color maps ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/colormaps.py:11,avail,available,11,phi/vis/_dash/colormaps.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/colormaps.py,1,['avail'],['available']
Availability,"# --- obstacles: mask and boundaries ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:17,mask,mask,17,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['mask'],['mask']
Availability,"# 1/2 error up to second intersection",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:6,error,error,6,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['error'],['error']
Availability,"# 1/4 error up to first intersection",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:6,error,error,6,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['error'],['error']
Availability,"# The point labels match one of the figure axes, so they are redundant",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:61,redundant,redundant,61,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,1,['redundant'],['redundant']
Availability,"# constant error until max_dist",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:11,error,error,11,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['error'],['error']
Availability,"# error increases gradually after block and obstacles collide",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/release/test_flip.py:2,error,error,2,tests/release/test_flip.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/release/test_flip.py,1,['error'],['error']
Availability,"# print(f""for offset {i} errors: {error_with_edge:row}"")",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:25,error,errors,25,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['error'],['errors']
Availability,"# signature not available for all functions",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_grid.py:16,avail,available,16,phi/field/_grid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_grid.py,2,['avail'],['available']
Availability,"# the error increases linearly up to this height, then assume constant error",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:6,error,error,6,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,2,['error'],['error']
Availability,'''; Takes 2D simulation case parameters as input and generates wall geometry and specifies boundary condition masks; ''',MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom.py:111,mask,masks,111,demos/Top_Opt/geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom.py,1,['mask'],['masks']
Availability,'''; Takes 3D simulation case parameters as input and generates wall geometry and specifies boundary condition masks; ''',MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom.py:111,mask,masks,111,demos/Top_Opt/geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/geom.py,1,['mask'],['masks']
Availability,"s should be laid out horizontally.; `Shape` or comma-separated names as `str`, `tuple` or `list`.; title: `str` for figures with a single subplot.; For subplots, pass a string `Tensor` matching the content dimensions, i.e. `row_dims` and `col_dims`.; Passing a `tuple`, `list` or `dict`, will create a tensor with these names internally.; size: Figure size in inches, `(width, height)`.; same_scale: Whether to use the same axis limits for all sub-figures.; log_dims: Dimensions for which the plot axes should be scaled logarithmically.; Can be given as a comma-separated `str`, a sequence of dimension names or a `Shape`.; Use `'_'` to scale unnamed axes logarithmically, e.g. the y-axis of scalar functions.; show_color_bar: Whether to display color bars for heat maps.; color: `Tensor` of line / marker colors.; The color can be specified either as a cycle index (int tensor) or as a hex code (str tensor).; The color of different lines and markers can vary.; alpha: Opacity as `float` or `Tensor`.; This affects all elements, not only line plots.; Opacity can vary between lines and markers.; err: Expected deviation from the value given in `fields`.; For supported plots, adds error bars of size *2·err*.; If the plotted data is the mean of some distribution, a good choice for `err` is the standard deviation along the mean dims.; animate: Time dimension to animate.; If not present in the data, will produce a regular plot instead.; overlay: Dimensions along which elements should be overlaid in the same subplot.; The default is only the `overlay` dimension which is created by `overlay()`.; frame_time: Interval between frames in the animation.; repeat: Whether the animation should loop. Returns:; `Tensor` of figure objects.; The tensor contains those dimensions of `fields` that were not reduced by `row_dims`, `col_dims` or `animate`.; Currently, only single-figure plots are supported. In case of an animation, a displayable animation object will be returned instead of a `Tensor`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:2024,error,error,2024,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['error'],['error']
Deployability,""""""" Euler integrator. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:10,integrat,integrator,10,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['integrat'],['integrator']
Deployability,""""""" Runge-Kutta-4 integrator with Euler fallback where velocity values are NaN. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:18,integrat,integrator,18,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['integrat'],['integrator']
Deployability,""""""" Runge-Kutta-4 integrator. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:18,integrat,integrator,18,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['integrat'],['integrator']
Deployability,""""""" Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:17,configurat,configuration,17,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,2,['configurat'],['configuration']
Deployability,"""""""; Advect `field` along the `velocity` vectors using the specified integrator. The behavior depends on the type of `field`:. * `phi.field.PointCloud`: Points are advected forward, see `points`.; * `phi.field.Grid`: Sample points are traced backward, see `semi_lagrangian`. Args:; field: Field to be advected as `phi.field.Field`.; velocity: Any `phi.field.Field` that can be sampled in the elements of `field`.; dt: Time increment; integrator: ODE integrator for solving the movement. Returns:; Advected field of same type as `field`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:69,integrat,integrator,69,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,3,['integrat'],['integrator']
Deployability,"""""""; Advects the sample points of a point cloud using a simple Euler step.; Each point moves by an amount equal to the local velocity times `dt`. Args:; points: Points to be advected. Can be provided as position `Tensor`, `Geometry` or `Field`.; velocity: velocity sampled at the same points as the point cloud; dt: Euler step time increment; integrator: ODE integrator for solving the movement. Returns:; Advected points, same type as `points`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:343,integrat,integrator,343,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['integrat'],['integrator']
Deployability,"""""""; Checks your configuration for potential problems and prints a summary. To run verify without importing `phi`, run the script `tests/verify.py` included in the source distribution.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:17,configurat,configuration,17,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['configurat'],['configuration']
Deployability,"""""""; Computes *∫<sub>R</sub> f(x) dx<sup>d</sup>* , where *f* denotes the `Field`, *R* the `region` and *d* the number of spatial dimensions (`d=field.shape.spatial_rank`).; Depending on the `sample` implementation for `field`, the integral may be a rough approximation. This method is currently only implemented for `CenteredGrid`. Args:; field: `Field` to integrate.; region: Region to integrate over.; **kwargs: Specify numerical scheme. Returns:; Integral as `phi.Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:358,integrat,integrate,358,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,2,['integrat'],['integrate']
Deployability,"""""""; Computes the field value inside the volume of the (batched) `geometry`. The field value may be determined by integrating over the volume, sampling the central value or any other way. The batch dimensions of `geometry` are matched with this field.; The `geometry` must not share any channel dimensions with this field.; Spatial dimensions of `geometry` can be used to sample a grid of geometries. See Also:; `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields). Args:; field: Source `Field` to sample.; geometry: Single or batched `phi.geom.Geometry` or `Field` or location `Tensor`.; When passing a `Field`, its `elements` are used as sample points.; When passing a vector-valued `Tensor`, a `Point` geometry will be created.; at: One of 'center', 'face', 'vertex'; boundary: Target extrapolation.; dot_face_normal: If not `None` and , `field` is a vector field and `at=='face'`, the dot product between sampled field vectors and the face normals is returned instead.; **kwargs: Sampling arguments, e.g. to specify the numerical scheme.; By default, linear interpolation is used.; Grids also support 6th order implicit sampling at mid-points. Returns:; Sampled values as a `phi.math.Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:114,integrat,integrating,114,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['integrat'],['integrating']
Deployability,"""""""; Creates a display for the given vis and initializes the configuration.; This method does not set up the display. It only sets up the Gui object and returns as quickly as possible.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:61,configurat,configuration,61,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,1,['configurat'],['configuration']
Deployability,"""""""; Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.; This approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step. Args:; pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.; velocity: Velocity grid at time `t`.; pressure: Pressure at time `t`.; dt: Time increment to integrate.; pressure_order: spatial order for derivative computations.; For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.; While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.; supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order); pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.; **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time. Returns:; velocity: Velocity at time `t+dt`, same type as `velocity`.; pressure: Pressure grid at time `t+dt`, `CenteredGrid`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:515,integrat,integrate,515,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['integrat'],['integrate']
Deployability,"""""""; Jax integration. Importing this module registers the Jax backend with `phiml.math`.; Without this, Jax tensors cannot be handled by `phiml.math` functions. To make Jax the default backend, import `phi.jax.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/jax/__init__.py:9,integrat,integration,9,phi/jax/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/jax/__init__.py,1,['integrat'],['integration']
Deployability,"""""""; Load an unstructured mesh from a `.msh` file. This requires the package `meshio` to be installed. Args:; file: Path to `.su2` file.; boundary_names: Boundary identifiers corresponding to the blocks in the file. If not specified, boundaries will be numbered.; cell_dim: Dimension along which to list the cells. This should be an instance dimension.; face_format: Sparse storage format for cell connectivity. Returns:; `Mesh`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:92,install,installed,92,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['install'],['installed']
Deployability,"""""""; Load an unstructured mesh from a `.su2` file. This requires the package `ezmesh` to be installed. Args:; file_or_mesh: Path to `.su2` file or *ezmesh* `Mesh` instance.; cell_dim: Dimension along which to list the cells. This should be an instance dimension.; face_format: Sparse storage format for cell connectivity. Returns:; `Mesh`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:92,install,installed,92,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['install'],['installed']
Deployability,"""""""; MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.; It then uses that error estimate to correct the field values.; To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup. Args:; field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`; velocity: Vector field, need not be sampled at same locations as `field`.; dt: Time increment; correction_strength: The estimated error is multiplied by this factor before being applied.; The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.; integrator: ODE integrator for solving the movement. Returns:; Advected field of type `type(field)`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:669,integrat,integrator,669,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['integrat'],['integrator']
Deployability,"""""""; PyTorch integration. Importing this module registers the PyTorch backend with `phiml.math`.; Without this, PyTorch tensors cannot be handled by `phiml.math` functions. To make PyTorch the default backend, import `phi.torch.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/torch/__init__.py:13,integrat,integration,13,phi/torch/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/torch/__init__.py,1,['integrat'],['integration']
Deployability,"""""""; Returns the current configuration of the GUI.; The returned dictionary may only contain serializable values and all keys must be strings.; The configuration can be passed to another instance of this class using set_configuration().; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:25,configurat,configuration,25,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,2,['configurat'],['configuration']
Deployability,"""""""; Semi-Lagrangian advection with simple backward lookup.; ; This method samples the `velocity` at the grid points of `field`; to determine the lookup location for each grid point by walking backwards along the velocity vectors.; The new values are then determined by sampling `field` at these lookup locations. Args:; field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid); velocity: vector field, need not be compatible with with `field`.; dt: time increment; integrator: ODE integrator for solving the movement. Returns:; Field with same sample points as `field`. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:490,integrat,integrator,490,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['integrat'],['integrator']
Deployability,"""""""; Show `fields` in a graphical user interface. `fields` may contain instances of `Field` or variable names of top-level variables (main module or Jupyter notebook).; During loops, e.g. `view().range()`, the variable status is tracked and the GUI is updated. When called from a Python script, name and description may be specified in the module docstring (string before imports).; The first line is interpreted as the name, the rest as the subtitle.; If not specified, a generic name and description is chosen. Args:; *fields: (Optional) Contents to be displayed. Either variable names or values.; For field instances, all variables referencing the value will be shown.; If not provided, the user namespace is searched for Field variables.; play: Whether to immediately start executing loops.; gui: (Optional) Name of GUI as `str` or GUI class.; Built-in GUIs can be selected via `'dash'`, `'console'`.; See https://tum-pbs.github.io/PhiFlow/Visualization.html; name: (Optional) Name to display in GUI and use for the output directory if `scene=True`.; Will be generated from the top-level script if not provided.; description: (Optional) Description to be displayed in the GUI.; Will be generated from the top-level script if not provided.; scene: Existing `Scene` to write into or `bool`. If `True`, creates a new Scene in `~/phi/<name>`; keep_alive: Whether the GUI should keep running even after the main thread finishes.; framerate: Target frame rate in Hz. Play will not step faster than the framerate. `None` for unlimited frame rate.; select: Dimension names along which one item to show is selected.; Dimensions may be passed as `tuple` of `str` or as comma-separated names in a single `str`.; For each `select` dimension, an associated selection slider will be created.; log_performance: Whether to measure and log the time each step takes.; If `True`, will be logged as `step_time` to `log_step_time.txt`.; **config: Additional GUI configuration arguments. Returns:; `Viewer`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:252,update,updated,252,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,2,"['configurat', 'update']","['configuration', 'updated']"
Deployability,"""""""; Simple cuboid defined by location of lower and upper corner in physical space. Boxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`. Examples:; >>> Box(x=1, y=1) # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.; >>> Box(x=(None, 1), y=(0, None) # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`. The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument. >>> Box['x,y', 0:1, 0:1] # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.; >>> Box['x,y', :1, 0:] # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_box.py:458,update,updated,458,phi/geom/_box.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_box.py,1,['update'],['updated']
Deployability,"""""""; TensorFlow integration. Importing this module registers the TensorFlow backend with `phiml.math`.; Without this, TensorFlow tensors cannot be handled by `phiml.math` functions. To make TensorFlow the default backend, import `phi.tf.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/__init__.py:16,integrat,integration,16,phi/tf/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/__init__.py,1,['integrat'],['integration']
Deployability,"""""""; The fields module provides a number of data structures and functions to represent continuous, spatially varying data. All fields are subclasses of `Field` which provides abstract functions for sampling field values at physical locations. The most important field types are:. * `CenteredGrid` embeds a tensor in the physical space. Uses linear interpolation between grid points.; * `StaggeredGrid` samples the vector components at face centers instead of at cell centers.; * `Noise` is a function that produces a procedurally generated noise field. Use `grid()` to create a `Grid` from data or by sampling another `Field` or `phi.geom.Geometry`.; Alternatively, the `phi.physics.Domain` class provides convenience methods for grid creation. All fields can be sampled at physical locations or volumes using `sample()` or `reduce_sample()`. See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/__init__.py:87,continuous,continuous,87,phi/field/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/__init__.py,1,['continuous'],['continuous']
Deployability,"""""""; Tools for running Smoothed Particle Hydrodynamics (SPH) simulations. 1. Create particles as a `Geometry` collections.; 2. Use `neighbor_graph` to find neighbor particles and compute kernel weights.; 3. Use custom function or built-in physics operations to integrate the dynamics.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py:261,integrat,integrate,261,phi/physics/sph.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py,1,['integrat'],['integrate']
Deployability,"""""""; Updates the GUI configuration.; This method may only be called while the GUI is not yet visible, i.e. before show() is called. Args:; config: Complete or partial GUI-specific configuration. dictionary mapping from strings to JSON serializable values; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:21,configurat,configuration,21,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,2,['configurat'],['configuration']
Deployability,"""""""; Updates the properties dictionary and stores it in `description.json` of all scene folders. Args:; update: new values, must be JSON serializable.; kw_updates: additional update as keyword arguments. This overrides `update`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:104,update,update,104,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,3,['update'],['update']
Deployability,"""""""Domain (phi.physics._boundaries) is deprecated and will be removed in a future release.; Please create grids directly, replacing the domain with a dict, e.g.; domain = dict(x=64, y=128, bounds=Box(x=1, y=1)); grid = CenteredGrid(0, **domain)""""""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py:82,release,release,82,phi/physics/_boundaries.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py,1,['release'],['release']
Deployability,"# --- integrate column above face: linearly increasing + constant ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:6,integrat,integrate,6,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['integrat'],['integrate']
Deployability,"# FLIP update; # particles = velocity @ particles # PIC update",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/physics/test_flip.py:7,update,update,7,tests/commit/physics/test_flip.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/physics/test_flip.py,4,['update'],['update']
Deployability,"# if isinstance(obj, matplotlib.patches.FancyArrowPatch):",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:32,patch,patches,32,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,1,['patch'],['patches']
Energy Efficiency,""""""". Args:; scene: `str` or `Tensor`. Scene paths containing the data to plot.; names: Data files to plot for each scene. The file must be located inside the scene directory and have the name `log_<name>.txt`.; reduce: Tensor dimensions along which all curves are plotted in the same diagram.; down: Tensor dimensions along which diagrams are ordered top-to-bottom instead of left-to-right.; smooth: `int` or `Tensor`. Number of data points to average, -1 for all.; smooth_alpha: Opacity of the non-smoothed curves under the smoothed curves.; smooth_linewidth: Line width of the smoothed curves.; size: Figure size in inches.; transform: Function `T(x,y) -> (x,y)` transforming the curves.; tight_layout:; grid:; log_scale:; legend:; x:; xlim:; ylim:; titles:; labels:; xlabel:; ylabel:; colors: Line colors as `str`, `int` or `Tensor`. Integers are interpreted as indices of the default color list. Returns:; MatPlotLib [figure](https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure); """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_scalars.py:211,reduce,reduce,211,phi/vis/_matplotlib/_scalars.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_scalars.py,1,['reduce'],['reduce']
Energy Efficiency,"""""""; Expels points at `location` out of the `geometry`.; This implementation works with all geometries that implement `approximate_closest_surface()`.; Specific geometries may override `Geometry.push()` for more accurate or efficient results. Args:; geometry: `Geometry` that has an inside and outside.; location: `Tensor` holding the positions before shifting.; min_separation: Minimum distance between positions and surface after shifting.; invert: Whether to invert the inside and outside of `geometry`. Returns:; Tensor holding shifted positions.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom_ops.py:224,efficient,efficient,224,phi/geom/_geom_ops.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom_ops.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Finite difference spatial_gradient. This function can operate in two modes:. * `type=CenteredGrid` approximates the spatial_gradient at cell centers using central differences; * `type=StaggeredGrid` computes the spatial_gradient at face centers of neighbouring cells. Args:; field: centered grid of any number of dimensions (scalar field, vector field, tensor field); boundary: Boundary conditions of the gradient field.; at: Either `'face'` or `'center'`; dims: Along which dimensions to compute the spatial gradient. Only supported when `type==CenteredGrid`.; stack_dim: Dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.; The `field` must not have a dimension of the same name.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; gradient_extrapolation: Alias for `boundary`.; scheme: For unstructured meshes only. Currently only `'green-gauss'` is supported.; upwind: For unstructured meshes only. Whether to use upwind interpolation. Returns:; spatial_gradient field of type `type`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:1307,green,green-gauss,1307,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['green'],['green-gauss']
Energy Efficiency,"""""""; Represents a tensor of Geometries.; Instance dimensions represent geometry unions and are reduced.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom_ops.py:95,reduce,reduced,95,phi/geom/_geom_ops.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom_ops.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Unstacks this Geometry along the given dimension.; The shapes of the returned geometries are reduced by `dimension`. Args:; dimension: dimension along which to unstack. Returns:; geometries: tuple of length equal to `geometry.shape.get_size(dimension)`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py:98,reduce,reduced,98,phi/geom/_geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py,1,['reduce'],['reduced']
Energy Efficiency,"# ToDo reduce instance dim",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_box.py:7,reduce,reduce,7,phi/geom/_box.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_box.py,1,['reduce'],['reduce']
Energy Efficiency,"# do not reduce these dims, has priority",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:9,reduce,reduce,9,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['reduce'],['reduce']
Energy Efficiency,"s should be laid out horizontally.; `Shape` or comma-separated names as `str`, `tuple` or `list`.; title: `str` for figures with a single subplot.; For subplots, pass a string `Tensor` matching the content dimensions, i.e. `row_dims` and `col_dims`.; Passing a `tuple`, `list` or `dict`, will create a tensor with these names internally.; size: Figure size in inches, `(width, height)`.; same_scale: Whether to use the same axis limits for all sub-figures.; log_dims: Dimensions for which the plot axes should be scaled logarithmically.; Can be given as a comma-separated `str`, a sequence of dimension names or a `Shape`.; Use `'_'` to scale unnamed axes logarithmically, e.g. the y-axis of scalar functions.; show_color_bar: Whether to display color bars for heat maps.; color: `Tensor` of line / marker colors.; The color can be specified either as a cycle index (int tensor) or as a hex code (str tensor).; The color of different lines and markers can vary.; alpha: Opacity as `float` or `Tensor`.; This affects all elements, not only line plots.; Opacity can vary between lines and markers.; err: Expected deviation from the value given in `fields`.; For supported plots, adds error bars of size *2·err*.; If the plotted data is the mean of some distribution, a good choice for `err` is the standard deviation along the mean dims.; animate: Time dimension to animate.; If not present in the data, will produce a regular plot instead.; overlay: Dimensions along which elements should be overlaid in the same subplot.; The default is only the `overlay` dimension which is created by `overlay()`.; frame_time: Interval between frames in the animation.; repeat: Whether the animation should loop. Returns:; `Tensor` of figure objects.; The tensor contains those dimensions of `fields` that were not reduced by `row_dims`, `col_dims` or `animate`.; Currently, only single-figure plots are supported. In case of an animation, a displayable animation object will be returned instead of a `Tensor`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:2642,reduce,reduced,2642,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['reduce'],['reduced']
Integrability,""""""" Euler integrator. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:10,integrat,integrator,10,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['integrat'],['integrator']
Integrability,""""""" Runge-Kutta-4 integrator with Euler fallback where velocity values are NaN. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:18,integrat,integrator,18,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['integrat'],['integrator']
Integrability,""""""" Runge-Kutta-4 integrator. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:18,integrat,integrator,18,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['integrat'],['integrator']
Integrability,"""""""; Abstract base class for N-dimensional shapes. Main implementing classes:. * Sphere; * box family: box (generator), Box, Cuboid, BaseBox. All geometry objects support batching.; Thereby any parameter defining the geometry can be varied along arbitrary batch dims.; All batch dimensions are listed in Geometry.shape. Property getters (`@property`, such as `shape`), save for getters, must not depend on any variables marked as *variable* via `__variable_attrs__()` as these may be `None` during tracing.; Equality checks must also take this into account.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py:396,depend,depend,396,phi/geom/_geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py,1,['depend'],['depend']
Integrability,"""""""; Adds `values` to the curves by name.; This can be used to log the evolution of scalar quantities or summaries. The values are stored in a text file within the scene directory.; The curves may also be directly viewed in the user interface. Args:; frame: step; values: Values and names to append to the curves, must be numbers or `phiml.math.Tensor`.; If a curve does not yet exists, a new one is created.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_log.py:233,interface,interface,233,phi/vis/_log.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_log.py,1,['interface'],['interface']
Integrability,"""""""; Advect `field` along the `velocity` vectors using the specified integrator. The behavior depends on the type of `field`:. * `phi.field.PointCloud`: Points are advected forward, see `points`.; * `phi.field.Grid`: Sample points are traced backward, see `semi_lagrangian`. Args:; field: Field to be advected as `phi.field.Field`.; velocity: Any `phi.field.Field` that can be sampled in the elements of `field`.; dt: Time increment; integrator: ODE integrator for solving the movement. Returns:; Advected field of same type as `field`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:69,integrat,integrator,69,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,4,"['depend', 'integrat']","['depends', 'integrator']"
Integrability,"""""""; Advects the sample points of a point cloud using a simple Euler step.; Each point moves by an amount equal to the local velocity times `dt`. Args:; points: Points to be advected. Can be provided as position `Tensor`, `Geometry` or `Field`.; velocity: velocity sampled at the same points as the point cloud; dt: Euler step time increment; integrator: ODE integrator for solving the movement. Returns:; Advected points, same type as `points`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:343,integrat,integrator,343,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['integrat'],['integrator']
Integrability,"""""""; Alias for `phi.field.pad()`. Pads this `Field` using its extrapolation. Unlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`. Args:; widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions; or `dict` mapping dimension names to `(lower, upper)`. Returns:; Padded `Field`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field.py:189,depend,depending,189,phi/field/_field.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field.py,1,['depend'],['depending']
Integrability,"""""""; Calls `f`, passing either the `elements` directly or the relevant sample points as a `Tensor`, depending on the signature of `f`. Args:; f: Function taking a `Geometry` or location `Tensor´ and returning a `Tensor`.; A `Geometry` will be passed if the first argument of `f` is called `geometry` or `geo` or ends with `_geo`.; elements: `Geometry` on which to sample `f`.; at: Set of sample points, see `Geometry.sets`.; extrapolation: Determines which boundary points are relevant. Returns:; Sampled values as `Tensor`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py:100,depend,depending,100,phi/geom/_geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py,1,['depend'],['depending']
Integrability,"""""""; Compute the SPH kernel value or a derivative of the kernel function. For kernels that only depends on the squared distance, such as `poly6`, the `distance` variable is not used.; Instead, the squared distance is derived from `delta`. Args:; delta: Vectors to neighbors, i.e. position differences.; distance: Scalar distance to neighbors.; h: Support radius / smoothing length / maximum distance / cutoff.; spatial_rank: Dimensionality of the simulation.; kernel: Which kernel to use, one of `'quintic-spline'`, `'wendland-c2'`, `'poly6'`.; types: Ordered `tuple` of derivatives to compute, `'kernel'`, `'grad'`, `'laplace'`. Returns:; `phi.math.Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py:96,depend,depends,96,phi/physics/sph.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py,1,['depend'],['depends']
Integrability,"""""""; Computes *∫<sub>R</sub> f(x) dx<sup>d</sup>* , where *f* denotes the `Field`, *R* the `region` and *d* the number of spatial dimensions (`d=field.shape.spatial_rank`).; Depending on the `sample` implementation for `field`, the integral may be a rough approximation. This method is currently only implemented for `CenteredGrid`. Args:; field: `Field` to integrate.; region: Region to integrate over.; **kwargs: Specify numerical scheme. Returns:; Integral as `phi.Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:358,integrat,integrate,358,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,2,['integrat'],['integrate']
Integrability,"""""""; Computes the approximate distance from location to the surface of the geometry.; Locations outside return positive values, inside negative values and zero exactly at the boundary. The exact distance metric used depends on the geometry.; The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.; The distance metric is differentiable and its gradients are bounded at every point in space. When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.; This also holds for negative distances. Args:; location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim. Returns:; Float `Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py:216,depend,depends,216,phi/geom/_geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py,1,['depend'],['depends']
Integrability,"""""""; Computes the divergence of a grid using finite differences. This function can operate in two modes depending on the type of `field`:. * `CenteredGrid` approximates the divergence at cell centers using central differences; * `StaggeredGrid` exactly computes the divergence at cell centers. Args:; field: vector field as `CenteredGrid` or `StaggeredGrid`; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; upwind: For unstructured meshes only. Whether to use upwind interpolation. Returns:; Divergence field as `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:104,depend,depending,104,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['depend'],['depending']
Integrability,"""""""; Computes the field value inside the volume of the (batched) `geometry`. The field value may be determined by integrating over the volume, sampling the central value or any other way. The batch dimensions of `geometry` are matched with this field.; The `geometry` must not share any channel dimensions with this field.; Spatial dimensions of `geometry` can be used to sample a grid of geometries. See Also:; `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields). Args:; field: Source `Field` to sample.; geometry: Single or batched `phi.geom.Geometry` or `Field` or location `Tensor`.; When passing a `Field`, its `elements` are used as sample points.; When passing a vector-valued `Tensor`, a `Point` geometry will be created.; at: One of 'center', 'face', 'vertex'; boundary: Target extrapolation.; dot_face_normal: If not `None` and , `field` is a vector field and `at=='face'`, the dot product between sampled field vectors and the face normals is returned instead.; **kwargs: Sampling arguments, e.g. to specify the numerical scheme.; By default, linear interpolation is used.; Grids also support 6th order implicit sampling at mid-points. Returns:; Sampled values as a `phi.math.Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:114,integrat,integrating,114,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['integrat'],['integrating']
Integrability,"""""""; Creates a new grid by evaluating `face_function` given two neighbouring cells.; One layer of missing cells is inferred from the extrapolation.; ; This method returns a Field of type `type` which must be either StaggeredGrid or CenteredGrid.; When returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.; When returning a CenteredGrid, the new grid has the same resolution as `field`. Args:; field: Grid; face_function: function mapping (value1: Tensor, value2: Tensor) -> center_value: Tensor; boundary: extrapolation mode of the returned grid. Has no effect on the values.; at: Where the result should be sampled, one of 'face', 'center'; dims: Which dimensions to stagger. Defaults to all spatial axes. Returns:; Grid sampled either at centers or faces depending on `at`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:794,depend,depending,794,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['depend'],['depending']
Integrability,"""""""; Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.; This approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step. Args:; pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.; velocity: Velocity grid at time `t`.; pressure: Pressure at time `t`.; dt: Time increment to integrate.; pressure_order: spatial order for derivative computations.; For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.; While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.; supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order); pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.; **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time. Returns:; velocity: Velocity at time `t+dt`, same type as `velocity`.; pressure: Pressure grid at time `t+dt`, `CenteredGrid`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:515,integrat,integrate,515,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['integrat'],['integrate']
Integrability,"""""""; Jax integration. Importing this module registers the Jax backend with `phiml.math`.; Without this, Jax tensors cannot be handled by `phiml.math` functions. To make Jax the default backend, import `phi.jax.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/jax/__init__.py:9,integrat,integration,9,phi/jax/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/jax/__init__.py,1,['integrat'],['integration']
Integrability,"""""""; MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.; It then uses that error estimate to correct the field values.; To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup. Args:; field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`; velocity: Vector field, need not be sampled at same locations as `field`.; dt: Time increment; correction_strength: The estimated error is multiplied by this factor before being applied.; The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.; integrator: ODE integrator for solving the movement. Returns:; Advected field of type `type(field)`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:669,integrat,integrator,669,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['integrat'],['integrator']
Integrability,"""""""; Mark a variable as controllable by any GUI created via `view()`. Example:; >>> dt = control(1.0, (0.1, 10), name=""Time increment (dt)""). This will cause a control component (slider, checkbox, text field, drop-down, etc.) to be generated in the user interface.; Changes to that component will immediately be reflected in the Python variable assigned to the control.; The Python variable will always hold a primitive type, such as `int`, `float´, `bool` or `str`. Args:; value: Initial value. Must be either `int`, `float`, `bool` or `str`.; range: (Optional) Specify range of possible values as `(min, max)`. Only for `int`, `float` and `str` values.; description: Human-readable description.; **kwargs: Additional arguments to determine the appearance of the GUI component,; e.g. `rows` for text fields or `log=False` for float sliders. Returns:; `value`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:254,interface,interface,254,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['interface'],['interface']
Integrability,"""""""; Pads a `Grid` using its extrapolation. Unlike `phi.math.pad()`, this function also affects the `bounds` of the grid, changing its size and origin depending on `widths`. Args:; grid: `CenteredGrid` or `StaggeredGrid`; widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions; or `dict` mapping dimension names to `(lower, upper)`. Returns:; `Grid` of the same type as `grid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:151,depend,depending,151,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['depend'],['depending']
Integrability,"""""""; PyTorch integration. Importing this module registers the PyTorch backend with `phiml.math`.; Without this, PyTorch tensors cannot be handled by `phiml.math` functions. To make PyTorch the default backend, import `phi.torch.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/torch/__init__.py:13,integrat,integration,13,phi/torch/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/torch/__init__.py,1,['integrat'],['integration']
Integrability,"""""""; Reads one or multiple fields from disc. See Also:; `Scene.write()`. Args:; names: Single field name or sequence of field names.; frame: Frame number.; convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors. Returns:; Single `phi.field.Field` or sequence of fields, depending on the type of `names`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:335,depend,depending,335,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,1,['depend'],['depending']
Integrability,"""""""; Returns the figure that was most recently created using `plot()`. The type of the figure depends on which library was used, e.g. `matplotlib.figure.Figure` or `plotly.graph_objs.Figure`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:94,depend,depends,94,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['depend'],['depends']
Integrability,"""""""; Samples a `Field`, `Geometry` or value at the sample points of the field `to`.; The result will approximate `value` on the data structure of `to`.; Unlike `sample()`, this method returns a `Field` object, not a `Tensor`. Aliases:; `value.at(to)`, (and the deprecated `value @ to`). See Also:; `sample()`, `reduce_sample()`, `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields). Args:; value: Object containing values to resample.; This can be; to: `Field` (`CenteredGrid`, `StaggeredGrid` or `PointCloud`) object defining the sample points.; The current values of `to` are ignored.; keep_boundary: Only available if `self` is a `Field`.; If True, the resampled field will inherit the extrapolation from `self` instead of `representation`.; This can result in non-compatible value tensors for staggered grids where the tensor size depends on the extrapolation type.; **kwargs: Sampling arguments, e.g. to specify the numerical scheme.; By default, linear interpolation is used.; Grids also support 6th order implicit sampling at mid-points. Returns:; Field object of same type as `representation`. Examples:; >>> grid = CenteredGrid(x=64, y=32); >>> field.resample(Noise(), to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(1, to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(Box(x=1, y=2), to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(grid, to=grid) == grid; True; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:883,depend,depends,883,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['depend'],['depends']
Integrability,"""""""; Semi-Lagrangian advection with simple backward lookup.; ; This method samples the `velocity` at the grid points of `field`; to determine the lookup location for each grid point by walking backwards along the velocity vectors.; The new values are then determined by sampling `field` at these lookup locations. Args:; field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid); velocity: vector field, need not be compatible with with `field`.; dt: time increment; integrator: ODE integrator for solving the movement. Returns:; Field with same sample points as `field`. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:490,integrat,integrator,490,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['integrat'],['integrator']
Integrability,"""""""; Show `fields` in a graphical user interface. `fields` may contain instances of `Field` or variable names of top-level variables (main module or Jupyter notebook).; During loops, e.g. `view().range()`, the variable status is tracked and the GUI is updated. When called from a Python script, name and description may be specified in the module docstring (string before imports).; The first line is interpreted as the name, the rest as the subtitle.; If not specified, a generic name and description is chosen. Args:; *fields: (Optional) Contents to be displayed. Either variable names or values.; For field instances, all variables referencing the value will be shown.; If not provided, the user namespace is searched for Field variables.; play: Whether to immediately start executing loops.; gui: (Optional) Name of GUI as `str` or GUI class.; Built-in GUIs can be selected via `'dash'`, `'console'`.; See https://tum-pbs.github.io/PhiFlow/Visualization.html; name: (Optional) Name to display in GUI and use for the output directory if `scene=True`.; Will be generated from the top-level script if not provided.; description: (Optional) Description to be displayed in the GUI.; Will be generated from the top-level script if not provided.; scene: Existing `Scene` to write into or `bool`. If `True`, creates a new Scene in `~/phi/<name>`; keep_alive: Whether the GUI should keep running even after the main thread finishes.; framerate: Target frame rate in Hz. Play will not step faster than the framerate. `None` for unlimited frame rate.; select: Dimension names along which one item to show is selected.; Dimensions may be passed as `tuple` of `str` or as comma-separated names in a single `str`.; For each `select` dimension, an associated selection slider will be created.; log_performance: Whether to measure and log the time each step takes.; If `True`, will be logged as `step_time` to `log_step_time.txt`.; **config: Additional GUI configuration arguments. Returns:; `Viewer`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:39,interface,interface,39,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['interface'],['interface']
Integrability,"""""""; Shows variables from the user namespace.; To create a `Viewer`, call `phi.vis.view()` from the top-level Python script or from a notebook. Use `Viewer.range()` to control the loop execution from the user interface. Also see the user interface documentation at https://tum-pbs.github.io/PhiFlow/Visualization.html; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:209,interface,interface,209,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,2,['interface'],['interface']
Integrability,"""""""; Similarly to `range()`, returns a generator that can be used in a `for` loop. >>> for step in ModuleViewer().range(100):; >>> print(f'Running step {step}'). However, `Viewer.range()` enables controlling the flow via the user interface.; Each element returned by the generator waits for `progress` to be invoked once. Note that `step` is always equal to `Viewer.steps`. This method can be invoked multiple times.; However, do not call this method while one `range` is still active. Args:; *args: Either no arguments for infinite loop or single `int` argument `stop`.; Must be empty if `rec_dim` is used.; **rec_dim: Can be used instead of `*args` to record values along a new batch dimension of this name.; The recorded values can be accessed as `Viewer.rec.<name>` or `Viewer.rec['<name>']`.; warmup: Number of uncounted loop iterations to perform before `step()` is invoked for the first time. Yields:; Step count of `Viewer`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:230,interface,interface,230,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,1,['interface'],['interface']
Integrability,"""""""; TensorFlow integration. Importing this module registers the TensorFlow backend with `phiml.math`.; Without this, TensorFlow tensors cannot be handled by `phiml.math` functions. To make TensorFlow the default backend, import `phi.tf.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/__init__.py:16,integrat,integration,16,phi/tf/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/__init__.py,1,['integrat'],['integration']
Integrability,"""""""; Tools for running Smoothed Particle Hydrodynamics (SPH) simulations. 1. Create particles as a `Geometry` collections.; 2. Use `neighbor_graph` to find neighbor particles and compute kernel weights.; 3. Use custom function or built-in physics operations to integrate the dynamics.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py:261,integrat,integrate,261,phi/physics/sph.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py,1,['integrat'],['integrate']
Integrability,"""""""; Update the status message.; The status message is written to the console and the log file.; Additionally, it may be displayed by the user interface. See `debug()`. Args:; message: Message to display; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:23,message,message,23,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,4,"['interface', 'message']","['interface', 'message']"
Integrability,"""""""; Visualization: plotting, interactive user interfaces. Use `view()` to show fields or field variables in an interactive user interface. Use `plot()` to plot fields using Matplotlib. See the user interface documentation at https://tum-pbs.github.io/PhiFlow/Visualization.html; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/__init__.py:47,interface,interfaces,47,phi/vis/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/__init__.py,3,['interface'],"['interface', 'interfaces']"
Integrability,"# --- integrate column above face: linearly increasing + constant ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:6,integrat,integrate,6,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['integrat'],['integrate']
Integrability,"# --- wrap results as Φ-Flow tensors ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:6,wrap,wrap,6,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['wrap'],['wrap']
Integrability,"# ------------------------------------------; # loc=1 for face centers whose cells are next to solid-fluid interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:107,interface,interface,107,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,1,['interface'],['interface']
Integrability,"# Assign value -1 to faces that lie inside or on the interfaces; # 1 to ones outside the interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:53,interface,interfaces,53,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,8,['interface'],"['interface', 'interfaces']"
Integrability,"# For computing x face locations that lie on solid-fluid interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:57,interface,interface,57,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,2,['interface'],['interface']
Integrability,"# For computing y face locations that lie on solid-fluid interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:57,interface,interface,57,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,4,['interface'],['interface']
Integrability,"# Mark the x faces that lie inside or on solid-fluid interfaces",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:53,interface,interfaces,53,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,4,['interface'],['interfaces']
Integrability,"# Mark the x faces that lie inside or on solid-fluid interfaces ",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:53,interface,interfaces,53,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,2,['interface'],['interfaces']
Integrability,"# No dependence on Geometry",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_functions.py:5,depend,dependence,5,phi/geom/_functions.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_functions.py,1,['depend'],['dependence']
Integrability,"# centroid_x = {dim: .5 * (wrap(x[:-1]) + wrap(x[1:])) for dim, x in resolution_.items()}; # centroids = math.meshgrid(**centroid_x)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:27,wrap,wrap,27,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,2,['wrap'],['wrap']
Integrability,"# cond_z_at = (obst_field_f+obst_field_b>0) * (obst_field_f+obst_field_b<2); # cond_x_out= not cond_x; # Assign value -1 to faces that lie inside or on the interface,; # 1 to ones outside the interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py:156,interface,interface,156,demos/Top_Opt/voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/voxels.py,2,['interface'],['interface']
Integrability,"# vis = self.vis; # self.vis.logger.removeHandler(self.vis.console_handler); # terminal_size = shutil.get_terminal_size(fallback=(80, 20)); #; # class CustomHandler(Handler):; #; # def emit(self, record: LogRecord) -> None:; # pass; #; # def handle(self, record: LogRecord) -> None:; # line = vis.message + "" "" * (max(1, terminal_size[0]-len(vis.message)-1)); # print(line, end=""\r""); #; # def createLock(self) -> None:; # pass; #; # self.vis.logger.addHandler(CustomHandler())",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_console/_console_gui.py:297,message,message,297,phi/vis/_console/_console_gui.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_console/_console_gui.py,2,['message'],['message']
Integrability,"# we could wrap instead of layout if all values have same shapes",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:11,wrap,wrap,11,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['wrap'],['wrap']
Integrability,"#------------------------------------------; ## loc=1 for face centers whose cells are next to solid-fluid interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_voxels.py:107,interface,interface,107,phi/geom/_voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_voxels.py,1,['interface'],['interface']
Integrability,"#cond_z_at = (obst_field_f+obst_field_b>0) * (obst_field_f+obst_field_b<2) ; #cond_x_out= not cond_x; # Assign value -1 to faces that lie inside or on the interface,; # 1 to ones outside the interface",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_voxels.py:155,interface,interface,155,phi/geom/_voxels.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_voxels.py,2,['interface'],['interface']
Modifiability,""""""" Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:17,config,configuration,17,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,2,['config'],['configuration']
Modifiability,"""""""; Abstract base class for N-dimensional shapes. Main implementing classes:. * Sphere; * box family: box (generator), Box, Cuboid, BaseBox. All geometry objects support batching.; Thereby any parameter defining the geometry can be varied along arbitrary batch dims.; All batch dimensions are listed in Geometry.shape. Property getters (`@property`, such as `shape`), save for getters, must not depend on any variables marked as *variable* via `__variable_attrs__()` as these may be `None` during tracing.; Equality checks must also take this into account.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py:410,variab,variables,410,phi/geom/_geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py,2,['variab'],"['variable', 'variables']"
Modifiability,"""""""; Build a mesh for a given domain, respecting obstacles. Args:; bounds: Bounds for uniform cells.; resolution: Base resolution; obstacles: Single `Geometry` or `dict` mapping boundary name to corresponding `Geometry`.; method: Meshing algorithm. Only `quad` is currently supported.; cell_dim: Dimension along which to list the cells. This should be an instance dimension.; face_format: Sparse storage format for cell connectivity.; max_squish: Smallest allowed cell size compared to the smallest regular cell.; **resolution_: For uniform grid, pass resolution as `int` and specify `bounds`.; Or pass a sequence of floats for each dimension, specifying the vertex positions along each axis.; This allows for variable cell stretching. Returns:; `Mesh`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:710,variab,variable,710,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['variab'],['variable']
Modifiability,"""""""; Checks your configuration for potential problems and prints a summary. To run verify without importing `phi`, run the script `tests/verify.py` included in the source distribution.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:17,config,configuration,17,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['config'],['configuration']
Modifiability,"""""""; Compute the SPH kernel value or a derivative of the kernel function. For kernels that only depends on the squared distance, such as `poly6`, the `distance` variable is not used.; Instead, the squared distance is derived from `delta`. Args:; delta: Vectors to neighbors, i.e. position differences.; distance: Scalar distance to neighbors.; h: Support radius / smoothing length / maximum distance / cutoff.; spatial_rank: Dimensionality of the simulation.; kernel: Which kernel to use, one of `'quintic-spline'`, `'wendland-c2'`, `'poly6'`.; types: Ordered `tuple` of derivatives to compute, `'kernel'`, `'grad'`, `'laplace'`. Returns:; `phi.math.Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py:161,variab,variable,161,phi/physics/sph.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/sph.py,1,['variab'],['variable']
Modifiability,"""""""; Compute the differential diffusion term, d·∇²u.; For grids, uses a finite difference scheme specified by `order` and `implicit`.; For FVM, the scheme is specified via `order` and `upwind`. In contrast to `explicit` and `implicit`, accuracy can be increased by using stencils of higher-order rather than calculating sub-steps. Args:; u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or centered `Mesh`.; diffusivity: Dynamic viscosity, i.e. diffusion per time. Constant or varying by cell.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; upwind: For unstructured meshes only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; Differential diffusion as a `Field` on the same geometry.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py:928,inherit,inherited,928,phi/physics/diffuse.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py,1,['inherit'],['inherited']
Modifiability,"""""""; Computes the differential advection term using the differentiation Scheme indicated by `order`, ´implicit´ and `upwind`. For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign. For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A. Args:; u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.; velocity: `Field` that can be sampled at the elements of `u`.; For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.; Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).; Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.; For FVM, the order is used when interpolating centroid values to faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; upwind: Whether to use upwind interpolation. Only supported for FVM at the moment. Returns:; Differential convection term as `Field` on the same geometry.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:895,inherit,inherited,895,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['inherit'],['inherited']
Modifiability,"""""""; Computes the laplace of `pressure` in the presence of obstacles. Args:; pressure: Pressure field.; hard_bcs: Mask encoding which cells are connected to each other.; One between fluid cells, zero inside and at the boundary of obstacles.; This should be of the same type as the velocity, i.e. `StaggeredGrid` or `CenteredGrid`.; active: Mask indicating for which cells the pressure value is valid.; Linear solves will only determine the pressure for these cells.; This is generally zero inside obstacles and in non-simulated regions.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`). Returns:; `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:756,inherit,inherited,756,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['inherit'],['inherited']
Modifiability,"""""""; Creates a display for the given vis and initializes the configuration.; This method does not set up the display. It only sets up the Gui object and returns as quickly as possible.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:61,config,configuration,61,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,1,['config'],['configuration']
Modifiability,"""""""; Explicit Euler diffusion with substeps. Simulate a finite-time diffusion process of the form dF/dt = α · ΔF on a given `Field` Field with diffusion coefficient α. Args:; u: CenteredGrid, StaggeredGrid or ConstantField; diffusivity: Diffusion per time. `diffusion_amount = diffusivity * dt`; Can be a number, `phi.Tensor` or `phi.field.Field`.; If a channel dimension is present, it will be interpreted as non-isotropic diffusion.; dt: Time interval. `diffusion_amount = diffusivity * dt`; substeps: number of iterations to use (Default value = 1); order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs a spatially implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; upwind: For unstructured meshes only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; Diffused field of same type as `field`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py:771,inherit,inherited,771,phi/physics/diffuse.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py,1,['inherit'],['inherited']
Modifiability,"""""""; Generates random noise fluctuations which can be configured in physical size and smoothness.; Each time values are sampled from a Noise field, a new noise field is generated. Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_noise.py:54,config,configured,54,phi/field/_noise.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_noise.py,1,['config'],['configured']
Modifiability,"""""""; Mark a variable as controllable by any GUI created via `view()`. Example:; >>> dt = control(1.0, (0.1, 10), name=""Time increment (dt)""). This will cause a control component (slider, checkbox, text field, drop-down, etc.) to be generated in the user interface.; Changes to that component will immediately be reflected in the Python variable assigned to the control.; The Python variable will always hold a primitive type, such as `int`, `float´, `bool` or `str`. Args:; value: Initial value. Must be either `int`, `float`, `bool` or `str`.; range: (Optional) Specify range of possible values as `(min, max)`. Only for `int`, `float` and `str` values.; description: Human-readable description.; **kwargs: Additional arguments to determine the appearance of the GUI component,; e.g. `rows` for text fields or `log=False` for float sliders. Returns:; `value`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:12,variab,variable,12,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,3,['variab'],['variable']
Modifiability,"""""""; Restores all viewed fields to the states they were in when the viewer was created.; Changes variable values in the user namespace.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:97,variab,variable,97,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,1,['variab'],['variable']
Modifiability,"""""""; Returns a Tensor enumerating the physical center locations of all cells within the Domain.; This is equivalent to calling `domain.cells.center`.; ; The shape of the returned Tensor extends the domain resolution by one vector dimension.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py:186,extend,extends,186,phi/physics/_boundaries.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py,1,['extend'],['extends']
Modifiability,"""""""; Returns the current configuration of the GUI.; The returned dictionary may only contain serializable values and all keys must be strings.; The configuration can be passed to another instance of this class using set_configuration().; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:25,config,configuration,25,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,2,['config'],['configuration']
Modifiability,"""""""; Run a number of steps. Args:; model: Model to progress; max_steps: (optional) stop when this many steps have been completed (independent of the `steps` variable) or `pause()` is called.; framerate: Target frame rate in Hz.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:157,variab,variable,157,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,1,['variab'],['variable']
Modifiability,"""""""; Samples a `Field`, `Geometry` or value at the sample points of the field `to`.; The result will approximate `value` on the data structure of `to`.; Unlike `sample()`, this method returns a `Field` object, not a `Tensor`. Aliases:; `value.at(to)`, (and the deprecated `value @ to`). See Also:; `sample()`, `reduce_sample()`, `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields). Args:; value: Object containing values to resample.; This can be; to: `Field` (`CenteredGrid`, `StaggeredGrid` or `PointCloud`) object defining the sample points.; The current values of `to` are ignored.; keep_boundary: Only available if `self` is a `Field`.; If True, the resampled field will inherit the extrapolation from `self` instead of `representation`.; This can result in non-compatible value tensors for staggered grids where the tensor size depends on the extrapolation type.; **kwargs: Sampling arguments, e.g. to specify the numerical scheme.; By default, linear interpolation is used.; Grids also support 6th order implicit sampling at mid-points. Returns:; Field object of same type as `representation`. Examples:; >>> grid = CenteredGrid(x=64, y=32); >>> field.resample(Noise(), to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(1, to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(Box(x=1, y=2), to=grid); CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]; >>> field.resample(grid, to=grid) == grid; True; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:725,inherit,inherit,725,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['inherit'],['inherit']
Modifiability,"""""""; Show `fields` in a graphical user interface. `fields` may contain instances of `Field` or variable names of top-level variables (main module or Jupyter notebook).; During loops, e.g. `view().range()`, the variable status is tracked and the GUI is updated. When called from a Python script, name and description may be specified in the module docstring (string before imports).; The first line is interpreted as the name, the rest as the subtitle.; If not specified, a generic name and description is chosen. Args:; *fields: (Optional) Contents to be displayed. Either variable names or values.; For field instances, all variables referencing the value will be shown.; If not provided, the user namespace is searched for Field variables.; play: Whether to immediately start executing loops.; gui: (Optional) Name of GUI as `str` or GUI class.; Built-in GUIs can be selected via `'dash'`, `'console'`.; See https://tum-pbs.github.io/PhiFlow/Visualization.html; name: (Optional) Name to display in GUI and use for the output directory if `scene=True`.; Will be generated from the top-level script if not provided.; description: (Optional) Description to be displayed in the GUI.; Will be generated from the top-level script if not provided.; scene: Existing `Scene` to write into or `bool`. If `True`, creates a new Scene in `~/phi/<name>`; keep_alive: Whether the GUI should keep running even after the main thread finishes.; framerate: Target frame rate in Hz. Play will not step faster than the framerate. `None` for unlimited frame rate.; select: Dimension names along which one item to show is selected.; Dimensions may be passed as `tuple` of `str` or as comma-separated names in a single `str`.; For each `select` dimension, an associated selection slider will be created.; log_performance: Whether to measure and log the time each step takes.; If `True`, will be logged as `step_time` to `log_step_time.txt`.; **config: Additional GUI configuration arguments. Returns:; `Viewer`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:95,variab,variable,95,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,8,"['config', 'variab']","['config', 'configuration', 'variable', 'variables']"
Modifiability,"""""""; Shows variables from the user namespace.; To create a `Viewer`, call `phi.vis.view()` from the top-level Python script or from a notebook. Use `Viewer.range()` to control the loop execution from the user interface. Also see the user interface documentation at https://tum-pbs.github.io/PhiFlow/Visualization.html; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:11,variab,variables,11,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,1,['variab'],['variables']
Modifiability,"""""""; Spatial Laplace operator for scalar grid. For grids, uses a finite difference scheme specified by `order` and `implicit`.; For unstructured meshes, the scheme is specified via `order` and `upwind`. Args:; u: n-dimensional grid or mesh.; axes: The second derivative along these dimensions is summed over; weights: (Optional) Multiply the axis terms by these factors before summation.; Must be a `phi.math.Tensor` or `phi.field.Field` with a single channel dimension that lists all laplace axes by name.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; upwind: FVM only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; laplacian field as `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:910,inherit,inherited,910,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['inherit'],['inherited']
Modifiability,"""""""; Standard import for TensorFlow mode. Extends the import `from phi.flow import *` by TensorFlow-related functions and modules. The following TensorFlow modules are included: `tensorflow` / `tf`, `keras`, `layers`. Importing this module registers the TensorFlow backend as the default backend unless called within a backend context.; New tensors created via `phiml.math` functions will be backed by TensorFlow tensors. See `phi.flow`, `phi.torch.flow`, `phi.jax.flow`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/flow.py:209,layers,layers,209,phi/tf/flow.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/flow.py,1,['layers'],['layers']
Modifiability,"""""""; Updates the GUI configuration.; This method may only be called while the GUI is not yet visible, i.e. before show() is called. Args:; config: Complete or partial GUI-specific configuration. dictionary mapping from strings to JSON serializable values; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:21,config,configuration,21,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,3,['config'],"['config', 'configuration']"
Modifiability,"""""""; Visualization: plotting, interactive user interfaces. Use `view()` to show fields or field variables in an interactive user interface. Use `plot()` to plot fields using Matplotlib. See the user interface documentation at https://tum-pbs.github.io/PhiFlow/Visualization.html; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/__init__.py:96,variab,variables,96,phi/vis/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/__init__.py,1,['variab'],['variables']
Modifiability,"# MODEL_ACTIONS.extend([Input(action.name, 'n_clicks') for action in actions])",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/model_controls.py:16,extend,extend,16,phi/vis/_dash/model_controls.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/model_controls.py,1,['extend'],['extend']
Modifiability,"# all variables are in the current scope",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_user_namespace.py:6,variab,variables,6,phi/vis/_user_namespace.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_user_namespace.py,1,['variab'],['variables']
Modifiability,"# edge_list = [(s, e) for s, e, m in zip(start_vert, end_vert, dim_mask) if m]; # boundaries.setdefault(boundary, []).extend(edge_list)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:118,extend,extend,118,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['extend'],['extend']
Modifiability,"# find variable names",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:7,variab,variable,7,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['variab'],['variable']
Performance,""""""". Args:; height: Heightmap `Tensor` of absolute (world-space) height values.; Scalar height values on a d-1 dimensional grid.; bounds: d-dimensional bounds.; Locations outside `bounds' can never lie inside this geometry if `extrapolation is None`.; Otherwise, only the height dimension is checked.; The grid dimensions of `bounds` must be finite but the height dimension may be infinite to count all values above/below `height` as inside.; max_dist: Maximum distance up to which the distance approximations should be valid.; This does not affect the number of computations performed to compute the distance.; Low values increase accuracy close to the surface but trade off possibly very wrong distances further away.; fill_below: Whether the inside is below or above the height values.; extrapolation: Surface height outside `bounds´. Can be any valid `phiml.math.Extrapolation`, such as a constant.; If not `None`, values outside `bounds` will be checked against the extrapolated `height` values.; Otherwise, values outside `bounds` always lie on the outside.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:576,perform,performed,576,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['perform'],['performed']
Performance,"""""""; Compute the differential diffusion term, d·∇²u.; For grids, uses a finite difference scheme specified by `order` and `implicit`.; For FVM, the scheme is specified via `order` and `upwind`. In contrast to `explicit` and `implicit`, accuracy can be increased by using stencils of higher-order rather than calculating sub-steps. Args:; u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or centered `Mesh`.; diffusivity: Dynamic viscosity, i.e. diffusion per time. Constant or varying by cell.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; upwind: For unstructured meshes only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; Differential diffusion as a `Field` on the same geometry.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py:1100,perform,performs,1100,phi/physics/diffuse.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py,1,['perform'],['performs']
Performance,"""""""; Computes the differential advection term using the differentiation Scheme indicated by `order`, ´implicit´ and `upwind`. For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign. For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A. Args:; u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.; velocity: `Field` that can be sampled at the elements of `u`.; For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.; Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).; Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.; For FVM, the order is used when interpolating centroid values to faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; upwind: Whether to use upwind interpolation. Only supported for FVM at the moment. Returns:; Differential convection term as `Field` on the same geometry.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:1165,perform,performs,1165,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['perform'],['performs']
Performance,"""""""; Computes the divergence of a grid using finite differences. This function can operate in two modes depending on the type of `field`:. * `CenteredGrid` approximates the divergence at cell centers using central differences; * `StaggeredGrid` exactly computes the divergence at cell centers. Args:; field: vector field as `CenteredGrid` or `StaggeredGrid`; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; upwind: For unstructured meshes only. Whether to use upwind interpolation. Returns:; Divergence field as `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:621,perform,performs,621,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['perform'],['performs']
Performance,"""""""; Explicit Euler diffusion with substeps. Simulate a finite-time diffusion process of the form dF/dt = α · ΔF on a given `Field` Field with diffusion coefficient α. Args:; u: CenteredGrid, StaggeredGrid or ConstantField; diffusivity: Diffusion per time. `diffusion_amount = diffusivity * dt`; Can be a number, `phi.Tensor` or `phi.field.Field`.; If a channel dimension is present, it will be interpreted as non-isotropic diffusion.; dt: Time interval. `diffusion_amount = diffusivity * dt`; substeps: number of iterations to use (Default value = 1); order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs a spatially implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; upwind: For unstructured meshes only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; Diffused field of same type as `field`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py:943,perform,performs,943,phi/physics/diffuse.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/diffuse.py,1,['perform'],['performs']
Performance,"""""""; Finite difference spatial_gradient. This function can operate in two modes:. * `type=CenteredGrid` approximates the spatial_gradient at cell centers using central differences; * `type=StaggeredGrid` computes the spatial_gradient at face centers of neighbouring cells. Args:; field: centered grid of any number of dimensions (scalar field, vector field, tensor field); boundary: Boundary conditions of the gradient field.; at: Either `'face'` or `'center'`; dims: Along which dimensions to compute the spatial gradient. Only supported when `type==CenteredGrid`.; stack_dim: Dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.; The `field` must not have a dimension of the same name.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; gradient_extrapolation: Alias for `boundary`.; scheme: For unstructured meshes only. Currently only `'green-gauss'` is supported.; upwind: For unstructured meshes only. Whether to use upwind interpolation. Returns:; spatial_gradient field of type `type`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:994,perform,performs,994,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['perform'],['performs']
Performance,"""""""; Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.; This approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step. Args:; pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.; velocity: Velocity grid at time `t`.; pressure: Pressure at time `t`.; dt: Time increment to integrate.; pressure_order: spatial order for derivative computations.; For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.; While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.; supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order); pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.; **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time. Returns:; velocity: Velocity at time `t+dt`, same type as `velocity`.; pressure: Pressure grid at time `t+dt`, `CenteredGrid`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:878,perform,performance,878,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['perform'],['performance']
Performance,"""""""; Loads a previously saved `Field` from disc. See Also:; `write()`. Args:; file: Single file as `str` or `Tensor` of string type.; If `file` is a tensor, all contained files are loaded an stacked according to the dimensions of `file`.; convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors. Returns:; Loaded `Field`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_io.py:181,load,loaded,181,phi/field/_field_io.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_io.py,1,['load'],['loaded']
Performance,"""""""; Open-source simulation toolkit built for optimization and machine learning applications. Use one of the following imports:. * `from phi.flow import *` for NumPy mode; * `from phi.tf.flow import *` for TensorFlow mode; * `from phi.torch.flow import *` for PyTorch mode; * `from phi.jax.flow import *` for Jax mode. Project homepage: https://github.com/tum-pbs/PhiFlow. Documentation overview: https://tum-pbs.github.io/PhiFlow. PyPI: https://pypi.org/project/phiflow/; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:46,optimiz,optimization,46,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['optimiz'],['optimization']
Performance,"""""""; Projects the given velocity field by solving for the pressure and subtracting its spatial_gradient. This method is similar to :func:`field.divergence_free()` but differs in how the boundary conditions are specified. Args:; velocity: Vector field sampled on a grid.; obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.; solve: `Solve` object specifying method and tolerances for the implicit pressure solve.; active: (Optional) Mask for which cells the pressure should be solved.; If given, the velocity may take `NaN` values where it does not contribute to the pressure.; Also, the total divergence will never be subtracted if active is given, even if all values are 1.; order: spatial order for derivative computations.; For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.; While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.; supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order). Returns:; velocity: divergence-free velocity of type `type(velocity)`; pressure: solved pressure field, `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:1083,perform,performance,1083,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['perform'],['performance']
Performance,"""""""; Samples a sub-grid from `grid` with an offset of half a grid cell in directions defined by `interpolation_dirs`. Args:; grid: `Tensor` to be resampled.; interpolation_dirs: List which defines for every spatial dimension of `grid` if interpolation should be performed,; in positive direction `1` / negative direction `-1` / no interpolation`0`; len(interpolation_dirs) == len(grid.shape.spatial.names) is assumed; Example: With `grid.shape.spatial.names=['x', 'y']` and `interpolation_dirs: [1, -1]`; grid will be interpolated half a grid cell in positive x direction and half a grid cell in negative y direction; padding: Extrapolation used for the needed out of Domain values; order: finite difference `Scheme` used for interpolation. Returns:; Sub-grid as `Tensor`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:262,perform,performed,262,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['perform'],['performed']
Performance,"""""""; Similarly to `range()`, returns a generator that can be used in a `for` loop. >>> for step in ModuleViewer().range(100):; >>> print(f'Running step {step}'). However, `Viewer.range()` enables controlling the flow via the user interface.; Each element returned by the generator waits for `progress` to be invoked once. Note that `step` is always equal to `Viewer.steps`. This method can be invoked multiple times.; However, do not call this method while one `range` is still active. Args:; *args: Either no arguments for infinite loop or single `int` argument `stop`.; Must be empty if `rec_dim` is used.; **rec_dim: Can be used instead of `*args` to record values along a new batch dimension of this name.; The recorded values can be accessed as `Viewer.rec.<name>` or `Viewer.rec['<name>']`.; warmup: Number of uncounted loop iterations to perform before `step()` is invoked for the first time. Yields:; Step count of `Viewer`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:845,perform,perform,845,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,1,['perform'],['perform']
Performance,"""""""; Spatial Laplace operator for scalar grid. For grids, uses a finite difference scheme specified by `order` and `implicit`.; For unstructured meshes, the scheme is specified via `order` and `upwind`. Args:; u: n-dimensional grid or mesh.; axes: The second derivative along these dimensions is summed over; weights: (Optional) Multiply the axis terms by these factors before summation.; Must be a `phi.math.Tensor` or `phi.field.Field` with a single channel dimension that lists all laplace axes by name.; gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. ∇u of the previous time step.; If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.; order: Spatial order of accuracy.; Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.; Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).; For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.; implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.; Otherwise, an explicit stencil is used.; implicitness: specifies the size of the implicit stencil in case an implicit treatment is used; upwind: FVM only. Whether to use upwind interpolation.; correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed. Returns:; laplacian field as `CenteredGrid`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:1082,perform,performs,1082,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['perform'],['performs']
Performance,"""""""; Unstructured mesh.; Use `phi.geom.mesh()` or `phi.geom.mesh_from_numpy()` to construct a mesh manually or `phi.geom.load_su2()` to load one from a file.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:136,load,load,136,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['load'],['load']
Performance,"""""""Topology Optimization; Fluid flow in a cubic container with inlets and outlets set using params dictionary.; After every few time steps non-optimal regions are filled with obstacles and optimization simulation is restarted; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/Top_Opt3D.py:189,optimiz,optimization,189,demos/Top_Opt/Top_Opt3D.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/demos/Top_Opt/Top_Opt3D.py,1,['optimiz'],['optimization']
Performance,"# scale can only be performed for finite sizes",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_box.py:20,perform,performed,20,phi/geom/_box.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_box.py,1,['perform'],['performed']
Performance,"# vertices without a cell could be removed to improve memory/cache efficiency",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py:61,cache,cache,61,phi/geom/_mesh.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_mesh.py,1,['cache'],['cache']
Safety,"""""""; MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.; It then uses that error estimate to correct the field values.; To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup. Args:; field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`; velocity: Vector field, need not be sampled at same locations as `field`.; dt: Time increment; correction_strength: The estimated error is multiplied by this factor before being applied.; The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.; integrator: ODE integrator for solving the movement. Returns:; Advected field of type `type(field)`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:193,avoid,avoid,193,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,2,['avoid'],['avoid']
Safety,"# The point labels match one of the figure axes, so they are redundant",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:61,redund,redundant,61,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,1,['redund'],['redundant']
Security,""""""" Determine whether outside cells are accessible based on the velocity extrapolation. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:40,access,accessible,40,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['access'],['accessible']
Security,"""""""; Similarly to `range()`, returns a generator that can be used in a `for` loop. >>> for step in ModuleViewer().range(100):; >>> print(f'Running step {step}'). However, `Viewer.range()` enables controlling the flow via the user interface.; Each element returned by the generator waits for `progress` to be invoked once. Note that `step` is always equal to `Viewer.steps`. This method can be invoked multiple times.; However, do not call this method while one `range` is still active. Args:; *args: Either no arguments for infinite loop or single `int` argument `stop`.; Must be empty if `rec_dim` is used.; **rec_dim: Can be used instead of `*args` to record values along a new batch dimension of this name.; The recorded values can be accessed as `Viewer.rec.<name>` or `Viewer.rec['<name>']`.; warmup: Number of uncounted loop iterations to perform before `step()` is invoked for the first time. Yields:; Step count of `Viewer`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:738,access,accessed,738,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,1,['access'],['accessed']
Security,"""""""; Unifies domain and Obstacle or Geometry objects into a binary StaggeredGrid mask which can be used; to enforce boundary conditions. Args:; not_accessible: blocked region(s) of space specified by geometries; type: class of Grid to create, must be either CenteredGrid or StaggeredGrid; extrapolation: (optional) grid extrapolation, defaults to Domain.boundaries['accessible']. Returns:; Binary mask indicating valid fields w.r.t. the boundary conditions.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py:366,access,accessible,366,phi/physics/_boundaries.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/_boundaries.py,1,['access'],['accessible']
Security,"# accessible = CenteredGrid(~union([obs.geometry for obs in obstacles]), accessible_boundary, velocity.bounds, velocity.resolution)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py:2,access,accessible,2,phi/physics/fluid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/fluid.py,1,['access'],['accessible']
Testability," be plotted, the dimensions `args` is created if multiple arguments are passed,; and `tuple`, `list`, `dict` are generated for corresponding objects to be plotted. Args:; fields: Fields or Tensors to plot.; lib: Plotting library name or reference. Valid names are `'matplotlib'`, `'plotly'` and `'console'`.; row_dims: Batch dimensions along which sub-figures should be laid out vertically.; `Shape` or comma-separated names as `str`, `tuple` or `list`.; col_dims: Batch dimensions along which sub-figures should be laid out horizontally.; `Shape` or comma-separated names as `str`, `tuple` or `list`.; title: `str` for figures with a single subplot.; For subplots, pass a string `Tensor` matching the content dimensions, i.e. `row_dims` and `col_dims`.; Passing a `tuple`, `list` or `dict`, will create a tensor with these names internally.; size: Figure size in inches, `(width, height)`.; same_scale: Whether to use the same axis limits for all sub-figures.; log_dims: Dimensions for which the plot axes should be scaled logarithmically.; Can be given as a comma-separated `str`, a sequence of dimension names or a `Shape`.; Use `'_'` to scale unnamed axes logarithmically, e.g. the y-axis of scalar functions.; show_color_bar: Whether to display color bars for heat maps.; color: `Tensor` of line / marker colors.; The color can be specified either as a cycle index (int tensor) or as a hex code (str tensor).; The color of different lines and markers can vary.; alpha: Opacity as `float` or `Tensor`.; This affects all elements, not only line plots.; Opacity can vary between lines and markers.; err: Expected deviation from the value given in `fields`.; For supported plots, adds error bars of size *2·err*.; If the plotted data is the mean of some distribution, a good choice for `err` is the standard deviation along the mean dims.; animate: Time dimension to animate.; If not present in the data, will produce a regular plot instead.; overlay: Dimensions along which elements should be overl",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:1362,log,logarithmically,1362,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['log'],['logarithmically']
Testability,""""""" Directory to which data and logging information should be written as `Scene` instance. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:32,log,logging,32,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,1,['log'],['logging']
Testability,""""""" Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:78,test,tests,78,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,1,['test'],['tests']
Testability,"""""""; Adds `values` to the curves by name.; This can be used to log the evolution of scalar quantities or summaries. The values are stored in a text file within the scene directory.; The curves may also be directly viewed in the user interface. Args:; frame: step; values: Values and names to append to the curves, must be numbers or `phiml.math.Tensor`.; If a curve does not yet exists, a new one is created.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_log.py:63,log,log,63,phi/vis/_log.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_log.py,1,['log'],['log']
Testability,"""""""; Args:; size: Figure size in inches.; rows: Number of sub-figures laid out vertically.; cols: Number of sub-figures laid out horizontally.; spaces: Axes and range per sub-plot: `(x,y) -> Box`. Only subplot locations contained as keys should be plotted.; To indicate automatic limit, the box will have a lower or upper limit of -inf or inf, respectively.; titles: Subplot titles.; log_dims: Dimensions along which axes should be log-scaled; plt_params: Additional library-specific parameters for plotting. Returns:; figure: Native figure object; subfigures: Native sub-figures by subplot location.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:432,log,log-scaled,432,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,1,['log'],['log-scaled']
Testability,"""""""; Checks your configuration for potential problems and prints a summary. To run verify without importing `phi`, run the script `tests/verify.py` included in the source distribution.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:131,test,tests,131,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['test'],['tests']
Testability,"""""""; Mark a variable as controllable by any GUI created via `view()`. Example:; >>> dt = control(1.0, (0.1, 10), name=""Time increment (dt)""). This will cause a control component (slider, checkbox, text field, drop-down, etc.) to be generated in the user interface.; Changes to that component will immediately be reflected in the Python variable assigned to the control.; The Python variable will always hold a primitive type, such as `int`, `float´, `bool` or `str`. Args:; value: Initial value. Must be either `int`, `float`, `bool` or `str`.; range: (Optional) Specify range of possible values as `(min, max)`. Only for `int`, `float` and `str` values.; description: Human-readable description.; **kwargs: Additional arguments to determine the appearance of the GUI component,; e.g. `rows` for text fields or `log=False` for float sliders. Returns:; `value`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:812,log,log,812,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['log'],['log']
Testability,"""""""; Read one or a `Tensor` of scalar logs as curves. Args:; scene: `Scene` or `str`. Directory containing the log files.; name: Log file base name.; prefix: Log file prefix.; suffix: Log file suffix.; x: 'steps' or 'time'; entries_dim: Curve dimension. Returns:; `Tensor` containing `entries_dim` and `vector`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_io.py:38,log,logs,38,phi/vis/_io.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_io.py,2,['log'],"['log', 'logs']"
Testability,"""""""; Sets the logging level for PhiFlow functions. Args:; level: Logging level, one of `'critical', 'fatal', 'error', 'warning', 'info', 'debug'`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:14,log,logging,14,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['log'],['logging']
Testability,"""""""; Show `fields` in a graphical user interface. `fields` may contain instances of `Field` or variable names of top-level variables (main module or Jupyter notebook).; During loops, e.g. `view().range()`, the variable status is tracked and the GUI is updated. When called from a Python script, name and description may be specified in the module docstring (string before imports).; The first line is interpreted as the name, the rest as the subtitle.; If not specified, a generic name and description is chosen. Args:; *fields: (Optional) Contents to be displayed. Either variable names or values.; For field instances, all variables referencing the value will be shown.; If not provided, the user namespace is searched for Field variables.; play: Whether to immediately start executing loops.; gui: (Optional) Name of GUI as `str` or GUI class.; Built-in GUIs can be selected via `'dash'`, `'console'`.; See https://tum-pbs.github.io/PhiFlow/Visualization.html; name: (Optional) Name to display in GUI and use for the output directory if `scene=True`.; Will be generated from the top-level script if not provided.; description: (Optional) Description to be displayed in the GUI.; Will be generated from the top-level script if not provided.; scene: Existing `Scene` to write into or `bool`. If `True`, creates a new Scene in `~/phi/<name>`; keep_alive: Whether the GUI should keep running even after the main thread finishes.; framerate: Target frame rate in Hz. Play will not step faster than the framerate. `None` for unlimited frame rate.; select: Dimension names along which one item to show is selected.; Dimensions may be passed as `tuple` of `str` or as comma-separated names in a single `str`.; For each `select` dimension, an associated selection slider will be created.; log_performance: Whether to measure and log the time each step takes.; If `True`, will be logged as `step_time` to `log_step_time.txt`.; **config: Additional GUI configuration arguments. Returns:; `Viewer`; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:1823,log,log,1823,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,2,['log'],"['log', 'logged']"
Testability,"""""""; Update the status message.; The status message is written to the console and the log file.; Additionally, it may be displayed by the user interface. See `debug()`. Args:; message: Message to display; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py:86,log,log,86,phi/vis/_viewer.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_viewer.py,1,['log'],['log']
Testability,"""""""assert that the frac of undocumented public wildcard imports is less than limit. :param modulename: Module to be checked; :type modulename: str; :param max_undoc_frac: Limit - Frac. below which undocumented public wildcard imports are okay; :type max_undoc_frac: float [0, 1]; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/test_docstrings.py:3,assert,assert,3,tests/commit/test_docstrings.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/test_docstrings.py,1,['assert'],['assert']
Testability,"# --- Run benchmark ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/board.py:10,benchmark,benchmark,10,phi/vis/_dash/board.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/board.py,1,['benchmark'],['benchmark']
Testability,"# --- test location against all considered faces and boundaries ---; # distances = plane_sgn_dist(-offsets, normals, location) # offset has the - convention here",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py:6,test,test,6,phi/geom/_heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_heightmap.py,1,['test'],['test']
Testability,"# Compare center; # new_center = get_color_interpolation(center, cm_arr); # if not all(new_center == [center, *central_color]):; # print(""Failed center comparison.""); # print(""Center: {}"".format(new_center)); # print(""Center should be: {}"".format([center, *central_color])); # assert False; # Cut to (0, 1)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/_plotly_plots.py:277,assert,assert,277,phi/vis/_dash/_plotly_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/_plotly_plots.py,1,['assert'],['assert']
Testability,"# Hides the Plotly logo",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/_plotly_plots.py:19,log,logo,19,phi/vis/_dash/_plotly_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_dash/_plotly_plots.py,1,['log'],['logo']
Testability,"# assert isinstance(item, dict), ""Index must be dict of type {dim: slice/int}.""; # item = {dim: sel for dim, sel in item.items() if dim != 'vector'}; # attrs = {a: getattr(self, a)[item] for a in variable_attributes(self)}; # return copy_with(self, **attrs)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py:2,assert,assert,2,phi/geom/_geom.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/geom/_geom.py,1,['assert'],['assert']
Testability,"# def connect(obj: Field, connections: Tensor) -> Mesh:; # """"""; # Build a `Mesh` by connecting elements from a field.; #; # See Also:; # `connect_neighbors()`.; #; # Args:; # obj: `PointCloud` or `Mesh`.; # connections: Connectivity matrix. Any non-zero entry represents a connection.; #; # Returns:; # `Mesh`; # """"""; # if isinstance(obj, (PointCloud, Mesh)):; # return Mesh(obj.elements, connections, obj.values, extrapolation=obj.extrapolation, bounds=obj.bounds); # else:; # raise ValueError(f""connect requires a PointCloud or Mesh but got {type(obj)}""); #; #; # def connect_neighbors(obj: Field, max_distance: float or Tensor, format: str = 'dense') -> Mesh:; # """"""; # Build a `Mesh` by connecting proximate elements of a `Field`.; #; # See Also:; # `connect()`.; #; # Args:; # obj: `PointCloud`, `Mesh`, `CenteredGrid` or `StaggeredGrid`.; # max_distance: Connectivity threshold distance. Elements further apart than this will not be connected.; # format: Connectivity matrix format, `'dense'`, `'coo'` or `'csr'`.; #; # Returns:; # `Mesh`.; # """"""; # if isinstance(obj, CenteredGrid):; # elements = flatten(obj.elements, instance('elements')); # values = math.pack_dims(obj.values, spatial, instance('elements')); # obj = PointCloud(elements, values, obj.extrapolation, bounds=obj.bounds); # elif isinstance(obj, StaggeredGrid):; # elements = flatten(obj.elements, instance('elements'), flatten_batch=True); # values = math.pack_dims(obj.values, spatial(obj.values).names + ('vector',), instance('elements')); # obj = PointCloud(elements, values, obj.extrapolation, bounds=obj.bounds); # assert isinstance(obj, (PointCloud, Mesh)), f""obj must be a PointCloud, Mesh or Grid but got {type(obj)}""; # points = math.rename_dims(obj.elements, spatial, instance).center; # dx = math.pairwise_distances(points, max_distance=max_distance, format=format); # con = math.vec_length(dx) > 0; # return connect(obj, con)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py:1593,assert,assert,1593,phi/field/_field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_field_math.py,1,['assert'],['assert']
Testability,"# def test_slice_staggered_grid_along_spatial(self):; # v = StaggeredGrid(Noise(batch(batch=10)), x=10, y=20); # x1 = v[{'x': 1}]; # x2 = v.x[1]; # x3 = field.unstack(v, 'x')[1]; # self.assertIsInstance(x1, StaggeredGrid); # field.assert_close(x1, x2, x3); # self.assertEqual(x1.bounds, Box['x,y', 1:2, 0:20])",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/field/test__grid.py:186,assert,assertIsInstance,186,tests/commit/field/test__grid.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/field/test__grid.py,2,['assert'],"['assertEqual', 'assertIsInstance']"
Testability,"# geom_ch = channel(geometry).without('vector'); # assert all(dim not in field.shape for dim in geom_ch); # if geom_ch:; # sampled = [field._sample(p, **kwargs) for p in geometry.unstack(geom_ch.name)]; # return math.stack(sampled, geom_ch)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py:51,assert,assert,51,phi/field/_resample.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_resample.py,1,['assert'],['assert']
Testability,"# if dual(values):; # assert dual(values).rank == 1, f""PointCloud cannot convert values with more than 1 dual dimension.""; # non_dual_name = dual(values).name[1:]; # indices = math.stored_indices(values)[non_dual_name]; # values = math.stored_values(values); # elements = elements[{non_dual_name: indices}]",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_point_cloud.py:22,assert,assert,22,phi/field/_point_cloud.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_point_cloud.py,1,['assert'],['assert']
Testability,"# self.assertEqual(converted.elements.center.default_backend, backend); # self.assertEqual(converted.elements.radius.default_backend, backend)",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/field/test__field_math.py:7,assert,assertEqual,7,tests/commit/field/test__field_math.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/field/test__field_math.py,2,['assert'],['assertEqual']
Testability,"# sometimes required for log axis",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:25,log,log,25,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,2,['log'],['log']
Testability,"# subplot.set_xscale('log')",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:22,log,log,22,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,1,['log'],['log']
Testability,"# subplot.set_yscale('log')",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:22,log,log,22,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,1,['log'],['log']
Testability,"# test all exist",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py:2,test,test,2,phi/field/_scene.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/field/_scene.py,1,['test'],['test']
Testability,"# vis = self.vis; # self.vis.logger.removeHandler(self.vis.console_handler); # terminal_size = shutil.get_terminal_size(fallback=(80, 20)); #; # class CustomHandler(Handler):; #; # def emit(self, record: LogRecord) -> None:; # pass; #; # def handle(self, record: LogRecord) -> None:; # line = vis.message + "" "" * (max(1, terminal_size[0]-len(vis.message)-1)); # print(line, end=""\r""); #; # def createLock(self) -> None:; # pass; #; # self.vis.logger.addHandler(CustomHandler())",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_console/_console_gui.py:29,log,logger,29,phi/vis/_console/_console_gui.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_console/_console_gui.py,2,['log'],['logger']
Testability,"be plotted. Args:; fields: Fields or Tensors to plot.; lib: Plotting library name or reference. Valid names are `'matplotlib'`, `'plotly'` and `'console'`.; row_dims: Batch dimensions along which sub-figures should be laid out vertically.; `Shape` or comma-separated names as `str`, `tuple` or `list`.; col_dims: Batch dimensions along which sub-figures should be laid out horizontally.; `Shape` or comma-separated names as `str`, `tuple` or `list`.; title: `str` for figures with a single subplot.; For subplots, pass a string `Tensor` matching the content dimensions, i.e. `row_dims` and `col_dims`.; Passing a `tuple`, `list` or `dict`, will create a tensor with these names internally.; size: Figure size in inches, `(width, height)`.; same_scale: Whether to use the same axis limits for all sub-figures.; log_dims: Dimensions for which the plot axes should be scaled logarithmically.; Can be given as a comma-separated `str`, a sequence of dimension names or a `Shape`.; Use `'_'` to scale unnamed axes logarithmically, e.g. the y-axis of scalar functions.; show_color_bar: Whether to display color bars for heat maps.; color: `Tensor` of line / marker colors.; The color can be specified either as a cycle index (int tensor) or as a hex code (str tensor).; The color of different lines and markers can vary.; alpha: Opacity as `float` or `Tensor`.; This affects all elements, not only line plots.; Opacity can vary between lines and markers.; err: Expected deviation from the value given in `fields`.; For supported plots, adds error bars of size *2·err*.; If the plotted data is the mean of some distribution, a good choice for `err` is the standard deviation along the mean dims.; animate: Time dimension to animate.; If not present in the data, will produce a regular plot instead.; overlay: Dimensions along which elements should be overlaid in the same subplot.; The default is only the `overlay` dimension which is created by `overlay()`.; frame_time: Interval between frames in the animat",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py:1498,log,logarithmically,1498,phi/vis/_vis.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis.py,1,['log'],['logarithmically']
Usability,"""""""; Advects the sample points of a point cloud using a simple Euler step.; Each point moves by an amount equal to the local velocity times `dt`. Args:; points: Points to be advected. Can be provided as position `Tensor`, `Geometry` or `Field`.; velocity: velocity sampled at the same points as the point cloud; dt: Euler step time increment; integrator: ODE integrator for solving the movement. Returns:; Advected points, same type as `points`.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:56,simpl,simple,56,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['simpl'],['simple']
Usability,"""""""; Jax implementation of the unified machine learning API.; Equivalent functions also exist for the other frameworks. For API documentation, see https://tum-pbs.github.io/PhiFlow/Network_API .; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/nets.py:47,learn,learning,47,phi/tf/nets.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/tf/nets.py,1,['learn'],['learning']
Usability,"""""""; Open-source simulation toolkit built for optimization and machine learning applications. Use one of the following imports:. * `from phi.flow import *` for NumPy mode; * `from phi.tf.flow import *` for TensorFlow mode; * `from phi.torch.flow import *` for PyTorch mode; * `from phi.jax.flow import *` for Jax mode. Project homepage: https://github.com/tum-pbs/PhiFlow. Documentation overview: https://tum-pbs.github.io/PhiFlow. PyPI: https://pypi.org/project/phiflow/; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py:71,learn,learning,71,phi/__init__.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/__init__.py,1,['learn'],['learning']
Usability,"""""""; PyTorch implementation of the unified machine learning API.; Equivalent functions also exist for the other frameworks. For API documentation, see https://tum-pbs.github.io/PhiFlow/Network_API .; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/torch/nets.py:51,learn,learning,51,phi/torch/nets.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/torch/nets.py,1,['learn'],['learning']
Usability,"""""""; Run a number of steps. Args:; model: Model to progress; max_steps: (optional) stop when this many steps have been completed (independent of the `steps` variable) or `pause()` is called.; framerate: Target frame rate in Hz.; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py:171,pause,pause,171,phi/vis/_vis_base.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_vis_base.py,1,['pause'],['pause']
Usability,"""""""; Semi-Lagrangian advection with simple backward lookup.; ; This method samples the `velocity` at the grid points of `field`; to determine the lookup location for each grid point by walking backwards along the velocity vectors.; The new values are then determined by sampling `field` at these lookup locations. Args:; field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid); velocity: vector field, need not be compatible with with `field`.; dt: time increment; integrator: ODE integrator for solving the movement. Returns:; Field with same sample points as `field`. """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py:36,simpl,simple,36,phi/physics/advect.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/physics/advect.py,1,['simpl'],['simple']
Usability,"""""""; Stax implementation of the unified machine learning API.; Equivalent functions also exist for the other frameworks. For API documentation, see https://tum-pbs.github.io/PhiFlow/Network_API .; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/jax/stax/nets.py:48,learn,learning,48,phi/jax/stax/nets.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/jax/stax/nets.py,1,['learn'],['learning']
Usability,"""""""assert that the frac of undocumented public wildcard imports is less than limit. :param modulename: Module to be checked; :type modulename: str; :param max_undoc_frac: Limit - Frac. below which undocumented public wildcard imports are okay; :type max_undoc_frac: float [0, 1]; """"""",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/test_docstrings.py:27,undo,undocumented,27,tests/commit/test_docstrings.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/test_docstrings.py,2,['undo'],['undocumented']
Usability,"# --- simple case ---",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/geom/test__heightmap.py:6,simpl,simple,6,tests/commit/geom/test__heightmap.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/tests/commit/geom/test__heightmap.py,1,['simpl'],['simple']
Usability,"# subplot.cla() # this also clears titles and subplot labels",MatchSource.CODE_COMMENT,tum-pbs,PhiFlow,3.1.0,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py:28,clear,clears,28,phi/vis/_matplotlib/_matplotlib_plots.py,,https://github.com/tum-pbs/PhiFlow/tree/3.1.0/phi/vis/_matplotlib/_matplotlib_plots.py,1,['clear'],['clears']
