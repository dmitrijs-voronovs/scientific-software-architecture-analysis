quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"y combained from connection key and session key. ; Definition at line 1992 of file RWebWindow.cxx. ◆ InvokeCallbacks(). void RWebWindow::InvokeCallbacks ; (; bool ; force = false). private . Invoke callbacks with existing data Must be called from appropriate thread. ; Definition at line 438 of file RWebWindow.cxx. ◆ IsFileDialogMessage(). bool RWebWindow::IsFileDialogMessage ; (; const std::string & ; msg). static . Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ; Definition at line 1963 of file RWebWindow.cxx. ◆ IsNativeOnlyConn(). bool ROOT::RWebWindow::IsNativeOnlyConn ; (; ); const. inline . returns true if only native (own-created) connections are allowed ; Definition at line 312 of file RWebWindow.hxx. ◆ IsRequireAuthKey(). bool ROOT::RWebWindow::IsRequireAuthKey ; (; ); const. inline . returns true if authentication string is required ; Definition at line 320 of file RWebWindow.hxx. ◆ IsShown(). bool ROOT::RWebWindow::IsShown ; (; ); const. inline . Returns true when window was shown at least once. ; Definition at line 369 of file RWebWindow.hxx. ◆ IsUseCurrentDir(). bool ROOT::RWebWindow::IsUseCurrentDir ; (; ); const. inline . returns true if window can access local files via currentdir/ path of http server ; Definition at line 328 of file RWebWindow.hxx. ◆ MakeHeadless(). unsigned RWebWindow::MakeHeadless ; (; bool ; create_new = false). private . Start headless browser for specified window Normally only single instance is used, but many can be created See ROOT::RWebWindowsManager::Show() docu for more info returns (future) connection id (or 0 when fails) ; Definition at line 202 of file RWebWindow.cxx. ◆ NumConnections(). int RWebWindow::NumConnections ; (; bool ; with_pending = false); const. Returns current number of active clients connections. ; Parameters. with_pendingif true, also pending (not yet establ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:37440,authenticat,authentication,37440,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['authenticat'],['authentication']
Security,"y combained from connection key and session key. ; Definition at line 2034 of file RWebWindow.cxx. ◆ InvokeCallbacks(). void RWebWindow::InvokeCallbacks ; (; bool ; force = false). private . Invoke callbacks with existing data Must be called from appropriate thread. ; Definition at line 439 of file RWebWindow.cxx. ◆ IsFileDialogMessage(). bool RWebWindow::IsFileDialogMessage ; (; const std::string & ; msg). static . Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ; Definition at line 2005 of file RWebWindow.cxx. ◆ IsNativeOnlyConn(). bool ROOT::RWebWindow::IsNativeOnlyConn ; (; ); const. inline . returns true if only native (own-created) connections are allowed ; Definition at line 315 of file RWebWindow.hxx. ◆ IsRequireAuthKey(). bool ROOT::RWebWindow::IsRequireAuthKey ; (; ); const. inline . returns true if authentication string is required ; Definition at line 323 of file RWebWindow.hxx. ◆ IsShown(). bool ROOT::RWebWindow::IsShown ; (; ); const. inline . Returns true when window was shown at least once. ; Definition at line 372 of file RWebWindow.hxx. ◆ IsUseCurrentDir(). bool ROOT::RWebWindow::IsUseCurrentDir ; (; ); const. inline . returns true if window can access local files via currentdir/ path of http server ; Definition at line 331 of file RWebWindow.hxx. ◆ MakeHeadless(). unsigned RWebWindow::MakeHeadless ; (; bool ; create_new = false). private . Start headless browser for specified window Normally only single instance is used, but many can be created See ROOT::RWebWindowsManager::Show() docu for more info returns (future) connection id (or 0 when fails) ; Definition at line 202 of file RWebWindow.cxx. ◆ NumConnections(). int RWebWindow::NumConnections ; (; bool ; with_pending = false); const. Returns current number of active clients connections. ; Parameters. with_pendingif true, also pending (not yet establ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:36324,authenticat,authentication,36324,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['authenticat'],['authentication']
Security,"y data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15141,password,password,15141,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['password'],['password']
Security,"y from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. TMap * GetDataSetNodeMap(TFileCollection* fc, TString& emsg); Get a map {server-name, list-of-files} for collection 'fc' to be used in; TPacketizerFile. Returns a pointer to the map (ownership of the caller).; Or (TMap *)0 and an error message in emsg. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:25838,authenticat,authentication,25838,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,6,['authenticat'],['authentication']
Security,"y from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:24881,authenticat,authentication,24881,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,4,['authenticat'],['authentication']
Security,"y matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:8243,access,access,8243,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['access'],['access']
Security,"y must be dimensioned to the size of the existing parameters) ;  ; const ROOT::Minuit2::MnUserParameterState & State ();  return the minimizer state (containing values, step size , etc..) ;  ; int VariableIndex (const std::string &name) const override;  get index of variable given a variable given a name return -1 if variable is not found ;  ; std::string VariableName (unsigned int ivar) const override;  get name of variables (override if minimizer support storing of variable names) ;  ; const double * X () const override;  return pointer to X values at the minimum ;  ;  Public Member Functions inherited from ROOT::Math::Minimizer;  Minimizer ();  Default constructor. ;  ;  Minimizer (Minimizer &&)=delete;  ;  Minimizer (Minimizer const &)=delete;  ; virtual ~Minimizer ();  Destructor (no operations). ;  ; double ErrorDef () const;  return the statistical scale used for calculate the error is typically 1 for Chi2 and 0.5 for likelihood minimization ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; void SetDefaultOptions ();  reset the default options (defined in MinimizerOptions) ;  ; void SetErrorDef (double up);  set scale for calculating the errors ;  ; void SetExtraOptions (const IOptions &extraOptions);  set o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:8713,validat,validation,8713,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['validat'],['validation']
Security,"y not allow the (void(*) (void*))s cast and just stop if Thread0 is not static. On the other hand, if Thread0 is static, no compiler warnings are generated at all. Because the 'this' pointer is passed in 'arg' in the call to Thread0(void *arg), you have access to the instance of the class even if Thread0 is static. Using the 'this' pointer, non static members can still be read and written from Thread0, as long as you have provided Getter and Setter methods for these members. For example:; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; Second, the pointer to the current instance of Myclass, i.e. (void*) this, has to be passed as first argument of the threaded function Thread0 (C++ member functions internally expect this pointer as first argument to have access to class members of the same instance). pthreads are made for simple C functions and do not know about Thread0 being a member function of a class. Thus, you have to pass this information by hand, if you want to access all members of the Myclass instance from the Thread0 function.; Note: Method Thread0 cannot be a virtual member function, since the cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1115830,access,access,1115830,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],['access']
Security,"y or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; To create a radioactive m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:892190,access,accessed,892190,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],['accessed']
Security,"y page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_sent >= 0));; 9781 ; 9782 if (sf_sent > 0) {; 9783 return; /* OK */; 9784 }; 9785 ; 9786 /* sf_sent<0 means error, thus fall back to the classic way */; 9787 /* This is always the case, if sf_file is not a ""normal"" file,; 9788 * e.g., for sending data from the output of a CGI process. */; 9789 offset = (int64_t)sf_offs;; 9790 }; 9791#endif; 9792 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9793 mg_cry_internal(conn,; 9794 ""%s: fseeko() failed: %s"",; 9795 __func__,; 9796 strerror(ERRNO));; 9797 mg_send_http_error(; 9798 conn,; 9799 500,; 9800 ""%s"",; 9801 ""Error: Unable to access file at requested position."");; 9802 } else {; 9803 while (len > 0) {; 9804 /* Calculate how much to read from the file in the buffer */; 9805 to_read = sizeof(buf);; 9806 if ((int64_t)to_read > len) {; 9807 to_read = (int)len;; 9808 }; 9809 ; 9810 /* Read from file, exit the loop on error */; 9811 if ((num_read =; 9812 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9813 <= 0) {; 9814 break;; 9815 }; 9816 ; 9817 /* Send read bytes to the client, exit the loop on error */; 9818 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9819 != num_read) {; 9820 break;; 9821 }; 9822 ; 9823 /* Both read and were successful, adjust counters */; 9824 len -= num_written;; 9825 }; 9826 }; 9827 }; 9828}; 9829 ; 98",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:280617,access,access,280617,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"y page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_sent >= 0));; 9782 ; 9783 if (sf_sent > 0) {; 9784 return; /* OK */; 9785 }; 9786 ; 9787 /* sf_sent<0 means error, thus fall back to the classic way */; 9788 /* This is always the case, if sf_file is not a ""normal"" file,; 9789 * e.g., for sending data from the output of a CGI process. */; 9790 offset = (int64_t)sf_offs;; 9791 }; 9792#endif; 9793 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9794 mg_cry_internal(conn,; 9795 ""%s: fseeko() failed: %s"",; 9796 __func__,; 9797 strerror(ERRNO));; 9798 mg_send_http_error(; 9799 conn,; 9800 500,; 9801 ""%s"",; 9802 ""Error: Unable to access file at requested position."");; 9803 } else {; 9804 while (len > 0) {; 9805 /* Calculate how much to read from the file in the buffer */; 9806 to_read = sizeof(buf);; 9807 if ((int64_t)to_read > len) {; 9808 to_read = (int)len;; 9809 }; 9810 ; 9811 /* Read from file, exit the loop on error */; 9812 if ((num_read =; 9813 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9814 <= 0) {; 9815 break;; 9816 }; 9817 ; 9818 /* Send read bytes to the client, exit the loop on error */; 9819 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9820 != num_read) {; 9821 break;; 9822 }; 9823 ; 9824 /* Both read and were successful, adjust counters */; 9825 len -= num_written;; 9826 }; 9827 }; 9828 }; 9829}; 9830 ; 98",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:280649,access,access,280649,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"y read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is changed to this file. ; Reimplemented in TSQLFile, TXMLFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 2162 of file TFile.cxx. ◆ ResetErrno(). void TFile::ResetErrno ; (; ); const. virtual . Method resetting the errno. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, and TMemFile.; Definition at line 1254 of file TFile.cxx. ◆ Seek(). void TFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ; Reimplemented in TDavixFile, TNetFile, TW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:90348,access,access,90348,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"y the color palette defined by gStyle->SetPalette().; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }. The default number of contour levels is 20 equidistant levels and can be changed with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option LIST is specified together with option CONT, the points used to draw the contours are saved in TGraph objects: h->Draw(""CONT LIST"");; gPad->Update();; The contour are saved in TGraph objects once the pad is painted. Therefore to use this functionality in a macro, gPad->Update() should be performed after the histogram drawing. Once the list is built, the contours are accessible in the following way: TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);; Where i is a contour number, and list contains a list of TGraph objects. For one given contour, more than one disjoint polyline may be generated. The number of TGraphs per contour is given by: list->GetSize();; To access the first graph in the list one should do: TGraph *gr1 = (TGraph*)list->First();; The following example (ContourList.C) shows how to use this functionality.; ; Double_t SawTooth(Double_t x, Double_t WaveLen);; ; TCanvas *ContourList(){; ; const Double_t PI = TMath::Pi();; ; TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);; ; Int_t i, j;; ; Int_t nZsamples = 80;; Int_t nPhiSamples = 80;; ; Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);; ; TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:80306,access,accessible,80306,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['access'],['accessible']
Security,"y the random number generator). The program Event generates in average 600 tracks per event. Each track has 17 data members. The read benchmark runs in the interactive version of ROOT. The ‘Total Time to Read All’ is the real time reported by the execution of the script &ROOTSYS/test/eventa.; We did not correct this time for the overhead coming from the interpreter itself. The Total time to read sample is the execution time of the script $ROOTSYS/test/eventb. This script loops on all events. For each event, the branch containing the number of tracks is read. In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:650522,access,access,650522,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['access'],['access']
Security,"y time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THtt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:1892,authenticat,authentication,1892,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['authenticat'],['authentication']
Security,"y updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to “catch” the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames.; 18.6 Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs.; 18.6.1 The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by the mother therefore are overlapping in that sense. This category of overlaps is ignored due to the fact that any such point is treated as belonging to the deepest node in the hierarchy. Extruding volumes. A volume containment region is in fact the result of the subtraction of all daughters. On the other hand, there are two other categories of overlaps that are considered illegal since they lead to unpredictable res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:997654,access,accessible,997654,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],['accessible']
Security,"y() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:15745,access,access,15745,root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,7,['access'],['access']
Security,"y() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:11006,access,access,11006,root/html602/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,4,['access'],['access']
Security,"y(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tTVirtualPacketizer::GetProcTime() const; TNtuple*TVirtualPacketizer::GetProgressPerf(Bool_t steal = kFALSE); Long64_tTVirtualPacketizer::GetReadCalls() const; TMap*TVirtualPacketizer::GetSlaveStats() const; TProofProgressStatus*TVirtualPacketizer::GetStatus(); virtual const char*TObject::GetTitle() const; Long64_tTVirtualPacketizer::GetTotalEntries() const; virtual UInt_tTObject::GetUniqueID() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTVirtualPacketizer::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTVirtualPacketizer::MarkBad(TSlave*, TProofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPacketizer.html:3633,Hash,Hash,3633,root/html532/TPacketizer.html,https://root.cern,https://root.cern/root/html532/TPacketizer.html,2,['Hash'],['Hash']
Security,"y(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tTVirtualPacketizer::GetProcTime() const; TNtuple*TVirtualPacketizer::GetProgressPerf(Bool_t steal = kFALSE); Long64_tTVirtualPacketizer::GetReadCalls() const; TMap*TVirtualPacketizer::GetSlaveStats() const; TProofProgressStatus*TVirtualPacketizer::GetStatus(); virtual const char*TObject::GetTitle() const; Long64_tTVirtualPacketizer::GetTotalEntries() const; virtual UInt_tTObject::GetUniqueID() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTVirtualPacketizer::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTVirtualPacketizer::MarkBad(TSlave*, TProofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:3656,Hash,Hash,3656,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,2,['Hash'],['Hash']
Security,"y(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TS3HTTPRequest&operator=(const TS3HTTPRequest&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TS3HTTPRequest&SetAccessKey(const TString& accessKey); TS3HTTPRequest&SetAuthKeys(const TString& accessKey, const TString& secretKey); TS3HTTPRequest&SetAuthType(TS3HTTPRequest::EAuthType authType); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); TS3HTTPRequest&SetBucket(const TString& bucket); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TS3HTTPRequest&SetHost(const TString& host); TS3HTTPRequest&SetObjectKey(const TString& objectKey); static voidTObject::SetObjectStat(Bool_t stat); TS3HTTPRequest&SetSecretKey(const TString& secretKey); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TS3HTTPRequest(); TS3HTTPRequest(const TS3HTTPRequest& m); TS3HTT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:4950,access,accessKey,4950,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,4,['access'],['accessKey']
Security,"y); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooAbsCollection::getSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Int_tRooArgList::index(const RooAbsArg* arg) const; Int_tRooArgList::index(const char* name) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsCollection::isOwning() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; RooLinkedListIterRooAbsCollection::iterator(Bool_t dir = kIterForward) const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual const char*name() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); const RooArgSet*RooAbsProxy::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooListProxy.html:4671,Hash,Hash,4671,root/html534/RooListProxy.html,https://root.cern,https://root.cern/root/html534/RooListProxy.html,3,['Hash'],['Hash']
Security,"y); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooAbsCollection::getSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Int_tindex(const RooAbsArg* arg) const; Int_tindex(const char* name) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsCollection::isOwning() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; RooLinkedListIterRooAbsCollection::iterator(Bool_t dir = kIterForward) const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFrom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgList.html:6294,Hash,Hash,6294,root/html534/RooArgList.html,https://root.cern,https://root.cern/root/html534/RooArgList.html,3,['Hash'],['Hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:5344,hash,hash,5344,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,26,['hash'],['hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:5459,hash,hash,5459,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,6,['hash'],['hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:5238,hash,hash,5238,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,12,['hash'],['hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tRooAbsCategoryLValue::getBin(const char* rangeName = 0) const; virtual Int_tRooAbsCategoryLValue::getBin(const RooAbsBinning*) const; virtual list<std::string>RooAbsCategoryLValue::getBinningNames() const; virtual const RooAbsBinning*RooAbsCategoryLValue::getBinningPtr(const char*) const; virtual Double_tRooAbsCategoryLValue::getBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:5476,hash,hash,5476,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,4,['hash'],['hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tRooAbsCategoryLValue::getBin(const char* rangeName = 0) const; virtual Int_tRooAbsCategoryLValue::getBin(const RooAbsBinning*) const; virtual list<string>RooAbsCategoryLValue::getBinningNames() const; virtual const RooAbsBinning*RooAbsCategoryLValue::getBinningPtr(const char*) const; virtual Double_tRooAbsCategoryLValue::getBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:5345,hash,hash,5345,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,8,['hash'],['hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<std::string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:5560,hash,hash,5560,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,2,['hash'],['hash']
Security,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:5555,hash,hash,5555,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,4,['hash'],['hash']
Security,"y. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGeoNode.html:21023,hash,hash,21023,doc/master/classTEveGeoNode.html,https://root.cern,https://root.cern/doc/master/classTEveGeoNode.html,3,['hash'],['hash']
Security,"y2, UInt_t col, UInt_t thick);  Internal line drawing. ;  ; void DrawTextTTF (Int_t x, Int_t y, const char *text, Int_t size, UInt_t color, const char *font_name, Float_t angle);  Draw text using TrueType fonts. ;  ; void DrawVLine (UInt_t x, UInt_t y1, UInt_t y2, UInt_t col, UInt_t thick);  Draw a vertical line. ;  ; void DrawWideLine (UInt_t x1, UInt_t y1, UInt_t x2, UInt_t y2, UInt_t col, UInt_t thick);  Draw wide line. ;  ; void FillRectangleInternal (UInt_t col, Int_t x, Int_t y, UInt_t width, UInt_t height);  Fill rectangle of size (width, height) at position (x,y) within the existing image with specified color. ;  ; void GetFillAreaSpans (UInt_t npt, TPoint *ppt, UInt_t *nspans, TPoint **firstPoint, UInt_t **firstWidth);  ; Bool_t GetPolygonSpans (UInt_t npt, TPoint *ppt, UInt_t *nspans, TPoint **firstPoint, UInt_t **firstWidth);  The code is based on Xserver/mi/mipolycon.c ""Copyright 1987, 1998 The Open Group"". ;  ; Int_t Idx (Int_t idx);  Return a valid index in fImage tables to avoid seg-fault by accessing out of indices out of array's ranges. ;  ; void SetDefaults ();  Set default parameters. ;  ; const char * TypeFromMagicNumber (const char *file);  Guess the file type from the first byte of file. ;  . Additional Inherited Members;  Public Types inherited from TImage; enum  ECharType { kUTF8 = 0; , kChar = 1; , kUnicode = 4; };  ; enum  EColorChan { ;   kRedChan = (1ULL << ( 0 )); , kGreenChan = (1ULL << ( 1 )); , kBlueChan = (1ULL << ( 2 )); , kAlphaChan = (1ULL << ( 3 )); , ;   kAllChan = kRedChan | kGreenChan | kBlueChan | kAlphaChan. };  ; enum  ECoordMode { kCoordModeOrigin = 0; , kCoordModePrevious; };  ; enum  EImageFileTypes { ;   kXpm = 0; , kZCompressedXpm; , kGZCompressedXpm; , kPng; , ;   kJpeg; , kXcf; , kPpm; , kPnm; , ;   kBmp; , kIco; , kCur; , kGif; , ;   kTiff; , kXbm; , kFits; , kTga; , ;   kXml; , kUnknown; , kAnimGif. };  ; enum  EText3DType { ;   kPlain = 0; , kEmbossed; , kSunken; , kShadeAbove; , ;   kShadeBelow; , kEmbossedThick; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:31242,access,accessing,31242,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['access'],['accessing']
Security,"yCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); virtual Bool_tRemoveDataSet(const char* uri); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); static Int_tTDataSetManager::ScanFile(TFileInfo* fileinfo, Bool_t notify); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidTDataSetManager::SetScanCounters(Int_t t = -1, Int_t o = -1, Int_t d = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tShowCache(const char* uri = 0); virtual voidTDataSetManager::ShowDataSets(const char* uri = ""*"", const char* opt = """"); virtual voidShowMembers(TMemberInspector& insp); virtual voidTDataSetManager::ShowQuota(const char* opt); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:7294,checksum,checksum,7294,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,1,['checksum'],['checksum']
Security,"yFile::GetNbytesKeys() const; virtual Int_tTDirectoryFile::GetNkeys() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectoryFile::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectoryFile::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectoryFile::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; virtual Long64_tTDirectoryFile::GetSeekDir() const; virtual Long64_tTDirectoryFile::GetSeekKeys() const; virtual Long64_tTDirectoryFile::GetSeekParent() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTDirectory::IsFolder() const; virtual Bool_tTDirectoryFile::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectoryFile::IsWritable() const; Bool_tTObject::IsZombie() const; virtual voidTDirectoryFile::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TDirectory*TDirectoryFile::mkdir(const char* name, const char* title = """"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual TFile*TDirectoryFile::OpenFile(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooWorkspace__WSDir.html:5735,Hash,Hash,5735,root/html532/RooWorkspace__WSDir.html,https://root.cern,https://root.cern/root/html532/RooWorkspace__WSDir.html,2,['Hash'],['Hash']
Security,"ySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CCvSplit;  CCvSplitKFolds;  CCvSplitKFoldsExpr;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImplementation of a Decision Tree ;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeAbstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP ;  CEvent;  CExpectedErrorPruneToolA helper class to prune a decision tree using the expected error (C4.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:80295,validat,validation,80295,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,2,['validat'],['validation']
Security,"ydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46464,secur,security,46464,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['secur'],['security']
Security,"yer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodANNBase.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodANNBase.html:21724,access,accessors,21724,root/html528/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html,1,['access'],['accessors']
Security,"yle() const; static voidROOT::v5::TFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); virtual const char*TNamed::GetName() const; virtual Int_tROOT::v5::TFormula::GetNdim() const; virtual Int_tROOT::v5::TFormula::GetNpar() const; virtual Int_tROOT::v5::TFormula::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tROOT::v5::TFormula::GetParameter(Int_t ipar) const; Double_tROOT::v5::TFormula::GetParameter(const char* name) const; virtual Double_t*ROOT::v5::TFormula::GetParameters() const; virtual voidROOT::v5::TFormula::GetParameters(Double_t* params); virtual const char*ROOT::v5::TFormula::GetParName(Int_t ipar) const; virtual Int_tROOT::v5::TFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TF1Data.html:4300,Hash,Hash,4300,root/html604/ROOT__v5__TF1Data.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TF1Data.html,1,['Hash'],['Hash']
Security,"yle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Bool_tWriteFile(const char* filename, unsigned char* argb, UInt_t w, UInt_t h). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfExtensionfile extension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePlugin(const char* ext); { fExtension = ext; }. virtual ~TImagePlugin(); { }. unsigned char * ReadFile(const char* filename, UInt_t& w, UInt_t& h). Bool_t WriteFile(const char* filename, unsigned char* argb, UInt_t w, UInt_t h). ULong_t Hash() const; { return fExtension.Hash(); }. » Author: Valeriy Onuchin 23/06/05 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TImagePlugin.html:6223,Hash,Hash,6223,root/html602/TImagePlugin.html,https://root.cern,https://root.cern/root/html602/TImagePlugin.html,2,['Hash'],['Hash']
Security,"yle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Bool_tWriteFile(const char* filename, unsigned char* argb, UInt_t w, UInt_t h). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfExtensionfile extension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePlugin(const char* ext); { fExtension = ext; }. virtual ~TImagePlugin(); { }. unsigned char * ReadFile(const char* filename, UInt_t& w, UInt_t& h). Bool_t WriteFile(const char* filename, unsigned char* argb, UInt_t w, UInt_t h). ULong_t Hash() const; { return fExtension.Hash(); }. » Author: Valeriy Onuchin 23/06/05 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TImagePlugin.html:6223,Hash,Hash,6223,root/html604/TImagePlugin.html,https://root.cern,https://root.cern/root/html604/TImagePlugin.html,2,['Hash'],['Hash']
Security,"yle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour plot (same as CONT0); ""CONT0"": Draw a contour plot using surface colors to distinguish contours; ""CONT1"": Draw a contour plot using line styles to distinguish contours; ""CONT2"": Draw a contour plot using the same line style for all contours; ""CONT3"": Draw a contour plot using fill area colors; ""CONT4"":Draw a contour plot using surface colors (SURF2 option at theta = 0); see also options “AITOFF”, “MERCATOR”, etc. below; ""CONT5"": Use Delaunay triangles to compute the contours. Different contour options. The default number of contour levels is 20 equidistant levels. It can be changed with TH1::SetContour. When option “LIST” is specified together with option “CONT”, all points used for contour drawing, are saved in the TGraph object and are accessible in the following way:; TObjArray *contours =; gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize(); TList *list =; (TList*)contours->At(i);; Where “i” is a contour number and list contains a list of TGraph objects. For one given contour, more than one disjoint poly-line may be generated. The TGraph numbers per contour are given by list->GetSize(). Here we show how to access the first graph in the list.; TGraph *gr1 = (TGraph*)list->First();. “AITOFF”: Draw a contour via an AITOFF projection; “MERCATOR”: Draw a contour via a Mercator projection; “SINUSOIDAL”: Draw a contour via a Sinusoidal projection; “PARABOLIC”: Draw a contour via a Parabolic projection. The tutorial macro earth.C uses these four options and produces the following picture:. The earth.C macro output. 3.8.2.8 The LEGO Options; In a lego plot, the cell contents are drawn as 3D boxes, with the height of the box proportional to the cell content. “LEGO” and “SURF” options. “LEGO”: Draw a lego plot with hidden line removal; “LEGO1”: Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:93327,access,accessible,93327,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],['accessible']
Security,"ype = CONNECTION_TYPE_REQUEST;; 18991 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18992 conn->content_len =; 18993 -1; /* content length is not predefined */; 18994 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18995 process_new_http2_connection(conn);; 18996 } else; 18997#endif; 18998 {; 18999 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19000 init_connection(conn);; 19001 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19002 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19003 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19004 process_new_connection(conn);; 19005 }; 19006 ; 19007 /* Free client certificate info */; 19008 if (conn->request_info.client_cert) {; 19009 mg_free((void *)(conn->request_info.client_cert->subject));; 19010 mg_free((void *)(conn->request_info.client_cert->issuer));; 19011 mg_free((void *)(conn->request_info.client_cert->serial));; 19012 mg_free((void *)(conn->request_info.client_cert->finger));; 19013 /* Free certificate memory */; 19014 X509_free(; 19015 (X509 *)conn->request_info.client_cert->peer_cert);; 19016 conn->request_info.client_cert->peer_cert = 0;; 19017 conn->request_info.client_cert->subject = 0;; 19018 conn->request_info.client_cert->issuer = 0;; 19019 conn->request_info.client_cert->serial = 0;; 19020 conn->request_info.client_cert->finger = 0;; 19021 conn->request_info.client_cert = 0;; 19022 }; 19023 } else {; 19024 /* make sure the connection is cleaned up on SSL failure */; 19025 close_connection(conn);; 19026 }; 19027#endif; 19028 ; 19029 } else {; 19030 /* process HTTP connection */; 19031 init_connection(conn);; 19032 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19033 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19034 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19035 process_new_connection(conn);; 19036 }; 19037 ; 19038 DEBUG_TRACE(""%s"", ""Connection closed"");; 19039 ; 19040#if defined(USE_SERVER_STATS); 19041 conn->conn_close_time = time(NULL);; 19042#endif; 19043",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:566233,certificate,certificate,566233,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['certificate'],['certificate']
Security,"ype = CONNECTION_TYPE_REQUEST;; 18992 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18993 conn->content_len =; 18994 -1; /* content length is not predefined */; 18995 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18996 process_new_http2_connection(conn);; 18997 } else; 18998#endif; 18999 {; 19000 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19001 init_connection(conn);; 19002 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19003 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19004 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19005 process_new_connection(conn);; 19006 }; 19007 ; 19008 /* Free client certificate info */; 19009 if (conn->request_info.client_cert) {; 19010 mg_free((void *)(conn->request_info.client_cert->subject));; 19011 mg_free((void *)(conn->request_info.client_cert->issuer));; 19012 mg_free((void *)(conn->request_info.client_cert->serial));; 19013 mg_free((void *)(conn->request_info.client_cert->finger));; 19014 /* Free certificate memory */; 19015 X509_free(; 19016 (X509 *)conn->request_info.client_cert->peer_cert);; 19017 conn->request_info.client_cert->peer_cert = 0;; 19018 conn->request_info.client_cert->subject = 0;; 19019 conn->request_info.client_cert->issuer = 0;; 19020 conn->request_info.client_cert->serial = 0;; 19021 conn->request_info.client_cert->finger = 0;; 19022 conn->request_info.client_cert = 0;; 19023 }; 19024 } else {; 19025 /* make sure the connection is cleaned up on SSL failure */; 19026 close_connection(conn);; 19027 }; 19028#endif; 19029 ; 19030 } else {; 19031 /* process HTTP connection */; 19032 init_connection(conn);; 19033 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19034 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19035 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19036 process_new_connection(conn);; 19037 }; 19038 ; 19039 DEBUG_TRACE(""%s"", ""Connection closed"");; 19040 ; 19041#if defined(USE_SERVER_STATS); 19042 conn->conn_close_time = time(NULL);; 19043#endif; 19044",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:566266,certificate,certificate,566266,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['certificate'],['certificate']
Security,"z_tStart() const; TString&String(); voidToLower(); voidToUpper(). protected:. voidAssertElement(Ssiz_t i) const; voidSubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const. private:. TSubString(const TString& s, Ssiz_t start, Ssiz_t len). Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademaker",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSubString.html:1748,Access,Access,1748,root/html532/TSubString.html,https://root.cern,https://root.cern/root/html532/TSubString.html,2,['Access'],['Access']
Security,"zation == ""L1"") {; 584 settings.regularization = DNN::ERegularization::kL1;; 585 } else if (regularization == ""L2"") {; 586 settings.regularization = DNN::ERegularization::kL2;; 587 } else {; 588 settings.regularization = DNN::ERegularization::kNone;; 589 }; 590 ; 591 TString strMultithreading = fetchValue(block, ""Multithreading"",; 592 TString (""True""));; 593 if (strMultithreading.BeginsWith (""T"")) {; 594 settings.multithreading = true;; 595 } else {; 596 settings.multithreading = false;; 597 }; 598 ; 599 fTrainingSettings.push_back(settings);; 600 }; 601}; 602 ; 603////////////////////////////////////////////////////////////////////////////////; 604/// Validation of the ValidationSize option. Allowed formats are 20%, 0.2 and; 605/// 100 etc.; 606/// - 20% and 0.2 selects 20% of the training set as validation data.; 607/// - 100 selects 100 events as the validation data.; 608///; 609/// @return number of samples in validation set; 610///; 611 ; 612UInt_t TMVA::MethodDNN::GetNumValidationSamples(); 613{; 614 Int_t nValidationSamples = 0;; 615 UInt_t trainingSetSize = GetEventCollection(Types::kTraining).size();; 616 ; 617 // Parsing + Validation; 618 // --------------------; 619 if (fValidationSize.EndsWith(""%"")) {; 620 // Relative spec. format 20%; 621 TString intValStr = TString(fValidationSize.Strip(TString::kTrailing, '%'));; 622 ; 623 if (intValStr.IsFloat()) {; 624 Double_t valSizeAsDouble = fValidationSize.Atof() / 100.0;; 625 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 626 } else {; 627 Log() << kFATAL << ""Cannot parse number \"""" << fValidationSize; 628 << ""\"". Expected string like \""20%\"" or \""20.0%\""."" << Endl;; 629 }; 630 } else if (fValidationSize.IsFloat()) {; 631 Double_t valSizeAsDouble = fValidationSize.Atof();; 632 ; 633 if (valSizeAsDouble < 1.0) {; 634 // Relative spec. format 0.2; 635 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 636 } else {; 637 // Absolute spec format",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:21080,validat,validation,21080,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['validat'],['validation']
Security,"ze multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TROOT. Function documentation; TROOT(); Default ctor. TROOT(const char* name, const char* title, VoidFuncPtr_t* initfunc = 0); Initialize the ROOT system. The creation of the TROOT object initializes; the ROOT system. It must be the first ROOT related action that is; performed by a program. The TROOT object must be created on the stack; (can not be called via new since ""operator new"" is protected). The; TROOT object is either created as a global object (outside the main(); program), or it is one of the first objects created in main().; Make sure that the TROOT object stays in scope for as long as ROOT; related actions are performed. TROOT is a so called singleton so; only one instance of it can be created. The single TROOT object can; always be accessed via the global pointer gROOT.; The name and title arguments can be used to identify the running; application. The initfunc argument can contain an array of; function pointers (last element must be 0). These functions are; executed at the end of the constructor. This way one can easily; extend the ROOT system without adding permanent dependencies; (e.g. the graphics system is initialized via such a function). ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes.; This routine is deprecated, use TClass::AddClass directly. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:21997,access,accessed,21997,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['access'],['accessed']
Security,"ze void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TBranch::SetFilevirtual void SetFile(TFile *file=nullptr)Set file where this branch writes/reads its buffers.Definition TBranch.cxx:2863; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TStringBasic string class.Definition TString.h:139; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; AuthorRene Brun ; Definition in file copytree2.C. tutorialstreecopytree2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/copytree2_8C.html:2755,access,access,2755,doc/master/copytree2_8C.html,https://root.cern,https://root.cern/doc/master/copytree2_8C.html,2,['access'],['access']
Security,"ze; static TSQLFile::ELockingKindskLockBusy; static TSQLFile::ELockingKindskLockFree. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TSQLFile. Function documentation; TSQLFile(); default TSQLFile constructor. TSQLFile(const char* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; This is usefull to prevent tables with very big number of columns; If limit==0, all arrays will be stored in raw format; If limit<0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:36088,access,access,36088,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,4,['access'],['access']
Security,"ze_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  . Protected Member Functions; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:10402,access,accessors,10402,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security,"zeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:29708,hash,hash,29708,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,"zeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:6435,access,access,6435,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['access'],['access']
Security,"zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html:6091,access,access,6091,root/html526/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html:5571,access,access,5571,root/html526/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html:5441,access,access,5441,root/html526/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"zesize_t fSizeDefinition TCollectionProxyInfo.h:233; ROOT::Detail::TCollectionProxyInfo::EnvironBase::operator=EnvironBase & operator=(const EnvironBase &); ROOT::Detail::TCollectionProxyInfo::EnvironBase::fObjectvoid * fObjectDefinition TCollectionProxyInfo.h:234; ROOT::Detail::TCollectionProxyInfo::EnvironSmall helper to save proxy environment in the event of recursive calls.Definition TCollectionProxyInfo.h:244; ROOT::Detail::TCollectionProxyInfo::Environ::fIteratorIter_t fIteratorDefinition TCollectionProxyInfo.h:247; ROOT::Detail::TCollectionProxyInfo::Environ::iterT & iter()Definition TCollectionProxyInfo.h:248; ROOT::Detail::TCollectionProxyInfo::Environ::Createstatic void * Create()Definition TCollectionProxyInfo.h:249; ROOT::Detail::TCollectionProxyInfo::Environ::Iter_tT Iter_tDefinition TCollectionProxyInfo.h:246; ROOT::Detail::TCollectionProxyInfo::Environ::EnvironEnviron()Definition TCollectionProxyInfo.h:245; ROOT::Detail::TCollectionProxyInfo::InsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc.Definition TCollectionProxyInfo.h:442; ROOT::Detail::TCollectionProxyInfo::Insert::resizestatic void resize(void *, size_t)Definition TCollectionProxyInfo.h:457; ROOT::Detail::TCollectionProxyInfo::Insert::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:460; ROOT::Detail::TCollectionProxyInfo::Insert::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:447; ROOT::Detail::TCollectionProxyInfo::Insert::feedstatic void * feed(void *from, void *to, size_t size)Definition TCollectionProxyInfo.h:450; ROOT::Detail::TCollectionProxyInfo::Insert::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:443; ROOT::Detail::TCollectionProxyInfo::Insert::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:448; ROOT::Detail::TCollectionProxyInfo::Insert::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:444; ROOT::Detail::TCollectionProxyInfo::Insert::Value_tT::value_type Value_tDefinition TCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:38821,access,accesses,38821,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['accesses']
Security,"zing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT traini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:29259,Validat,ValidationSample,29259,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,3,['Validat'],['ValidationSample']
Security,zjh ; Definition at line 186 of file MethodANNBase.h. ◆ fLayerSpec. TString TMVA::MethodANNBase::fLayerSpec. private . layout specification option ; Definition at line 221 of file MethodANNBase.h. ◆ fNcycles. Int_t TMVA::MethodANNBase::fNcycles. protected . number of epochs to train ; Definition at line 192 of file MethodANNBase.h. ◆ fNetwork. TObjArray* TMVA::MethodANNBase::fNetwork. Definition at line 139 of file MethodANNBase.h. ◆ fNeuronInputType. TString TMVA::MethodANNBase::fNeuronInputType. protected . name of neuron input calculator class ; Definition at line 195 of file MethodANNBase.h. ◆ fNeuronType. TString TMVA::MethodANNBase::fNeuronType. protected . name of neuron activation function class ; Definition at line 194 of file MethodANNBase.h. ◆ fOutput. TActivation* TMVA::MethodANNBase::fOutput. protected . Definition at line 164 of file MethodANNBase.h. ◆ fOutputNeurons. std::vector<TNeuron*> TMVA::MethodANNBase::fOutputNeurons. private . cache this for fast access ; Definition at line 220 of file MethodANNBase.h. ◆ fRandomSeed. Int_t TMVA::MethodANNBase::fRandomSeed. protected . random seed for initial synapse weights ; Definition at line 190 of file MethodANNBase.h. ◆ fRegulatorIdx. std::vector<Int_t> TMVA::MethodANNBase::fRegulatorIdx. protected . Definition at line 169 of file MethodANNBase.h. ◆ fRegulators. std::vector<Double_t> TMVA::MethodANNBase::fRegulators. protected . Definition at line 170 of file MethodANNBase.h. ◆ frgen. TRandom3* TMVA::MethodANNBase::frgen. protected . Definition at line 166 of file MethodANNBase.h. ◆ fSynapses. TObjArray* TMVA::MethodANNBase::fSynapses. protected . Definition at line 162 of file MethodANNBase.h. ◆ fUseRegulator. bool TMVA::MethodANNBase::fUseRegulator. protected . zjh ; Definition at line 187 of file MethodANNBase.h. Libraries for TMVA::MethodANNBase:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/MethodANNBase.h; tmva/tmva/src/MethodANNBase.cxx. TMVA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:45941,access,access,45941,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['access'],['access']
Security,"zmax) The argument option (default=""QNR"") can be used to change the fit options. ""Q"" means Quiet mode ""N"" means do not show the result of the fit ""R"" means fit the function in the specified function range; Note that the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.; Example: Assume a 3-d histogram h3 Root > h3->FitSlicesZ(); produces 4 TH2D histograms with h3_0 containing parameter 0(Constant) for a Gaus fit of each cell in X,Y projected along Z with h3_1 containing parameter 1(Mean) for a gaus fit with h3_2 containing parameter 2(StdDev) for a gaus fit with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; Root > h3->Fit(0,15,22,0,0,10); same as above, but only for bins 15 to 22 along X and only for cells in X,Y for which the corresponding projection along Z has more than cut bins filled.; NOTE: To access the generated histograms in the current directory, do eg: TH2D h3_1 = (TH2D)gDirectory->Get(""h3_1""); ; Definition at line 978 of file TH3.cxx. ◆ GetBin(). Int_t TH3::GetBin ; (; Int_t ; binx, . Int_t ; biny, . Int_t ; binz . ); const. overridevirtual . See comments in TH1::GetBin. ; Reimplemented from TH1.; Definition at line 1117 of file TH3.cxx. ◆ GetBinContent() [1/4]. Double_t TH1::GetBinContent ; (; Int_t ; bin); const. virtual . Return content of bin number bin. ; Implemented in TH1C,S,F,D; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; h#define h(i)Definition RSha256.hxx:106; int; returns a global/linearized bin number. This global bin is useful to access the bin information independ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:78781,access,access,78781,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['access'],['access']
Security,"{.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:7565,access,accessiblecolorschemes,7565,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['access'],['accessiblecolorschemes']
Security,"{; 1838 if (s->sa.sa_family == AF_INET); 1839 return s->sin.sin_port;; 1840#if defined(USE_IPV6); 1841 if (s->sa.sa_family == AF_INET6); 1842 return s->sin6.sin6_port;; 1843#endif; 1844 return 0;; 1845}; 1846#endif; 1847#if defined(USE_IPV6); 1848#define USA_IN_PORT_UNSAFE(s) \; 1849 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1850#else; 1851#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1852#endif; 1853 ; 1854/* Describes a string (chunk of memory). */; 1855struct vec {; 1856 const char *ptr;; 1857 size_t len;; 1858};; 1859 ; 1860struct mg_file_stat {; 1861 /* File properties filled by mg_stat: */; 1862 uint64_t size;; 1863 time_t last_modified;; 1864 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1865 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:57228,access,access,57228,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"{; 1839 if (s->sa.sa_family == AF_INET); 1840 return s->sin.sin_port;; 1841#if defined(USE_IPV6); 1842 if (s->sa.sa_family == AF_INET6); 1843 return s->sin6.sin6_port;; 1844#endif; 1845 return 0;; 1846}; 1847#endif; 1848#if defined(USE_IPV6); 1849#define USA_IN_PORT_UNSAFE(s) \; 1850 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1851#else; 1852#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1853#endif; 1854 ; 1855/* Describes a string (chunk of memory). */; 1856struct vec {; 1857 const char *ptr;; 1858 size_t len;; 1859};; 1860 ; 1861struct mg_file_stat {; 1862 /* File properties filled by mg_stat: */; 1863 uint64_t size;; 1864 time_t last_modified;; 1865 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1866 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:57260,access,access,57260,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"| (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char name[UTF8_PATH_MAX];; 8281 const char *p, *e,; 8282 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8283 int truncated;; 8284 ; 8285 if (gpass != NULL) {; 8286 /* Use global passwords file */; 8287 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8288#if defined(DEBUG); 8289 /* Use mg_cry_internal here, since gpass has been; 8290 * configured. */; 8291 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8292#endif; 8293 }; 8294 /* Important: using local struct mg_file to test path for; 8295 * is_directory flag. If filep is used, mg_stat() makes it; 8296 * appear as if auth file was opened.; 8297 * TODO(mid): Check if this is still required after rewriting; 8298 * mg_stat */; 8299 } else if (mg_stat(conn, path, &filep->stat); 8300 && filep->stat.is_directory) {; 8301 mg_snprintf(conn,; 8302 &truncated,; 8303 name,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:238999,password,passwords,238999,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['password'],['passwords']
Security,"| (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char name[UTF8_PATH_MAX];; 8282 const char *p, *e,; 8283 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8284 int truncated;; 8285 ; 8286 if (gpass != NULL) {; 8287 /* Use global passwords file */; 8288 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8289#if defined(DEBUG); 8290 /* Use mg_cry_internal here, since gpass has been; 8291 * configured. */; 8292 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8293#endif; 8294 }; 8295 /* Important: using local struct mg_file to test path for; 8296 * is_directory flag. If filep is used, mg_stat() makes it; 8297 * appear as if auth file was opened.; 8298 * TODO(mid): Check if this is still required after rewriting; 8299 * mg_stat */; 8300 } else if (mg_stat(conn, path, &filep->stat); 8301 && filep->stat.is_directory) {; 8302 mg_snprintf(conn,; 8303 &truncated,; 8304 name,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:239031,password,passwords,239031,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['password'],['passwords']
Security,"|; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; TASPluginGS Class ReferenceGraphics » 2D Graphics » libAfterImage interface. ; Allows to read PS/EPS/PDF files via GhostScript. ; Definition at line 25 of file TASPluginGS.h. Public Member Functions;  TASPluginGS (const char *ext);  ctor ;  ;  ~TASPluginGS () override;  dtor ;  ; ASImage * File2ASImage (const char *filename) override;  read PS/EPS/PDF file and convert it to ASImage ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TASImagePlugin;  TASImagePlugin (const char *ext);  ;  ~TASImagePlugin () override;  ; virtual Bool_t ASImage2File (ASImage *);  ; unsigned char * ReadFile (const char *, UInt_t &, UInt_t &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t WriteFile (const char *, unsigned char *, UInt_t, UInt_t) override;  ;  Public Member Functions inherited from TImagePlugin;  TImagePlugin (const char *ext);  ;  ~TImagePlugin () override;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPluginGS.html:1434,hash,hash,1434,doc/master/classTASPluginGS.html,https://root.cern,https://root.cern/doc/master/classTASPluginGS.html,1,['hash'],['hash']
Security,"|;            ; | yx  yy  yz  yt |;    lambda = |               ; |;            ; | zx  zy  zz  zt |;            ; |               ; |;            ; | tx  ty  tz  tt |;  . Declaration; By default it is initialized to the identity matrix, but it may also be; intialized by an other TLorentzRotation,; by a pure TRotation or by a boost:;   TLorentzRotation l;      // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);    ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLorentzRotation.html:1894,Access,Access,1894,root/html532/TLorentzRotation.html,https://root.cern,https://root.cern/root/html532/TLorentzRotation.html,8,['Access'],['Access']
Security,"}. Int_t GetNumber() const; {return fNumber;}. Int_t GetTickx() const; {return fTickx;}. Int_t GetTicky() const; {return fTicky;}. Double_t GetX1() const; { return fX1; }. Double_t GetX2() const; { return fX2; }. Double_t GetY1() const; { return fY1; }. Double_t GetY2() const; { return fY2; }. TList * GetListOfPrimitives() const; {return fPrimitives;}. TList * GetListOfExecs() const; {return fExecs;}. TObject * GetPadPointer() const; {return fPadPointer;}. TView * GetView() const; {return fView;}. TObject * GetView3D() const; {return fPadView3D;}. Int_t GetLogx() const; {return fLogx;}. Int_t GetLogy() const; {return fLogy;}. Int_t GetLogz() const; {return fLogz;}. TVirtualPad * GetMother() const; {return fMother;}. const char * GetName() const; {return fName.Data();}. const char * GetTitle() const; {return fTitle.Data();}. TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetPadPaint() const; {return fPadPaint;}. Int_t GetPixmapID() const; {return fPixmapID;}. ULong_t Hash() const; { return fName.Hash(); }. Bool_t HasFixedAspectRatio() const; { return fFixedAspectRatio; }. Bool_t IsEditable() const; {return fEditable;}. Bool_t IsFolder() const; {return kTRUE;}. Bool_t IsModified() const; {return fModified;}. Bool_t IsVertical() const; {return !TestBit(kHori);}. void RangeChanged(); { Emit(""RangeChanged()""); }. void RangeAxisChanged(); { Emit(""RangeAxisChanged()""); }. void ResetView3D(TObject* view = 0); {fPadView3D=view;}. void SetBorderMode(Short_t bordermode); {fBorderMode = bordermode; Modified();}. void SetBorderSize(Short_t bordersize); {fBorderSize = bordersize; Modified();}. void SetCanvas(TCanvas* c); { fCanvas = c; }. void SetGrid(Int_t valuex = 1, Int_t valuey = 1); {fGridx = valuex; fGridy = valuey; Modified();}. void SetGridx(Int_t value = 1); {fGridx = value; Modified();}. void SetGridy(Int_t value = 1); {fGridy = value; Modified();}. void SetNumber(Int_t number); {fNumber = number;}. void SetName(const char* name); {fName = name;}. void SetTicks",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPad.html:65580,Hash,Hash,65580,root/html532/TPad.html,https://root.cern,https://root.cern/root/html532/TPad.html,4,['Hash'],['Hash']
Security,"}; }. 4. Working with date/time parameters. Current implementation supports date, time, date&time and timestamp; data (all time intervals not supported yet). To set or get date/time values,; following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware, that TDatime supports only dates after 1995-01-01.; There are also methods to get separately year, month, day, hour, minutes and seconds. Different SQL databases has different treatement of date/time types.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps.; Therefore, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from 'DATE' column in Oracle, one should use GetDatime() method. The only difference of timestamp from date/time, that it has fractional; seconds part. Be aware, that fractional part can has different meaning; (actual value) in different SQL plugins. 5. Binary data. Most of modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; Current implementation supposed, that complete content of the; column must be retrieved at once. Therefore very big data of; gigabytes size may cause a problem. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLStateme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLStatement.html:7873,access,access,7873,root/html528/TSQLStatement.html,https://root.cern,https://root.cern/root/html528/TSQLStatement.html,4,['access'],['access']
Security,"};  ; TString fWdpath;  ; TFdSet * fWritemask {nullptr};  Files that should be checked for read events. ;  ; TFdSet * fWriteready {nullptr};  Files with reads waiting. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TDCacheFile.h>. Inheritance diagram for TDCacheSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDCacheSystem(). TDCacheSystem::TDCacheSystem ; (; ). Create helper class that allows directory access via dCache. ; Definition at line 610 of file TDCacheFile.cxx. ◆ ~TDCacheSystem(). TDCacheSystem::~TDCacheSystem ; (; ). inlineoverride . Definition at line 88 of file TDCacheFile.h. Member Function Documentation. ◆ AccessPathName(). Bool_t TDCacheSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 695 of file TDCacheFile.cxx. ◆ Class(). static TClass * TDCacheSystem::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDCacheSystem::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDCacheSystem::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 97 of file TDCacheFile.h. ◆ DeclFileName(). static const char * TDCacheSystem::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 97 of file TDCacheFile.h. ◆ FreeDirectory(). void TDCacheSystem::FreeDirectory ; (; void * ; dirp). overridevirtual . Close a directory. ; Reimplemented from TSystem.; Definition at line 658 of file TDCacheFile.cxx. ◆ GetDirEntry(). const char * TDCacheSystem::GetDirEntry ; (; void * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:34094,access,access,34094,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,1,['access'],['access']
Security,"~~{.cpp}; 1201df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1202df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1203~~~; 1204 ; 1205Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1206overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1207 ; 1208When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1209 ; 1210~~~{.cpp}; 1211// this throws an error (note the typo); 1212df.Define(""x"", ""0"").Filter(""x = 0"");; 1213~~~; 1214 ; 1215\anchor generic-actions; 1216### User-defined custom actions; 1217RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1218time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1219 ; 1220#### Implementing custom actions with Book(); 1221 ; 1222Through the Book() method, users can implement a custom action and have access to the same features; 1223that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1224event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1225 ; 1226~~~{.cpp}; 1227#include <ROOT/RDataFrame.hxx>; 1228#include <memory>; 1229 ; 1230class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1231 std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; 1232 std::vector<int> fPerThreadResults;; 1233 ; 1234public:; 1235 // We use a public type alias to advertise the type of the result of this action; 1236 using Result_t = int;; 1237 ; 1238 MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; 1239 ; 1240 // Called before the event loop to retrieve the address of the resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:71625,inject,inject,71625,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['inject'],['inject']
Security,"~~{.cpp}; 1241df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1242df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1243~~~; 1244 ; 1245Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1246overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1247 ; 1248When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1249 ; 1250~~~{.cpp}; 1251// this throws an error (note the typo); 1252df.Define(""x"", ""0"").Filter(""x = 0"");; 1253~~~; 1254 ; 1255\anchor generic-actions; 1256### User-defined custom actions; 1257RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1258time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1259 ; 1260#### Implementing custom actions with Book(); 1261 ; 1262Through the Book() method, users can implement a custom action and have access to the same features; 1263that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1264event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1265 ; 1266~~~{.cpp}; 1267#include <ROOT/RDataFrame.hxx>; 1268#include <memory>; 1269 ; 1270class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1271 std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; 1272 std::vector<int> fPerThreadResults;; 1273 ; 1274public:; 1275 // We use a public type alias to advertise the type of the result of this action; 1276 using Result_t = int;; 1277 ; 1278 MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; 1279 ; 1280 // Called before the event loop to retrieve the address of the resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:73305,inject,inject,73305,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['inject'],['inject']
Security," ! flag indicates if fQualityIndex is owned by this ;  ; std::vector< TMVA::DecisionTreeNode * > fPruneSequence;  ! map of weakest links (i.e., branches to prune) -> pruning index ;  ; std::vector< Float_t > fPruneStrengthList;  ! map of alpha -> pruning index ;  ; SeparationBase * fQualityIndex;  ! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) } ;  ; std::vector< Float_t > fQualityIndexList;  ! map of R(T) -> pruning index ;  ; DecisionTree * fTree;  ! (pruned) decision tree ;  ; const DataSet * fValidationDataSet;  ! the event sample to select the optimally-pruned tree ;  ; const EventList * fValidationSample;  ! the event sample to select the optimally-pruned tree ;  . #include <TMVA/CCPruner.h>; Member Typedef Documentation. ◆ EventList. typedef std::vector<Event*> TMVA::CCPruner::EventList. Definition at line 64 of file CCPruner.h. Constructor & Destructor Documentation. ◆ CCPruner() [1/2]. CCPruner::CCPruner ; (; DecisionTree * ; t_max, . const EventList * ; validationSample, . SeparationBase * ; qualityIndex = nullptr . ). constructor ; Definition at line 69 of file CCPruner.cxx. ◆ CCPruner() [2/2]. CCPruner::CCPruner ; (; DecisionTree * ; t_max, . const DataSet * ; validationSample, . SeparationBase * ; qualityIndex = nullptr . ). constructor ; Definition at line 92 of file CCPruner.cxx. ◆ ~CCPruner(). CCPruner::~CCPruner ; (; ). Definition at line 115 of file CCPruner.cxx. Member Function Documentation. ◆ GetOptimalPruneSequence(). std::vector< DecisionTreeNode * > CCPruner::GetOptimalPruneSequence ; (; ); const. return the prune strength (=alpha) corresponding to the prune sequence ; Definition at line 240 of file CCPruner.cxx. ◆ GetOptimalPruneStrength(). Float_t TMVA::CCPruner::GetOptimalPruneStrength ; (; ); const. inline . Definition at line 89 of file CCPruner.h. ◆ GetOptimalQualityIndex(). Float_t TMVA::CCPruner::GetOptimalQualityIndex ; (; ); const. inline . Definition at line 85 of file CCPruner.h. ◆ Optimize(). void CCPruner:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CCPruner.html:3305,validat,validationSample,3305,doc/master/classTMVA_1_1CCPruner.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CCPruner.html,1,['validat'],['validationSample']
Security," . Protected Types; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  . Protected Member Functions; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:9967,access,accessors,9967,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security," . Static Private Member Functions; static void ProcessDeclaration (TObjArray *array, const TString &list);  Split the list as a declaration into as a TObjArray of TNamed(name,type). ;  ; static void ProcessList (TObjArray *array, const TString &list);  Split the list as a comma separated list into a TObjArray of TObjString. ;  . Private Attributes; TString fAttributes;  ; TString fChecksum;  Source version vector (for searching purposes) ;  ; std::vector< UInt_t > * fChecksumVect;  ; TString fCode;  Includes vector. ;  ; Bool_t fEmbed;  ; TString fInclude;  Source data member vector (for searching purposes) ;  ; TObjArray * fIncludeVect;  ; ReadFuncPtr_t fReadFuncPtr;  ; ReadRawFuncPtr_t fReadRawFuncPtr;  Conversion function pointer for read rule. ;  ; RuleType_t fRuleType;  Conversion function pointer for readraw rule. ;  ; TString fSource;  Target data member vector (for searching purposes) ;  ; TString fSourceClass;  Source checksum vector (for searching purposes) ;  ; TObjArray * fSourceVect;  ; TString fTarget;  ; TString fTargetClass;  ; TObjArray * fTargetVect;  ; TString fVersion;  ; std::vector< std::pair< Int_t, Int_t > > * fVersionVect;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TSchemaRule.h>. Inheritance diagram for ROOT::TSchemaRule:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ReadFuncPtr_t. typedef void(* ROOT::TSchemaRule::ReadFuncPtr_t) (char *, TVirtualObject *). Definition at line 40 of file TSchemaRule.h. ◆ ReadRawFuncPtr_t. typedef void(* ROOT::TSchemaRule::ReadRawFuncPtr_t) (char *, TBuffer &). Definition at line 41 of file TSchemaRule.h. Member Enumeration Documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:15405,checksum,checksum,15405,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['checksum'],['checksum']
Security," ; TClass * IsA () const override;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual Bool_t IsMapSubwindows () const;  ; virtual Int_t MustCleanup () const;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetEditDisabled (UInt_t on=kEditDisable);  ; virtual void SetMapSubwindows (Bool_t);  ; virtual void SetName (const char *name);  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDragWindow.html:9831,hash,hash,9831,doc/master/classTGDragWindow.html,https://root.cern,https://root.cern/doc/master/classTGDragWindow.html,1,['hash'],['hash']
Security," ; Types::ETreeType GetCurrentType () const;  ; const Event * GetEvent () const;  returns event without transformations ;  ; const Event * GetEvent (Long64_t ievt) const;  ; const Event * GetEvent (Long64_t ievt, Types::ETreeType type) const;  ; const std::vector< Event * > & GetEventCollection (Types::ETreeType type=Types::kMaxTreeType) const;  ; const TTree * GetEventCollectionAsTree ();  ; Long64_t GetNClassEvents (Int_t type, UInt_t classNumber);  ; Long64_t GetNEvents (Types::ETreeType type=Types::kMaxTreeType) const;  ; Long64_t GetNEvtBkgdTest ();  return number of background test events in dataset ;  ; Long64_t GetNEvtBkgdTrain ();  return number of background training events in dataset ;  ; Long64_t GetNEvtSigTest ();  return number of signal test events in dataset ;  ; Long64_t GetNEvtSigTrain ();  return number of signal training events in dataset ;  ; UInt_t GetNSpectators () const;  access the number of targets through the datasetinfo ;  ; UInt_t GetNTargets () const;  access the number of targets through the datasetinfo ;  ; Long64_t GetNTestEvents () const;  ; Long64_t GetNTrainingEvents () const;  ; UInt_t GetNVariables () const;  access the number of variables through the datasetinfo ;  ; Results * GetResults (const TString &, Types::ETreeType type, Types::EAnalysisType analysistype);  ; const Event * GetTestEvent (Long64_t ievt) const;  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; TTree * GetTree (Types::ETreeType type);  create the test/trainings tree with all the variables, the weights, the classes, the targets, the spectators, the MVA outputs ;  ; Bool_t HasNegativeEventWeights () const;  ; void IncrementNClassEvents (Int_t type, UInt_t classNumber);  ; void InitSampling (Float_t fraction, Float_t weight, UInt_t seed=0);  initialize random or importance sampling ;  ; virtual TClass * IsA () const;  ; void MoveTrainingBlock (Int_t blockInd, Types::ETreeType dest, Bool_t applyChanges=kTRUE);  move training block ;  ; void SetCurrentEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:2331,access,access,2331,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['access'],['access']
Security," ; enum  EMode { kRead = 0; , kWrite = 1; };  ; enum  EStatusBits { kIsOwner = (1ULL << ( 16 )); , kCannotHandleMemberWiseStreaming = (1ULL << ( 17 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TBufferIO; enum  { kNullTag = 0; };  ;  Protected Types inherited from TBuffer; typedef std::vector< TVirtualArray * > CacheList_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TBufferIO; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  ;  Protected Attributes inherited from TBufferIO; TExMap * fClassMap {nullptr};  Map containing object,class pairs for reading. ;  ; Int_t fDisplacement {0};  Value to be added to the map offsets. ;  ; TExMap * fMap {nullptr};  Map containing object,offset pairs for reading/writing. ;  ; Int_t fMapCount {0};  Number of objects or classes in map. ;  ; Int_t fMapSize {0};  Default size of map. ;  ; UShort_t fPidOffset {0};  Offset to be added to the pid index in this key/buffer. ;  ;  Protected Attributes inherited from TBuffer; char * fBufCur;  ; char * fBuffer;  ; char * fBufMax;  ; Int_t fBufSize;  ; CacheList_t fCacheStack;  Realloc function to be used when extending the buffer. ;  ; Bool_t fMode;  ; TObject * fParent;  ; ReAllocCharFun_t fReAllocFunc;  ; Int_t fVersion;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferText.html:32460,hash,hash,32460,doc/master/classTBufferText.html,https://root.cern,https://root.cern/doc/master/classTBufferText.html,1,['hash'],['hash']
Security," ; enum  EMode { kRead = 0; , kWrite = 1; };  ; enum  EStatusBits { kIsOwner = (1ULL << ( 16 )); , kCannotHandleMemberWiseStreaming = (1ULL << ( 17 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TBufferIO; enum  { kNullTag = 0; };  ;  Protected Types inherited from TBuffer; typedef std::vector< TVirtualArray * > CacheList_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TBufferIO; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  ;  Static Protected Attributes inherited from TBufferText; static const char * fgDoubleFmt = ""%.14e"";  ! printf argument for doubles, either ""%f"" or ""%e"" or ""%10f"" and so on ;  ; static const char * fgFloatFmt = ""%e"";  ! printf argument for floats, either ""%f"" or ""%e"" or ""%10f"" and so on ;  ;  Static Protected Attributes inherited from TBufferIO; static Int_t fgMapSize = kMapSize;  Default map size for all TBuffer objects. ;  . #include <TBufferSQL2.h>. Inheritance diagram for TBufferSQL2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TBufferSQL2() [1/3]. TBufferSQL2::TBufferSQL2 ; (; const TBufferSQL2 & ; ). protecteddelete . ◆ TBufferSQL2() [2/3]. TBufferSQL2::TBufferSQL2 ; (; ). p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL2.html:46885,hash,hash,46885,doc/master/classTBufferSQL2.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL2.html,1,['hash'],['hash']
Security," ; int ParNumber () const;  ; void SetParNumber (int number);  ; const MnUserParameterState & UserState () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit2TraceObject.html:1928,hash,hash,1928,doc/master/classTMinuit2TraceObject.html,https://root.cern,https://root.cern/doc/master/classTMinuit2TraceObject.html,1,['hash'],['hash']
Security," ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  . Protected Member Functions; void DoSetMinimOptions (const GSLSimAnParams &params);  Set the Minimizer options from the simulated annealing parameters. ;  ; void DoSetSimAnParameters (const MinimizerOptions &opt);  set minimizer option parameters from stored ROOT::Math::MinimizerOptions (fOpt) ;  ;  Protected Member Functions inherited from ROOT::Math::BasicMinimizer; bool CheckDimension () const;  ; bool CheckObjFunction () const;  ; MinimTransformFunction * CreateTransformation (std::vector< double > &startValues, const ROOT::Math::IMultiGradFunction *func=nullptr);  ; void SetFinalValues (const double *x, const MinimTransformFunction *func=nullptr);  ; void SetMinValue (double val);  . Private Attributes; ROOT::Math::GSLSimAnnealing fSolver;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Math/GSLSimAnMinimizer.h>. Inheritance diagram for ROOT::Math::GSLSimAnMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GSLSimAnMinimizer(). ROOT::Math::GSLSimAnMinimizer::GSLSimAnMinimizer ; (; int ; type = 0). Default constructor. ; Definition at line 33 of file GSLSimAnMinimizer.cxx. ◆ ~GSLSimAnMinimizer(). ROOT::Math::GSLSimAnMinimizer::~GSLSimAnMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 52 of file GSLSimAnMinimizer.cxx. Member Function Documentation. ◆ DoSetMinimOptions(). void ROOT::Math::GSLSimAnMinimizer::DoSetMinimOptions ; (; const GSLSimAnParams & ; params). protected . Set the Minimizer options from the simulated annealing parameters. ; Definition at line 148 of file GSLSimAnMinimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html:12767,validat,validated,12767,doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,1,['validat'],['validated']
Security," ; kENTRY_NAMELEN_OFF ; kENTRY_NAMELEN_LEN ; kENTRY_EXTRALEN_OFF ; kENTRY_EXTRALEN_LEN ; kENTRY_HEADER_SIZE ; kZIP64_EXTENDED_MAGIC_OFF ; kZIP64_EXTENDED_MAGIC_LEN ; kZIP64_EXTENDED_SIZE_OFF ; kZIP64_EXTENDED_SIZE_LEN ; kZIP64_EXTENDED_USIZE_OFF ; kZIP64_EXTENDED_USIZE_LEN ; kZIP64_EXTENTED_CSIZE_OFF ; kZIP64_EXTENDED_CSIZE_LEN ; kZIP64_EXTENDED_HDR_OFFSET_OFF ; kZIP64_EXTENDED_HDR_OFFSET_LEN ; kZIP64_EXTENDED_DISK_OFF ; kZIP64_EXTENDED_DISK_LEN ; kZIP64_EXTENDED_SIZE ; kSTORED Stored as is. . kDEFLATED Stored using deflate. . Definition at line 39 of file TZIPFile.h. Constructor & Destructor Documentation. ◆ TZIPFile() [1/3]. TZIPFile::TZIPFile ; (; const TZIPFile & ; ). protecteddelete . ◆ TZIPFile() [2/3]. TZIPFile::TZIPFile ; (; ). Default ctor. ; Definition at line 65 of file TZIPFile.cxx. ◆ TZIPFile() [3/3]. TZIPFile::TZIPFile ; (; const char * ; archive, . const char * ; member, . TFile * ; file . ). Specify the archive name and member name. ; The member can be a decimal number which allows to access the n-th member. ; Definition at line 76 of file TZIPFile.cxx. ◆ ~TZIPFile(). TZIPFile::~TZIPFile ; (; ). inlineoverride . Definition at line 137 of file TZIPFile.h. Member Function Documentation. ◆ Class(). static TClass * TZIPFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TZIPFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TZIPFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 144 of file TZIPFile.h. ◆ DeclFileName(). static const char * TZIPFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 144 of file TZIPFile.h. ◆ DecodeZip64ExtendedExtraField(). Int_t TZIPFile::DecodeZip64ExtendedExtraField ; (; TZIPMember * ; m, . Bool_t ; global = kTRUE . ). protected . Decode the Zip64 extended extra field. ; If global is true, decode the e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTZIPFile.html:22471,access,access,22471,doc/master/classTZIPFile.html,https://root.cern,https://root.cern/doc/master/classTZIPFile.html,1,['access'],['access']
Security," ; virtual Double_t Variance (Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:30084,hash,hash,30084,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,4,['hash'],['hash']
Security," ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THtml::TFileSysDir;  TFileSysDir (const char *name, TFileSysDir *parent);  ; const TList * GetFiles () const;  ; const TList * GetSubDirs () const;  ; TClass * IsA () const override;  ; void Recurse (TFileSysDB *db, const char *path);  Recursively fill entries by parsing the contents of path. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THtml::TFileSysEntry;  TFileSysEntry (const char *name, TFileSysDir *parent);  ;  ~TFileSysEntry () override;  ; virtual void GetFullName (TString &fullname, Bool_t asIncluded) const;  ; Int_t GetLevel () const;  ; const char * GetName () const override;  Returns name of object. ;  ; TFileSysDir * GetParent () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileSysDB.html:1649,hash,hash,1649,doc/master/classTHtml_1_1TFileSysDB.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileSysDB.html,1,['hash'],['hash']
Security," ; x, . unsigned ; y . ). inline . Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 269 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 316 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1953 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 324 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1310 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1915 of file RWebWindow.cxx. ◆ StartThread(). void RWebWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:48354,access,accessible,48354,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['accessible']
Security," ; x, . unsigned ; y . ). inline . Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 272 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 319 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1995 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 327 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1352 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1957 of file RWebWindow.cxx. ◆ StartThread(). void RWebWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:47238,access,accessible,47238,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['access'],['accessible']
Security," AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; void AddFirst (TObject *obj, Option_t *opt) override;  Add object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; void Clear (Option_t *option) override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Delete all TDataMember object files. ;  ; TEnum * Find (DeclId_t id) const;  Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ;  ; TObject * FindObject (const char *) const override;  Specialize FindObject to do search for the a enum just by name or create it if its not already in the list. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; virtual TEnum * GetObject (const char *) const;  Return an object from the list of enums if and only if is has already been loaded in the list. ;  ; TClass * IsA () const override;  ; Bool_t IsLoaded () const;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:3116,hash,hash,3116,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hash']
Security," Adds a field whose type is not known at compile time. ;  ; RResult< void > AddProjectedField (std::unique_ptr< RFieldBase > field, FieldMappingFunc_t mapping);  Adds a top-level field based on existing fields. ;  ; std::unique_ptr< RNTupleModel > Clone () const;  ; std::unique_ptr< REntry > CreateBareEntry () const;  In a bare entry, all values point to nullptr. ;  ; RFieldBase::RBulk CreateBulk (std::string_view fieldName) const;  Calls the given field's CreateBulk() method. Throws an exception if no field with the given name exists. ;  ; std::unique_ptr< REntry > CreateEntry () const;  ; std::size_t EstimateWriteMemoryUsage (const RNTupleWriteOptions &options=RNTupleWriteOptions()) const;  Estimate the memory usage for this model during writing. ;  ; void Freeze ();  ; const RFieldBase & GetConstField (std::string_view fieldName) const;  ; const RFieldZero & GetConstFieldZero () const;  ; REntry & GetDefaultEntry ();  ; const REntry & GetDefaultEntry () const;  ; const std::string & GetDescription () const;  ; std::uint64_t GetModelId () const;  ; RFieldBase & GetMutableField (std::string_view fieldName);  ; RFieldZero & GetMutableFieldZero ();  Mutable access to the root field is used to make adjustments to the fields. ;  ; const std::unordered_set< std::string > & GetRegisteredSubfields () const;  Get the (qualified) names of subfields that have been registered to be included in entries from this model. ;  ; std::uint64_t GetSchemaId () const;  ; REntry::RFieldToken GetToken (std::string_view fieldName) const;  Creates a token to be used in REntry methods to address a field present in the entry. ;  ; bool IsBare () const;  ; bool IsFrozen () const;  ; template<typename T , typename... ArgsT> ; std::shared_ptr< T > MakeField (const NameWithDescription_t &fieldNameDesc, ArgsT &&...args);  Creates a new field given a name or {name, description} pair and a corresponding value that is managed by a shared pointer. ;  ; RNTupleModel & operator= (const RNTupleModel &)=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:2916,access,access,2916,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['access'],['access']
Security," Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More...;  ; class  TSeqCollection;  Sequenceable collection abstract base class. More...;  ; class  TSortedList;  A ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Containers.html:2234,hash,hash,2234,doc/master/group__Containers.html,https://root.cern,https://root.cern/doc/master/group__Containers.html,1,['hash'],['hash']
Security," Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More...;  ; class  TSeqCollection;  Sequenceable collection abstract base class. More...;  ; class  TSortedList;  A sorted doubly linked list. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Containers.html:2725,hash,hash,2725,doc/master/group__Containers.html,https://root.cern,https://root.cern/doc/master/group__Containers.html,1,['hash'],['hash']
Security, CTH2GLRendering of TH2 and derived classes ;  CTH2I2-D histogram with a int per channel (see TH1 documentation)} ;  CTH2Poly2D Histogram with Polygonal Bins ;  CTH2PolyBinHelper class to represent a bin in the TH2Poly histogram ;  CTH2S2-D histogram with a short per channel (see TH1 documentation) ;  CTH3The 3-D histogram classes derived from the 1-D histogram classes ;  CTH3C3-D histogram with a bype per channel (see TH1 documentation) ;  CTH3D3-D histogram with a double per channel (see TH1 documentation)} ;  CTH3F3-D histogram with a float per channel (see TH1 documentation)} ;  CTH3GLOpenGL renderer class for TH3 ;  CTH3I3-D histogram with a int per channel (see TH1 documentation)} ;  CTH3S3-D histogram with a short per channel (see TH1 documentation) ;  CTHaarMatrixT;  CTHashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject's ;  CTHashTableTHashTable implements a hash table to store TObject's ;  CTHashTableIterIterator of hash table ;  CTHbookBranchHBOOK Branch ;  CTHbookFileThis class is an interface to the Hbook objects in Hbook files ;  CTHbookKeyHBOOK Key ;  CTHbookTreeA wrapper class supporting Hbook ntuples (CWN and RWN) ;  CTHDFSFileReads and writes its data via the HDFS protocols ;  CTHDFSSystemDirectory handler for HDFS (THDFSFile) ;  CTHelixTHelix has two different constructors ;  CTHilbertMatrixT;  CTHilbertMatrixTSym;  CTHistPainterThe histogram painter class ;  CTHLimitsFinderClass to find nice axis limits ;  CTHnMultidimensional histogram ;  CTHnBaseMultidimensional histogram base ;  CTHnIterIterator over THnBase bins ;  CTHnSparseEfficient multidimensional histogram ;  CTHnSparseArrayChunkTHnSparseArrayChunk is used internally by THnSparse ;  CTHnSparseTTemplated implementation of the abstract base THnSparse ;  CTHnTTemplated implementation of the abstract base THn ;  CTHostAuth;  CTHStackThe Histogram stack class ;  ►CTHtml;  CDocEntityInfo_t;  CDocSyntax_t;  CLinkInfo_t;  COutputStyle_t;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:135700,hash,hash,135700,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['hash'],['hash']
Security," Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:10586,access,accessors,10586,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security," Class_Version(). static constexpr Version_t TSelectorDraw::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 121 of file TSelectorDraw.h. ◆ ClearFormula(). void TSelectorDraw::ClearFormula ; (; ). protectedvirtual . Delete internal buffers. ; Definition at line 941 of file TSelectorDraw.cxx. ◆ CompileVariables(). bool TSelectorDraw::CompileVariables ; (; const char * ; varexp = """", . const char * ; selection = """" . ). protectedvirtual . Compile input variables and selection expression. ; varexp is an expression of the general form e1:e2:e3 where e1,etc is a formula referencing a combination of the columns; Example: varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); selection is an expression with a combination of the columns; Example: selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized; Return false if any of the variable is not compilable. ; Definition at line 976 of file TSelectorDraw.cxx. ◆ DeclFileName(). static const char * TSelectorDraw::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file TSelectorDraw.h. ◆ GetAction(). virtual Int_t TSelectorDraw::GetAction ; (; ); const. inlinevirtual . Definition at line 80 of file TSelectorDraw.h. ◆ GetCleanElist(). virtual bool TSelectorDraw::GetCleanElist ; (; ); const. inlinevirtual . Definition at line 81 of file TSelectorDraw.h. ◆ GetDimension(). virtual Int_t TSelectorDraw::GetDimension ; (; ); const. inlinevirtual . Definition at line 82 of file TSelectorDraw.h. ◆ GetDrawFlag(). virtual Long64_t TSelectorDraw::GetDrawFlag ; (; ); const. inlinevirtual . Definition at line 83 of file TSelectorDraw.h. ◆ GetMultiplicity(). Int_t TSelectorDraw::GetMultiplicity ; (; ); const. inline . Definition at line 85 of file TSelectorDraw.h. ◆ GetNfill(). virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorDraw.html:19004,authoriz,authorized,19004,doc/master/classTSelectorDraw.html,https://root.cern,https://root.cern/doc/master/classTSelectorDraw.html,1,['authoriz'],['authorized']
Security," Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorList.html:2532,hash,hash,2532,doc/master/classTSelectorList.html,https://root.cern,https://root.cern/doc/master/classTSelectorList.html,1,['hash'],['hash']
Security," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TArchiveFile.h>. Inheritance diagram for TArchiveFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TArchiveFile() [1/3]. TArchiveFile::TArchiveFile ; (; const TArchiveFile & ; ). privatedelete . Not implemented because TArchiveFile can not be copied. . ◆ TArchiveFile() [2/3]. TArchiveFile::TArchiveFile ; (; ). inline . Definition at line 41 of file TArchiveFile.h. ◆ TArchiveFile() [3/3]. TArchiveFile::TArchiveFile ; (; const char * ; archive, . const char * ; member, . TFile * ; file . ). Specify the archive name and member name. ; Parameters. [in]archiveName of the archive file ; [in]memberName of the ROOT file or integer number ; [in]fileAddress of the TFile instance from where the call takes place. The member can be a decimal number which allows to access the n-th sub-file. This method is normally only called via TFile. ; Definition at line 44 of file TArchiveFile.cxx. ◆ ~TArchiveFile(). TArchiveFile::~TArchiveFile ; (; ). override . Dtor. ; Definition at line 63 of file TArchiveFile.cxx. Member Function Documentation. ◆ Class(). static TClass * TArchiveFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TArchiveFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TArchiveFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 61 of file TArchiveFile.h. ◆ DeclFileName(). static const char * TArchiveFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 61 of file TArchiveFile.h. ◆ GetArchiveName(). const char * TArchiveFile::GetArchiveName ; (; ); const. inline . Definition at line 55 of file TArchiveFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArchiveFile.html:12571,access,access,12571,doc/master/classTArchiveFile.html,https://root.cern,https://root.cern/doc/master/classTArchiveFile.html,1,['access'],['access']
Security," Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassMenuItem.html:6178,hash,hash,6178,doc/master/classTClassMenuItem.html,https://root.cern,https://root.cern/doc/master/classTClassMenuItem.html,1,['hash'],['hash']
Security," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:17578,hash,hash,17578,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,1,['hash'],['hash']
Security," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:9765,hash,hash,9765,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['hash'],['hash']
Security," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLDocument.html:4487,hash,hash,4487,doc/master/classTXMLDocument.html,https://root.cern,https://root.cern/doc/master/classTXMLDocument.html,465,['hash'],['hash']
Security," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:3820,hash,hash,3820,doc/master/structRooHelpers_1_1WrapIntoTObject.html,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html,55,['hash'],['hash']
Security," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInspectorObject.html:3964,hash,hash,3964,doc/master/classTInspectorObject.html,https://root.cern,https://root.cern/doc/master/classTInspectorObject.html,1,['hash'],['hash']
Security," GetBin(). Int_t TH2::GetBin ; (; Int_t ; binx, . Int_t ; biny, . Int_t ; binz = 0 . ); const. overridevirtual . Return Global bin number corresponding to binx,y,z. ; 2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions.; In case of a TH1x, returns binx directly. see TH1::GetBinXYZ for the inverse transformation.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; h#define h(i)Definition RSha256.hxx:106; int; returns a global/linearized bin number. This global bin is useful to access the bin information independently of the dimension. ; Reimplemented from TH1.; Definition at line 1086 of file TH2.cxx. ◆ GetBinContent() [1/5]. Double_t TH1::GetBinContent ; (; Int_t ; bin); const. virtual . Return content of bin number bin. ; Implemented in TH1C,S,F,D; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful to access the bin information independently of the dimension. ; Reimplemented from TH1.; Reimplemented in TH2Poly, TProfile2D, TProfile2Poly, and TProfile2Poly.; Definition at line 265 of file TH1.cxx. ◆ GetBinContent() [2/5]. virtual Double_t TH1::GetBinConten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:80651,access,access,80651,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['access'],['access']
Security," IndexOf (const TObject *arg) const;  Return position of given object in list. ;  ; TClass * IsA () const override;  ; RooLinkedListIter iterator (bool forward=true) const;  Create an iterator for this list. ;  ; TIterator * MakeIterator (bool forward=true) const;  Create a TIterator for this list. ;  ; RooLinkedList & operator= (const RooLinkedList &other);  Assignment operator, copy contents from 'other'. ;  ; void Print (const char *opt) const override;  Print contents of list, defers to Print() function of contained objects. ;  ; RooLinkedListIterImpl rbegin () const;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; virtual bool Remove (TObject *arg);  Remove object from collection. ;  ; RooLinkedListIterImpl rend () const;  ; bool Replace (const TObject *oldArg, const TObject *newArg);  Replace object 'oldArg' in collection with new object 'newArg'. ;  ; void setHashTableSize (Int_t size);  Change the threshold for hash-table use to given size. ;  ; void SetName (const char *name);  ; std::size_t size () const;  ; void Sort (bool ascend=true);  ; void Streamer (TBuffer &) override;  Custom streaming handling schema evolution w.r.t past implementations. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void useNptr (bool flag);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:3439,hash,hash-table,3439,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hash-table']
Security," InitWindow (ULong_t window) override;  Creates a new window and return window number. ;  ; Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist) override;  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; void IntersectRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the intersection of two regions. ;  ; TClass * IsA () const override;  ; Bool_t IsCmdThread () const override;  ; Bool_t IsCocoaDraw () const;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist) override;  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; Int_t KeysymToKeycode (UInt_t keysym) override;  Converts the ""keysym"" to the appropriate keycode. ;  ; char ** ListFonts (const char *fontname, Int_t max, Int_t &count) override;  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; FontStruct_t LoadQueryFont (const char *font_name) override;  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t wid) override;  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID) override;  Makes context ctx current OpenGL context. ;  ; void MapRaised (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t wid) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:16934,access,accessing,16934,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['access'],['accessing']
Security," Initializes the X system. ;  ; virtual Int_t InitWindow (ULongptr_t window);  Creates a new window and return window number. ;  ; virtual Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist);  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; virtual void IntersectRegion (Region_t rega, Region_t regb, Region_t result);  Computes the intersection of two regions. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsCmdThread () const;  ; virtual Bool_t IsDNDAware (Window_t win, Atom_t *typelist);  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; virtual Int_t KeysymToKeycode (UInt_t keysym);  Converts the ""keysym"" to the appropriate keycode. ;  ; virtual char ** ListFonts (const char *fontname, Int_t max, Int_t &count);  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; virtual FontStruct_t LoadQueryFont (const char *font_name);  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; virtual void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym);  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; virtual void LowerWindow (Window_t id);  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; virtual Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID);  Makes context ctx current OpenGL context. ;  ; virtual void MapGCFont (GContext_t, FontStruct_t);  Map the XftFont with the Graphics Context using it. ;  ; virtual void MapRaised (Window_t id);  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; virtual void MapSubwindows (Window_t id);  Maps all subw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:18446,access,accessing,18446,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['access'],['accessing']
Security," MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:10152,access,accessible,10152,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,7,['access'],['accessible']
Security," MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRefArray.html:8297,access,accessible,8297,doc/master/classRooRefArray.html,https://root.cern,https://root.cern/doc/master/classRooRefArray.html,15,['access'],['accessible']
Security," MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:16608,access,accessible,16608,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['access'],['accessible']
Security," Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; virtual TObject * Remove (TObject *obj)=0;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSeqCollection.html:5920,access,access,5920,doc/master/classTSeqCollection.html,https://root.cern,https://root.cern/doc/master/classTSeqCollection.html,1,['access'],['access']
Security," ReadMap (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadMapHelper (StreamHelper *i, Value *v, Bool_t vsn3, TBuffer &b);  ; void ReadObjects (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadPairFromMap (int nElements, TBuffer &b);  ; void ReadPrimitives (int nElements, TBuffer &b, const TClass *onfileClass);  ; void WriteMap (int nElements, TBuffer &b);  ; void WriteObjects (int nElements, TBuffer &b);  ; void WritePrimitives (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:9905,access,accessors,9905,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['access'],['accessors']
Security," SetColor (Pixel_t pixel);  Sets the color to ""pixel"". ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStructNodeProperty.html:2258,hash,hash,2258,doc/master/classTStructNodeProperty.html,https://root.cern,https://root.cern/doc/master/classTStructNodeProperty.html,1,['hash'],['hash']
Security," Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; virtual TObjLink * FirstLink () const;  ; TObject ** Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:4737,hash,hashlist,4737,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hashlist']
Security," StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TDictionary *member);  Mark 'func' as being unloaded. ;  ; void Update (TDictionary *member);  Move the member or data member to the expect set of list. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:5512,hash,hash,5512,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['hash'],['hash']
Security," Unload (TDictionary *member);  Mark 'func' as being unloaded. ;  ; void Update (TDictionary *member);  Move the member or data member to the expect set of list. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; virtual TObjLink * FirstLink () const;  ; TObject ** Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:5604,hash,hashlist,5604,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['hash'],['hashlist']
Security," fConstruct. ArrIterfunc_t TGenCollectionProxy::fConstruct. protected . Container accessors: block construct. ; Definition at line 306 of file TGenCollectionProxy.h. ◆ fConversionReadMemberWise. std::map<std::string, TObjArray*>* TGenCollectionProxy::fConversionReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ; Definition at line 292 of file TGenCollectionProxy.h. ◆ fCreateEnv. Method0 TGenCollectionProxy::fCreateEnv. protected . Method to allocate an Environment holder. ; Definition at line 310 of file TGenCollectionProxy.h. ◆ fDestruct. Sizing_t TGenCollectionProxy::fDestruct. protected . Container accessors: block destruct. ; Definition at line 307 of file TGenCollectionProxy.h. ◆ fEnv. EnvironBase_t* TGenCollectionProxy::fEnv. protected . Address of the currently proxied object. ; Definition at line 314 of file TGenCollectionProxy.h. ◆ fFeed. Feedfunc_t TGenCollectionProxy::fFeed. protected . Container accessors: block feed. ; Definition at line 308 of file TGenCollectionProxy.h. ◆ fFirst. Method TGenCollectionProxy::fFirst. protected . Container accessors: generic iteration: first. ; Definition at line 304 of file TGenCollectionProxy.h. ◆ fFunctionCopyIterator. CopyIterator_t TGenCollectionProxy::fFunctionCopyIterator. protected . Definition at line 325 of file TGenCollectionProxy.h. ◆ fFunctionCreateIterators. CreateIterators_t TGenCollectionProxy::fFunctionCreateIterators. protected . Definition at line 324 of file TGenCollectionProxy.h. ◆ fFunctionDeleteIterator. DeleteIterator_t TGenCollectionProxy::fFunctionDeleteIterator. protected . Definition at line 327 of file TGenCollectionProxy.h. ◆ fFunctionDeleteTwoIterators. DeleteTwoIterators_t TGenCollectionProxy::fFunctionDeleteTwoIterators. protected . Definition at line 328 of file TGenCollectionProxy.h. ◆ fFunctionNextIterator. Next_t TGenCollectionProxy::fFunctionNextIterator. protected . Definition at line 326 of file TGenCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:28396,access,accessors,28396,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security," mp_H1_lambdas.C Lambdas used to check and fit the result of the H1 analysis ;  mt001_fillHistos.C Fill histograms in parallel and write them on file ;  mt101_fillNtuples.C Fill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.C Read n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.C Fill the same TNtuple from different threads ;  mt201_parallelHistoFill.C Parallel fill of a histogram ;  mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:140568,authenticat,authentication,140568,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['authenticat'],['authentication']
Security," { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ; Double_t GetColorAlpha (UInt_t indx) const;  Return alpha parameter of selected color. ;  ; const Double_t * GetColorPositions () const;  Get color positions. ;  ; const Double_t * GetColors () const;  Get colors. ;  ; ECoordinateMode GetCoordinateMode () const;  Get coordinate mode. ;  ; SizeType_t GetNumberOfSteps () const;  Get number of steps. ;  ; TClass * IsA () const override;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Color_t *colorIndices);  Reset color. ;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Double_t *colorIndices);  Reset color. ;  ; void SetColorAlpha (UInt_t indx, Double_t alpha);  Change alpha parameter of the color. ;  ; void SetCoordinateMode (ECoordinateMode mode);  Set coordinate mode. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColorGradient.html:2167,validat,validate,2167,doc/master/classTColorGradient.html,https://root.cern,https://root.cern/doc/master/classTColorGradient.html,1,['validat'],['validate']
Security," { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TParameter ();  ;  TParameter (const char *name, const AParamType &val);  ;  TParameter (const char *name, const AParamType &val, char mergemode);  ; virtual ~TParameter ();  ; Int_t Compare (const TObject *obj) const override;  Compare abstract method. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const AParamType & GetVal () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsConst () const;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *) const override;  The ls function lists the contents of a class on stdout. ;  ; virtual Int_t Merge (TCollection *in);  ; Int_t Merge (TCollection *in);  ; void Print (Option_t *) const override;  This method must be overridden when a class wants to print itself. ;  ; void SetMergeMode (char mergemode='+');  ; void SetVal (const AParamType &val);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParameter.html:1840,hash,hash,1840,doc/master/classTParameter.html,https://root.cern,https://root.cern/doc/master/classTParameter.html,1,['hash'],['hash']
Security,"  kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSystem; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:30986,access,access,30986,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,2,['access'],['access']
Security,"►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderA simple, robust and fast interface to read values from ROOT colmnar datasets such as TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:217687,access,access,217687,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['access'],['access']
Security,"◆ fInclude. TString ROOT::TSchemaRule::fInclude. private . Source data member vector (for searching purposes) ; Definition at line 111 of file TSchemaRule.h. ◆ fIncludeVect. TObjArray* ROOT::TSchemaRule::fIncludeVect. mutableprivate . Definition at line 112 of file TSchemaRule.h. ◆ fReadFuncPtr. ReadFuncPtr_t ROOT::TSchemaRule::fReadFuncPtr. private . Definition at line 115 of file TSchemaRule.h. ◆ fReadRawFuncPtr. ReadRawFuncPtr_t ROOT::TSchemaRule::fReadRawFuncPtr. private . Conversion function pointer for read rule. ; Definition at line 116 of file TSchemaRule.h. ◆ fRuleType. RuleType_t ROOT::TSchemaRule::fRuleType. private . Conversion function pointer for readraw rule. ; Definition at line 117 of file TSchemaRule.h. ◆ fSource. TString ROOT::TSchemaRule::fSource. private . Target data member vector (for searching purposes) ; Definition at line 109 of file TSchemaRule.h. ◆ fSourceClass. TString ROOT::TSchemaRule::fSourceClass. private . Source checksum vector (for searching purposes) ; Definition at line 105 of file TSchemaRule.h. ◆ fSourceVect. TObjArray* ROOT::TSchemaRule::fSourceVect. mutableprivate . Definition at line 110 of file TSchemaRule.h. ◆ fTarget. TString ROOT::TSchemaRule::fTarget. private . Definition at line 107 of file TSchemaRule.h. ◆ fTargetClass. TString ROOT::TSchemaRule::fTargetClass. private . Definition at line 106 of file TSchemaRule.h. ◆ fTargetVect. TObjArray* ROOT::TSchemaRule::fTargetVect. mutableprivate . Definition at line 108 of file TSchemaRule.h. ◆ fVersion. TString ROOT::TSchemaRule::fVersion. private . Definition at line 101 of file TSchemaRule.h. ◆ fVersionVect. std::vector<std::pair<Int_t, Int_t> >* ROOT::TSchemaRule::fVersionVect. mutableprivate . Definition at line 102 of file TSchemaRule.h. Libraries for ROOT::TSchemaRule:. [legend]; The documentation for this class was generated from the following files:; core/meta/inc/TSchemaRule.h; core/meta/src/TSchemaRule.cxx. ROOTTSchemaRule. ROOT master - Reference Guide Generated o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TSchemaRule.html:28993,checksum,checksum,28993,doc/master/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TSchemaRule.html,1,['checksum'],['checksum']
Testability," """") const; virtual voidPrintValue(Int_t i = 0) const; virtual Int_tTObject::Read(const char* name); virtual voidReadBasket(TBuffer& b); virtual voidReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); virtual voidReadValue(istream& s); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTLeaf::ResetAddress(void* add, Bool_t destructor = kFALSE); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTLeaf::SetBranch(TBranch* branch); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTLeaf::SetLeafCount(TLeaf* leaf); virtual voidTLeaf::SetLen(Int_t len = 1); virtual voidSetMaximum(Bool_t max); virtual voidSetMinimum(Bool_t min); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTLeaf::SetOffset(Int_t offset = 0); virtual voidTLeaf::SetRange(Bool_t range = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTLeaf::SetUnsigned(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafO.html:5969,Test,TestBit,5969,root/html532/TLeafO.html,https://root.cern,https://root.cern/root/html532/TLeafO.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSaveSelf(Bool_t force = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBufferSize(Int_t bufsize); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TDirectoryFile(); TDirectoryFile(const char* name, const char* title, Option_t* option = """", TDirectory* motherDir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t opt = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t opt = 0, Int_t bufsize = 0) const; virtual voidWriteDirHeader(); virtual voidWriteKeys(); virtual Int_tWriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tWriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tWriteTObject(const TObject* obj, const char* name = 0, Option_t* option = """", Int_t bufsize = 0).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDirectoryFile.html:8090,Test,TestBit,8090,root/html602/TDirectoryFile.html,https://root.cern,https://root.cern/root/html602/TDirectoryFile.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumGenFactory&operator=(const RooNumGenFactory&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Bool_tstoreProtoSampler(RooAbsNumGenerator* proto, const RooArgSet& defConfig); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumGenFactory.html:5130,Test,TestBit,5130,root/html532/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html532/RooNumGenFactory.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidReallocBlock(Long64_t*, Int_t*, Int_t); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBuffer(char*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetPos(Int_t, Long64_t); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TFPBlock(Long64_t*, Int_t*, Int_t); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFPBlock.html:4775,Test,TestBit,4775,root/html602/TFPBlock.html,https://root.cern,https://root.cern/root/html602/TFPBlock.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSendMsgToUsers(const char* msg, const char* usr = 0); virtual voidTProofMgr::SetAlias(const char* alias = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInvalid(); virtual voidTProofMgr::SetMssUrl(const char* mss); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetROOTVersion(const char* tag); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTProofMgr::SetTXProofMgrHook(TProofMgr_t pmh); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidShowROOTVersions(); virtual voidShowWorkers(); virtual voidTProofMgr::ShutdownSession(Int_t id); virtual voidTProofMgr::ShutdownSession(TProof* p); virtual Int_tTNamed::Sizeof() const; virtual Int_tStat(const char* what, FileStat_t& st, const char* where = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTail(const char* what, const char* how = 0, const char* where = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TFileCollection*TProofMgr::UploadFiles(TList* src, const char* mss, const char* dest = 0); static TFileCollection*TProofMgr::UploadFiles(const char* txtfile, const char* mss, const char* dest = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:7736,Test,TestBit,7736,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," """"); virtual Int_tTProofServ::SendAsynMessage(const char* msg, Bool_t lf = kTRUE); virtual voidTProofServ::SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); voidTProofServ::SendParallel(Bool_t async = kFALSE); voidTProofServ::SendStatistics(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); static FILE*TProofServ::SetErrorHandlerFile(FILE* ferr); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTProofServ::SetLastEntry(Long64_t lastentry); static voidTProofServ::SetLastMsg(const char* lastmsg); static voidTObject::SetObjectStat(Bool_t stat); voidTApplication::SetReturnFromRun(Bool_t ret); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTApplication::Show(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTApplication::StartIdleing(); virtual voidTApplication::StopIdleing(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual Int_tTApplication::TabCompletionHook(char* buf, int* pLoc, ostream& out); virtual voidTerminate(Int_t status); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TProofServ*TProofServ::This(); TProofServLite(const TProofServLite&); TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); voidTProofServ::TruncateLogFile(); Int_tTProofServ::UpdateSessionStatus(Int_t xst = -1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServLite.html:13211,Test,TestBit,13211,root/html602/TProofServLite.html,https://root.cern,https://root.cern/root/html602/TProofServLite.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," """"); virtual voidTObject::Pop(); virtual voidPrefetch(Long64_t pos, Int_t len); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Int_tReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); virtual Int_tReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); virtual Int_tReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSecondPrefetch(Long64_t, Int_t); virtual voidSecondSort(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEnablePrefetching(Bool_t setPrefetching = kFALSE); virtual voidSetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSkipZip(Bool_t = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual voidTObject::UseCurrentStyle(); virtual voidWaitFinishPrefetch(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheRead.html:6182,Test,TestBit,6182,root/html602/TFileCacheRead.html,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetErrmsgcallback(void*) const; virtual Bool_tSetErrorMessages(Bool_t enable = kTRUE); virtual voidSetGetline(const char*(*)(const char*) getlineFunc, void(*)(const char*) histaddFunc); virtual voidSetgvp(Long_t) const; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetProcessLineLock(Bool_t lock = kTRUE); virtual voidSetRTLD_LAZY() const; virtual voidSetRTLD_NOW() const; virtual voidSetTempLevel(int) const; virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TInterpreter(); TInterpreter(const TInterpreter&); TInterpreter(const char* name, const char* title = ""Generic Interpreter""); virtual voidTypedefInfo_Delete(TypedefInfo_t*) const; virtual TypedefInfo_t*TypedefInfo_Factory() const; virtual TypedefInfo_t*TypedefInfo_Factory(const char*) const; virtual TypedefInfo_t*TypedefInfo_FactoryCopy(TypedefInfo_t*) const; virtual voidTypedefInfo_Init(TypedefInfo_t*, const char*) const; virtual Bool_tTypedefInfo_IsValid(TypedefInfo_t*) const; virtual const char*TypedefInfo_Name(TypedefInfo_t*) const; virtual intTypedefInfo_Next(TypedefInfo_t*) const; virtual Long_tTypedefInfo_Property(TypedefInfo_t*) const; virtual intTypedefInfo_Size(TypedefInfo_t*) const; virtual const char*TypedefInfo_Title(TypedefInfo_t*) const; virtual const char*TypedefInfo_TrueName(TypedefInfo_t*) const; virtual voidTypeInfo_Delete(TypeInfo_t*) const; virtual TypeInfo_t*TypeInfo_Factory() const; virtual TypeInfo_t*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:21636,Test,TestBit,21636,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Test'],['TestBit']
Testability," """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); TGCompositeFrame*StartEmbedding(); TEveWindowFrame*StopEmbedding(const char* name = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveWindowSlot.html:17093,Test,TestBit,17093,root/html534/TEveWindowSlot.html,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html,3,['Test'],"['TestBit', 'TestBits', 'TestCSCBits']"
Testability," """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); voidSetTransparency(Char_t tr)MENU ; voidSetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); voidSetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertex(Int_t i, Float_t x, Float_t y, Float_t z); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; Int_t*Triangle(Int_t i); UChar_t*TriangleColor(Int_t i); Float_t*TriangleNormal(Int_t i); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); Float_t*Vertex(Int_t i); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTriangleSet.html:16218,Test,TestBit,16218,root/html532/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html532/TEveTriangleSet.html,3,['Test'],"['TestBit', 'TestBits', 'TestCSCBits']"
Testability," """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<float>&SelectNonZeros(const TVectorT<float>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const float* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<float>&SetSub(Int_t row_lwb, const TVectorT<float>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<float>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp) const; Bool_tSomePositive(const TVectorT<float>& select); TVectorT<float>&Sqr(); TVectorT<float>&Sqrt(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, float iv1); TVectorT<float>&Use(TVectorT<float>& v); const TVectorT<float>&Use(const TVectorT<float>& v) const; TVectorT<float>&Use(Int_t n, float* data); const TVectorT<float>&Use(Int_t n, const float* data) const; TVectorT<float>&Use(Int_t lwb, Int_t upb, float* data); const TVectorT<float>&Use(Int_t lwb, Int_t upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_float_.html:7634,Test,TestBits,7634,root/html602/TVectorT_float_.html,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html,2,['Test'],['TestBits']
Testability," """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCenterVec(Double_t x, Double_t y, Double_t z); voidSetCenterVecWarp(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetExternalCenter(Bool_t x); voidSetFixDefCenter(Bool_t x); voidSetFixDefCenterVec(Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetup(const TGLBoundingBox& box, Bool_t reset = kTRUE); voidSetVAxisMinAngle(Float_t x); voidSetViewport(const TGLRect& viewport); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; UInt_tTimeStamp() const; virtual Bool_tTruck(Double_t xDelta, Double_t yDelta); virtual Bool_tTruck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Bool_tUpdateInterest(Bool_t force); virtual voidTObject::UseCurrentStyle(); TGLVector3ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Rgl::EOverlapViewportOverlap(const TGLBoundingBox& box) const; pair<Bool_t,TGLVertex3>ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; pair<Bool_t,TGLVertex3>ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; TGLRectViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; TGLRectViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; TGLLine3ViewportToWorld(const TPoint& viewport) const; TGLVertex3ViewportToWorld(const TGLVerte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLCamera.html:7074,Test,TestBit,7074,root/html534/TGLCamera.html,https://root.cern,https://root.cern/root/html534/TGLCamera.html,1,['Test'],['TestBit']
Testability," ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------------------------------------------------------------------|; 2907| "" "" | Default, cartesian coordinates system.|; 2908| ""POL"" | Polar coordinates system.|; 2909| ""CYL"" | Cylindrical coordinates system.|; 2910| ""SPH"" | Spherical coordinates system.|; 2911 ; 2912 ; 2913 ; 2914\anchor HP290; 2915#### TH3 as color boxes; 2916 ; 2917The supported option is:; 2918 ; 2919| Option | Description |; 2920|----------|-------------------------------------------------------------------|; 2921| ""GLCOL"" | H3 is drawn using semi-transparent colored boxes. See `$ROOTSYS/tutorials/gl/glvox1.C`.|; 2922 ; 2923 ; 2924 ; 2925\anchor HP29b; 2926#### TH3 as boxes (spheres); 2927 ; 2928The supported options are:; 2929 ; 2930| Option | Description |; 2931|----------|---------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:115414,log,logarithmic,115414,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logarithmic']
Testability," ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #define USE_CEPHES. Definition at line 27 of file SpecFuncMathCore.cxx. mathmathcoresrcSpecFuncMathCore.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html:1600,log,logarithm,1600,doc/master/SpecFuncMathCore_8cxx.html,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html,1,['log'],['logarithm']
Testability," ""determined event sample size to select training sample from=""<<useForTraining<<Endl;; 1254 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select test sample from=""<<useForTesting<<Endl;; 1255 ; 1256 ; 1257 ; 1258 // associate undefined events; 1259 if( splitMode == ""ALTERNATE"" ){; 1260 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split 'ALTERNATE'"" << Endl;; 1261 Int_t nTraining = availableTraining;; 1262 for( EventVector::iterator it = eventVectorUndefined.begin(), itEnd = eventVectorUndefined.end(); it != itEnd; ){; 1263 ++nTraining;; 1264 if( nTraining <= requestedTraining ){; 1265 eventVectorTraining.insert( eventVectorTraining.end(), (*it) );; 1266 ++it;; 1267 }; 1268 if( it != itEnd ){; 1269 eventVectorTesting.insert( eventVectorTesting.end(), (*it) );; 1270 ++it;; 1271 }; 1272 }; 1273 } else {; 1274 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split '"" << splitMode << ""'"" << Endl;; 1275 ; 1276 // test if enough events are available; 1277 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableundefined : "" << availableUndefined << Endl;; 1278 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTraining : "" << useForTraining << Endl;; 1279 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTesting : "" << useForTesting << Endl;; 1280 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTraining : "" << availableTraining << Endl;; 1281 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTesting : "" << availableTesting << Endl;; 1282 ; 1283 if( availableUndefined<(useForTraining-availableTraining) ||; 1284 availableUndefined<(useForTesting -availableTesting ) ||; 1285 availableUndefined<(useForTraining+useForTesting-availableTraining-availableTesting ) ){; 1286 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested than available!"" << Endl;; 1287 }; 1288 ; 1289 // select the events; 1290 if (useFor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:55649,test,test,55649,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['test']
Testability," # cannot use Keras if PYMVA is not available; ; if useKeras:; try:; import tensorflow; except:; ROOT.Warning(""TMVA_Higgs_Classification"", ""Skip using Keras since tensorflow is not available""); useKeras = False; ; outputFile = TFile.Open(""Higgs_ClassificationOutput.root"", ""RECREATE""); factory = TMVA.Factory(; ""TMVA_Higgs_Classification"", outputFile, V=False, ROC=True, Silent=False, Color=True, AnalysisType=""Classification""; ); ; ; ## Setup Dataset(s); ; # Define now input data file and signal and background trees; ; inputFileName = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:58897,test,test,58897,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['test'],['test']
Testability," $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g++ -shared -o$@ `root-config --ldflags` $(CXXFLAGS) -I$(ROOTSYS)/include $^. See Interacting with Shared Libraries: rootcint for more details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry for details. ; . Can I integrate ROOT into my CMake build? . Absolutely. The CMake command find_package() will set all needed ROOT related variables, which can be used to compile and link one's own code. An example from the ROOT Event example (found in root/test) can be downloaded here. Just un-tar the attached file and run:. cd event/build; cmake ..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:4004,test,testVector,4004,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['test'],['testVector']
Testability," && fDataErrorPtr );; 531 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 532 ; 533 fData[ fNPoints ] = val;; 534 fDataError[ fNPoints ] = (eval != 0.0) ? 1.0/eval : 0.0;; 535 ; 536 FitData::Add( x );; 537 fSumContent += val;; 538 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 539 if (!fIsWeighted); 540 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 541 }; 542 ; 543 /**; 544 add multi-dim coordinate data with both error in coordinates and value; 545 */; 546 void BinData::Add( const double* x, double val, const double* ex, double eval ); 547 {; 548 assert( kCoordError == fErrorType );; 549 assert( !fData.empty() && fDataPtr );; 550 assert( !fDataError.empty() && fDataErrorPtr );; 551 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 552 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 553 assert( fCoordErrors.size() == fDim );; 554 assert( fCoordErrorsPtr.size() == fDim );; 555 ; 556 fData[ fNPoints ] = val;; 557 ; 558 for( unsigned int i=0; i<fDim; i++ ); 559 {; 560 assert( &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 561 ; 562 fCoordErrors[i][ fNPoints ] = ex[i];; 563 }; 564 // in this case we store the y error and not the inverse; 565 fDataError[ fNPoints ] = eval;; 566 ; 567 FitData::Add( x );; 568 fSumContent += val;; 569 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 570 if (!fIsWeighted); 571 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 572 }; 573 ; 574 /**; 575 add multi-dim coordinate data with both error in coordinates and value; 576 */; 577 void BinData::Add( const double* x, double val, const double* ex, double elval, double ehval ); 578 {; 579 assert( kAsymError == fErrorType );; 580 ; 581 assert( !fData.empty() && fDataPtr );; 582 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 583 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 584 assert( fDataError.empty() && !fDataErrorPtr );; 585 assert( fCoordErrors.size() == fDim );; 586 a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:17282,assert,assert,17282,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," &month, Int_t &day) const;  Get the numeric value (date format). ;  ; virtual ULong_t GetHexNumber () const;  Get the numeric value (hex format). ;  ; virtual Long_t GetIntNumber () const;  Get the numeric value (integer representation). ;  ; virtual EAttribute GetNumAttr () const;  Get the numerical attribute. ;  ; virtual Double_t GetNumber () const;  Get the numeric value (floating point representation). ;  ; virtual ELimit GetNumLimits () const;  Get the numerical limit attribute. ;  ; virtual Double_t GetNumMax () const;  Get the upper limit. ;  ; virtual Double_t GetNumMin () const;  Get the lower limit. ;  ; virtual EStyle GetNumStyle () const;  Get the numerical style. ;  ; virtual void GetTime (Int_t &hour, Int_t &min, Int_t &sec) const;  Get the numeric value (time format). ;  ; Bool_t HandleFocusChange (Event_t *event) override;  Handle focus change. ;  ; Bool_t HandleKey (Event_t *event) override;  Handle keys. ;  ; virtual void IncreaseNumber (EStepSize step=kNSSSmall, Int_t sign=1, Bool_t logstep=kFALSE);  Increase the number value. ;  ; virtual void InvalidInput (const char *instr);  ; TClass * IsA () const override;  ; Bool_t IsEditable () const override;  ; virtual Bool_t IsLogStep () const;  Is log step enabled? ;  ; void Layout () override;  Layout. ;  ; void ReturnPressed () override;  Return was pressed. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save a number entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SetDate (Int_t year, Int_t month, Int_t day, Bool_t emit=kTRUE);  Set the numeric value (date format). ;  ; virtual void SetFormat (EStyle style, EAttribute attr=kNEAAnyNumber);  Set the numerical format. ;  ; virtual void SetHexNumber (ULong_t val, Bool_t emit=kTRUE);  Set the numeric value (hex format). ;  ; virtual void SetIntNumber (Long_t val, Bool_t emit=kTRUE);  Set the numeric value (integer representation). ;  ; virtual void SetLimits (ELimit limits=kNELNoLimits, Double_t min=0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:1988,log,logstep,1988,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,1,['log'],['logstep']
Testability," &name, const TString &desc=""""); TMVA::Configurable::AddPreDefValvoid AddPreDefVal(const T &)Definition Configurable.h:168; TMVA::Configurable::SetConfigNamevoid SetConfigName(const char *n)Definition Configurable.h:63; TMVA::Configurable::ParseOptionsvirtual void ParseOptions()options parserDefinition Configurable.cxx:124; TMVA::Configurable::GetOptionsconst TString & GetOptions() constDefinition Configurable.h:84; TMVA::Configurable::LogMsgLogger & Log() constDefinition Configurable.h:122; TMVA::Configurable::fLoggerMsgLogger * fLogger! message loggerDefinition Configurable.h:128; TMVA::Configurable::CheckForUnusedOptionsvoid CheckForUnusedOptions() constchecks for unused options in option stringDefinition Configurable.cxx:270; TMVA::DataInputHandler::GetEntriesUInt_t GetEntries(const TString &name) constDefinition DataInputHandler.h:100; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::GetDataSetInfoDataSetInfo & GetDataSetInfo()Definition DataLoader.cxx:137; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetInfo::GetNVariablesUInt_t GetNVariables() constDefinition DataSetInfo.h:127; TMVA::DataSetInfo::GetNamevirtual const char * GetName() constReturns name of object.Definition DataSetInfo.h:71; TMVA::DataSetInfo::CorrelationMatrixconst TMatrixD * CorrelationMatrix(const TString &className) constDefinition DataSetInfo.cxx:197; TMVA::DataSetInfo::GetNClassesUInt_t GetNClasses() constDefinition DataSetInfo.h:155; TMVA::DataSetInfo::GetSplitO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:116228,test,test,116228,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability," &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; invvoid inv(rsa_NUMBER *, rsa_NUMBE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:338183,log,logarithm,338183,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['log'],['logarithm']
Testability," &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation. { fGenerateBinned = binned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. string GetSamplingDistName(void); { return fSamplingDistName; }. void SetMaxToys(Double_t t); This option forces a maximum number of total toys. { fMaxToys = t; }. void SetToysLeftTail(Double_t toys, Double_t threshold). void SetToysRightTail(Double_t toys, Double_t threshold). void SetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold). void SetImportanceDensity(RooAbsPdf* p); for importance sampling, specifies the pdf to sample from. void SetImportanceSnapshot(const RooArgSet& s); for importance sampling, a snapshot of the parameters used ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSampler.html:8759,test,testStatistic,8759,root/html530/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html,1,['test'],['testStatistic']
Testability," &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation. { fGenerateBinned = binned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. string GetSamplingDistName(void); { return fSamplingDistName; }. void SetMaxToys(Double_t t); This option forces a maximum number of total toys. { fMaxToys = t; }. void SetToysLeftTail(Double_t toys, Double_t threshold). void SetToysRightTail(Double_t toys, Double_t threshold). void SetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold). void SetImportanceDensity(RooAbsPdf* p); for importance sampling, specifies the pdf to sample from. { fImportanceDensity = p; }. void SetImportanceSnapshot(const RooArgSet& s); for importance sampling, a sna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSampler.html:7221,test,testStatistic,7221,root/html528/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSampler.html,1,['test'],['testStatistic']
Testability, &yup) override;; 212 Double_t GetXlowNDC() const override { return fXlowNDC; }; 213 Double_t GetYlowNDC() const override { return fYlowNDC; }; 214 /// Get width of pad along X in Normalized Coordinates (NDC); 215 Double_t GetWNDC() const override { return fWNDC; }; 216 /// Get height of pad along Y in Normalized Coordinates (NDC); 217 Double_t GetHNDC() const override { return fHNDC; }; 218 UInt_t GetWw() const override;; 219 UInt_t GetWh() const override;; 220 Double_t GetAbsXlowNDC() const override { return fAbsXlowNDC; }; 221 Double_t GetAbsYlowNDC() const override { return fAbsYlowNDC; }; 222 Double_t GetAbsWNDC() const override { return fAbsWNDC; }; 223 Double_t GetAbsHNDC() const override { return fAbsHNDC; }; 224 Double_t GetAspectRatio() const override { return fAspectRatio; }; 225 Double_t GetPhi() const override { return fPhi; }; 226 Double_t GetTheta() const override { return fTheta; }; 227 ///Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 228 Double_t GetUxmin() const override { return fUxmin; }; 229 ///Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 230 Double_t GetUymin() const override { return fUymin; }; 231 ///Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 232 Double_t GetUxmax() const override { return fUxmax; }; 233 ///Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 234 Double_t GetUymax() const override { return fUymax; }; 235 Bool_t GetGridx() const override { return fGridx; }; 236 Bool_t GetGridy() const override { return fGridy; }; 237 Int_t GetNumber() const override { return fNumber; }; 238 Int_t GetTickx() const override { return fTickx; }; 239 Int_t GetTicky() const override { return fTicky; }; 240 Double_t GetX1() const override { return fX1; }; 241 Double_t GetX2() const override { return fX2; }; 242 Double,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:11883,log,log,11883,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['log'],['log']
Testability," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:62022,test,testArg,62022,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,4,['test'],['testArg']
Testability," ( val <= 0 ); 368 {; 369 MATH_ERROR_MSG(""BinData::TransformLog"",""Some points have negative values - cannot apply a log transformation"");; 370 return *this;; 371 }; 372 ; 373 fData[i] = std::log( val );; 374 ; 375 if( kNoError == fErrorType ); 376 {; 377 fDataError[i] = val;; 378 }; 379 else if ( kValueError == fErrorType ); 380 {; 381 fDataError[i]*= val;; 382 }; 383 else if ( kCoordError == fErrorType ); 384 {; 385 fDataError[i]/= val;; 386 }; 387 else if ( kAsymError == fErrorType ); 388 {; 389 fDataErrorHigh[i]/= val;; 390 fDataErrorLow[i]/= val;; 391 }; 392 else; 393 assert(false);; 394 }; 395 ; 396 if ( kNoError == fErrorType ); 397 {; 398 fErrorType = kValueError;; 399 }; 400 ; 401 return *this;; 402 }; 403 ; 404 ; 405 /**; 406 add one dim data with only coordinate and values; 407 */; 408 void BinData::Add( double x, double y ); 409 {; 410 assert( kNoError == fErrorType );; 411 ; 412 assert( !fData.empty() && fDataPtr );; 413 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 414 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 415 assert( fDataError.empty() && !fDataErrorPtr );; 416 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 417 ; 418 fData[ fNPoints ] = y;; 419 ; 420 FitData::Add( x );; 421 fSumContent += y;; 422 }; 423 ; 424 /**; 425 add one dim data with no error in the coordinate (x); 426 in this case store the inverse of the error in the value (y); 427 */; 428 void BinData::Add( double x, double y, double ey ); 429 {; 430 assert( kValueError == fErrorType );; 431 assert( !fData.empty() && fDataPtr );; 432 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:11960,assert,assert,11960,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:49371,log,logged,49371,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,4,['log'],['logged']
Testability, (0.601) - ; : ; : (Signal Efficiency for Background Efficiency 0.10%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.911 (0.853) 0.991 (0.981) 0.945 (0.913) ; : bg0 0.833 (0.774) - 0.654 (0.582) 0.930 (0.901) ; : bg1 0.971 (0.980) 0.716 (0.681) - 0.871 (0.862) ; : bg2 0.976 (0.951) 0.971 (0.973) 0.936 (0.941) - ; : ; : (Signal Efficiency for Background Efficiency 0.30%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.978 (0.957) 0.999 (1.000) 0.998 (0.997) ; : bg0 0.965 (0.926) - 0.874 (0.835) 0.991 (0.976) ; : bg1 1.000 (0.999) 0.916 (0.894) - 0.988 (0.985) ; : bg2 0.999 (0.999) 0.997 (0.999) 0.996 (0.997) - ; : ; : === Showing confusion matrix for method : MLP ; : (Signal Efficiency for Background Efficiency 0.01%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.465 (0.490) 0.974 (0.953) 0.632 (0.498) ; : bg0 0.320 (0.269) - 0.224 (0.250) 0.655 (0.627) ; : bg1 0.943 (0.920) 0.341 (0.275) - 0.632 (0.687) ; : bg2 0.665 (0.642) 0.697 (0.680) 0.706 (0.598) - ; : ; : (Signal Efficiency for Background Efficiency 0.10%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.865 (0.854) 0.996 (0.994) 0.908 (0.907) ; : bg0 0.784 (0.776) - 0.666 (0.655) 0.919 (0.895) ; : bg1 0.998 (0.998) 0.791 (0.785) - 0.912 (0.902) ; : bg2 0.943 (0.903) 0.946 (0.939) 0.924 (0.928) - ; : ; : (Signal Efficiency for Background Efficiency 0.30%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.978 (0.964) 0.997 (0.997) 0.993 (0.986) ; : bg0 0.952 (0.924) - 0.936 (0.928) 0.992 (0.990) ; : bg1 1.000 (1.000) 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:27345,test,test,27345,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,4,['test'],['test']
Testability, (0.941) - ; : ; : (Signal Efficiency for Background Efficiency 0.30%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.978 (0.957) 0.999 (1.000) 0.998 (0.997) ; : bg0 0.965 (0.926) - 0.874 (0.835) 0.991 (0.976) ; : bg1 1.000 (0.999) 0.916 (0.894) - 0.988 (0.985) ; : bg2 0.999 (0.999) 0.997 (0.999) 0.996 (0.997) - ; : ; : === Showing confusion matrix for method : MLP ; : (Signal Efficiency for Background Efficiency 0.01%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.465 (0.490) 0.974 (0.953) 0.632 (0.498) ; : bg0 0.320 (0.269) - 0.224 (0.250) 0.655 (0.627) ; : bg1 0.943 (0.920) 0.341 (0.275) - 0.632 (0.687) ; : bg2 0.665 (0.642) 0.697 (0.680) 0.706 (0.598) - ; : ; : (Signal Efficiency for Background Efficiency 0.10%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.865 (0.854) 0.996 (0.994) 0.908 (0.907) ; : bg0 0.784 (0.776) - 0.666 (0.655) 0.919 (0.895) ; : bg1 0.998 (0.998) 0.791 (0.785) - 0.912 (0.902) ; : bg2 0.943 (0.903) 0.946 (0.939) 0.924 (0.928) - ; : ; : (Signal Efficiency for Background Efficiency 0.30%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.978 (0.964) 0.997 (0.997) 0.993 (0.986) ; : bg0 0.952 (0.924) - 0.936 (0.928) 0.992 (0.990) ; : bg1 1.000 (1.000) 0.945 (0.936) - 0.998 (0.995) ; : bg2 0.994 (0.985) 0.998 (0.998) 0.998 (0.998) - ; : ; : === Showing confusion matrix for method : PDEFoam ; : (Signal Efficiency for Background Efficiency 0.01%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.289 (0.233) 0.467 (0.436) 0.421 (0.332) ; : bg0 0.100 (0.045) ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:27749,test,test,27749,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,4,['test'],['test']
Testability, (0.997) - ; : ; : === Showing confusion matrix for method : MLP ; : (Signal Efficiency for Background Efficiency 0.01%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.465 (0.490) 0.974 (0.953) 0.632 (0.498) ; : bg0 0.320 (0.269) - 0.224 (0.250) 0.655 (0.627) ; : bg1 0.943 (0.920) 0.341 (0.275) - 0.632 (0.687) ; : bg2 0.665 (0.642) 0.697 (0.680) 0.706 (0.598) - ; : ; : (Signal Efficiency for Background Efficiency 0.10%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.865 (0.854) 0.996 (0.994) 0.908 (0.907) ; : bg0 0.784 (0.776) - 0.666 (0.655) 0.919 (0.895) ; : bg1 0.998 (0.998) 0.791 (0.785) - 0.912 (0.902) ; : bg2 0.943 (0.903) 0.946 (0.939) 0.924 (0.928) - ; : ; : (Signal Efficiency for Background Efficiency 0.30%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.978 (0.964) 0.997 (0.997) 0.993 (0.986) ; : bg0 0.952 (0.924) - 0.936 (0.928) 0.992 (0.990) ; : bg1 1.000 (1.000) 0.945 (0.936) - 0.998 (0.995) ; : bg2 0.994 (0.985) 0.998 (0.998) 0.998 (0.998) - ; : ; : === Showing confusion matrix for method : PDEFoam ; : (Signal Efficiency for Background Efficiency 0.01%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.289 (0.233) 0.467 (0.436) 0.421 (0.332) ; : bg0 0.100 (0.045) - 0.132 (0.116) 0.540 (0.313) ; : bg1 0.209 (0.434) 0.153 (0.092) - 0.347 (0.323) ; : bg2 0.560 (0.552) 0.445 (0.424) 0.501 (0.506) - ; : ; : (Signal Efficiency for Background Efficiency 0.10%); : ---------------------------------------------------; : Signal bg0 bg1 bg2 ; : test (train) test (train) test (train) test (train) ; : Signal - 0.665 (0.640) 0.854 (0.822) 0.807 (0.790) ; : bg0 0.538 (0.520) ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:28153,test,test,28153,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,4,['test'],['test']
Testability," (; TGeoManager * ; geomanager, . const char * ; filename, . TString ; option . ). inlinestatic . Definition at line 61 of file TGDMLWrite.h. ◆ StartVolumeN(). XMLNodePointer_t TGDMLWrite::StartVolumeN ; (; const char * ; name, . const char * ; solid, . const char * ; material . ). private . Creates ""volume"" node for GDML. ; Definition at line 2078 of file TGDMLWrite.cxx. ◆ UnsetTemporaryBits(). void TGDMLWrite::UnsetTemporaryBits ; (; TGeoManager * ; geoMng). private . Unsetting bits that were changed in gGeoManager during export so that export can be run more times with the same instance of gGeoManager. ; Definition at line 2498 of file TGDMLWrite.cxx. ◆ WriteGDMLfile() [1/5]. void TGDMLWrite::WriteGDMLfile ; (; TGeoManager * ; geomanager, . const char * ; filename = ""test.gdml"", . TString ; option = """" . ). Definition at line 264 of file TGDMLWrite.cxx. ◆ WriteGDMLfile() [2/5]. void TGDMLWrite::WriteGDMLfile ; (; TGeoManager * ; geomanager, . TGeoNode * ; top_node, . const char * ; filename = ""test.gdml"", . TString ; option = """" . ). Definition at line 279 of file TGDMLWrite.cxx. ◆ WriteGDMLfile() [3/5]. void TGDMLWrite::WriteGDMLfile ; (; TGeoManager * ; geomanager, . TGeoNode * ; top_node, . TList * ; materialsLst, . const char * ; filename, . TString ; option . ). private . Wrapper of all exporting methods Creates blank GDML file and fills it with gGeoManager structure converted to GDML structure of xml nodes. ; Definition at line 307 of file TGDMLWrite.cxx. ◆ WriteGDMLfile() [4/5]. void TGDMLWrite::WriteGDMLfile ; (; TGeoManager * ; geomanager, . TGeoVolume * ; top_vol, . const char * ; filename = ""test.gdml"", . TString ; option = """" . ). Definition at line 2516 of file TGDMLWrite.cxx. ◆ WriteGDMLfile() [5/5]. void TGDMLWrite::WriteGDMLfile ; (; TGeoManager * ; geomanager, . TGeoVolume * ; top_vol, . TList * ; materialsLst, . const char * ; filename, . TString ; option . ). private . Wrapper of all exporting methods Creates blank GDML file and fills it with gG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDMLWrite.html:43818,test,test,43818,doc/master/classTGDMLWrite.html,https://root.cern,https://root.cern/doc/master/classTGDMLWrite.html,1,['test'],['test']
Testability," (Double_t s, Double_t b, Int_t d, TVectorD *se, TVectorD *be, TObjArray *, Int_t nmc=50000, bool stat=false, TRandom *generator=nullptr);  ; static TConfidenceLevel * ComputeLimit (TH1 *s, TH1 *b, TH1 *d, Int_t nmc=50000, bool stat=false, TRandom *generator=nullptr);  ; static TConfidenceLevel * ComputeLimit (TH1 *s, TH1 *b, TH1 *d, TVectorD *se, TVectorD *be, TObjArray *, Int_t nmc=50000, bool stat=false, TRandom *generator=nullptr);  ; static TConfidenceLevel * ComputeLimit (TLimitDataSource *data, Int_t nmc=50000, bool stat=false, TRandom *generator=nullptr);  ; static const char * DeclFileName ();  . Static Protected Member Functions; static bool Fluctuate (TLimitDataSource *input, TLimitDataSource *output, bool init, TRandom *, bool stat=false);  ; static Double_t LogLikelihood (Double_t s, Double_t b, Double_t b2, Double_t d);  . Static Private Attributes; static TOrdCollection * fgSystNames = new TOrdCollection();  Collection of systematics names. ;  ; static TArrayD * fgTable = new TArrayD(0);  A log table... just to speed up calculation. ;  . #include <TLimit.h>; Constructor & Destructor Documentation. ◆ TLimit(). TLimit::TLimit ; (; ). inline . Definition at line 25 of file TLimit.h. ◆ ~TLimit(). virtual TLimit::~TLimit ; (; ). inlinevirtual . Definition at line 26 of file TLimit.h. Member Function Documentation. ◆ Class(). static TClass * TLimit::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TLimit::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TLimit::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 52 of file TLimit.h. ◆ ComputeLimit() [1/5]. TConfidenceLevel * TLimit::ComputeLimit ; (; Double_t ; s, . Double_t ; b, . Int_t ; d, . Int_t ; nmc = 50000, . bool ; stat = false, . TRandom * ; generator = nullptr . ). static . Definition at line 361 of file TLimit.cxx. ◆ ComputeLimit() [2/5]. TConfidenceLev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLimit.html:6473,log,log,6473,doc/master/classTLimit.html,https://root.cern,https://root.cern/doc/master/classTLimit.html,1,['log'],['log']
Testability," (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the daemon for remote ROOT file access (see the TNetFile). 1.6.2 $ROOTSYS/lib; There are several ways to use ROOT, one way is to run",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16758,test,test,16758,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability," (Int_t &hour, Int_t &min, Int_t &sec) const;  ; virtual void IncreaseNumber (EStepSize step=kNSSSmall, Int_t sign=1, Bool_t logstep=kFALSE);  ; TClass * IsA () const override;  ; Bool_t IsEditable () const override;  Return kTRUE if frame is being edited. ;  ; virtual Bool_t IsLogStep () const;  ; virtual void Modified ();  Emit Modified() signal. ;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t parm2) override;  Process the up/down button messages. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save a number entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SetButtonToNum (Bool_t state);  Send button messages to the number field (true) or parent widget (false). ;  ; virtual void SetDate (Int_t year, Int_t month, Int_t day, Bool_t emit=kTRUE);  ; virtual void SetFormat (EStyle style, EAttribute attr=TGNumberFormat::kNEAAnyNumber);  ; virtual void SetHexNumber (ULong_t val, Bool_t emit=kTRUE);  ; virtual void SetIntNumber (Long_t val, Bool_t emit=kTRUE);  ; virtual void SetLimits (ELimit limits=TGNumberFormat::kNELNoLimits, Double_t min=0, Double_t max=1);  ; void SetLimitValues (Double_t min=0, Double_t max=1);  ; virtual void SetLogStep (Bool_t on=kTRUE);  Set log steps. ;  ; void SetNumAttr (EAttribute attr=kNEAAnyNumber);  ; virtual void SetNumber (Double_t val, Bool_t emit=kTRUE);  ; void SetNumLimits (ELimit limits=kNELNoLimits);  ; void SetNumStyle (EStyle style);  ; virtual void SetState (Bool_t enable=kTRUE);  Set the active state. ;  ; virtual void SetText (const char *text, Bool_t emit=kTRUE);  ; virtual void SetTime (Int_t hour, Int_t min, Int_t sec, Bool_t emit=kTRUE);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void ValueChanged (Long_t val);  Emit ValueChanged(Long_t) signal. ;  ; virtual void ValueSet (Long_t val);  Emit ValueSet(Long_t) signal. ;  ;  Public Member Functions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntry.html:5356,log,log,5356,doc/master/classTGNumberEntry.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntry.html,1,['log'],['log']
Testability," (Palette Line Color) and AMC (Palette Marker Color). ;  ;  hksimple.C;   Illustrates the advantages of a TH1K histogram ;  ;  hlabels1.C;   1-D histograms with alphanumeric labels ;  ;  hlabels2.C;   2-D histograms with alphanumeric labels. ;  ;  hlHisto1.C;  This tutorial demonstrates how the highlight mechanism can be used on an histogram. ;  ;  hlHisto2.C;  This tutorial demonstrates how the highlight mechanism can be used on an histogram. ;  ;  hlHisto3.C;  This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ;  ;  hlHisto4.C;  This tutorial demonstrates how the highlight mechanism can be used on an histogram. ;  ;  hstack.C;   Example of stacked histograms: class THStack. ;  ;  hstackpads.C;   Drawing stack histograms on subpads. ;  ;  hsum.C;   Histograms filled and drawn in a loop. ;  ;  hsumTimer.C;   Demo of Timers. ;  ;  legendautoplaced.C;   The legend can be placed automatically in the current pad in an empty space found at painting time. ;  ;  logscales.C;   Draw parametric functions with log scales. ;  ;  movepalette.C;   When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ;  ;  multicolor.C;   Use a THStack to show a 2-D hist with cells with different colors. ;  ;  NormalizeHistogram.C;   Normalizing a Histogram ;  ;  ratioplot1.C;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ;  ratioplot1.py;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ;  ratioplot2.C;   Example of a fit residual plot. ;  ;  ratioplot2.py;   Example of a fit residual plot. ;  ;  ratioplot3.C;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ;  ratioplot3.py;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ;  ratioplot4.C;   Example that shows custom dashed lines on the lower plot, specifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3123,log,logscales,3123,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['log'],['logscales']
Testability," (axis=2)Definition TGraph.cxx:1339; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:115312,log,logx,115312,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,4,['log'],"['log', 'logari', 'logx', 'logy']"
Testability," (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const =0;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; virtual bool operator== (const RooAbsArg &other) const =0;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:12462,test,testArg,12462,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,2,['test'],['testArg']
Testability," (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TProofMgr; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TProofMgr * Create (const char *url, Int_t loglevel=-1, const char *alias=0, Bool_t xpd=kTRUE);  Static method returning the appropriate TProofMgr object using the plugin manager. ;  ; static const char * DeclFileName ();  ; static TList * GetListOfManagers ();  Extract pointers to PROOF managers from TROOT::fProofs. ;  ; static Int_t Ping (const char *url, Bool_t checkxrd=kFALSE);  Non-blocking check for a PROOF (or Xrootd, if checkxrd) service at 'url' Return 0 if a XProofd (or Xrootd, if checkxrd) daemon is listening at 'url' -1 if nothing is listening on the port (connection cannot be open) 1 if something is listening but not XProofd (or not Xrootd, if checkxrd) ;  ; static void SetTXProofMgrHook (TProofMgr_t pmh);  Set hook to TXProofMgr ctor. ;  ; static TFileCollection * UploadFiles (const char *txtfile, const char *mss, const char *dest=0);  Upload to 'mss' the files listed in the text",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgrLite.html:13137,log,loglevel,13137,doc/master/classTProofMgrLite.html,https://root.cern,https://root.cern/doc/master/classTProofMgrLite.html,1,['log'],['loglevel']
Testability," (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVDUnfold.html:10686,test,test,10686,root/html602/TSVDUnfold.html,https://root.cern,https://root.cern/root/html602/TSVDUnfold.html,4,['test'],['test']
Testability," (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:41817,test,tests,41817,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['test'],['tests']
Testability," (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. iterator & operator=(const TIndexTable& ); {fTable = iter.fTable; fCurrentRow = iter.fCurrentRow; return *this;}. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }. » Author: Valery Fine(fine@bnl.gov) 01/03/2001 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TIndexTable.html:17917,assert,assert,17917,root/html604/TIndexTable.html,https://root.cern,https://root.cern/root/html604/TIndexTable.html,4,['assert'],['assert']
Testability," (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. iterator & operator=(const TIndexTable& ); {fTable = iter.fTable; fCurrentRow = iter.fCurrentRow; return *this;}. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }. » Author: Valery Fine(fine@bnl.gov) 01/03/2001 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TIndexTable.html:17917,assert,assert,17917,root/html602/TIndexTable.html,https://root.cern,https://root.cern/root/html602/TIndexTable.html,4,['assert'],['assert']
Testability," (objfunc) {; 587 fFunc = objfunc->ModelFunctionPtr();; 588 fData = objfunc->DataPtr();; 589 return true;; 590 }; 591 else {; 592 return false;; 593 }; 594}; 595 ; 596#ifdef R__HAS_VECCORE; 597template <class NotCompileIfScalarBackend>; 598void Fitter::SetFunction(const IModelFunction_v &func, bool useGradient); 599{; 600 fUseGradient = useGradient;; 601 if (fUseGradient) {; 602 const IGradModelFunction_v *gradFunc = dynamic_cast<const IGradModelFunction_v *>(&func);; 603 if (gradFunc) {; 604 SetFunction(*gradFunc, true);; 605 return;; 606 } else {; 607 MATH_WARN_MSG(""Fitter::SetFunction"",; 608 ""Requested function does not provide gradient - use it as non-gradient function "");; 609 }; 610 }; 611 ; 612 // set the fit model function (clone the given one and keep a copy ); 613 // std::cout << ""set a non-grad function"" << std::endl;; 614 fUseGradient = false;; 615 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IModelFunction_v *>(func.Clone()));; 616 assert(fFunc_v);; 617 ; 618 // creates the parameter settings; 619 fConfig.CreateParamsSettings(*fFunc_v);; 620 fFunc.reset();; 621}; 622 ; 623template <class NotCompileIfScalarBackend>; 624void Fitter::SetFunction(const IGradModelFunction_v &func, bool useGradient); 625{; 626 fUseGradient = useGradient;; 627 ; 628 // set the fit model function (clone the given one and keep a copy ); 629 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IGradModelFunction_v *>(func.Clone()));; 630 assert(fFunc_v);; 631 ; 632 // creates the parameter settings; 633 fConfig.CreateParamsSettings(*fFunc_v);; 634 fFunc.reset();; 635}; 636#endif; 637 ; 638 } // end namespace Fit; 639 ; 640} // end namespace ROOT; 641 ; 642// implementation of inline methods; 643 ; 644 ; 645 ; 646#include ""Math/WrappedFunction.h""; 647 ; 648template<class Function>; 649bool ROOT::Fit::Fitter::FitFCN(unsigned int npar, Function & f, const double * par, unsigned int datasize,int fitType) {; 650 ROOT::Math::WrappedMultiFunction<Function &> wf(f,npar);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:25439,assert,assert,25439,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['assert'],['assert']
Testability," (other._specGeneratorConfig) {; 268 _specGeneratorConfig = std::make_unique<RooNumGenConfig>(*other._specGeneratorConfig);; 269 }; 270}; 271 ; 272 ; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11327,log,logEvalError,11327,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['logEvalError']
Testability," (sensitivity) for a given background efficiency (sensitivity).Definition ROCCurve.cxx:217; TMVA::ROCCurve::GetROCIntegralDouble_t GetROCIntegral(const UInt_t points=41)Calculates the ROC integral (AUC)Definition ROCCurve.cxx:248; TMVA::ROCCurve::GetROCCurveTGraph * GetROCCurve(const UInt_t points=100)Returns a new TGraph containing the ROC curve.Definition ROCCurve.cxx:274; TMVA::RankingRanking for variables in method (implementation)Definition Ranking.h:48; TMVA::Ranking::Printvirtual void Print() constget maximum length of variable namesDefinition Ranking.cxx:111; TMVA::ResultsClassificationClass that is the base-class for a vector of result.Definition ResultsClassification.h:48; TMVA::ResultsMulticlassClass which takes the results of a multiclass classification.Definition ResultsMulticlass.h:55; TMVA::ResultsClass that is the base-class for a vector of result.Definition Results.h:57; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::UsefulSortDescendingvoid UsefulSortDescending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:564; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Tools::Colorconst TString & Color(const TString &)human readable color stringsDefinition Tools.cxx:828; TMVA::Tools::GetCorrelationMatrixconst TMatrixD * GetCorrelationMatrix(const TMatrixD *c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:133189,log,logger,133189,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['log'],['logger']
Testability," (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as well; as the original one [3], has a restriction on the expected frequencies. The; expected frequencies recommended for the weighted histogram is more than 25.; The value of the minimal expected frequency can be decreased down to 10 for; the case when the weights of the events are close to constant. In the case; of a weighted histogram if the number of events is unknown, then we can; apply this recommendation for the equivalent number of events as. The minimal expected frequency for an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that have constant weights equal to 1.; The variance of the difference between the weight wi; and the estimated expectation value of the weight is approximately equal to:. The residuals. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted histograms comparison:. Let us denote the common weight of events of the ith bin in the first; histogram as w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:48923,test,test,48923,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,10,['test'],['test']
Testability," (xv[0] < f1->GetXmin() || xv[0] > f1->GetXmax()) continue;; 7200 fval = f1->Eval(xv[0],0,0);; 7201 if (f1->GetMaximumStored() != -1111) fval = TMath::Min(f1->GetMaximumStored(), fval);; 7202 ymax = TMath::Max(ymax,fval);; 7203 if (Hoption.Logy) {; 7204 if (c1 > 0 && fval > 0.3*c1) ymin = TMath::Min(ymin,fval);; 7205 }; 7206 }; 7207 }; 7208 next.Reset();; 7209 }; 7210 allchan += c1;; 7211 }; 7212 if (!nonNullErrors) {; 7213 if (Hoption.Error) {; 7214 if (!Hoption.Mark && !Hoption.Line && !Hoption.Star && !Hoption.Curve) Hoption.Hist = 2;; 7215 Hoption.Error=0;; 7216 }; 7217 }; 7218 ; 7219 ; 7220 // Take into account maximum , minimum; 7221 ; 7222 if (Hoption.Logy && ymin <= 0) {; 7223 if (ymax >= 1) ymin = TMath::Max(.005,ymax*1e-10);; 7224 else ymin = 0.001*ymax;; 7225 }; 7226 ; 7227 Double_t xm = ymin;; 7228 if (maximum) ymax = fH->GetMaximumStored();; 7229 if (minimum) xm = fH->GetMinimumStored();; 7230 if (Hoption.Logy && xm < 0) {; 7231 Error(where, ""log scale requested with a negative argument (%f)"", xm);; 7232 return 0;; 7233 } else if (Hoption.Logy && xm>=0 && ymax==0) { // empty histogram in log scale; 7234 ymin = 0.01;; 7235 ymax = 10.;; 7236 } else {; 7237 ymin = xm;; 7238 }; 7239 ; 7240 if (ymin >= ymax) {; 7241 if (Hoption.Logy) {; 7242 if (ymax > 0) ymin = 0.001*ymax;; 7243 else {; 7244 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", ymax);; 7245 return 0;; 7246 }; 7247 }; 7248 else {; 7249 if (ymin > 0) {; 7250 ymin = 0;; 7251 ymax *= 2;; 7252 } else if (ymin < 0) {; 7253 ymax = 0;; 7254 ymin *= 2;; 7255 } else {; 7256 ymin = 0;; 7257 ymax = 1;; 7258 }; 7259 }; 7260 }; 7261 ; 7262 // In some cases, mainly because of precision issues, ymin and ymax could almost equal.; 7263 if (TMath::AreEqualRel(ymin,ymax,1E-15)) {; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:261915,log,log,261915,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['log']
Testability," )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofLog (const char *stag, const char *url, TProofMgr *mgr);  Constructor. ;  ;  ~TProofLog () override;  Destructor. ;  ; void Display (const char *ord=""*"", Int_t from=-10, Int_t to=-1);  Display the content associated with worker 'ord' from line 'from' to line 'to' inclusive. ;  ; TList * GetListOfLogs () const;  ; Int_t Grep (const char *txt, Int_t from=0);  Search lines containing 'txt', starting from line 'from'. ;  ; TClass * IsA () const override;  ; Bool_t LogToBox ();  ; void Print (Option_t *opt=0) const override;  Print head info about the content. ;  ; void Prt (const char *what, Bool_t newline=kTRUE);  Special printing procedure. ;  ; Int_t Retrieve (const char *ord=""*"", TProofLog::ERetrieveOpt opt=TProofLog::kTrailing, const char *fname=0, const char *pattern=0);  Retrieve the content of the log file associated with worker 'ord'. ;  ; Int_t Save (const char *ord=""*"", const char *fname=0, Option_t *opt=""w"");  Save the content associated with worker 'ord' to finel 'fname'. ;  ; void SetLogToBox (Bool_t lgbox=kFALSE);  ; TDatime StartTime ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLog.html:2100,log,log,2100,doc/master/classTProofLog.html,https://root.cern,https://root.cern/doc/master/classTProofLog.html,1,['log'],['log']
Testability," ). Creates a profile of the difference of the MLP output outnode minus the true value of outnode vs the input value innode, for all test data events. ; The resulting TProfile histogram is returned. It is not drawn if option ""goff"" is specified. Options are passed to TProfile::Draw ; Definition at line 474 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviationInsOut(). THStack * TMLPAnalyzer::DrawTruthDeviationInsOut ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Creates a profile of the difference of the MLP output outnode minus the true value of outnode vs the input value, stacked for all inputs, for all test data events. ; The returned THStack contains all the TProfiles. It is drawn unless the option ""goff"" is specified. Options are passed to TProfile::Draw. ; Definition at line 506 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviations(). THStack * TMLPAnalyzer::DrawTruthDeviations ; (; Option_t * ; option = """"). Creates TProfiles of the difference of the MLP output minus the true value vs the true value, one for each output, filled with the test data events. ; This method is mainly useful when doing regression analysis with the MLP (i.e. not classification, but continuous truth values). The returned THStack contains all the TProfiles. It is drawn unless the option ""goff"" is specified. Options are passed to TProfile::Draw. ; Definition at line 431 of file TMLPAnalyzer.cxx. ◆ GatherInformations(). void TMLPAnalyzer::GatherInformations ; (; ). Collect information about what is useful in the network. ; This method has to be called first when analyzing a network. Fills the two analysis trees. ; Definition at line 170 of file TMLPAnalyzer.cxx. ◆ GetInputNeuronTitle(). const char * TMLPAnalyzer::GetInputNeuronTitle ; (; Int_t ; in). protected . Returns the name of any neuron from the input layer. ; Definition at line 128 of file TMLPAnalyzer.cxx. ◆ GetIOTree(). TTree * TMLPAnalyzer::GetIOTree ; (; ); const. inline . Definition at line 56 of file TMLPAnalyzer.h. ◆ GetLayers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:17022,test,test,17022,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['test'],['test']
Testability, ). virtual . ◆ StreamerNVirtual(). void TMVA::Config::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 148 of file Config.h. ◆ UseColor(). Bool_t TMVA::Config::UseColor ; (; ); const. inline . Definition at line 59 of file Config.h. ◆ WriteOptionsReference(). Bool_t TMVA::Config::WriteOptionsReference ; (; ); const. inline . Definition at line 65 of file Config.h. Member Data Documentation. ◆ fDrawProgressBar. std::atomic<Bool_t> TMVA::Config::fDrawProgressBar. private . draw progress bar to indicate training evolution ; Definition at line 140 of file Config.h. ◆ fExecutor. Executor TMVA::Config::fExecutor. protected . Definition at line 52 of file Config.h. ◆ fgConfigPtr. std::atomic< TMVA::Config * > TMVA::Config::fgConfigPtr { 0 }. staticprivate . Definition at line 137 of file Config.h. ◆ fIONames. class TMVA::Config::IONames TMVA::Config::fIONames. ◆ fLogger. MsgLogger* TMVA::Config::fLogger. mutableprivate . ! message logger ; Definition at line 145 of file Config.h. ◆ fNWorkers. std::atomic<UInt_t> TMVA::Config::fNWorkers. private . Default number of workers for multi-process jobs. ; Definition at line 141 of file Config.h. ◆ fSilent. std::atomic<Bool_t> TMVA::Config::fSilent. private . no output at all ; Definition at line 143 of file Config.h. ◆ fUseColoredConsole. std::atomic<Bool_t> TMVA::Config::fUseColoredConsole. private . coloured standard output ; Definition at line 142 of file Config.h. ◆ fVariablePlotting. class TMVA::Config::VariablePlotting TMVA::Config::fVariablePlotting. ◆ fWriteOptionsReference. std::atomic<Bool_t> TMVA::Config::fWriteOptionsReference. private . if set true: Configurable objects write file with option reference ; Definition at line 144 of file Config.h. Libraries for TMVA::Config:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Config.h; tmva/tmva/src/Config.cxx. TMVAConfig. ROOT master - Reference Guide Generated on Tue Nov 5 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Config.html:7843,log,logger,7843,doc/master/classTMVA_1_1Config.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Config.html,1,['log'],['logger']
Testability," ); 386 {; 387 x -= 1.0;; 388 z *= x;; 389 }; 390 ; 391 while( x < 0.0 ); 392 {; 393 if( x > -1.E-9 ); 394 goto small;; 395 z /= x;; 396 x += 1.0;; 397 }; 398 ; 399 while( x < 2.0 ); 400 {; 401 if( x < 1.e-9 ); 402 goto small;; 403 z /= x;; 404 x += 1.0;; 405 }; 406 ; 407 if( x == 2.0 ); 408 return(z);; 409 ; 410 x -= 2.0;; 411 p = Polynomialeval( x, P, 6 );; 412 q = Polynomialeval( x, Q, 7 );; 413 return( z * p / q );; 414 ; 415small:; 416 if( x == 0 ); 417 return( std::numeric_limits<double>::infinity() );; 418 else; 419 return( z/((1.0 + 0.5772156649015329 * x) * x) );; 420}; 421 ; 422/*---------------------------------------------------------------------------*/; 423 ; 424//#define kMAXLGM 2.556348e305; 425 ; 426/*---------------------------------------------------------------------------*/; 427/* implementation based on cephes log gamma */; 428double beta(double z, double w); 429{; 430 return std::exp(ROOT::Math::Cephes::lgam(z) + ROOT::Math::Cephes::lgam(w)- ROOT::Math::Cephes::lgam(z+w) );; 431}; 432 ; 433 ; 434/*---------------------------------------------------------------------------*/; 435/* implementation of the incomplete beta function */; 436/**; 437 * DESCRIPTION:; 438 *; 439 * Returns incomplete beta integral of the arguments, evaluated; 440 * from zero to x. The function is defined as; 441 *; 442 * x; 443 * - -; 444 * | (a+b) | | a-1 b-1; 445 * ----------- | t (1-t) dt.; 446 * - - | |; 447 * | (a) | (b) -; 448 * 0; 449 *; 450 * The domain of definition is 0 <= x <= 1. In this; 451 * implementation a and b are restricted to positive values.; 452 * The integral from x to 1 may be obtained by the symmetry; 453 * relation; 454 *; 455 * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; 456 *; 457 * The integral is evaluated by a continued fraction expansion; 458 * or, when b*x is small, by a power series.; 459 *; 460 * ACCURACY:; 461 *; 462 * Tested at uniformly distributed random points (a,b,x) with a and b; 463 * in ""domain"" and x between 0 and 1.; 464 * R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:9218,log,log,9218,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,1,['log'],['log']
Testability," ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 109 of file TEnv.h. ◆ GetType(). const char * TEnvRec::GetType ; (; ); const. inline . Definition at line 111 of file TEnv.h. ◆ GetValue(). const char * TEnvRec::GetValue ; (; ); const. inline . Definition at line 110 of file TEnv.h. ◆ Hash(). ULong_t TEnvRec::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 113 of file TEnv.h. ◆ IsA(). TClass * TEnvRec::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnvRec.html:13646,log,logarithmic,13646,doc/master/classTEnvRec.html,https://root.cern,https://root.cern/doc/master/classTEnvRec.html,1,['log'],['logarithmic']
Testability," ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 66 of file TParameter.h. ◆ GetVal(). template<class AParamType > . const AParamType & TParameter< AParamType >::GetVal ; (; ); const. inline . Definition at line 67 of file TParameter.h. ◆ Hash(). template<class AParamType > . ULong_t TParameter< AParamType >::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TParameter::HashULong_t Hash() const overrideReturn hash value for this object.Definition TParameter.h:92; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 92 of file TParameter.h. ◆ IsA(). template<class AParamType > . TClass * TParameter< AParamType >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParameter.html:14258,log,logarithmic,14258,doc/master/classTParameter.html,https://root.cern,https://root.cern/doc/master/classTParameter.html,1,['log'],['logarithmic']
Testability," ); const. privatepure virtual . Implemented in ROOT::Math::GSLMultiRootSolver, and ROOT::Math::GSLMultiRootDerivSolver. ◆ InitSolver(). bool ROOT::Math::GSLMultiRootBaseSolver::InitSolver ; (; const std::vector< ROOT::Math::IMultiGenFunction * > & ; funcVec, . const double * ; x . ). inline . init the solver with function list and initial values ; Definition at line 71 of file GSLMultiRootSolver.h. ◆ Iterate(). virtual int ROOT::Math::GSLMultiRootBaseSolver::Iterate ; (; ). pure virtual . perform an iteration ; Implemented in ROOT::Math::GSLMultiRootSolver, and ROOT::Math::GSLMultiRootDerivSolver. ◆ Name(). virtual const std::string & ROOT::Math::GSLMultiRootBaseSolver::Name ; (; ); const. pure virtual . return name ; Implemented in ROOT::Math::GSLMultiRootSolver, and ROOT::Math::GSLMultiRootDerivSolver. ◆ SetSolver(). virtual int ROOT::Math::GSLMultiRootBaseSolver::SetSolver ; (; const std::vector< ROOT::Math::IMultiGenFunction * > & ; funcVec, . const double * ; x . ). privatepure virtual . Implemented in ROOT::Math::GSLMultiRootSolver, and ROOT::Math::GSLMultiRootDerivSolver. ◆ TestDelta(). int ROOT::Math::GSLMultiRootBaseSolver::TestDelta ; (; double ; absTol, . double ; relTol . ); const. inline . test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ; Definition at line 117 of file GSLMultiRootSolver.h. ◆ TestResidual(). int ROOT::Math::GSLMultiRootBaseSolver::TestResidual ; (; double ; absTol); const. inline . test using abs tolerance Sum |f|_i < absTol ; Definition at line 126 of file GSLMultiRootSolver.h. ◆ X(). const double * ROOT::Math::GSLMultiRootBaseSolver::X ; (; ); const. inline . solution values at the current iteration ; Definition at line 98 of file GSLMultiRootSolver.h. The documentation for this class was generated from the following file:; math/mathmore/src/GSLMultiRootSolver.h. ROOTMathGSLMultiRootBaseSolver. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html:4284,test,test,4284,doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,2,['test'],['test']
Testability," *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList"")) useList = kTRUE;; }; ; void h1analysisTreeReader::Terminate() {; // function called at the end of the event loop; ; hdmd = dynamic_cast<TH1F*>(fOutput->FindObject(""hdmd""));; h2 = dynamic_cast<TH2F*>(fOutput->FindObject(""h2""));; ; if (hdmd == nullptr || h2 == nullptr) {; Error(""Terminate"", ""hdmd = %p , h2 = %p"", hdmd, h2);; return;; }; ; //create the canvas for the h1analysis fit; gStyle->SetOptFit();; TCanvas *c1 = new TCanvas(""c1"",""h1analysis analysis"",10,10,800,600);; c1->SetBottomMargin(0.15);; hdmd->GetXaxis()->SetTitle(""m_{K#pi#pi} - m_{K#pi}[GeV/c^{2}]"");; hdmd->GetXaxis()->SetTitleOffset(1.4);; ; //fit histogram hdmd with function f5 using the loglfIkelihood option; if (gROOT->GetListOfFunctions()->FindObject(""f5"")); delete gROOT->GetFunction(""f5"");; TF1 *f5 = new TF1(""f5"",fdm5,0.139,0.17,5);; f5->SetParameters(1000000, .25, 2000, .1454, .001);; hdmd->Fit(""f5"",""lr"");; ; //create the canvas for tau d0; gStyle->SetOptFit(0);; gStyle->SetOptStat(1100);; TCanvas *c2 = new TCanvas(""c2"",""tauD0"",100,100,800,600);; c2->SetGrid();; c2->SetBottomMargin(0.15);; ; // Project slices of 2-d histogram h2 along X , then fit each slice; // with function f2 and make a histogram for each fit parameter; // Note that the generated histograms are added to the list of objects; // in the current directory.; if (gROOT->GetListOfFunctions()->FindObject(""f2"")); delete gROOT->GetFunction(""f2"");; TF1 *f2 = new TF1(""f2"",fdm2,0.139,0.17,2);; f2->SetParameters(10000, 10);; h2->FitSlicesX(f2,0,-1,1,""qln"");; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; h2_1->GetXaxis()->SetTitle(""#tau[ps]"");; h2_1->SetMarkerStyle(21);; h2_1->Draw();; c2->Update();; TLine *line = new TLine(0,0,0,c2->GetUymax());; li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:5595,log,loglfIkelihood,5595,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['log'],['loglfIkelihood']
Testability," *const err, Double_t *const errUpper); virtual voidProcessOptions(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*fCurrentMethod; UInt_tfCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>fMethodWeight; vector<IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCompositeBase.html:15502,test,testing,15502,root/html534/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCompositeBase.html,2,['test'],['testing']
Testability," *const err, Double_t *const errUpper); virtual voidProcessOptions(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; Int_tfMethodIndex; vector<Double_t>fMethodWeight; vector<IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCompositeBase.html:15382,test,testing,15382,root/html530/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCompositeBase.html,3,['test'],['testing']
Testability," *const err, Double_t *const errUpper); virtual voidProcessOptions(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; Int_tfMethodIndex; vector<Double_t>fMethodWeight; vector<IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCompositeBase.html:14841,test,testing,14841,root/html528/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html,1,['test'],['testing']
Testability," *const err, Double_t *const errUpper); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidInit(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodDT.html:18133,test,testing,18133,root/html530/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodDT.html,5,['test'],['testing']
Testability," *const err, Double_t *const errUpper); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidInit(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:17592,test,testing,17592,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,1,['test'],['testing']
Testability," *params, unsigned int n, double const *low, double const *high, double boundary, double nominal, int doCutoff);  ; double flexibleInterpSingle (unsigned int code, double low, double high, double boundary, double nominal, double paramVal, double res);  ; double gaussian (double x, double mean, double sigma);  Function to evaluate an un-normalized RooGaussian. ;  ; double gaussianIntegral (double xMin, double xMax, double mean, double sigma);  Function to calculate the integral of an un-normalized RooGaussian over x. ;  ; unsigned int getUniformBinning (double low, double high, double val, unsigned int numBins);  ; double interpolate1d (double low, double high, double val, unsigned int numBins, double const *vals);  ; double landau (double x, double mu, double sigma);  ; double logNormal (double x, double k, double m0);  ; double logNormalIntegral (double xMin, double xMax, double m0, double k);  ; double logNormalIntegralStandard (double xMin, double xMax, double mu, double sigma);  ; double logNormalStandard (double x, double sigma, double mu);  ; double nll (double pdf, double weight, int binnedL, int doBinOffset);  ; double poisson (double x, double par);  ; double poissonIntegral (int code, double mu, double x, double integrandMin, double integrandMax, unsigned int protectNegative);  ; template<bool pdfMode = false> ; double polynomial (double const *coeffs, int nCoeffs, int lowestOrder, double x);  In pdfMode, a coefficient for the constant term of 1.0 is implied if lowestOrder > 0. ;  ; template<bool pdfMode = false> ; double polynomialIntegral (double const *coeffs, int nCoeffs, int lowestOrder, double xMin, double xMax);  In pdfMode, a coefficient for the constant term of 1.0 is implied if lowestOrder > 0. ;  ; double product (double const *factors, std::size_t nFactors);  ; double ratio (double numerator, double denominator);  ; double recursiveFraction (double *a, unsigned int n);  . Function Documentation. ◆ approxErf(). double RooFit::Detail::MathFuncs::a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html:2411,log,logNormal,2411,doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,https://root.cern,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,4,['log'],"['logNormal', 'logNormalIntegral', 'logNormalIntegralStandard', 'logNormalStandard']"
Testability," += val;; 518 }; 519 ; 520 /**; 521 add multi-dim coordinate data with only error in value; 522 The class stores internally the inverse of the error in this case; 523 */; 524 void BinData::Add( const double* x, double val, double eval ); 525 {; 526 assert( kValueError == fErrorType );; 527 assert( !fData.empty() && fDataPtr );; 528 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 529 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 530 assert( !fDataError.empty() && fDataErrorPtr );; 531 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 532 ; 533 fData[ fNPoints ] = val;; 534 fDataError[ fNPoints ] = (eval != 0.0) ? 1.0/eval : 0.0;; 535 ; 536 FitData::Add( x );; 537 fSumContent += val;; 538 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 539 if (!fIsWeighted); 540 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 541 }; 542 ; 543 /**; 544 add multi-dim coordinate data with both error in coordinates and value; 545 */; 546 void BinData::Add( const double* x, double val, const double* ex, double eval ); 547 {; 548 assert( kCoordError == fErrorType );; 549 assert( !fData.empty() && fDataPtr );; 550 assert( !fDataError.empty() && fDataErrorPtr );; 551 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 552 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 553 assert( fCoordErrors.size() == fDim );; 554 assert( fCoordErrorsPtr.size() == fDim );; 555 ; 556 fData[ fNPoints ] = val;; 557 ; 558 for( unsigned int i=0; i<fDim; i++ ); 559 {; 560 assert( &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 561 ; 562 fCoordErrors[i][ fNPoints ] = ex[i];; 563 }; 564 // in this case we store the y error and not the inverse; 565 fDataError[ fNPoints ] = eval;; 566 ; 567 FitData::Add( x );; 568 fSumContent += val;; 569 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 570 if (!fIsWeighted); 571 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 572 }; 573 ; 574 /**; 575 add multi-dim coo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:16842,assert,assert,16842,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,2,['assert'],['assert']
Testability," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:30252,test,test,30252,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,8,['test'],"['test', 'testStat', 'tests']"
Testability," - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t autorange = kTRUE); {fAutoRange=autorange;}. void SetDview(Double_t dview); {fDview=dview;}. void SetDproj(Double_t dproj); {fDproj=dproj;}. void SetLatitude(Double_t latitude); {fLatitude = latitude;}. void SetLongitude(Double_t longitude); {fLongitude = longitude;}. void SetPsi(Double_t psi); {fPsi = psi;}. void SetSystem(Int_t system); {fSystem = system;}. void SetViewChanged(Bool_t flag = kTRUE); {fChanged = flag;}. » Author: Rene Brun 19/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TView3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TView3D.html:23351,Test,TestBit,23351,root/html532/TView3D.html,https://root.cern,https://root.cern/root/html532/TView3D.html,1,['Test'],['TestBit']
Testability," - verbose, a - analytical (default). Double_t WeightA() const; Analytical computation of the weight. Int_t GetNdaughters() const; {if (!fNodes) return 0; return (fNodes->GetEntriesFast());}. void ClearNodes(); {fNodes = 0;}. Bool_t Contains(const Double_t* point) const; {return fShape->Contains(point);}. Bool_t IsRunTime() const; {return fShape->IsRunTimeShape();}. Bool_t IsVolumeMulti() const; {return kFALSE;}. Int_t GetRefCount() const; {return fRefCount;}. TGeoExtension * GetUserExtension() const; {return fUserExtension;}. TGeoExtension * GetFWExtension() const; {return fFWExtension;}. void Grab(); {fRefCount++;}. void Release(); {fRefCount--; if (fRefCount==0) delete this;}. Bool_t IsActive() const; {return TGeoAtt::IsActive();}. Bool_t IsActiveDaughters() const; {return TGeoAtt::IsActiveDaughters();}. Bool_t IsAdded() const; {return TObject::TestBit(kVolumeAdded);}. Bool_t IsOverlappingCandidate() const; {return TObject::TestBit(kVolumeOC);}. Bool_t IsReplicated() const; {return TObject::TestBit(kVolumeReplicated);}. Bool_t IsSelected() const; {return TObject::TestBit(kVolumeSelected);}. Bool_t IsCylVoxels() const; {return TObject::TestBit(kVoxelsCyl);}. Bool_t IsXYZVoxels() const; {return TObject::TestBit(kVoxelsXYZ);}. Bool_t IsValid() const; {return fShape->IsValid();}. Bool_t IsVisible() const; {return TGeoAtt::IsVisible();}. Bool_t IsVisibleDaughters() const; {return TGeoAtt::IsVisDaughters();}. Bool_t IsVisContainers() const; {return TGeoAtt::IsVisContainers();}. Bool_t IsVisLeaves() const; {return TGeoAtt::IsVisLeaves();}. Bool_t IsVisOnly() const; {return TGeoAtt::IsVisOnly();}. Int_t GetCurrentNodeIndex() const; {return -1;}. Int_t GetNextNodeIndex() const; {return -1;}. TObjArray * GetNodes(); {return fNodes;}. Int_t GetNtotal() const; {return fNtotal;}. TGeoManager * GetGeoManager() const; {return fGeoManager;}. TGeoMaterial * GetMaterial() const; {return GetMedium()->GetMaterial();}. TGeoMedium * GetMedium() const; {return (fMedium)?fMedium:DummyMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:44684,Test,TestBit,44684,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,3,['Test'],['TestBit']
Testability," -0.1641741416E+1};; 519 static double a2[4] = {-0.1958333333E+1, 0.5563368056E+1,-0.2111352961E+2,; 520 0.1006946266E+3};; 521 static double a3[4] = {-1.0 , 0.4458333333E+1,-0.2116753472E+2,; 522 0.1163674359E+3};; 523 ; 524 double v = (x-x0)/xi;; 525 double xm2lan;; 526 if (v < -4.5); 527 {; 528 double u = std::exp(v+1);; 529 xm2lan = v*v-2*u*u*; 530 (v/u+a2[0]*v+a3[0]+(a2[1]*v+a3[1]+(a2[2]*v+a3[2]+; 531 (a2[3]*v+a3[3])*u)*u)*u)/; 532 (1+(a1[1]+(a1[2]+a1[3]*u)*u)*u);; 533 }; 534 else if (v < -2); 535 {; 536 xm2lan = (p1[0]+(p1[1]+(p1[2]+(p1[3]+p1[4]*v)*v)*v)*v)/; 537 (q1[0]+(q1[1]+(q1[2]+(q1[3]+q1[4]*v)*v)*v)*v);; 538 }; 539 else if (v < 2); 540 {; 541 xm2lan = (p2[0]+(p2[1]+(p2[2]+(p2[3]+p2[4]*v)*v)*v)*v)/; 542 (q2[0]+(q2[1]+(q2[2]+(q2[3]+q2[4]*v)*v)*v)*v);; 543 }; 544 else if (v < 5); 545 {; 546 double u = 1/v;; 547 xm2lan = v*(p3[0]+(p3[1]+(p3[2]+p3[3]*u)*u)*u)/; 548 (q3[0]+(q3[1]+(q3[2]+q3[3]*u)*u)*u);; 549 }; 550 else if (v < 50); 551 {; 552 double u = 1/v;; 553 xm2lan = v*(p4[0]+(p4[1]+(p4[2]+(p4[3]+p4[4]*u)*u)*u)*u)/; 554 (q4[0]+(q4[1]+(q4[2]+(q4[3]+q4[4]*u)*u)*u)*u);; 555 }; 556 else if (v < 200); 557 {; 558 double u = 1/v;; 559 xm2lan = v*(p5[0]+(p5[1]+(p5[2]+p5[3]*u)*u)*u)/; 560 (q5[0]+(q5[1]+(q5[2]+q5[3]*u)*u)*u);; 561 }; 562 else; 563 {; 564 double u = v-v*std::log(v)/(v+1);; 565 v = 1/(u-u*(u+log(u)-v)/(u+1));; 566 u = -std::log(v);; 567 xm2lan = (1/v+u*u+a0[0]+a0[1]*u+(-u*u+a0[2]*u+a0[3]+; 568 (a0[4]*u*u+a0[5]*u+a0[6])*v)*v)/(1-(1-a0[4]*v)*v);; 569 }; 570 if (x0 == 0) return xm2lan*xi*xi;; 571 double xm1lan = ROOT::Math::landau_xm1(x, xi, x0);; 572 return xm2lan*xi*xi + (2*xm1lan-x0)*x0;; 573 }; 574 ; 575} // namespace Math; 576} // namespace ROOT; 577 ; 578 ; 579 ; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; Math.h; ProbFuncMathCore.h; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; M_PI#define M_PIDefinition Rotated.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html:18905,log,log,18905,doc/master/ProbFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html,3,['log'],['log']
Testability," -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetFeedback(TString& opt, TString& optfb, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:20092,assert,assert,20092,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['assert'],['assert']
Testability," -1111)MENU ; virtual voidTGraph::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGraph::SetPoint(Int_t i, Double_t x, Double_t y); virtual voidTGraphAsymmErrors::SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)MENU ; virtual voidTGraphAsymmErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); virtual voidTGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); virtual voidTGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); virtual voidTGraphAsymmErrors::SetPointEYhigh(Int_t i, Double_t eyh); virtual voidTGraphAsymmErrors::SetPointEYlow(Int_t i, Double_t eyl); voidsetRawEntries(Double_t n); virtual voidTGraph::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidRooPlotable::setYAxisLabel(const char* label); voidRooPlotable::setYAxisLimits(Double_t ymin, Double_t ymax); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidTGraph::Sort(Bool_t (*)(const TGraph*, Int_t, Int_t) greater = &TGraph::CompareX, Bool_t ascending = kTRUE, Int_t low = 0, Int_t high = -1111); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidRooPlotable::updateYAxisLimits(Double_t y); virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHist.html:15431,Test,TestBit,15431,root/html534/RooHist.html,https://root.cern,https://root.cern/root/html534/RooHist.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," . ; Contribute . ; Collaborate with Us . You are hereHome » Development » Git Primer Github ssh key. Using Github with ssh keys is preferred, as it's much easier to use. Here is how to set it up:; 1. Create an ssh key; Run; ssh-keygen -t rsa -b 4096 -C ""your_email@example.com"" -f ~/.ssh/github_id_rsa. The email address is for your convenience, it doesn't really matter what you put there; you can even use this to state the name of the computer that will use that key.; You can use a passphrase - but even without it's sufficiently safe, because only you have the secret key file! But please enabling Two Factor Authentication!; 2. Add the key to Github; Log in to https://github.com. In the top right corner, in a drop-down menu, click ""Settings"". Select ""SSH and GPG keys"" from the menu on the left. Click ""New SSH key"", add something as a title and copy the output of; cat ~/.ssh/github_id_rsa.pub. into the ""Key"" text box.; 3. Guide ssh to your key; Edit (or create) ~/.ssh/config and enter the following lines:; Host github.com; User git; PreferredAuthentications publickey; IdentityFile ~/.ssh/github_id_rsa. 4. Check; ssh -T git@github.com. should print; Hi UserName! You've successfully authenticated, but GitHub does not provide shell access. References. Create an ssh key; Add the key to Github; Check. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/github-ssh-key.html:3643,test,tests,3643,d/github-ssh-key.html,https://root.cern,https://root.cern/d/github-ssh-key.html,1,['test'],['tests']
Testability," . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 1. Extracting an object from a TFile. File can be local on your disk or remote accessible for instance through http:; root [0] TFile* file = TFile::Open(""http://someserver/somefile.root"");. You can list the objects inside the file using .ls:; root [1] .ls; TFile** hsimple.root Demo ROOT file with histograms; TFile* hsimple.root Demo ROOT file with histograms; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple. You can access objects inside the files by their names, either by using this name as a variable on the prompt:; root [2] hpx->Draw();. In regular code you should use TFile::GetObject():; root [3] TH1* readThis = 0;; root [4] file->GetObject(""hpx"", readThis);. Now let's try this out: get the TTree called ""MyTree"" from a file located at http://root.cern.ch/root/files/tutorials/mockupx.root Note that you don't need to download it with your browser: you just specify the http:// location as an argument to TFile::Open(). Once you have the TTree object, call Print() on it to see its structure.; . ‹ 0. Setting up ROOT; up; 2. Running code in ROOT ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/1-extracting-object-tfile.html:2793,mock,mockupx,2793,d/1-extracting-object-tfile.html,https://root.cern,https://root.cern/d/1-extracting-object-tfile.html,1,['mock'],['mockupx']
Testability," . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Support Guidelines for submitting a bug. Introduction; The RootTalk mailing list and forum can be used to pass information of general interest to the ROOT user community or to submit problems that you cannot solve with the information provided in the Documentation. Several thousands users read the list and forum and my provide you with solutions to your problem.; Only if you are convinced that your problem is a real bug of the ROOT software then follow the instructions on how to report a bug with JIRA.; When you submit a bug, please follow these guidelines:. If you submit a problem, always indicate your ROOT version number (e.g. 6.02.00, 5.34.22) and the platform you are running on (e.g. Ubuntu 14 gcc49, SLC6 clang35).; The bug title subject line should clearly identify the problem.; If you use a non recent version of ROOT, try to test your problem with newer version. If this is too difficult, consult the release and development notes to check if your problem has not already been solved.; Try to quickly search the internet and look in the forum if your problem has been already solved.; Try to share the maximum amount of information. A bug report which only says ""My macro crashes when running on kubuntu but on windows works"" is much less likely to be solved quickly than a complete message with a gdb stacktrace and a reproducer (see next item).; Send a minimal program or macro reproducing the problem. Make sure that your script can be executed directly. If it uses a data file, send the smallest possible data file as a mail attachment, or indicate how to get this file.; If for some reason it is not possible to share a minimal reproducer, try to make sure that your explanations are sufficient to speed up the whole fixing procedure. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; Us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guidelines-submitting-bug.html:2711,test,test,2711,d/guidelines-submitting-bug.html,https://root.cern,https://root.cern/d/guidelines-submitting-bug.html,1,['test'],['test']
Testability, . Definition at line 183 of file TGNumberEntry.h. ◆ Streamer(). void TGNumberEntry::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TGNumberEntry::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 273 of file TGNumberEntry.h. ◆ ValueChanged(). void TGNumberEntry::ValueChanged ; (; Long_t ; val). virtual . Emit ValueChanged(Long_t) signal. ; This signal is emitted when fButtonToNum is false. The val has the following meaning: val % 100 is the step size val % 10000 / 100 != 0 indicates log step val / 10000 != 0 indicates button down ; Definition at line 2165 of file TGNumberEntry.cxx. ◆ ValueSet(). void TGNumberEntry::ValueSet ; (; Long_t ; val). virtual . Emit ValueSet(Long_t) signal. ; This signal is emitted when the number entry value is changed. The val has the following meaning: val % 100 is the step size val % 10000 / 100 != 0 indicates log step val / 10000 != 0 indicates button down ; Definition at line 2177 of file TGNumberEntry.cxx. Member Data Documentation. ◆ fButtonDown. TGButton* TGNumberEntry::fButtonDown. protected . Button for decreasing value. ; Definition at line 165 of file TGNumberEntry.h. ◆ fButtonToNum. Bool_t TGNumberEntry::fButtonToNum. protected . Send button messages to parent rather than number entry field. ; Definition at line 166 of file TGNumberEntry.h. ◆ fButtonUp. TGButton* TGNumberEntry::fButtonUp. protected . Button for increasing value. ; Definition at line 164 of file TGNumberEntry.h. ◆ fNumAttr. EAttribute TGNumberEntry::fNumAttr. private . Definition at line 152 of file TGNumberEntry.h. ◆ fNumericEntry. TGNumberEntryField* TGNumberEntry::fNumericEntry. protected . Number text entry field. ; Definition at line 163 of file TGNumberEntry.h. ◆ fNumLimits. ELimit TGNumberEntry::fNumLimits. private . Definition at line 153 of file TGNumberEntry.h. ◆ fNumStyle. EStyle TGNumberEntry::fNumStyle.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntry.html:47546,log,log,47546,doc/master/classTGNumberEntry.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntry.html,1,['log'],['log']
Testability," . Definition at line 52 of file RooNumConvolution.h. ◆ redirectServersHook(). bool RooNumConvolution::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. ; Reimplemented from RooAbsReal.; Definition at line 262 of file RooNumConvolution.cxx. ◆ setCallProfiling(). void RooNumConvolution::setCallProfiling ; (; bool ; flag, . Int_t ; nbinX = 40, . Int_t ; nbinCall = 40, . Int_t ; nCallHigh = 1000 . ). Activate call profile if flag is set to true. ; A 2-D histogram is kept that stores the required number of function calls versus the value of x, the convolution variable; All clones of RooNumConvolution objects will keep logging to the histogram of the original class so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating are all logged in a single place.; Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor; Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram ; Definition at line 324 of file RooNumConvolution.cxx. ◆ setCallWarning(). void RooNumConvolution::setCallWarning ; (; Int_t ; threshold = 2000). Activate warning messages if number of function calls needed for evaluation of convolution integral exceeds given threshold. ; Definition at line 302 of file RooNumConvolution.cxx. ◆ setConvolutionWindow(). void RooNumConvolution::setConvolutionWindow ; (; RooAbsReal & ; centerParam, . RooAbsReal & ; widthParam, . double ; widthScaleFactor = 1 . ). Restrict convolution integral to finite range [ x - C - S*W, x - C + S*W ] where x is current value of convolution variablem, C = centerParam, W=widthParam and S = widthScaleFactor Inputs centerParam and withParam can be function expressions (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:69653,log,logged,69653,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['log'],['logged']
Testability," . Definition at line 90 of file Rule.h. ◆ SetSSBNeve(). void TMVA::Rule::SetSSBNeve ; (; Double_t ; v). inline . Definition at line 93 of file Rule.h. ◆ SetSupport(). void TMVA::Rule::SetSupport ; (; Double_t ; v). inline . Definition at line 87 of file Rule.h. Friends And Related Symbol Documentation. ◆ operator<<. std::ostream & operator<< ; (; std::ostream & ; os, . const Rule & ; rule . ). friend . Member Data Documentation. ◆ fCoefficient. Double_t TMVA::Rule::fCoefficient. private . rule coeff. a(k) ; Definition at line 176 of file Rule.h. ◆ fCut. RuleCut* TMVA::Rule::fCut. private . all cuts associated with the rule ; Definition at line 172 of file Rule.h. ◆ fImportance. Double_t TMVA::Rule::fImportance. private . importance of rule ; Definition at line 177 of file Rule.h. ◆ fImportanceRef. Double_t TMVA::Rule::fImportanceRef. private . importance ref ; Definition at line 178 of file Rule.h. ◆ fLogger. MsgLogger* TMVA::Rule::fLogger. mutableprivate . ! message logger ; Definition at line 183 of file Rule.h. ◆ fNorm. Double_t TMVA::Rule::fNorm. private . normalization - usually 1.0/t(k) ; Definition at line 173 of file Rule.h. ◆ fRuleEnsemble. const RuleEnsemble* TMVA::Rule::fRuleEnsemble. private . pointer to parent RuleEnsemble ; Definition at line 179 of file Rule.h. ◆ fSigma. Double_t TMVA::Rule::fSigma. private . t(k) = sqrt(s*(1-s)) ; Definition at line 175 of file Rule.h. ◆ fSSB. Double_t TMVA::Rule::fSSB. private . S/(S+B) for rule. ; Definition at line 180 of file Rule.h. ◆ fSSBNeve. Double_t TMVA::Rule::fSSBNeve. private . N(events) reaching the last node in reevaluation. ; Definition at line 181 of file Rule.h. ◆ fSupport. Double_t TMVA::Rule::fSupport. private . s(k) ; Definition at line 174 of file Rule.h. Libraries for TMVA::Rule:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Rule.h; tmva/tmva/src/Rule.cxx. TMVARule. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:42 (GVA ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Rule.html:10890,log,logger,10890,doc/master/classTMVA_1_1Rule.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Rule.html,1,['log'],['logger']
Testability," . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3408 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:120416,log,logged,120416,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['log'],['logged']
Testability," . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121746,log,logged,121746,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['log'],['logged']
Testability," . error value of b parameter for 1D ridges in y direction ; Definition at line 85 of file TSpectrum2Fit.h. ◆ fByInit. Double_t TSpectrum2Fit::fByInit. protected . initial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references ; Definition at line 83 of file TSpectrum2Fit.h. ◆ fChi. Double_t TSpectrum2Fit::fChi. protected . here the fitting functions return resulting chi square ; Definition at line 29 of file TSpectrum2Fit.h. ◆ fFitTaylor. Int_t TSpectrum2Fit::fFitTaylor. protected . order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; Definition at line 27 of file TSpectrum2Fit.h. ◆ fFixA0. Bool_t TSpectrum2Fit::fFixA0. protected . logical value of a0 parameter, which allows to fix the parameter (not to fit). ; Definition at line 113 of file TSpectrum2Fit.h. ◆ fFixAmp. Bool_t* TSpectrum2Fit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 99 of file TSpectrum2Fit.h. ◆ fFixAmpX1. Bool_t* TSpectrum2Fit::fFixAmpX1. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional ; Definition at line 100 of file TSpectrum2Fit.h. ◆ fFixAmpY1. Bool_t* TSpectrum2Fit::fFixAmpY1. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ; Definition at line 101 of file TSpectrum2Fit.h. ◆ fFixAx. Bool_t TSpectrum2Fit::fFixAx. protected . logical value of ax parameter, which allows to fix the parameter (not to fit). ; Definition at line 114 of file TSpectrum2Fit.h. ◆ fFixAy. Bool_t TSpectrum2Fit::fFixAy. protected . logical value of ay parameter, which allows to fix the parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:83048,log,logical,83048,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability," ...Definition TGeoMedium.h:23; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoNode::GetVolumeTGeoVolume * GetVolume() constDefinition TGeoNode.h:99; TGeoRotationClass describing rotations.Definition TGeoMatrix.h:168; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideset visibility of this volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::FindNodeTGeoNode * FindNode(const char *name) constsearch a daughter inside the list of nodesDefinition TGeoVolume.cxx:1721; eveMngROOT::Experimental::REveManager * eveMngDefinition collection_proxies.C:59; eveGeoBrowservoid eveGeoBrowser(bool showDet=true)Definition eveGeoBrowser.C:169; getNodeFromPathTGeoNode * getNodeFromPath(TGeoNode *top, std::string path)Definition eveGeoBrowser.C:9; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47; testCmsGeoTGeoNode * testCmsGeo()Definition eveGeoBrowser.C:20; nconst Int_t nDefinition legend1.C:16; ROOT::ExperimentalDefinition RDirectory.hxx:30. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/eveGeoBrowser_8C_source.html:13456,test,testCmsGeoTGeoNode,13456,doc/master/eveGeoBrowser_8C_source.html,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html,2,['test'],"['testCmsGeo', 'testCmsGeoTGeoNode']"
Testability," // can choose z0 = 0 if line not parallel to x-y plane and z1 = 1;; x = p[0] + p[1]*t;; y = p[2] + p[3]*t;; z = t;; }; ; ; bool first = true;; ; // function Object to be minimized; struct SumDistance2 {; // the TGraph is a data member of the object; TGraph2D *fGraph;; ; SumDistance2(TGraph2D *g) : fGraph(g) {}; ; // calculate distance line-point; double distance2(double x,double y,double z, const double *p) {; // distance line point is D= | (xp-x0) cross ux |; // where ux is direction of line and x0 is a point in the line (like t = 0); XYZVector xp(x,y,z);; XYZVector x0(p[0], p[2], 0. );; XYZVector x1(p[0] + p[1], p[2] + p[3], 1. );; XYZVector u = (x1-x0).Unit();; double d2 = ((xp-x0).Cross(u)).Mag2();; return d2;; }; ; // implementation of the function to be minimized; double operator() (const double *par) {; assert(fGraph != nullptr);; double * x = fGraph->GetX();; double * y = fGraph->GetY();; double * z = fGraph->GetZ();; int npoints = fGraph->GetN();; double sum = 0;; for (int i = 0; i < npoints; ++i) {; double d = distance2(x[i],y[i],z[i],par);; sum += d;; }; if (first) {; std::cout << ""Total Initial distance square = "" << sum << std::endl;; }; first = false;; return sum;; }; ; };; ; int line3Dfit(); {; gStyle->SetOptStat(0);; gStyle->SetOptFit();; ; ; //double e = 0.1;; int nd = 10000;; ; ; // double xmin = 0; double ymin = 0;; // double xmax = 10; double ymax = 10;; ; TGraph2D * gr = new TGraph2D();; ; // Fill the 2D graph; double p0[4] = {10,20,1,2};; ; // generate graph with the 3d points; for (int N=0; N<nd; N++) {; double x,y,z = 0;; // Generate a random number; double t = gRandom->Uniform(0,10);; line(t,p0,x,y,z);; double err = 1;; // do a Gaussian smearing around the points in all coordinates; x += gRandom->Gaus(0,err);; y += gRandom->Gaus(0,err);; z += gRandom->Gaus(0,err);; gr->SetPoint(N,x,y,z);; //dt->SetPointError(N,0,0,err);; }; // fit the graph now; ; ROOT::Fit::Fitter fitter;; ; ; // make the functor objet; SumDistance2 sdist(gr);; ROOT::Math:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/line3Dfit_8C.html:2044,assert,assert,2044,doc/master/line3Dfit_8C.html,https://root.cern,https://root.cern/doc/master/line3Dfit_8C.html,1,['assert'],['assert']
Testability," // create a TChain instead of a TTree; TChain *chain = new TChain(""EventTree"", ""Event Data Chain"");; // add our file; chain->Add(""http://root.cern/files/introtutorials/eventdata.root"");; // tell the chain that we want to use PROOF; chain->SetProof();; // run the selector; chain->Process(""ProofEventSelector.C+"");. For the functions used, see the documentation of the TChain constructor and TChain::Add().; You need to register the histogram in your selector's output list, by passing it to GetOutputList()->Add(hist), ideally right after you have created it with new TH1F(...). If you don't add it to the output list, PROOF cannot know that this histogram is the result of the analysis.; Note: If the network is good, try to take this file instead: http://root.cern/files/introtutorials/eventdata-10k.root, it contains more events.; Then the TChain::Process() call is the same than before, but it will now use all your CPUs!; . ‹ Histogramming in a Selector; up; The End ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-tselector-proof.html:4406,test,tests,4406,d/using-tselector-proof.html,https://root.cern,https://root.cern/d/using-tselector-proof.html,1,['test'],['tests']
Testability," // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 Numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:67199,test,testingEventVector,67199,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testingEventVector']
Testability," /// assignment operator; 113 BinData & operator= ( const BinData & rhs );; 114 ; 115 ; 116 /**; 117 Preallocate a data set with given size, dimension and error type.; 118 If the data set already exists, `newPoints` are appended to the existing data set.; 119 (i.e., if the data exists Initialize() is equivalent to a `resize( NPoints() + maxpoints)`).; 120 Initialize() and Append() are equivalent.; 121 */; 122 void Initialize( unsigned int newPoints, unsigned int dim = 1, ErrorType err = kValueError ){; 123 Append(newPoints,dim,err);; 124 }; 125 ; 126 /// Equivalent to Initialize(); 127 void Append( unsigned int newPoints, unsigned int dim = 1, ErrorType err = kValueError );; 128 ; 129 ; 130 ; 131 /**; 132 flag to control if data provides error on the coordinates; 133 */; 134 bool HaveCoordErrors() const {; 135 assert ( fErrorType == kNoError ||; 136 fErrorType == kValueError ||; 137 fErrorType == kCoordError ||; 138 fErrorType == kAsymError );; 139 ; 140 return fErrorType == kCoordError;; 141 }; 142 ; 143 /**; 144 flag to control if data provides asymmetric errors on the value; 145 */; 146 bool HaveAsymErrors() const {; 147 assert ( fErrorType == kNoError ||; 148 fErrorType == kValueError ||; 149 fErrorType == kCoordError ||; 150 fErrorType == kAsymError );; 151 ; 152 return fErrorType == kAsymError;; 153 }; 154 ; 155 ; 156 /**; 157 apply a Log transformation of the data values; 158 can be used for example when fitting an exponential or gaussian; 159 Transform the data in place need to copy if want to preserve original data; 160 The data sets must not contain negative values. IN case it does,; 161 an empty data set is returned; 162 */; 163 BinData & LogTransform();; 164 ; 165 ; 166 /**; 167 add one dim data with only coordinate and values; 168 */; 169 void Add( double x, double y );; 170 ; 171 /**; 172 add one dim data with no error in the coordinate (x); 173 in this case store the inverse of the error in the value (y); 174 */; 175 void Add( double x, double y, doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:4791,assert,assert,4791,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,2,['assert'],['assert']
Testability," //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;�����������������",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:48935,log,logical,48935,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,10,['log'],['logical']
Testability," //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:48179,log,logical,48179,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,10,['log'],['logical']
Testability," /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:48825,log,logger,48825,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability, 0); Analyze a sub-expression in one formula*-*-; *-* =======================================; -; *-* Expressions in one formula are recursively analyzed.; *-* Result of analysis is stored in the object tables.; -; *-* Table of function codes and errors; *-* ==================================; -; *-* * functions :; -; *-* + 1 pow 20; *-* - 2 sq 21; *-* * 3 sqrt 22; *-* / 4 strstr 23; *-* % 5 min 24; *-* max 25; *-* log 30; *-* cos 10 exp 31; *-* sin 11 log10 32; *-* tan 12; *-* acos 13 abs 41; *-* asin 14 sign 42; *-* atan 15 int 43; *-* atan2 16; *-* fmod 17 rndm 50; -; *-* cosh 70 acosh 73; *-* sinh 71 asinh 74; *-* tanh 72 atanh 75; -; *-* expo 100 gaus 110 gausn (see note below); *-* expo(0) 100 0 gaus(0) 110 0 gausn(0); *-* expo(1) 100 1 gaus(1) 110 1 gausn(1); *-* xexpo 100 x xgaus 110 x xgausn; *-* yexpo 101 x ygaus 111 x ygausn; *-* zexpo 102 x zgaus 112 x zgausn; *-* xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFormula.html:15993,log,log,15993,root/html528/TFormula.html,https://root.cern,https://root.cern/root/html528/TFormula.html,4,['log'],['log']
Testability," 0); user inserts target in data set info. void AddSpectator(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0); user inserts target in data set info. TMVA::DataSetInfo& DefaultDataSetInfo(); default creation. void SetInputVariables(vector<TString>* theVariables); fill input variables in data set. void SetSignalWeightExpression(const TString& variable). void SetBackgroundWeightExpression(const TString& variable). void SetWeightExpression(const TString& variable, const TString& className = """"); Log() << kWarning << DefaultDataSetInfo().GetNClasses() /*fClasses.size()*/ << Endl;. void SetCut(const TString& cut, const TString& className = """"). void SetCut(const TCut& cut, const TString& className = """"). void AddCut(const TString& cut, const TString& className = """"). void AddCut(const TCut& cut, const TString& className = """"). void PrepareTrainingAndTestTree(const TCut& cut, Int_t NsigTrain, Int_t NbkgTrain, Int_t NsigTest, Int_t NbkgTest, const TString& otherOpt = ""SplitMode=Random:!V""); prepare the training and test trees. void PrepareTrainingAndTestTree(const TCut& cut, Int_t Ntrain, Int_t Ntest = -1); prepare the training and test trees; kept for backward compatibility. void PrepareTrainingAndTestTree(const TCut& cut, const TString& splitOpt); prepare the training and test trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Factory.html:18063,test,test,18063,root/html528/TMVA__Factory.html,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html,6,['test'],['test']
Testability," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual Double_tCalcNLL(Double_t xL); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual Bool_tShouldTakeStep(Double_t d). Data Members; public:. enum FunctionSign { kNegative; kPositive; kSignUnset; };; enum FunctionType { kRegular; kLog; kTypeUnset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooAbsReal*fFunctionfunction that will generate likelihood values; Int_tfNumBurnInStepsnumber of iterations to discard as burn-in, starting from the first; Int_tfNumItersnumber of iterations to run metropolis algorithm; RooArgSet*fParametersRooRealVars that define parameter space; RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; RooStats::MetropolisHastings::FunctionSignfSignwhether the likelihood is negative (like NLL) or positive; RooStats::MetropolisHastings::FunctionTypefTypewhether the likelihood is on a regular, log, (or other) scale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MetropolisHastings(); default constructor. MetropolisHastings(RooAbsReal& function, RooArgSet& paramsOfInterest, RooStats::ProposalFunction& proposalFunction, Int_t numIters). MarkovChain* ConstructChain(). Bool_t ShouldTakeStep(Double_t d). Double_t CalcNLL(Double_t xL). MetropolisHastings(); default constructor. virtual ~MetropolisHastings(); {}. void SetParameters(RooArgSet& set); specify the parameters of interest in the interval; kbelasco: should clone before removing constant parameters?. { fParameters = &set; RemoveConstantParameters(fParameters); }. void SetProposalFunction(RooStats::ProposalFunction& prop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MetropolisHastings.html:8039,log,log,8039,root/html526/RooStats__MetropolisHastings.html,https://root.cern,https://root.cern/root/html526/RooStats__MetropolisHastings.html,3,['log'],['log']
Testability," 0); virtual voidSetImage(const TVectorD& imageData, UInt_t width, TImagePalette* palette = 0); virtual voidSetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0); virtual Bool_tSetImageBuffer(char** buffer, TImage::EImageFileTypes type = TImage::kPng); virtual voidTAttImage::SetImageCompression(UInt_t lcompression)MENU ; virtual voidTAttImage::SetImageQuality(TAttImage::EImageQuality lquality); Bool_tSetJpegDpi(const char* name, UInt_t dpi = 72); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPalette(const TImagePalette* palette); virtual voidSetPaletteEnabled(Bool_t on = kTRUE)TOGGLE ; virtual voidSetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidSlice(UInt_t xStart, UInt_t xEnd, UInt_t yStart, UInt_t yEnd, UInt_t toWidth, UInt_t toHeight)MENU ; virtual voidStartPaletteEditor()MENU ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTile(UInt_t width, UInt_t height)MENU ; virtual voidUnZoom()MENU ; virtual voidTObject::UseCurrentStyle(); virtual Double_t*Vectorize(UInt_t max_colors = 256, UInt_t dither = 4, Int_t opaque_threshold = 1); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown)MENU ; virtual voidZoom(UInt_t offX, UInt_t offY, UInt_t width, UInt_t height)MENU .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TASImage.html:13779,Test,TestBit,13779,root/html534/TASImage.html,https://root.cern,https://root.cern/root/html534/TASImage.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," 0, Int_t opt = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:20044,log,loglevel,20044,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,3,['log'],['loglevel']
Testability," 1 1 52 52 52; TClassTable 1 1 12 12 12; TObjectTable 1 1 12 12 12; ----------------------------------------------------------------------------; Total: 10225 10219 5976 506988 506340; ============================================================================; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAxisClass to manage histogram axis.Definition TAxis.h:31; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBenchmarkThis class is a ROOT utility to help benchmarking applications.Definition TBenchmark.h:29; TBoxCreate a Box.Definition TBox.h:22; TCanvasThe Canvas class.Definition TCanvas.h:23; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TColorThe color creation and management class.Definition TColor.h:21; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileHandlerDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectTable.html:3282,benchmark,benchmarking,3282,doc/master/classTObjectTable.html,https://root.cern,https://root.cern/doc/master/classTObjectTable.html,1,['benchmark'],['benchmarking']
Testability," 1); virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAngle(Float_t angle = 60)MENU ; virtual voidSetArrowSize(Float_t arrowsize = 0.05)MENU ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidSetDefaultAngle(Float_t Angle); static voidSetDefaultArrowSize(Float_t ArrowSize); static voidSetDefaultOption(Option_t* Option); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTLine::SetHorizontal(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOption(Option_t* option = "">""); virtual voidTObject::SetUniqueID(UInt_t uid); voidTLine::SetVertical(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTLine::SetX1(Double_t x1); virtual voidTLine::SetX2(Double_t x2); virtual voidTLine::SetY1(Double_t y1); virtual voidTLine::SetY2(Double_t y2); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TArrow.html:7983,Test,TestBit,7983,root/html532/TArrow.html,https://root.cern,https://root.cern/root/html532/TArrow.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTVirtualPS::SetStream(ofstream* os); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidSetTextColor(Color_t cindex = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTVirtualPS::SetType(Int_t = -111); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidText(Double_t x, Double_t y, const char* string); virtual voidText(Double_t x, Double_t y, const wchar_t* string); voidTextNDC(Double_t u, Double_t v, const char* string); voidTextNDC(Double_t u, Double_t v, const wchar_t* string); virtual voidTObject::UseCurrentStyle(); Int_tUtoPS(Double_t u); Int_tVtoPS(Double_t v); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTVirtualPS::WriteInteger(Int_t i, Bool_t space = kTRUE); virtual voidTVirtualPS::WriteReal(Float_t r, Bool_t space = kTRUE); Int_tXtoPS(Double_t x); Int_tYtoPS(Double_t y); voidZone().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPostScript.html:16217,Test,TestBit,16217,root/html534/TPostScript.html,https://root.cern,https://root.cern/root/html534/TPostScript.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveLineEditor(const TGWindow* p = 0, Int_t width = 170, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveLineEditor.html:14638,Test,TestBit,14638,root/html602/TEveLineEditor.html,https://root.cern,https://root.cern/root/html602/TEveLineEditor.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveTextEditor(const TGWindow* p = 0, Int_t width = 170, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTextEditor.html:14720,Test,TestBit,14720,root/html602/TEveTextEditor.html,https://root.cern,https://root.cern/root/html602/TEveTextEditor.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," 1); voidSetTitleFont(Style_t font = 62, Option_t* axis = ""X""); voidSetTitleFontSize(Float_t size = 0); voidSetTitleH(Float_t h = 0); voidSetTitleOffset(Float_t offset = 1, Option_t* axis = ""X""); voidSetTitlePS(const char* pstitle); voidSetTitleSize(Float_t size = 0.02, Option_t* axis = ""X""); voidSetTitleStyle(Style_t style = 1001); voidSetTitleTextColor(Color_t color = 1); voidSetTitleW(Float_t w = 0); voidSetTitleX(Float_t x = 0); voidSetTitleXOffset(Float_t offset = 1); voidSetTitleXSize(Float_t size = 0.02); voidSetTitleY(Float_t y = 0.985); voidSetTitleYOffset(Float_t offset = 1); voidSetTitleYSize(Float_t size = 0.02); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidToggleEditor(); voidToggleEventStatus(); voidToggleToolBar(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EPaperSize { kA4; kUSLetter; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStyle.html:16290,Test,TestBit,16290,root/html534/TStyle.html,https://root.cern,https://root.cern/root/html534/TStyle.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberOfDivisions(Int_t p); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPCON.html:7107,Test,TestBit,7107,root/html534/TPCON.html,https://root.cern,https://root.cern/root/html534/TPCON.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," 1.0);; dataloader->AddBackgroundTree(bkgTree, 1.0);; ; // The CV mechanism of TMVA splits up the training set into several folds.; // The test set is currently left unused. The `nTest_ClassName=1` assigns; // one event to the test set for each class and puts the rest in the; // training set. A value of 0 is a special value and would split the; // datasets 50 / 50.; dataloader->PrepareTrainingAndTestTree("""", """",; ""nTest_Signal=1""; "":nTest_Background=1""; "":SplitMode=Random""; "":NormMode=NumEvents""; "":!V"");; ; // --------------------------------------------------------------------------; ; //; // This sets up a CrossValidation class (which wraps a TMVA::Factory; // internally) for 2-fold cross validation.; //; // The split type can be ""Random"", ""RandomStratified"" or ""Deterministic"".; // For the last option, check the comment below. Random splitting randomises; // the order of events and distributes events as evenly as possible.; // RandomStratified applies the same logic but distributes events within a; // class as evenly as possible over the folds.; //; UInt_t numFolds = 2;; TString analysisType = ""Classification"";; ; TString splitType = (useRandomSplitting) ? ""Random"" : ""Deterministic"";; ; //; // One can also use a custom splitting function for producing the folds.; // The example uses a dataset spectator `eventID`.; //; // The idea here is that eventID should be an event number that is integral,; // random and independent of the data, generated only once. This last; // property ensures that if a calibration is changed the same event will; // still be assigned the same fold.; //; // This can be used to use the cross validated classifiers in application,; // a technique that can simplify statistical analysis.; //; // If you want to run TMVACrossValidationApplication, make sure you have; // run this tutorial with Deterministic splitting type, i.e.; // with the option useRandomSPlitting = false; //; ; TString splitExpr = (!useRandomSplitting) ? ""int(fabs([eventID]))%int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:22388,log,logic,22388,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['log'],['logic']
Testability, 1.0078 [ -4.5469 4.5058 ]; : var4: 0.65748 0.95864 [ -4.0893 3.7760 ]; : -----------------------------------------------------------; <WARNING> : You have asked for histogram EFF_BVSS_TR which does not seem to exist in *Results* .. better don't use it ; TFHandler_CutsD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; TFHandler_CutsD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.14555 1.0166 [ -5.5736 5.0206 ]; : myvar2: -0.093417 1.0353 [ -3.8442 3.7856 ]; : var3: -0.096857 1.0078 [ -4.5469 4.5058 ]; : var4: 0.65748 0.95864 [ -4.0893 3.7760 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: Likelihood; : ; Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: LikelihoodPCA; : ; TFHandler_LikelihoodPCA : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 1.1147 2.2628 [ -12.508 10.719 ]; : myvar2: -0.25554 1.1225 [ -4.1578 3.8995 ]; : var3: -0.19401 0.58225 [ -2.2950 1.8880 ]; : var4: -0.32038 0.33412 [ -1.3929 0.88819 ]; : -----------------------------------------------------------; LikelihoodPCA : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_Li,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:70683,test,test,70683,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['test']
Testability, 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: LikelihoodPCA; : ; TFHandler_LikelihoodPCA : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 1.1147 2.2628 [ -12.508 10.719 ]; : myvar2: -0.25554 1.1225 [ -4.1578 3.8995 ]; : var3: -0.19401 0.58225 [ -2.2950 1.8880 ]; : var4: -0.32038 0.33412 [ -1.3929 0.88819 ]; : -----------------------------------------------------------; LikelihoodPCA : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_LikelihoodPCA : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 1.1147 2.2628 [ -12.508 10.719 ]; : myvar2: -0.25554 1.1225 [ -4.1578 3.8995 ]; : var3: -0.19401 0.58225 [ -2.2950 1.8880 ]; : var4: -0.32038 0.33412 [ -1.3929 0.88819 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: PDERS; : ; PDERS : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_PDERS : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: PDEFoam; : ; PDEFoam : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: KNN; : ; KNN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:72059,test,test,72059,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['test']
Testability," 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:17938,test,testing,17938,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['testing']
Testability," 1014 // Perform minimization steps for a full epoch.; 1015 trainingData.Shuffle();; 1016 for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1017 batches.clear();; 1018 for (size_t j = 0; j < nThreads; j++) {; 1019 batches.reserve(nThreads);; 1020 batches.push_back(trainingData.GetBatch());; 1021 }; 1022 if (settings.momentum > 0.0) {; 1023 minimizer.StepMomentum(net, nets, batches, settings.momentum);; 1024 } else {; 1025 minimizer.Step(net, nets, batches);; 1026 }; 1027 }; 1028 ; 1029 if ((stepCount % minimizer.GetTestInterval()) == 0) {; 1030 ; 1031 // Compute test error.; 1032 Double_t testError = 0.0;; 1033 for (auto batch : testData) {; 1034 auto inputMatrix = batch.GetInput();; 1035 auto outputMatrix = batch.GetOutput();; 1036 testError += testNet.Loss(inputMatrix, outputMatrix);; 1037 }; 1038 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1039 ; 1040 //Log the loss value; 1041 fTrainHistory.AddValue(""testError"",stepCount,testError);; 1042 ; 1043 end = std::chrono::system_clock::now();; 1044 ; 1045 // Compute training error.; 1046 Double_t trainingError = 0.0;; 1047 for (auto batch : trainingData) {; 1048 auto inputMatrix = batch.GetInput();; 1049 auto outputMatrix = batch.GetOutput();; 1050 trainingError += net.Loss(inputMatrix, outputMatrix);; 1051 }; 1052 trainingError /= (Double_t) (nTrainingSamples / settings.batchSize);; 1053 //Log the loss value; 1054 fTrainHistory.AddValue(""trainingError"",stepCount,trainingError);; 1055 ; 1056 // Compute numerical throughput.; 1057 std::chrono::duration<double> elapsed_seconds = end - start;; 1058 double seconds = elapsed_seconds.count();; 1059 double nFlops = (double) (settings.testInterval * batchesInEpoch);; 1060 nFlops *= net.GetNFlops() * 1e-9;; 1061 ; 1062 converged = minimizer.HasConverged(testError);; 1063 start = std::chrono::system_clock::now();; 1064 ; 1065 if (fInteractive) {; 1066 fInteractive->AddPoint(stepCount, trainingError, testError);; 1067 fIPyCurrentIter = 100.0 * minimizer.Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:37228,test,testError,37228,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,2,['test'],['testError']
Testability," 104/*; 105 Independent implementation of MD5 (RFC 1321).; 106 ; 107 This code implements the MD5 Algorithm defined in RFC 1321, whose; 108 text is available at; 109 http://www.ietf.org/rfc/rfc1321.txt; 110 The code is derived from the text of the RFC, including the test suite; 111 (section A.5) but excluding the rest of Appendix A. It does not include; 112 any code or documentation that is identified in the RFC as being; 113 copyrighted.; 114 ; 115 The original and principal author of md5.c is L. Peter Deutsch; 116 <ghost@aladdin.com>. Other authors are noted in the change history; 117 that follows (in reverse chronological order):; 118 ; 119 2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order; 120 either statically or dynamically; added missing #include <string.h>; 121 in library.; 122 2002-03-11 lpd Corrected argument list for main(), and added int return; 123 type, in test program and T value program.; 124 2002-02-21 lpd Added missing #include <stdio.h> in test program.; 125 2000-07-03 lpd Patched to eliminate warnings about ""constant is; 126 unsigned in ANSI C, signed in traditional""; made test program; 127 self-checking.; 128 1999-11-04 lpd Edited comments slightly for automatic TOC extraction.; 129 1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).; 130 1999-05-03 lpd Original version.; 131 */; 132 ; 133#if !defined(MD5_STATIC); 134#include <stdint.h>; 135#include <string.h>; 136#endif; 137 ; 138#undef BYTE_ORDER /* 1 = big-endian, -1 = little-endian, 0 = unknown */; 139#if defined(ARCH_IS_BIG_ENDIAN); 140#define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1); 141#else; 142#define BYTE_ORDER (0); 143#endif; 144 ; 145#define T_MASK ((md5_word_t)~0); 146#define T1 /* 0xd76aa478 */ (T_MASK ^ 0x28955b87); 147#define T2 /* 0xe8c7b756 */ (T_MASK ^ 0x173848a9); 148#define T3 (0x242070db); 149#define T4 /* 0xc1bdceee */ (T_MASK ^ 0x3e423111); 150#define T5 /* 0xf57c0faf */ (T_MASK ^ 0x0a83f050); 151#define T6 (0x4787c62a); 152#defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:5183,test,test,5183,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['test'],['test']
Testability," 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:580850,test,test,580850,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability," 1183 You should update the version to ClassDef(%s,%d).\n\; 1184 Do not try to write objects with the current class definition,\n\; 1185 the files will not be readable.\n"", GetName(), file->GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1186 } else {; 1187 Warning(""BuildCheck"", ""\n\; 1188 The StreamerInfo of class %s \n\; 1189 has the same version (=%d) as the active class but a different checksum.\n\; 1190 You should update the version to ClassDef(%s,%d).\n\; 1191 Do not try to write objects with the current class definition,\n\; 1192 the files will not be readable.\n"", GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1193 }; 1194 CompareContent(fClass,0,kTRUE,kTRUE,file);; 1195 fClass->SetBit(TClass::kWarned);; 1196 }; 1197 } else {; 1198 if (!fClass->IsVersioned()) {; 1199 Fatal(""BuildCheck"", ""\n\; 1200 The StreamerInfo of unversioned class %s \n\; 1201 has the same version (=%d) as the active class but an old checksum.\n\; 1202 This should not happen. An assert will follow.\n"", GetName(), fClassVersion);; 1203 }; 1204 }; 1205 }; 1206 if (!fClass->IsLoaded() && this->fOnFileClassVersion>1); 1207 {; 1208 ROOT::ResetClassVersion(fClass,(const char*)-1, this->fClassVersion);; 1209 }; 1210 }; 1211 // FIXME: This code can never execute because Build() calls; 1212 // TStreamerElement::Class()->IgnoreTObjectStreamer(); 1213 // so our bits are never saved to the file.; 1214 if (TestBit(kIgnoreTObjectStreamer)) {; 1215 fClass->IgnoreTObjectStreamer();; 1216 }; 1217 if ((fClassVersion < -1) || (fClassVersion > 65000)) {; 1218 printf(""ERROR reading TStreamerInfo: %s fClassVersion=%d\n"", GetName(), fClassVersion);; 1219 SetBit(kCanDelete);; 1220 fNumber = -1;; 1221 return;; 1222 }; 1223 ; 1224 if (!fClass->TestBit(TClass::kWarned); 1225 && fClass->GetState() >= TClass::kInterpreted; 1226 && GetCheckSum() != fClass->GetCheckSum(); 1227 && fClassVersion == fClass->GetClassVersion()) {; 1228 // We got here, thus we are a perfect alias for the current streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:46000,assert,assert,46000,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['assert'],['assert']
Testability," 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Peter Speckmayer <peter.speckmayer@cern.ch> - CERN, Switzerland *; 16 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 17 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 18 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 19 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 20 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 21 * *; 22 * Copyright (c) 2005-2011: *; 23 * CERN, Switzerland *; 24 * U. of Victoria, Canada *; 25 * MPI-K Heidelberg, Germany *; 26 * U. of Bonn, Germany *; 27 * *; 28 * Redistribution and use in source and binary forms, with or without *; 29 * modification, are permitted according to the terms listed in LICENSE *; 30 * (see tmva/doc/LICENSE) *; 31 **********************************************************************************/; 32 ; 33#ifndef ROOT_TMVA_MethodBase; 34#define ROOT_TMVA_MethodBase; 35 ; 36//////////////////////////////////////////////////////////////////////////; 37// //; 38// MethodBase //; 39// //; 40// Virtual base class for all TMVA method //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include <iosfwd>; 45#include <vector>; 46#include <map>; 47#include ""assert.h""; 48 ; 49#include ""TString.h""; 50 ; 51#include ""TMVA/IMethod.h""; 52#include ""TMVA/Configurable.h""; 53#include ""TMVA/Types.h""; 54#include ""TMVA/DataSet.h""; 55#include ""TMVA/Event.h""; 56#include ""TMVA/TransformationHandler.h""; 57#include <TMVA/Results.h>; 58#include ""TMVA/TrainingHistory.h""; 59 ; 60#include <TFile.h>; 61 ; 62class TGraph;; 63class TTree;; 64class TDirectory;; 65class TSpline;; 66class TH1F;; 67class TH1D;; 68class TMultiGraph;; 69 ; 70/*! \class TMVA::IPythonInteractive; 71\ingroup TMVA; 72 ; 73This class is needed by JsMVA, and it's a helper class for tracking errors during; 74the training in Jupyter notebook. It’s only ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:1973,assert,assert,1973,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['assert'],['assert']
Testability, 1217 of file MethodCuts.cxx. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodCuts::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . read coefficients from xml weight file ; Implements TMVA::MethodBase.; Definition at line 1327 of file MethodCuts.cxx. ◆ SetTestSignalEfficiency(). void TMVA::MethodCuts::SetTestSignalEfficiency ; (; Double_t ; effS). inline . Definition at line 116 of file MethodCuts.h. ◆ Streamer(). virtual void TMVA::MethodCuts::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodCuts::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 238 of file MethodCuts.h. ◆ TestClassification(). void TMVA::MethodCuts::TestClassification ; (; ). virtual . nothing to test ; Reimplemented from TMVA::MethodBase.; Definition at line 827 of file MethodCuts.cxx. ◆ Train(). void TMVA::MethodCuts::Train ; (; void ; ). virtual . training method: here the cuts are optimised for the training sample ; Implements TMVA::MethodBase.; Definition at line 578 of file MethodCuts.cxx. ◆ WriteMonitoringHistosToFile(). void TMVA::MethodCuts::WriteMonitoringHistosToFile ; (; void ; ); const. virtual . write histograms and PDFs to file for monitoring purposes ; Reimplemented from TMVA::MethodBase.; Definition at line 1411 of file MethodCuts.cxx. Member Data Documentation. ◆ fAllVarsI. TString* TMVA::MethodCuts::fAllVarsI. private . what to do with variables ; Definition at line 188 of file MethodCuts.h. ◆ fBinaryTreeB. BinarySearchTree* TMVA::MethodCuts::fBinaryTreeB. private . Definition at line 181 of file MethodCuts.h. ◆ fBinaryTreeS. BinarySearchTree* TMVA::MethodCuts::fBinaryTreeS. private . Definition at line 180 of file MethodCuts.h. ◆ fCutMax. Double_t** TMVA::MethodCuts::fCutMa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:47489,test,test,47489,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['test'],['test']
Testability," 1250 ; 1251 - `a = 0`; no anchor drawn; 1252 - `a = 1`; the anchors are drawn; 1253 ; 1254 - `p = 0`; no points drawn; 1255 - `p = 1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options for both candle and violin plots can be accessed by this; 1268mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; 1269meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; 1270vice versa, if you wish.; 1271 ; 1272Using a logarithmic x- or y-axis is possible for candle and violin charts.; 1273 ; 1274\since **ROOT version 6.11/01**; 1275 ; 1276a logarithmic z-axis is possible, too but will only affect violin charts of course.; 1277 ; 1278\anchor HP140a; 1279#### The CANDLE option; 1280 ; 1281<a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 1287 3. The median (M): 50% of the data points in D are less than M.; 1288 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 1289 5. The maximum value of the distribution D (top or right whisker).; 1290 ; 1291In this implementation a TH2 is considered as a collection of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:51818,log,logarithmic,51818,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logarithmic']
Testability," 13.2125; TH1.Print Name = TrainingHistory_PyKeras_'val_loss', Entries= 0, Total sum= 12.2158; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0107 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00276 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0472 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : ---------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:49552,test,testing,49552,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['test'],['testing']
Testability," 1418 }; 1419 // testing vector; 1420 itTarget = testingEventVector->begin() - 1;; 1421 // loop over source; 1422 for( itEvent = tmpEventVector[Types::kTesting].at(cls).begin(), itEventEnd = tmpEventVector[Types::kTesting].at(cls).end(); itEvent != itEventEnd; ++itEvent ){; 1423 // if( std::distance( itTarget, testingEventVector->end()) < Int_t(cls+1) ) {; 1424 if( ( testingEventVector->end() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 145",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65298,test,testingEventVector,65298,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['test'],['testingEventVector']
Testability," 147 kUseGeneticAlgorithm,; 148 kUseSimulatedAnnealing,; 149 kUseMinuit,; 150 kUseEventScan,; 151 kUseMonteCarloEvents };; 152 ; 153 // efficiency calculation method; 154 // - kUseEventSelection: computes efficiencies from given data sample; 155 // - kUsePDFs : creates smoothed PDFs from data samples, and; 156 // uses this to compute efficiencies; 157 enum EEffMethod { kUseEventSelection = 0,; 158 kUsePDFs };; 159 ; 160 // improve the Monte Carlo by providing some additional information; 161 enum EFitParameters { kNotEnforced = 0,; 162 kForceMin,; 163 kForceMax,; 164 kForceSmart };; 165 ; 166 // general; 167 TString fFitMethodS; ///< chosen fit method (string); 168 EFitMethodType fFitMethod; ///< chosen fit method; 169 TString fEffMethodS; ///< chosen efficiency calculation method (string); 170 EEffMethod fEffMethod; ///< chosen efficiency calculation method; 171 std::vector<EFitParameters>* fFitParams; ///< vector for series of fit methods; 172 Double_t fTestSignalEff; ///< used to test optimized signal efficiency; 173 Double_t fEffSMin; ///< used to test optimized signal efficiency; 174 Double_t fEffSMax; ///< used to test optimized signal efficiency; 175 Double_t* fCutRangeMin; ///< minimum of allowed cut range; 176 Double_t* fCutRangeMax; ///< maximum of allowed cut range; 177 std::vector<Interval*> fCutRange; ///< allowed ranges for cut optimisation; 178 ; 179 // for the use of the binary tree method; 180 BinarySearchTree* fBinaryTreeS;; 181 BinarySearchTree* fBinaryTreeB;; 182 ; 183 // MC method; 184 Double_t** fCutMin; ///< minimum requirement; 185 Double_t** fCutMax; ///< maximum requirement; 186 Double_t* fTmpCutMin; ///< temporary minimum requirement; 187 Double_t* fTmpCutMax; ///< temporary maximum requirement; 188 TString* fAllVarsI; ///< what to do with variables; 189 ; 190 // relevant for all methods; 191 Int_t fNpar; ///< number of parameters in fit (default: 2*Nvar); 192 Double_t fEffRef; ///< reference efficiency; 193 std::vector<Int_t>* fRangeSign; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:6415,test,test,6415,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['test'],['test']
Testability," 158#include ""RooParamBinning.h""; 159#include ""RooNumCdf.h""; 160#include ""RooFitResult.h""; 161#include ""RooNumGenConfig.h""; 162#include ""RooCachedReal.h""; 163#include ""RooRealIntegral.h""; 164#include ""RooWorkspace.h""; 165#include ""RooNaNPacker.h""; 166#include ""RooFitImplHelpers.h""; 167#include ""RooHelpers.h""; 168#include ""RooFormulaVar.h""; 169#include ""RooDerivative.h""; 170 ; 171#include ""ROOT/StringUtils.hxx""; 172#include ""TMath.h""; 173#include ""TPaveText.h""; 174#include ""TMatrixD.h""; 175#include ""TMatrixDSym.h""; 176 ; 177#include <algorithm>; 178#include <iostream>; 179#include <string>; 180#include <cmath>; 181#include <stdexcept>; 182 ; 183namespace {; 184 ; 185inline double getLog(double prob, RooAbsReal const *caller); 186{; 187 ; 188 if (prob < 0) {; 189 caller->logEvalError(""getLogVal() top-level p.d.f evaluates to a negative number"");; 190 return RooNaNPacker::packFloatIntoNaN(-prob);; 191 }; 192 ; 193 if (std::isinf(prob)) {; 194 oocoutW(caller, Eval) << ""RooAbsPdf::getLogVal("" << caller->GetName(); 195 << "") WARNING: top-level pdf has an infinite value"" << std::endl;; 196 }; 197 ; 198 if (prob == 0) {; 199 caller->logEvalError(""getLogVal() top-level p.d.f evaluates to zero"");; 200 ; 201 return -std::numeric_limits<double>::infinity();; 202 }; 203 ; 204 if (TMath::IsNaN(prob)) {; 205 caller->logEvalError(""getLogVal() top-level p.d.f evaluates to NaN"");; 206 ; 207 return prob;; 208 }; 209 ; 210 return std::log(prob);; 211}; 212 ; 213} // namespace; 214 ; 215using std::endl, std::string, std::ostream, std::vector, std::pair, std::make_pair;; 216 ; 217using RooHelpers::getColonSeparatedNameString;; 218 ; 219ClassImp(RooAbsPdf);; 220 ; 221ClassImp(RooAbsPdf::GenSpec);; 222 ; 223 ; 224Int_t RooAbsPdf::_verboseEval = 0;; 225TString RooAbsPdf::_normRangeOverride;; 226 ; 227////////////////////////////////////////////////////////////////////////////////; 228/// Default constructor; 229 ; 230RooAbsPdf::RooAbsPdf() : _normMgr(this, 10) {}; 231 ; 232//////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:8239,log,logEvalError,8239,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['logEvalError']
Testability," 1600 // normalize loss to number of batches and add regularization term; 1601 trainingError /= (Double_t)(nTrainingSamples / settings.batchSize);; 1602 trainingError += regTerm;; 1603 ; 1604 //Log the loss value; 1605 fTrainHistory.AddValue(""trainingError"",nTrainEpochs,trainingError);; 1606 ; 1607 // stop measuring; 1608 tend = std::chrono::system_clock::now();; 1609 ; 1610 // Compute numerical throughput.; 1611 std::chrono::duration<double> elapsed_seconds = tend - tstart;; 1612 std::chrono::duration<double> elapsed1 = t1-tstart;; 1613 // std::chrono::duration<double> elapsed2 = t2-tstart;; 1614 // time to compute training and test errors; 1615 std::chrono::duration<double> elapsed_testing = tend-t1;; 1616 ; 1617 double seconds = elapsed_seconds.count();; 1618 // double nGFlops = (double)(settings.testInterval * batchesInEpoch * settings.batchSize)*1.E-9;; 1619 // nGFlops *= deepnet.GetNFlops() * 1e-9;; 1620 double eventTime = elapsed1.count()/( batchesInEpoch * settings.testInterval * settings.batchSize);; 1621 ; 1622 converged =; 1623 convergenceCount > settings.convergenceSteps || nTrainEpochs >= settings.maxEpochs;; 1624 ; 1625 ; 1626 Log() << std::setw(10) << nTrainEpochs << "" | ""; 1627 << std::setw(12) << trainingError; 1628 << std::setw(12) << valError; 1629 << std::setw(12) << seconds / settings.testInterval; 1630 << std::setw(12) << elapsed_testing.count(); 1631 << std::setw(12) << 1. / eventTime; 1632 << std::setw(12) << convergenceCount; 1633 << Endl;; 1634 ; 1635 if (converged) {; 1636 Log() << Endl;; 1637 }; 1638 tstart = std::chrono::system_clock::now();; 1639 }; 1640 ; 1641 // if (stepCount % 10 == 0 || converged) {; 1642 if (converged && debug) {; 1643 Log() << ""Final Deep Net Weights for phase "" << trainingPhase << "" epoch "" << nTrainEpochs; 1644 << Endl;; 1645 auto & weights_tensor = deepNet.GetLayerAt(0)->GetWeights();; 1646 auto & bias_tensor = deepNet.GetLayerAt(0)->GetBiases();; 1647 for (size_t l = 0; l < weights_tensor.size(); ++l); 1648 we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:64518,test,testInterval,64518,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['test'],['testInterval']
Testability," 172 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 173 return *this;; 174 }; 175#endif; 176 ; 177 // ------ Set, Get, and access coordinate data ------; 178 ; 179 /**; 180 Retrieve a copy of the coordinates object; 181 */; 182 CoordSystem Coordinates() const {; 183 return fCoordinates;; 184 }; 185 ; 186 /**; 187 Set internal data based on a C-style array of 3 Scalar numbers; 188 */; 189 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( const Scalar src[] ); 190 { fCoordinates.SetCoordinates(src); return *this; }; 191 ; 192 /**; 193 Set internal data based on 3 Scalar numbers; 194 */; 195 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b, Scalar c ); 196 { fCoordinates.SetCoordinates(a, b, c); return *this; }; 197 ; 198 /**; 199 Set internal data based on 3 Scalars at *begin to *end; 200 */; 201 template <class IT>; 202 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( IT begin, IT end ); 203 { IT a = begin; IT b = ++begin; IT c = ++begin;; 204 (void)end;; 205 assert (++begin==end);; 206 SetCoordinates (*a,*b,*c);; 207 return *this;; 208 }; 209 ; 210 /**; 211 get internal data into 3 Scalar numbers; 212 */; 213 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c ) const; 214 { fCoordinates.GetCoordinates(a, b, c); }; 215 ; 216 /**; 217 get internal data into a C-style array of 3 Scalar numbers; 218 */; 219 void GetCoordinates( Scalar dest[] ) const; 220 { fCoordinates.GetCoordinates(dest); }; 221 ; 222 /**; 223 get internal data into 3 Scalars at *begin to *end (3 past begin); 224 */; 225 template <class IT>; 226 void GetCoordinates( IT begin, IT end ) const; 227 { IT a = begin; IT b = ++begin; IT c = ++begin;; 228 (void)end;; 229 assert (++begin==end);; 230 GetCoordinates (*a,*b,*c);; 231 }; 232 /**; 233 get internal data into 3 Scalars starting at *begin; 234 */; 235 template <class IT>; 236 void GetCoordinates( IT begin) const {; 237 Scalar a = Scalar(0);; 238 Scalar b = Scalar(0);; 239 Scalar c = Scalar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:6778,assert,assert,6778,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['assert'],['assert']
Testability," 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1816/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1817/// of iteration of the Brent algorithm; 1818/// If the flag logx is set the grid search is done in log step size; 1819/// This is done automatically if the log scale is set in the current Pad; 1820///; 1821/// NOTE: see also TF1::GetX; 1822 ; 1823Double_t TF1::GetMinimumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1824{; 1825 if (xmin >= xmax) {; 1826 xmin = fXmin;; 1827 xmax = fXmax;; 1828 }; 1829 ; 1830 ROOT::Math::BrentMinimizer1D bm;; 1831 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1832 bm.SetFunction(wf1, xmin, xmax);; 1833 bm.SetNpx(fNpx);; 1834 bm.SetLogScan(logx);; 1835 bm.Minimize(maxiter, epsilon, epsilon);; 1836 Double_t x;; 1837 x = bm.XMinimum();; 1838 ; 1839 return x;; 1840}; 1841 ; 1842 ; 1843////////////////////////////////////////////////////////////////////////////////; 1844/// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; 1845/// in other words it can find the roots of the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:67257,log,logx,67257,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['logx']
Testability," 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:56786,log,logs,56786,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['log'],['logs']
Testability," 2 Signal; : Dataset[dataset] : create input formulas for tree ; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree ; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Dataset[dataset] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[dataset] : such that the effective (weighted) number of events in each class is the same ; : Dataset[dataset] : (and equals the number of events (entries) given for class=0 ); : Dataset[dataset] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[dataset] : ... (note that N_j is the sum of TRAINING events; : Dataset[dataset] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 500; : Signal -- testing events : 500; : Signal -- training and testing events: 1000; : Background -- training events : 500; : Background -- testing events : 500; : Background -- training and testing events: 1000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ------------------------; : x y; : x: +1.000 +0.030; : y: +0.030 +1.000; : ------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ------------------------; : x y; : x: +1.000 -0.022; : y: -0.022 +1.000; : ------------------------; <HEADER> DataSetFactory : [dataset] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'x' <---> Output : variable 'x'; : Input : variable 'y' <---> Output : variable 'y'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: 1.0229 0.57835 [ 0.00044777 1.9988 ]; : y: 1.4942 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMinimalClassification_8C.html:2140,test,testing,2140,doc/master/TMVAMinimalClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMinimalClassification_8C.html,5,['test'],['testing']
Testability," 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.weights.xml␛[0m; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; MLPBNN : Building Network. ; : Initializing weights; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_SVM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_RuleFit.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Cuts for Classification performance; : ; Cuts : [dataset] : Evaluation of Cuts on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00226 sec ; Factory : Test method: CutsD for Classification performance; : ; CutsD : [dataset] : Evaluation of CutsD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:65374,test,testing,65374,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['testing']
Testability," 220}; 221R__DLLEXPORT clang::RecordDecl* TCling__DEBUG__DCtoRecordDecl(clang::DeclContext* DC) {; 222 return llvm::dyn_cast<clang::RecordDecl>(DC);; 223}; 224R__DLLEXPORT void TCling__DEBUG__dump(clang::DeclContext* DC) {; 225 return DC->dumpDeclContext();; 226}; 227R__DLLEXPORT void TCling__DEBUG__dump(clang::Decl* D) {; 228 return D->dump();; 229}; 230R__DLLEXPORT void TCling__DEBUG__dump(clang::FunctionDecl* FD) {; 231 return FD->dump();; 232}; 233R__DLLEXPORT void TCling__DEBUG__decl_dump(void* D) {; 234 return ((clang::Decl*)D)->dump();; 235}; 236R__DLLEXPORT void TCling__DEBUG__printName(clang::Decl* D) {; 237 if (clang::NamedDecl* ND = llvm::dyn_cast<clang::NamedDecl>(D)) {; 238 std::string name;; 239 {; 240 llvm::raw_string_ostream OS(name);; 241 ND->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),; 242 true /*Qualified*/);; 243 }; 244 printf(""%s\n"", name.c_str());; 245 }; 246}; 247//______________________________________________________________________________; 248// These functions are helpers for testing issues directly rather than; 249// relying on side effects.; 250// This is used for the test for ROOT-7462/ROOT-6070; 251R__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {; 252 return D->isInvalidDecl();; 253}; 254R__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {; 255 TClingClassInfo *info( (TClingClassInfo*) input);; 256 assert(info && info->IsValid());; 257 return info->GetDecl()->isInvalidDecl();; 258}; 259 ; 260using std::string, std::vector;; 261using namespace clang;; 262using namespace ROOT;; 263 ; 264namespace {; 265 static const std::string gInterpreterClassDef = R""ICF(; 266#undef ClassDef; 267#define ClassDef(name, id) \; 268_ClassDefInterp_(name,id,virtual,) \; 269static int DeclFileLine() { return __LINE__; }; 270#undef ClassDefNV; 271#define ClassDefNV(name, id) \; 272_ClassDefInterp_(name,id,,) \; 273static int DeclFileLine() { return __LINE__; }; 274#undef ClassDefOverride; 275#define ClassDefOv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:8202,test,testing,8202,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['test'],['testing']
Testability," 2218/// Return a random number following this function shape in [xmin,xmax]; 2219///; 2220/// The distribution contained in the function fname (TF1) is integrated; 2221/// over the channel contents.; 2222/// It is normalized to 1.; 2223/// For each bin the integral is approximated by a parabola.; 2224/// The parabola coefficients are stored as non persistent data members; 2225/// Getting one random number implies:; 2226/// - Generating a random number between 0 and 1 (say r1); 2227/// - Look in which bin in the normalized integral r1 corresponds to; 2228/// - Evaluate the parabolic curve in the selected bin to find; 2229/// the corresponding X value.; 2230///; 2231/// The parabolic approximation is very good as soon as the number; 2232/// of bins is greater than 50.; 2233///; 2234/// @param xmin minimum value for generated random numbers; 2235/// @param xmax maximum value for generated random numbers; 2236/// @param rng (optional) random number generator pointer; 2237/// @param option (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table; 2238///; 2239/// IMPORTANT NOTE; 2240///; 2241/// The integral of the function is computed at fNpx points. If the function; 2242/// has sharp peaks, you should increase the number of points (SetNpx); 2243/// such that the peak is correctly tabulated at several points.; 2244 ; 2245Double_t TF1::GetRandom(Double_t xmin, Double_t xmax, TRandom * rng, Option_t * option); 2246{; 2247 // Check if integral array must be built; 2248 if (fIntegral.empty()) {; 2249 Bool_t ret = ComputeCdfTable(option);; 2250 if (!ret) return TMath::QuietNaN();; 2251 }; 2252 ; 2253 // return random number; 2254 Double_t dx = (fXmax - fXmin) / fNpx;; 2255 Int_t nbinmin = (Int_t)((xmin - fXmin) / dx);; 2256 Int_t nbinmax = (Int_t)((xmax - fXmin) / dx) + 2;; 2257 if (nbinmax > fNpx) nbinmax = fNpx;; 2258 ; 2259 Double_t pmin = fIntegral[nbinmin];; 2260 Double_t pmax = fIntegral[nbinmax];; 2261 ; 2262 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:82795,log,log,82795,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['log']
Testability," 231 dataloader->AddSpectator( ""spec2 := var1*3"", ""Spectator 2"", ""units"", 'F' );; 232 ; 233 ; 234 // global event weights per tree (see below for setting event-wise weights); 235 Double_t signalWeight = 1.0;; 236 Double_t backgroundWeight = 1.0;; 237 ; 238 // You can add an arbitrary number of signal or background trees; 239 dataloader->AddSignalTree ( signalTree, signalWeight );; 240 dataloader->AddBackgroundTree( background, backgroundWeight );; 241 ; 242 // To give different trees for training and testing, do as follows:; 243 //; 244 // dataloader->AddSignalTree( signalTrainingTree, signalTrainWeight, ""Training"" );; 245 // dataloader->AddSignalTree( signalTestTree, signalTestWeight, ""Test"" );; 246 ; 247 // Use the following code instead of the above two or four lines to add signal and background; 248 // training and test events ""by hand""; 249 // NOTE that in this case one should not give expressions (such as ""var1+var2"") in the input; 250 // variable definition, but simply compute the expression before adding the event; 251 // ```cpp; 252 // // --- begin ----------------------------------------------------------; 253 // std::vector<Double_t> vars( 4 ); // vector has size of number of input variables; 254 // Float_t treevars[4], weight;; 255 //; 256 // // Signal; 257 // for (UInt_t ivar=0; ivar<4; ivar++) signalTree->SetBranchAddress( Form( ""var%i"", ivar+1 ), &(treevars[ivar]) );; 258 // for (UInt_t i=0; i<signalTree->GetEntries(); i++) {; 259 // signalTree->GetEntry(i);; 260 // for (UInt_t ivar=0; ivar<4; ivar++) vars[ivar] = treevars[ivar];; 261 // // add training and test events; here: first half is training, second is testing; 262 // // note that the weight can also be event-wise; 263 // if (i < signalTree->GetEntries()/2.0) dataloader->AddSignalTrainingEvent( vars, signalWeight );; 264 // else dataloader->AddSignalTestEvent ( vars, signalWeight );; 265 // }; 266 //; 267 // // Background (has event weights); 268 // background->SetBranchAddress( ""weight"", &weigh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:10034,test,testing,10034,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,4,['test'],"['test', 'testing']"
Testability," 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedParamFunction_8h_source.html:9192,assert,assert,9192,doc/master/WrappedParamFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html,1,['assert'],['assert']
Testability," 258 fCoordErrors.clear();; 259 fDataError.clear();; 260 fDataErrorHigh.clear();; 261 fDataErrorLow.clear();; 262 ; 263 fDataPtr = rhs.fDataPtr;; 264 fCoordErrorsPtr = rhs.fCoordErrorsPtr;; 265 fDataErrorPtr = rhs.fDataErrorPtr;; 266 fDataErrorHighPtr = rhs.fDataErrorHighPtr;; 267 fDataErrorLowPtr = rhs.fDataErrorLowPtr;; 268 }; 269 else; 270 {; 271 // copy data vector and set correct pointer; 272 fData = rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fDataErrorPtr = &fDataError.front();; 290 }; 291 // copy the asymmetric data error; 292 fDataErrorHigh = rhs.fDataErrorHigh;; 293 fDataErrorLow = rhs.fDataErrorLow;; 294 // both error low and high should be empty or not; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty()) ;; 296 if (!fDataErrorHigh.empty() && !fDataErrorLow.empty()) {; 297 assert(kAsymError == fErrorType);; 298 fDataErrorHighPtr = &fDataErrorHigh.front();; 299 fDataErrorLowPtr = &fDataErrorLow.front();; 300 }; 301 }; 302 ; 303 fpTmpCoordErrorVector= new double[ fDim ];; 304 ; 305 if ( HasBinEdges() ); 306 fpTmpBinEdgeVector = new double[ fDim ];; 307 ; 308 return *this;; 309 }; 310 ; 311 ; 312 /**; 313 preallocate a data set with given size , dimension and error type (to get the full point size); 314 If the data set already exists and it is having the compatible point size space for the new points; 315 is created in the data sets, while if not compatible the old data are erased and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:8074,assert,assert,8074,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," 258 } else if (x <= -boundary) {; 259 return x * (nominal - low);; 260 }; 261 ; 262 // interpolate 6th degree; 263 double t = x / boundary;; 264 double eps_plus = high - nominal;; 265 double eps_minus = nominal - low;; 266 double S = 0.5 * (eps_plus + eps_minus);; 267 double A = 0.0625 * (eps_plus - eps_minus);; 268 ; 269 return x * (S + t * A * (15 + t * t * (-10 + t * t * 3)));; 270 } else if (code == 5) {; 271 double x = paramVal;; 272 double mod = 1.0;; 273 if (x >= boundary) {; 274 mod = std::pow(high / nominal, +paramVal);; 275 } else if (x <= -boundary) {; 276 mod = std::pow(low / nominal, -paramVal);; 277 } else {; 278 // interpolate 6th degree exp; 279 double x0 = boundary;; 280 ; 281 high /= nominal;; 282 low /= nominal;; 283 ; 284 // GHL: Swagato's suggestions; 285 double powUp = std::pow(high, x0);; 286 double powDown = std::pow(low, x0);; 287 double logHi = std::log(high);; 288 double logLo = std::log(low);; 289 double powUpLog = high <= 0.0 ? 0.0 : powUp * logHi;; 290 double powDownLog = low <= 0.0 ? 0.0 : -powDown * logLo;; 291 double powUpLog2 = high <= 0.0 ? 0.0 : powUpLog * logHi;; 292 double powDownLog2 = low <= 0.0 ? 0.0 : -powDownLog * logLo;; 293 ; 294 double S0 = 0.5 * (powUp + powDown);; 295 double A0 = 0.5 * (powUp - powDown);; 296 double S1 = 0.5 * (powUpLog + powDownLog);; 297 double A1 = 0.5 * (powUpLog - powDownLog);; 298 double S2 = 0.5 * (powUpLog2 + powDownLog2);; 299 double A2 = 0.5 * (powUpLog2 - powDownLog2);; 300 ; 301 // fcns+der+2nd_der are eq at bd; 302 ; 303 double a = 1. / (8 * x0) * (15 * A0 - 7 * x0 * S1 + x0 * x0 * A2);; 304 double b = 1. / (8 * x0 * x0) * (-24 + 24 * S0 - 9 * x0 * A1 + x0 * x0 * S2);; 305 double c = 1. / (4 * std::pow(x0, 3)) * (-5 * A0 + 5 * x0 * S1 - x0 * x0 * A2);; 306 double d = 1. / (4 * std::pow(x0, 4)) * (12 - 12 * S0 + 7 * x0 * A1 - x0 * x0 * S2);; 307 double e = 1. / (8 * std::pow(x0, 5)) * (+3 * A0 - 3 * x0 * S1 + x0 * x0 * A2);; 308 double f = 1. / (8 * std::pow(x0, 6)) * (-8 + 8 * S0 - 5 * x0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:8764,log,logHi,8764,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,1,['log'],['logHi']
Testability," 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> false",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:11713,test,testSample,11713,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['test'],['testSample']
Testability," 283 if (fWrapped); 284 return eval;; 285 else; 286 return (eval != 0.0) ? 1.0/eval : 0.0;; 287 }; 288 ; 289 if ( fErrorType == kAsymError ); 290 { // return 1/2(el + eh); 291 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 292 assert( fDataError.empty() );; 293 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 294 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 296 ; 297 double eh = fDataErrorHighPtr[ ipoint ];; 298 double el = fDataErrorLowPtr[ ipoint ];; 299 ; 300 return (el+eh) / 2.0;; 301 }; 302 ; 303 assert( fErrorType == kCoordError );; 304 return fDataErrorPtr[ ipoint ];; 305 }; 306 ; 307 void GetAsymError( unsigned int ipoint, double& lowError, double& highError ) const; 308 {; 309 assert( fErrorType == kAsymError );; 310 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 311 assert( fDataError.empty() );; 312 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 313 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 314 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 315 ; 316 lowError = fDataErrorLowPtr[ ipoint ];; 317 highError = fDataErrorHighPtr[ ipoint ];; 318 }; 319 ; 320 /**; 321 Return the inverse of error on the value for the given fit point; 322 useful when error in the coordinates are not stored and then this is used directly this as the weight in; 323 the least square function; 324 */; 325 double InvError( unsigned int ipoint ) const; 326 {; 327 assert( ipoint < fMaxPoints );; 328 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 329 kAsymError == fErrorType || kNoError == fErrorType );; 330 ; 331 if ( fErrorType == kNoError ); 332 {; 333 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 334 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 335 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:10756,assert,assert,10756,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability," 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting the item colors in the VIEW menu of the canvas tool bar. The red, green, and blue components of a color can be changed thanks to TColor::SetRGB().; SinceROOT version 6.19/01; As default labels and ticks are drawn by TGAxis at equidistant (lin or log) points as controlled by SetNdivisions. If option ""CJUST"" is given labels and ticks are justified at the color boundaries defined by the contour levels. For more details see TPaletteAxis. Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D histogram. One must create a graphical cut (mouse or C++) and specify the name of the cut between [] in the Draw() option. For example (fit2a.C), with a TCutG named cutg, one can call: myhist->Draw(""surf1 [cutg]"");; To invert the cut, it is enough to put a - in front of its name: myhist->Draw(""surf1 [-cutg]"");; It is possible to apply several cuts (, means logical AND): myhist->Draw(""surf1 [cutg1,cutg2]"");; ; #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h""; #include ""TCanvas.h""; #include ""TStyle.h""; ; double g2(double *x, double *par) {; double r1 = double((x[0]-par[1])/par[2]);; double r2 = double((x[1]-par[3])/par[4]);; return par[0]*TMath::Exp(-0.5*(r1*r1+r2*r2));; }; double fun2(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; double *p3 = &par[10];; double result = g2(x,p1) + g2(x,p2) + g2(x,p3);; return result;; }; ; TCanvas *fit2a() {; TCanvas *c = new TCanvas();; gStyle->SetOptStat(true);; gStyle->SetPalette(57);; const int npar = 15;; double f2params[npar] = {100,-3,3,-3,3,160,0,0.8,0,0.9,40,4,0.7,4,0.7};; auto f2 = new TF2(""f2"",fun2,-10,10,-10,10, npar);; f2->SetParameters(f2params);; ; //Create an histogram and fill it randomly with f2; auto h2 = new TH2F(""h2"",""From f2"",40,-10,10,40,-10,10);; int nentrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:111456,log,logical,111456,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['log'],['logical']
Testability," 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchanged();; 301 ; 302 atexit(ResetTermAtExit);; 303 ; 304 // Setup for tab completion; 305 gTabCom = new TTabCom;; 306 Gl_in_key = &Key_Pressed;; 307 Gl_beep_hook = &BeepHook;; 308 ; 309 // tell Cling to use our getline; 310 gCling->SetGetline(Getline, Gl_histadd);; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:11392,log,logon,11392,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['log'],['logon']
Testability," 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""frac"", ""frac"", nsig.getVal() / (nsig.getVal() + nbkg.getVal()), 0.0, 1.0); ; model = ROOT.RooAddPdf(""model"", ""model"", [gauss, expo], [nsig, nbkg]); ; model_data = model.generateBinned(x); ; # Set the starting values for the Gaussian parameters away from the true; # value such that the fit is not trivial.; mu.setVal(2.0); sigma.setVal(1.0); ; fit6 = model.fitTo(model_data, Save=True, PrintLevel=-1, SumW2Error=False); fit6.Print(); ; # You should see in the previous fit result that the fit did not converge:; # the `MINIMIZE` return code should be -1 (a successful fit has status code zero).; ; # To improve the situation, we can apply a numeric trick: if we subtract in; # each bin a constant counterterm \f[n\log(n/N)\f], we get terms for each; # bin that are closer to each other in order of magnitude as long as the; # initial model is not extremely off. Proving this mathematically is left; # as an exercise to the reader.; ; # This counterterms can be enabled by passing the Offset(""bin"") option to; # RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; ; fit7 = model.fitTo(model_data, Offset=""bin"", Save=True, PrintLevel=-1, SumW2Error=False); fit7.Print(); ; # You should now see in the last fit result that the fit has converged.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'bin' created with bounds [0.1,0.6]; ; RooFitResult: minimized FCN value: 4754.37, estimated distance to minimum: 3.09852e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.6862e+00 +/- 1.70e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:7615,log,log,7615,doc/master/rf614__binned__fit__problems_8py.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html,1,['log'],['log']
Testability," 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554///////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150699,log,logEvalError,150699,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['logEvalError']
Testability," 3519 ; 3520 // rootcling pre-includes things such as Rtypes.h. This means that ACLiC can; 3521 // call rootcling asking it to create a module for a file with no #includes; 3522 // but relying on things from Rtypes.h such as the ClassDef macro.; 3523 //; 3524 // When rootcling starts building a module, it becomes resilient to the; 3525 // outside environment and pre-included files have no effect. This hook; 3526 // informs rootcling when a new submodule is being built so that it can; 3527 // make Core.Rtypes.h visible.; 3528 void EnteredSubmodule(clang::Module* M,; 3529 clang::SourceLocation ImportLoc,; 3530 bool ForPragma) override {; 3531 assert(M);; 3532 using namespace clang;; 3533 if (llvm::StringRef(M->Name).endswith(""ACLiC_dict"")) {; 3534 Preprocessor& PP = m_Interpreter->getCI()->getPreprocessor();; 3535 HeaderSearch& HS = PP.getHeaderSearchInfo();; 3536 // FIXME: Reduce to Core.Rtypes.h.; 3537 Module* CoreModule = HS.lookupModule(""Core"", SourceLocation(),; 3538 /*AllowSearch*/false);; 3539 assert(M && ""Must have module Core"");; 3540 PP.makeModuleVisible(CoreModule, ImportLoc);; 3541 }; 3542 }; 3543};; 3544 ; 3545static llvm::cl::opt<bool> gOptSystemModuleByproducts(""mSystemByproducts"", llvm::cl::Hidden,; 3546 llvm::cl::desc(""Allow implicit build of system modules.""),; 3547 llvm::cl::cat(gRootclingOptions));; 3548static llvm::cl::list<std::string>; 3549gOptModuleByproducts(""mByproduct"", llvm::cl::ZeroOrMore,; 3550 llvm::cl::Hidden,; 3551 llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module.""),; 3552 llvm::cl::cat(gRootclingOptions));; 3553// Really llvm::cl::Required, will be changed in RootClingMain below.; 3554static llvm::cl::opt<std::string>; 3555gOptDictionaryFileName(llvm::cl::Positional,; 3556 llvm::cl::desc(""<output dictionary file>""),; 3557 llvm::cl::cat(gRootclingOptions));; 3558 ; 3559////////////////////////////////////////////////////////////////////////////////; 3560/// Custom diag client for cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:140931,assert,assert,140931,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['assert'],['assert']
Testability," 3725 ; 3726 TString testcmd = fMakeExe;; 3727 TString fakeMain;; 3728 AssignAndDelete( fakeMain, ConcatFileName( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dyna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:127186,test,testcmd,127186,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['test'],['testcmd']
Testability," 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:127306,test,testcmd,127306,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['test'],['testcmd']
Testability," 4.0761 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: -0.014284 1.4061 [ -4.1075 4.0969 ]; : y: -0.0066370 1.4204 [ -4.8520 4.0761 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : datasetcv Fisher : 0.971; : datasetcv BDTG : 0.965; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : datasetcv Fisher : 0.665 (0.665) 0.922 (0.922) 0.980 (0.980); : datasetcv BDTG : 0.617 (0.617) 0.914 (0.914) 0.974 (0.974); : -------------------------------------------------------------------------------------------------------------------; : ; <HEADER> Dataset:datasetcv : Created tree 'TestTree' with 1998 events; : ; <HEADER> Dataset:datasetcv : Created tree 'TrainTree' with 1998 events; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.html; : Evaluation done.; Summary for method BDT; Fold 0: ROC int: 0.972504, BkgEff@SigEff=0.3: 0.981; Fold 1: ROC int: 0.96115, BkgEff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:17573,test,test,17573,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['test'],['test']
Testability," 4/// \date 2021-08-04; 5 ; 6/*************************************************************************; 7 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 8 * All rights reserved. *; 9 * *; 10 * For the licensing terms see $ROOTSYS/LICENSE. *; 11 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 12 *************************************************************************/; 13 ; 14#ifndef ROOT_RRangeCast; 15#define ROOT_RRangeCast; 16 ; 17#include ""ROOT/RSpan.hxx""; 18 ; 19#include <cassert>; 20#include <iterator>; 21#include <type_traits>; 22#include <utility>; 23 ; 24namespace ROOT {; 25namespace Internal {; 26 ; 27template <typename T>; 28struct RBaseType {; 29 using type = typename std::remove_pointer<typename std::decay<T>::type>::type;; 30};; 31 ; 32#if (__cplusplus < 201700L); 33 ; 34template <typename T, bool isDynamic = true, bool isPolymorphic = std::is_polymorphic<RBaseType<T>>::value>; 35struct RCast {; 36 template <typename U>; 37 static T cast(U &&u); 38 {; 39 return dynamic_cast<T>(u);; 40 }; 41};; 42 ; 43template <typename T>; 44struct RCast<T, false, false> {; 45 template <typename U>; 46 static T cast(U &&u); 47 {; 48 return static_cast<T>(u);; 49 }; 50};; 51 ; 52template <typename T>; 53struct RCast<T, false, true> {; 54 template <typename U>; 55 static T cast(U &&u); 56 {; 57 assert(dynamic_cast<T>(u));; 58 return static_cast<T>(u);; 59 }; 60};; 61 ; 62#endif; 63 ; 64// For SFINAE-based checks for the existence of the `begin` and `end` methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RRangeCast_8hxx_source.html:1647,assert,assert,1647,doc/master/RRangeCast_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html,2,['assert'],['assert']
Testability," 406 add one dim data with only coordinate and values; 407 */; 408 void BinData::Add( double x, double y ); 409 {; 410 assert( kNoError == fErrorType );; 411 ; 412 assert( !fData.empty() && fDataPtr );; 413 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 414 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 415 assert( fDataError.empty() && !fDataErrorPtr );; 416 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 417 ; 418 fData[ fNPoints ] = y;; 419 ; 420 FitData::Add( x );; 421 fSumContent += y;; 422 }; 423 ; 424 /**; 425 add one dim data with no error in the coordinate (x); 426 in this case store the inverse of the error in the value (y); 427 */; 428 void BinData::Add( double x, double y, double ey ); 429 {; 430 assert( kValueError == fErrorType );; 431 assert( !fData.empty() && fDataPtr );; 432 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444 if (!fIsWeighted); 445 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 446 }; 447 ; 448 /**; 449 add one dim data with error in the coordinate (x); 450 in this case store the value (y) error and not the inverse; 451 */; 452 void BinData::Add( double x, double y, double ex, double ey ); 453 {; 454 assert( kCoordError == fErrorType );; 455 assert( !fData.empty() && fDataPtr );; 456 assert( !fDataError.empty() && fDataErrorPtr );; 457 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 458 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 459 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 460 assert( !fCoordErrorsPtr.empty() && f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:12698,assert,assert,12698,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444 if (!fIsWeighted); 445 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 446 }; 447 ; 448 /**; 449 add one dim data with error in the coordinate (x); 450 in this case store the value (y) error and not the inverse; 451 */; 452 void BinData::Add( double x, double y, double ex, double ey ); 453 {; 454 assert( kCoordError == fErrorType );; 455 assert( !fData.empty() && fDataPtr );; 456 assert( !fDataError.empty() && fDataErrorPtr );; 457 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 458 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 459 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 460 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 461 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 462 ; 463 fData[ fNPoints ] = y;; 464 fCoordErrors[0][ fNPoints ] = ex;; 465 fDataError[ fNPoints ] = ey;; 466 ; 467 FitData::Add( x );; 468 fSumContent += y;; 469 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 470 // set the weight flag checking if error^2 != y; 471 if (!fIsWeighted); 472 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 473 }; 474 ; 475 /**; 476 add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); 477 in this case store the y errors and not the inverse; 478 */; 479 void BinData::Add( double x, double y, double ex, double eyl, double eyh ); 480 {; 481 assert( kAsymError == fErrorType );; 482 assert( !fData.empty() && fDataPtr );; 483 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:13589,assert,assert,13589,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," 448 if (P->getInit()) {; 449 std::string init_value = ExprToStr(P->getDefaultArg());; 450 result += ""="" + init_value;; 451 }; 452 }; 453 ; 454 return result;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458 ; 459std::string RScanner::FuncParameterList(clang::FunctionDecl* D) const; 460{; 461 std::string result = """";; 462 ; 463 for (clang::FunctionDecl::param_iterator I = D->param_begin(), E = D->param_end(); I != E; ++I) {; 464 clang::ParmVarDecl* P = *I;; 465 ; 466 if (result != """"); 467 result += "","";; 468 ; 469 std::string type = P->getType().getAsString();; 470 result += type;; 471 }; 472 ; 473 return ""("" + result + "")"";; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// This method visits a namespace node; 478 ; 479bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N); 480{; 481 // We don't need to visit this while creating the big PCM; 482 if (fScanType == EScanType::kOnePCM); 483 return true;; 484 ; 485 if (!shouldVisitDecl(N)); 486 return true;; 487 ; 488 // in case it is implicit we don't create a builder; 489 // [Note: Can N be nullptr?, is so 'ShouldVisitDecl' should test or we should test sooner]; 490 if((N && N->isImplicit()) || !N){; 491 return true;; 492 }; 493 ; 494 bool ret = true;; 495 ; 496 const ClassSelectionRule *selected = fSelectionRules.IsDeclSelected(N);; 497 if (selected) {; 498 ; 499 clang::DeclContext* primary_ctxt = N->getPrimaryContext();; 500 clang::NamespaceDecl* primary = llvm::dyn_cast<clang::NamespaceDecl>(primary_ctxt);; 501 ; 502 RPredicateIsSameNamespace pred(primary);; 503 if ( find_if(fSelectedNamespaces.begin(),fSelectedNamespaces.end(),pred) == fSelectedNamespaces.end() ) {; 504 // The namespace is not already registered.; 505 ; 506 if (fVerboseLevel > 0) {; 507 std::string qual_name;; 508 GetDeclQualName(N,qual_name);; 509 // std::cout<<""\tSelected namespace -> "" << qual_name << "" ptr "" << (void*)N << "" decl ctxt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:15807,test,test,15807,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,2,['test'],['test']
Testability," 453 {; 454 assert( kCoordError == fErrorType );; 455 assert( !fData.empty() && fDataPtr );; 456 assert( !fDataError.empty() && fDataErrorPtr );; 457 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 458 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 459 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 460 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 461 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 462 ; 463 fData[ fNPoints ] = y;; 464 fCoordErrors[0][ fNPoints ] = ex;; 465 fDataError[ fNPoints ] = ey;; 466 ; 467 FitData::Add( x );; 468 fSumContent += y;; 469 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 470 // set the weight flag checking if error^2 != y; 471 if (!fIsWeighted); 472 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 473 }; 474 ; 475 /**; 476 add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); 477 in this case store the y errors and not the inverse; 478 */; 479 void BinData::Add( double x, double y, double ex, double eyl, double eyh ); 480 {; 481 assert( kAsymError == fErrorType );; 482 assert( !fData.empty() && fDataPtr );; 483 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 484 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 485 assert( fDataError.empty() && !fDataErrorPtr );; 486 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 487 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 488 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 489 ; 490 fData[ fNPoints ] = y;; 491 fCoordErrors[0][ fNPoints ] = ex;; 492 fDataErrorHigh[ fNPoints ] = eyh;; 493 fDataErrorLow[ fNPoints ] = eyl;; 494 ; 495 FitData::Add( x );; 496 fSumContent += y;; 497 if (y != 0 || eyl != 1.0 || eyh != 1.0) fSumError2 += (eyl+eyh)*(eyl+eyh)/4;; 498 ; 499 }; 500 ; 501 /**; 502 add multi-dim coordinate data with only value; 503 */; 504 void BinData::Add( const do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:14441,assert,assert,14441,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,2,['assert'],['assert']
Testability," 464 assert( ipoint < fMaxPoints );; 465 assert( fErrorType == kCoordError || fErrorType == kAsymError );; 466 ; 467 errvalue = Error( ipoint );; 468 return CoordErrors( ipoint );; 469 }; 470 ; 471 /**; 472 Get errors on the point (coordinate errors and asymmetric value errors) for the; 473 given fit point.; 474 It must be called only when the coordinate errors and asymmetric errors are stored; 475 otherwise it will produce an assert.; 476 */; 477 // not threadsafe, to be replaced with never constructs!; 478 // for example: just return std::array or std::vector, there's; 479 // is going to be only minor overhead in c++11.; 480 const double* GetPointError(unsigned int ipoint, double & errlow, double & errhigh) const; 481 {; 482 assert( ipoint < fMaxPoints );; 483 assert( fErrorType == kAsymError );; 484 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 485 assert( fDataError.empty() );; 486 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 487 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 488 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 489 ; 490 errhigh = fDataErrorHighPtr[ ipoint ];; 491 errlow = fDataErrorLowPtr[ ipoint ];; 492 ; 493 return CoordErrors( ipoint );; 494 }; 495 ; 496 /**; 497 returns a single coordinate error component of a point.; 498 This function is threadsafe in contrast to Coords(...); 499 and can easily get vectorized by the compiler in loops; 500 running over the ipoint-index.; 501 */; 502 double GetBinUpEdgeComponent( unsigned int ipoint, unsigned int icoord ) const; 503 {; 504 assert( icoord < fDim );; 505 assert( !fBinEdge.empty() );; 506 assert( ipoint < fBinEdge.front().size() );; 507 ; 508 return fBinEdge[icoord][ipoint];; 509 }; 510 ; 511 /**; 512 return an array containing the upper edge of the bin for coordinate i; 513 In case of empty bin they could be merged in a single larger bin; 514 Return a NULL pointer if the bin width is not stor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:17367,assert,assert,17367,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability," 4704 if (autoFlush || autoSave) {; 4705 // First call FlushBasket to make sure that fTotBytes is up to date.; 4706 FlushBasketsImpl();; 4707 autoFlush = false; // avoid auto flushing again later; 4708 ; 4709 // When we are in one-basket-per-cluster mode, there is no need to optimize basket:; 4710 // they will automatically grow to the size needed for an event cluster (with the basket; 4711 // shrinking preventing them from growing too much larger than the actually-used space).; 4712 if (!TestBit(TTree::kOnlyFlushAtCluster)) {; 4713 OptimizeBaskets(GetTotBytes(), 1, """");; 4714 if (gDebug > 0); 4715 Info(""TTree::Fill"", ""OptimizeBaskets called at entry %lld, fZipBytes=%lld, fFlushedBytes=%lld\n"",; 4716 fEntries, GetZipBytes(), fFlushedBytes);; 4717 }; 4718 fFlushedBytes = GetZipBytes();; 4719 fAutoFlush = fEntries; // Use test on entries rather than bytes; 4720 ; 4721 // subsequently in run; 4722 if (fAutoSave < 0) {; 4723 // Set fAutoSave to the largest integer multiple of; 4724 // fAutoFlush events such that fAutoSave*fFlushedBytes; 4725 // < (minus the input value of fAutoSave); 4726 Long64_t totBytes = GetTotBytes();; 4727 if (zipBytes != 0) {; 4728 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / zipBytes) / fEntries));; 4729 } else if (totBytes != 0) {; 4730 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / totBytes) / fEntries));; 4731 } else {; 4732 TBufferFile b(TBuffer::kWrite, 10000);; 4733 TTree::Class()->WriteBuffer(b, (TTree *)this);; 4734 Long64_t total = b.Length();; 4735 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / total) / fEntries));; 4736 }; 4737 } else if (fAutoSave > 0) {; 4738 fAutoSave = fAutoFlush * (fAutoSave / fAutoFlush);; 4739 }; 4740 ; 4741 if (fAutoSave != 0 && fEntries >= fAutoSave); 4742 autoSave = true;; 4743 ; 4744 if (gDebug > 0); 4745 Info(""TTree::Fill"", ""First AutoFlush. fAutoFlush = %lld, fAutoSave = %lld\n"", fAutoFlush, fAutoSave);; 4746 }; 4747 } else {; 4748 // Check if we need to auto fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:191261,test,test,191261,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['test'],['test']
Testability," 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16474,log,log,16474,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['log'],['log']
Testability," 49 ; 50 The sampling is provided via these methods:; 51 - TUnuran::Sample() returns a double for all one-dimensional distribution; 52 - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; 53 - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; 54 size at least equal to the distribution dimension must be passed; 55 ; 56 In addition is possible to set the random number generator in the constructor of the class, its seed; 57 via the TUnuran::SetSeed() method.; 58*/; 59 ; 60 ; 61 ; 62//class TUnuranGenerator;; 63struct unur_gen;; 64typedef struct unur_gen UNUR_GEN;; 65 ; 66// struct unur_urng_generic;; 67// typedef struct unur_urng_generic UNUR_URNG;; 68 ; 69struct unur_distr;; 70typedef struct unur_distr UNUR_DISTR;; 71 ; 72struct unur_urng;; 73typedef struct unur_urng UNUR_URNG;; 74 ; 75 ; 76class TRandom;; 77class TH1;; 78 ; 79class TUnuran {; 80 ; 81public:; 82 ; 83 /**; 84 Constructor with a generator instance and given level of log output; 85 */; 86 TUnuran (TRandom * r = nullptr, unsigned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:2898,log,log,2898,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,2,['log'],['log']
Testability," 498 ; 499 }; 500 ; 501 /**; 502 add multi-dim coordinate data with only value; 503 */; 504 void BinData::Add( const double* x, double val ); 505 {; 506 assert( kNoError == fErrorType );; 507 ; 508 assert( !fData.empty() && fDataPtr );; 509 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 510 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 511 assert( fDataError.empty() && !fDataErrorPtr );; 512 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 513 ; 514 fData[ fNPoints ] = val;; 515 ; 516 FitData::Add( x );; 517 fSumContent += val;; 518 }; 519 ; 520 /**; 521 add multi-dim coordinate data with only error in value; 522 The class stores internally the inverse of the error in this case; 523 */; 524 void BinData::Add( const double* x, double val, double eval ); 525 {; 526 assert( kValueError == fErrorType );; 527 assert( !fData.empty() && fDataPtr );; 528 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 529 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 530 assert( !fDataError.empty() && fDataErrorPtr );; 531 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 532 ; 533 fData[ fNPoints ] = val;; 534 fDataError[ fNPoints ] = (eval != 0.0) ? 1.0/eval : 0.0;; 535 ; 536 FitData::Add( x );; 537 fSumContent += val;; 538 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 539 if (!fIsWeighted); 540 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 541 }; 542 ; 543 /**; 544 add multi-dim coordinate data with both error in coordinates and value; 545 */; 546 void BinData::Add( const double* x, double val, const double* ex, double eval ); 547 {; 548 assert( kCoordError == fErrorType );; 549 assert( !fData.empty() && fDataPtr );; 550 assert( !fDataError.empty() && fDataErrorPtr );; 551 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 552 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 553 assert( fCoordErrors.size() == fDim );; 554 assert( fCoordErrorsPtr.size() == fDim );; 555 ; 556 fData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:16210,assert,assert,16210,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa;; 521 b = bb;; 522 xc = w;; 523 x = xx;; 524 }; 525 ; 526 if( flag == 1 && (b * x) <= 1.0 && x <= 0.95); 527 {; 528 t = pseries(a, b, x);; 529 goto done;; 530 }; 531 ; 532/* Choose expansion for better convergence. */; 533 y = x * (a+b-2.0) - (a-1.0);; 534 if( y < 0.0 ); 535 w = incbcf( a, b, x );; 536 else; 537 w = incbd( a, b, x ) / xc;; 538 ; 539/* Multiply w by the factor; 540 a b _ _ _; 541 x (1-x) | (a+b) / ( a | (a) | (b) ) . */; 542 ; 543 y = a * std::log(x);; 544 t = b * std::log(xc);; 545 if( (a+b) < kMAXSTIR && std::abs(y) < kMAXLOG && std::abs(t) < kMAXLOG ); 546 {; 547 t = pow(xc,b);; 548 t *= pow(x,a);; 549 t /= a;; 550 t *= w;; 551 t *= ROOT::Math::Cephes::gamma(a+b) / (ROOT::Math::Cephes::gamma(a) * ROOT::Math::Cephes::gamma(b));; 552 goto done;; 553 }; 554/* Resort to logarithms. */; 555 y += t + lgam(a+b) - lgam(a) - lgam(b);; 556 y += std::log(w/a);; 557 if( y < kMINLOG ); 558 t = 0.0;; 559 else; 560 t = std::exp(y);; 561 ; 562done:; 563 ; 564 if( flag == 1 ); 565 {; 566 if( t <= kMACHEP ); 567 t = 1.0 - kMACHEP;; 568 else; 569 t = 1.0 - t;; 570 }; 571 return( t );; 572}; 573/*---------------------------------------------------------------------------*/; 574 ; 575/*---------------------------------------------------------------------------*/; 576 ; 577/* Continued fraction expansion #1; 578 * for incomplete beta integral; 579 */; 580 ; 581double incbcf( double a, double b, double x ); 582{; 583 double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;; 584 double k1, k2, k3, k4, k5, k6, k7, k8;; 585 double r, t, ans, thresh;; 586 int n;; 587 ; 588 k1 = a;; 589 k2 = a + b;; 590 k3 = a;; 591 k4 = a + 1.0;; 592 k5 = 1.0;; 593 k6 = b - 1.0;; 594 k7 = k4;; 595 k8 = a + 2.0;; 596 ; 597 pkm2 = 0.0;; 598 qkm2 = 1.0;; 599 pkm1 = 1.0;; 600 qkm1 = 1.0;; 601 ans = 1.0;; 602 r = 1.0;; 603 n = 0;; 604 thresh = 3.0 * kMACHEP;; 605 do; 606 {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:12669,log,log,12669,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,1,['log'],['log']
Testability," 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3 MixMax240 MixMax17 Mixmax256_0 MixMax256_2 MixMax256_4 MT_64 Ranlux48; Rndm.............. 5.000 100.000 5.000 10.000 10.000 10.000 10.000 25.000 35.000 20.000 200.000; ; RndmArray......... 5.000 50.000 5.000 5.000 10.000 5.000 10.000 20.000 30.000 20.000 200.000; Gaus.............. 25.000 150.000 30.000 30.000 40.000 40.000 35.000 60.000 70.000 45.000; Rannor............ 25.000 100.000 30.000 30.000 35.000 35.000 35.000 45.000 55.000 45.000; Landau............ 15.000 100.000 15.000 20.000; Exponential....... 15.000 100.000 15.000 20.000; Binomial(5,0.5)... 20.000 450.000 30.000 35.000; Binomial(15,0.5).. 60.000 1300.000 80.000 80.000; Poisson(3)........ 45.000 400.000 50.000 50.000; Poisson(10)....... 75.000 950.000 85.000 85.000; Poisson(70)....... 250.000 550.000 255.000 260.000; Poisson(100)...... 250.000 550.000 255.000 260.000; GausTF1........... 50.000 130.000 65.000 55.000; Lan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/testrandom_8C.html:1922,test,testrandom,1922,doc/master/testrandom_8C.html,https://root.cern,https://root.cern/doc/master/testrandom_8C.html,1,['test'],['testrandom']
Testability," 55 ; 56f_sum.SetParName(1, ""NBackground""); 57f_sum.SetParName(0, ""NSignal""); 58for i in range(2, f_sum.GetNpar()):; 59 f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); 60 ; 61# GENERATE HISTOGRAM TO FIT ..............................................................; 62w = ROOT.TStopwatch(); 63w.Start(); 64h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); 65h_sum.FillRandom(""fsum"", nEvents); 66print(""Time to generate {0} events: "".format(nEvents)); 67w.Print(); 68 ; 69# need to scale histogram with width since we are fitting a density; 70h_sum.Sumw2(); 71h_sum.Scale(1.0, ""width""); 72 ; 73# fit - use Minuit2 if available; 74ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); 75c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); 76# do a least-square fit of the spectrum; 77result = h_sum.Fit(""fsum"", ""SQ""); 78result.Print(); 79h_sum.Draw(); 80print(""Time to fit using ROOT TF1Normsum: ""); 81w.Print(); 82 ; 83# test if parameters are fine; 84for i, pref in enumerate([nsig, nbkg, signal_mean]):; 85 if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; 86 ROOT.Error(; 87 ""testFitNormSum"",; 88 ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; 89 f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); 90 ),; 91 ); 92 ; 93ROOT.gStyle.SetOptStat(0); 94# add parameters; 95t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); 96t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); 97t1.Draw(); 98t2.Draw(); 99 ; 100c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitNormSum_8py_source.html:3107,test,test,3107,doc/master/fitNormSum_8py_source.html,https://root.cern,https://root.cern/doc/master/fitNormSum_8py_source.html,1,['test'],['test']
Testability," 555 ; 556 fData[ fNPoints ] = val;; 557 ; 558 for( unsigned int i=0; i<fDim; i++ ); 559 {; 560 assert( &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 561 ; 562 fCoordErrors[i][ fNPoints ] = ex[i];; 563 }; 564 // in this case we store the y error and not the inverse; 565 fDataError[ fNPoints ] = eval;; 566 ; 567 FitData::Add( x );; 568 fSumContent += val;; 569 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 570 if (!fIsWeighted); 571 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 572 }; 573 ; 574 /**; 575 add multi-dim coordinate data with both error in coordinates and value; 576 */; 577 void BinData::Add( const double* x, double val, const double* ex, double elval, double ehval ); 578 {; 579 assert( kAsymError == fErrorType );; 580 ; 581 assert( !fData.empty() && fDataPtr );; 582 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 583 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 584 assert( fDataError.empty() && !fDataErrorPtr );; 585 assert( fCoordErrors.size() == fDim );; 586 assert( fCoordErrorsPtr.size() == fDim );; 587 ; 588 fData[ fNPoints ] = val;; 589 ; 590 for( unsigned int i=0; i<fDim; i++ ); 591 {; 592 assert( &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 593 ; 594 fCoordErrors[i][ fNPoints ] = ex[i];; 595 }; 596 ; 597 fDataErrorLow[ fNPoints ] = elval;; 598 fDataErrorHigh[ fNPoints ] = ehval;; 599 ; 600 FitData::Add( x );; 601 fSumContent += val;; 602 if (val != 0 || elval != 1.0 || ehval != 1.0 ); 603 fSumError2 += (elval+ehval)*(elval+ehval)/4;; 604 }; 605 ; 606 ; 607 /**; 608 add the bin width data, a pointer to an array with the bin upper edge information.; 609 This is needed when fitting with integral or Bin volume normalization options; 610 The information is added for the previously inserted point.; 611 BinData::Add must be called before; 612 */; 613 void BinData::AddBinUpEdge( const double* xup ); 614 {; 615 if ( fBinEdge.empty() ); 616 InitBinEdge();; 617 ; 618 assert( fBinEdge.size()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:18193,assert,assert,18193,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," 584 }; 585 ; 586 TAttLine::Modify();; 587 //Check if SetTickPolar is activated, and draw tick marks; 588 Bool_t issettickpolar = gPad->GetTicky();; 589 if (issettickpolar) {; 590 if (theta != 0 && theta !=TMath::Pi()) {; 591 gPad->PaintLine((sintheta-GetTickpolarSize())/tantheta,sintheta-GetTickpolarSize(),; 592 (sintheta+GetTickpolarSize())/tantheta,sintheta+GetTickpolarSize());; 593 }; 594 if (theta == 0 || theta ==TMath::Pi()) {; 595 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 596 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 597 }; 598 }; 599 TAttLine::SetLineStyle(1);; 600 TAttLine::Modify();; 601 gPad->PaintLine(0.,0.,costheta,sintheta);; 602 // Add minor lines w/o text.; 603 Int_t oldLineStyle = GetLineStyle();; 604 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 605 TAttLine::Modify(); //Changes line attributes apart from style.; 606 Double_t a=0;; 607 Double_t b,c,d;; 608 b = TMath::Log(10)*test;; 609 d= 2*TMath::Pi()/(double)test;; 610 for (j=1; j<9; j++) {; 611 a=TMath::Log(j+1)-TMath::Log(j)+a;; 612 c=a/b*6.28+d*(i-1);; 613 gPad->PaintLine(0.,0.,TMath::Cos(c),TMath::Sin(c));; 614 }; 615 TAttLine::SetLineStyle(oldLineStyle);; 616 TAttLine::Modify();; 617 }; 618 }; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Paint radial divisions.; 623/// Check for editable pad or create default.; 624 ; 625void TGraphPolargram::PaintRadialDivisions(Bool_t drawaxis); 626{; 627 if (!gPad) return ;; 628 ; 629 static char chopt[8] = """";; 630 Int_t i,j;; 631 Int_t ndiv = TMath::Abs(fNdivRad);; 632 Int_t ndivMajor = ndiv%100;; 633 Int_t ndivMinor = ndiv/100;; 634 Int_t ndivmajor = 0;; 635 Double_t frwrmin = 0., frwrmax = 0., binWidth = 0;; 636 ; 637 THLimitsFinder::Optimize(fRwrmin,fRwrmax,ndivMajor,frwrmin,; 638 frwrmax, ndivmajor,binWidth,"""");; 639 ; 640 if (!gPad->GetLogx()) {; 641 gPad->RangeAxis(-1,-1,1,1);; 642 gPad->Range(-1.25,-1.25,1.25,1.25);; 643 Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:20596,test,test,20596,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,2,['test'],['test']
Testability," 595 of file TGraphDelaunay.cxx. ◆ InterpolateOnPlane(). Double_t TGraphDelaunay::InterpolateOnPlane ; (; Int_t ; TI1, . Int_t ; TI2, . Int_t ; TI3, . Int_t ; E . ); const. protected . Finds the z-value at point e given that it lies on the plane defined by t1,t2,t3. ; Definition at line 556 of file TGraphDelaunay.cxx. ◆ IsA(). TClass * TGraphDelaunay::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 100 of file TGraphDelaunay.h. ◆ operator=(). TGraphDelaunay & TGraphDelaunay::operator= ; (; const TGraphDelaunay & ; ). privatedelete . ◆ SetMarginBinsContent(). void TGraphDelaunay::SetMarginBinsContent ; (; Double_t ; z = 0.). Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin. ; Definition at line 943 of file TGraphDelaunay.cxx. ◆ SetMaxIter(). void TGraphDelaunay::SetMaxIter ; (; Int_t ; n = 100000). Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoning the search. ; Definition at line 932 of file TGraphDelaunay.cxx. ◆ Streamer(). void TGraphDelaunay::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGraphDelaunay::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TGraphDelaunay.h. Member Data Documentation. ◆ fAllTri. Bool_t TGraphDelaunay::fAllTri. protected . ! True if FindAllTriangles() has been performed on fGraph2D ; Definition at line 64 of file TGraphDelaunay.h. ◆ fDist. Double_t* TGraphDelaunay::fDist. protected . ! Array used to order mass points by distance ; Definition at line 56 of file TGraphDelaunay.h. ◆ fGraph2D. TGraph2D* TGraphDelaunay::fGraph2D. protected . ! 2D graph containing the user data ; Definition at line 66 of file TGraphDelaunay.h. ◆ fHullPoints. Int_t* TGraphDelaunay::fHullPoints. protected . ! Hull points of size",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphDelaunay.html:22522,test,tested,22522,doc/master/classTGraphDelaunay.html,https://root.cern,https://root.cern/doc/master/classTGraphDelaunay.html,1,['test'],['tested']
Testability," 6. };  ; enum  EUploadOpt { ;   kAppend = 0x1; , kOverwriteDataSet = 0x2; , kNoOverwriteDataSet = 0x4; , kOverwriteAllFiles = 0x8; , ;   kOverwriteNoFiles = 0x10; , kAskUser = 0x0. };  ; enum  EUploadPackageOpt { kUntar = 0x0; , kRemoveOld = 0x1; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProof (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0);  Create a PROOF environment. ;  ;  ~TProof () override;  Clean up PROOF environment. ;  ; Int_t ActivateWorker (const char *ord, Bool_t save=kTRUE);  Make sure that the worker identified by the ordinal number 'ord' is in the active list. ;  ; void AddChain (TChain *chain);  Add chain to data set. ;  ; Int_t AddDynamicPath (const char *libpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'libpath' to the lib path search. ;  ; void AddFeedback (const char *name);  Add object to feedback list. ;  ; Int_t AddIncludePath (const char *incpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'incpath' to the inc path search. ;  ; void AddInput (TObject *obj);  Add objects that might be needed during the processing of the selector (see Process()). ;  ; void AddInputData (TObject *obj, Bool_t push=kFALSE);  Add data objects that might be needed during the processing of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:2624,log,loglevel,2624,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['loglevel']
Testability," 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Release it */; 14333 release_handler_ref(conn, handler_info);; 14334 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(conn);; 14342 }; 14343 } else {; 14344 /* The handler did NOT handle the request. */; 14345 /* Some proper reactions would be:; 14346 * a) close the connections without sending anything; 14347 * b) send a 404 not found; 14348 * c) try if there is a file matching the URI; 14349 * It would be possible to do a, b or c in the callback; 14350 * implementation, and return 1 - we cannot do anything; 14351 * here, that is not possible in the callback.; 14352 *; 14353 * TODO: What would be the best reaction here?; 14354 * (Note: The reaction may change, if there is a better; 14355 * idea.); 14356 */; 14357 ; 14358 /* For the moment, use option c: We look for a proper file,; 14359 * but since a file request is not always a script resource,; 14360 * the authorization check might be different. */; 14361 interpret_uri(conn,; 14362 pat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:421831,log,log,421831,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['log'],['log']
Testability," 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Release it */; 14334 release_handler_ref(conn, handler_info);; 14335 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(conn);; 14343 }; 14344 } else {; 14345 /* The handler did NOT handle the request. */; 14346 /* Some proper reactions would be:; 14347 * a) close the connections without sending anything; 14348 * b) send a 404 not found; 14349 * c) try if there is a file matching the URI; 14350 * It would be possible to do a, b or c in the callback; 14351 * implementation, and return 1 - we cannot do anything; 14352 * here, that is not possible in the callback.; 14353 *; 14354 * TODO: What would be the best reaction here?; 14355 * (Note: The reaction may change, if there is a better; 14356 * idea.); 14357 */; 14358 ; 14359 /* For the moment, use option c: We look for a proper file,; 14360 * but since a file request is not always a script resource,; 14361 * the authorization check might be different. */; 14362 interpret_uri(conn,; 14363 pat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:421864,log,log,421864,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['log'],['log']
Testability," 604 SetFunction(*gradFunc, true);; 605 return;; 606 } else {; 607 MATH_WARN_MSG(""Fitter::SetFunction"",; 608 ""Requested function does not provide gradient - use it as non-gradient function "");; 609 }; 610 }; 611 ; 612 // set the fit model function (clone the given one and keep a copy ); 613 // std::cout << ""set a non-grad function"" << std::endl;; 614 fUseGradient = false;; 615 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IModelFunction_v *>(func.Clone()));; 616 assert(fFunc_v);; 617 ; 618 // creates the parameter settings; 619 fConfig.CreateParamsSettings(*fFunc_v);; 620 fFunc.reset();; 621}; 622 ; 623template <class NotCompileIfScalarBackend>; 624void Fitter::SetFunction(const IGradModelFunction_v &func, bool useGradient); 625{; 626 fUseGradient = useGradient;; 627 ; 628 // set the fit model function (clone the given one and keep a copy ); 629 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IGradModelFunction_v *>(func.Clone()));; 630 assert(fFunc_v);; 631 ; 632 // creates the parameter settings; 633 fConfig.CreateParamsSettings(*fFunc_v);; 634 fFunc.reset();; 635}; 636#endif; 637 ; 638 } // end namespace Fit; 639 ; 640} // end namespace ROOT; 641 ; 642// implementation of inline methods; 643 ; 644 ; 645 ; 646#include ""Math/WrappedFunction.h""; 647 ; 648template<class Function>; 649bool ROOT::Fit::Fitter::FitFCN(unsigned int npar, Function & f, const double * par, unsigned int datasize,int fitType) {; 650 ROOT::Math::WrappedMultiFunction<Function &> wf(f,npar);; 651 if (!DoSetFCN(false, wf, par, datasize, fitType)); 652 return false;; 653 return FitFCN();; 654}; 655template<class Function>; 656bool ROOT::Fit::Fitter::SetFCN(unsigned int npar, Function & f, const double * par, unsigned int datasize,int fitType) {; 657 ROOT::Math::WrappedMultiFunction<Function &> wf(f,npar);; 658 return DoSetFCN(false, wf, par, datasize, fitType);; 659}; 660 ; 661 ; 662 ; 663 ; 664#endif /* ROOT_Fit_Fitter */; BinData.h; EExecutionPolicy.hxx; MATH_WARN_MSG#define M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:25932,assert,assert,25932,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['assert'],['assert']
Testability," 6847 Int_t htype, oldhtype;; 6848 Int_t i, j, first, last, nbins, fixbin;; 6849 Double_t c1, yb;; 6850 yb = 0;; 6851 ; 6852 strlcpy(chopth, "" "",17);; 6853 ; 6854 Double_t ymin = Hparam.ymin;; 6855 Double_t ymax = Hparam.ymax;; 6856 Double_t baroffset = fH->GetBarOffset();; 6857 Double_t barwidth = fH->GetBarWidth();; 6858 Double_t baroffsetsave = gStyle->GetBarOffset();; 6859 Double_t barwidthsave = gStyle->GetBarWidth();; 6860 gStyle->SetBarOffset(baroffset);; 6861 gStyle->SetBarWidth(barwidth);; 6862 ; 6863 // Create ""LIFE"" structure to keep current histogram status; 6864 ; 6865 first = Hparam.xfirst;; 6866 last = Hparam.xlast;; 6867 nbins = last - first + 1;; 6868 ; 6869 std::vector<Double_t> keepx, keepy;; 6870 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6871 else fixbin = 1;; 6872 if (fixbin) keepx.resize(2);; 6873 else keepx.resize(nbins+1);; 6874 keepy.resize(nbins);; 6875 Double_t logymin = 0;; 6876 if (Hoption.Logy) logymin = TMath::Power(10,ymin);; 6877 ; 6878 // Loop on histogram bins; 6879 ; 6880 for (j=first; j<=last;j++) {; 6881 c1 = Hparam.factor*fH->GetBinContent(j);; 6882 if (TMath::Abs(ymax-ymin) > 0) {; 6883 if (Hoption.Logy) yb = TMath::Log10(TMath::Max(c1,.1*logymin));; 6884 else yb = c1;; 6885 }; 6886 if (!Hoption.Line) {; 6887 yb = TMath::Max(yb, ymin);; 6888 yb = TMath::Min(yb, ymax);; 6889 }; 6890 keepy[j-first] = yb;; 6891 }; 6892 ; 6893 // Draw histogram according to value of FillStyle and FillColor; 6894 ; 6895 if (fixbin) { keepx[0] = Hparam.xmin; keepx[1] = Hparam.xmax; }; 6896 else {; 6897 for (i=0; i<nbins; i++) keepx[i] = fXaxis->GetBinLowEdge(i+first);; 6898 keepx[nbins] = fXaxis->GetBinUpEdge(nbins-1+first);; 6899 }; 6900 ; 6901 // Prepare Fill area (systematic with option ""Bar"").; 6902 ; 6903 oldhtype = fH->GetFillStyle();; 6904 htype = oldhtype;; 6905 if (Hoption.Bar) {; 6906 if (htype == 0 || htype == 1000) htype = 1001;; 6907 }; 6908 ; 6909 Width_t lw = (Width_t)fH->GetLineWidth();; 6910 ; 6911 // Code option for GrapHist; 6912 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:250851,log,logymin,250851,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logymin']
Testability," 71 ; 72//==============================================================================; 73// New Constructors from STL interfaces; 74//==============================================================================; 75 ; 76#ifdef LATER; 77template <class T, unsigned int D>; 78template <class InputIterator>; 79SVector<T,D>::SVector(InputIterator begin, InputIterator end) {; 80 assert(begin + D == end);; 81 std::copy(begin, end, fArray);; 82}; 83 ; 84template <class T, unsigned int D>; 85template <class InputIterator>; 86SVector<T,D>::SVector(InputIterator begin, unsigned int size) {; 87 assert( size <= D);; 88 std::copy(begin, begin+size, fArray);; 89}; 90 ; 91#else; 92 ; 93template <class T, unsigned int D>; 94SVector<T,D>::SVector(const T* a, unsigned int len) {; 95 (void)len;; 96 assert(len == D);; 97 for(unsigned int i=0; i<D; ++i); 98 fArray[i] = a[i];; 99}; 100 ; 101template <class T, unsigned int D>; 102SVector<T,D>::SVector(const_iterator ibegin, const_iterator iend) {; 103 assert(ibegin + D == iend);; 104 std::copy(ibegin, iend, fArray);; 105}; 106 ; 107 ; 108#endif; 109 ; 110 ; 111template <class T, unsigned int D>; 112SVector<T,D>::SVector(const T& a1) {; 113 STATIC_CHECK( D == 1,SVector_dimension_not_right);; 114 fArray[0] = a1;; 115}; 116 ; 117template <class T, unsigned int D>; 118SVector<T,D>::SVector(const T& a1, const T& a2) {; 119 STATIC_CHECK( D == 2,SVector_dimension_not_right);; 120 fArray[0] = a1; fArray[1] = a2;; 121}; 122 ; 123template <class T, unsigned int D>; 124SVector<T,D>::SVector(const T& a1, const T& a2, const T& a3) {; 125 STATIC_CHECK( D == 3,SVector_dimension_not_right);; 126 fArray[0] = a1; fArray[1] = a2; fArray[2] = a3;; 127}; 128 ; 129template <class T, unsigned int D>; 130SVector<T,D>::SVector(const T& a1, const T& a2, const T& a3, const T& a4) {; 131 STATIC_CHECK( D == 4,SVector_dimension_not_right);; 132 fArray[0] = a1; fArray[1] = a2; fArray[2] = a3; fArray[3] = a4;; 133}; 134 ; 135template <class T, unsigned int D>; 136SVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SVector_8icc_source.html:3047,assert,assert,3047,doc/master/SVector_8icc_source.html,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html,1,['assert'],['assert']
Testability," 7324 }; 7325 ; 7326 Hparam.ymin = ymin;; 7327 Hparam.ymax = ymax;; 7328 return 1;; 7329}; 7330 ; 7331////////////////////////////////////////////////////////////////////////////////; 7332/// Compute histogram parameters used by the drawing routines for a rotated pad.; 7333 ; 7334Int_t THistPainter::PaintInitH(); 7335{; 7336 ; 7337 static const char *where = ""PaintInitH"";; 7338 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7339 Int_t maximum = 0;; 7340 Int_t minimum = 0;; 7341 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7342 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7343 ; 7344 // Compute X axis parameters; 7345 ; 7346 Int_t last = fXaxis->GetLast();; 7347 Int_t first = fXaxis->GetFirst();; 7348 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7349 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7350 Hparam.xlast = last;; 7351 Hparam.xfirst = first;; 7352 Hparam.ymin = Hparam.xlowedge;; 7353 Hparam.ymax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7354 ; 7355 // if log scale in Y, replace ymin,max by the log; 7356 if (Hoption.Logy) {; 7357 if (Hparam.xlowedge <=0 ) {; 7358 Hparam.xlowedge = 0.1*Hparam.xbinsize;; 7359 Hparam.ymin = Hparam.xlowedge;; 7360 }; 7361 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 7362 Error(where, ""cannot set Y axis to log scale"");; 7363 return 0;; 7364 }; 7365 Hparam.xfirst= fXaxis->FindFixBin(Hparam.ymin);; 7366 Hparam.xlast = fXaxis->FindFixBin(Hparam.ymax);; 7367 Hparam.ymin = TMath::Log10(Hparam.ymin);; 7368 Hparam.ymax = TMath::Log10(Hparam.ymax);; 7369 if (Hparam.xlast > last) Hparam.xlast = last;; 7370 }; 7371 ; 7372 // Compute Y axis parameters; 7373 Double_t bigp = TMath::Power(10,32);; 7374 Double_t xmax = -bigp;; 7375 Double_t xmin = bigp;; 7376 Double_t c1, e1;; 7377 Double_t xv[1];; 7378 Double_t fval;; 7379 Int_t i;; 7380 TObject *f;; 7381 TF1 *f1;; 7382 Double_t allchan = 0;; 7383 TIter next(fFunctions);; 7384 for (i=first; i<=last;i++) {; 7385 c1 = fH->GetBinContent(i);; 7386 xmax = TMath::Max(xma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:265741,log,log,265741,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['log'],['log']
Testability," 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 742",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:284147,test,testio,284147,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['test'],['testio']
Testability," 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7458/// \endcode; 7459 ; 7460Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7461{; 7462 ; 7463 if (fNew) return kTRUE;; 7464 ; 7465 if (HasInterpreterInfo()) {; 7466 R__LOCKGUARD(gInterpreterMutex);; 7467 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7468 }; 7469 if (fCollectionProxy) {; 7470 return kTRUE;; 7471 }; 7472 if (fCurrentInfo.load()) {; 7473 // Emulated class, we know how to construct them via the TStreamerInfo; 7474 return kTRUE;; 7475 }; 7476 return kFALSE;; 7477}; 7478 ; 7479////////////////////////////////////////////////////////////////////////////////; 7480/// Returns true if this class has an definition and/or overload of the; 7481/// member function Hash.; 7482///; 7483/// For example to test if the class overload TObject::Hash use; 7484/// ~~~ {.cpp}; 7485/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7486/// ~~~; 7487 ; 7488Bool_t TClass::HasLocalHashMember() const; 7489{; 7490 if (fProperty == (-1)); 7491 Property();; 7492 return TestBit(kHasLocalHashMember);; 7493}; 7494 ; 7495////////////////////////////////////////////////////////////////////////////////; 749",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:286898,test,testio,286898,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['test'],['testio']
Testability," 764 of file NeuralNet.h. ◆ setProgressLimits(). virtual void TMVA::DNN::Settings::setProgressLimits ; (; double ; minProgress = 0, . double ; maxProgress = 100 . ). inlinevirtual . Parameters. maxProgressfor monitoring and logging (set the current ""progress"" limits for the display of the progress); minProgressminimum value; maxProgressmaximum value . Definition at line 790 of file NeuralNet.h. ◆ startTestCycle(). virtual void TMVA::DNN::Settings::startTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. ◆ startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. ◆ startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. ◆ testIteration(). virtual void TMVA::DNN::Settings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 806 of file NeuralNet.h. ◆ testRepetitions(). size_t TMVA::DNN::Settings::testRepetitions ; (; ); const. inline . how often is the test data tested ; Definition at line 768 of file NeuralNet.h. ◆ testSample(). virtual void TMVA::DNN::Settings::testSample ; (; double ; , . double ; , . double ; , . double ;  . ). inlinevirtual . virtual function to be used for monitoring (callback) ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 781 of file NeuralNet.h. ◆ useMultithreading(). bool TMVA::DNN::Settings::useMultithreading ; (; ); const. inline . is multithreading turned on? ; Definition at line 815 of file NeuralNet.h. Member Data Documentation. ◆ count_dE. size_t TMVA::DNN::Settings::count_dE. Definition at line 843 of file NeuralNet.h. ◆ count_E. size_t TMVA::DNN::Settings::count_E. Definition at line 842 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:12269,test,testIteration,12269,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['test'],['testIteration']
Testability," 83 /**; 84 Construct from four Scalars representing the coefficients of u, i, j, k; 85 */; 86 Quaternion(Scalar u, Scalar i, Scalar j, Scalar k) :; 87 fU(u), fI(i), fJ(j), fK(k) { }; 88 ; 89 // The compiler-generated copy ctor, copy assignment, and dtor are OK.; 90 ; 91 /**; 92 Re-adjust components to eliminate small deviations from |Q| = 1; 93 orthonormality.; 94 */; 95 void Rectify();; 96 ; 97 /**; 98 Assign from another supported rotation type (see gv_detail::convert ); 99 */; 100 template <class OtherRotation>; 101 Quaternion & operator=( OtherRotation const & r ) {; 102 gv_detail::convert(r,*this);; 103 return *this;; 104 }; 105 ; 106 // ======== Components ==============; 107 ; 108 /**; 109 Set the four components given an iterator to the start of; 110 the desired data, and another to the end (4 past start).; 111 */; 112 template<class IT>; 113 void SetComponents(IT begin, IT end) {; 114 fU = *begin++;; 115 fI = *begin++;; 116 fJ = *begin++;; 117 fK = *begin++;; 118 (void)end;; 119 assert (end==begin);; 120 }; 121 ; 122 /**; 123 Get the components into data specified by an iterator begin; 124 and another to the end of the desired data (4 past start).; 125 */; 126 template<class IT>; 127 void GetComponents(IT begin, IT end) const {; 128 *begin++ = fU;; 129 *begin++ = fI;; 130 *begin++ = fJ;; 131 *begin++ = fK;; 132 (void)end;; 133 assert (end==begin);; 134 }; 135 ; 136 /**; 137 Get the components into data specified by an iterator begin; 138 */; 139 template<class IT>; 140 void GetComponents(IT begin ) const {; 141 *begin++ = fU;; 142 *begin++ = fI;; 143 *begin++ = fJ;; 144 *begin = fK;; 145 }; 146 ; 147 /**; 148 Set the components based on four Scalars. The sum of the squares of; 149 these Scalars should be 1; no checking is done.; 150 */; 151 void SetComponents(Scalar u, Scalar i, Scalar j, Scalar k) {; 152 fU=u; fI=i; fJ=j; fK=k;; 153 }; 154 ; 155 /**; 156 Get the components into four Scalars.; 157 */; 158 void GetComponents(Scalar & u, Scalar & i, Scalar & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html:3548,assert,assert,3548,doc/master/GenVector_2Quaternion_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html,1,['assert'],['assert']
Testability," 90 private:; 91 ; 92 gsl_multimin_function fFunc;; 93 ; 94 };; 95 ; 96 ; 97/**; 98 Wrapper for a multi-dimensional function with derivatives used in GSL multidim; 99 minimization algorithm; 100 ; 101 @ingroup MultiMin; 102 ; 103 */; 104 class GSLMultiMinDerivFunctionWrapper {; 105 ; 106 public:; 107 ; 108 GSLMultiMinDerivFunctionWrapper(); 109 {; 110 fFunc.f = nullptr;; 111 fFunc.df = nullptr;; 112 fFunc.fdf = nullptr;; 113 fFunc.n = 0;; 114 fFunc.params = nullptr;; 115 }; 116 ; 117 ; 118 void SetFuncPointer( GSLMultiMinFuncPointer f) { fFunc.f = f; }; 119 void SetDerivPointer( GSLMultiMinDfPointer f) { fFunc.df = f; }; 120 void SetFdfPointer( GSLMultiMinFdfPointer f) { fFunc.fdf = f; }; 121 void SetDim ( unsigned int n ) { fFunc.n = n; }; 122 void SetParams ( void * p) { fFunc.params = p; }; 123 ; 124 /// Fill gsl function structure from a C++ Function class; 125 template<class FuncType>; 126 void SetFunction(const FuncType &f) {; 127 const void * p = &f;; 128 assert (p != nullptr);; 129 SetFuncPointer(&GSLMultiMinFunctionAdapter<FuncType >::F);; 130 SetDerivPointer(&GSLMultiMinFunctionAdapter<FuncType >::Df);; 131 SetFdfPointer(&GSLMultiMinFunctionAdapter<FuncType >::Fdf);; 132 SetDim( f.NDim() );; 133 SetParams(const_cast<void *>(p));; 134 }; 135 ; 136 gsl_multimin_function_fdf * GetFunc() { return &fFunc; }; 137 ; 138#ifdef NEEDED_LATER; 139 // evaluate the function; 140 double operator() (const double * x) {; 141 // vx must be a gsl_vector; 142 return GSL_MULTIMIN_FN_EVAL(&fFunc, vx);; 143 }; 144#endif; 145 ; 146 /// check if function is valid (has been set); 147 bool IsValid() {; 148 return (fFunc.f != nullptr) ? true : false;; 149 }; 150 ; 151 private:; 152 ; 153 gsl_multimin_function_fdf fFunc;; 154 ; 155 };; 156 ; 157 ; 158 ; 159 ; 160} // namespace Math; 161} // namespace ROOT; 162 ; 163#endif /* ROOT_Math_GSLMultiMinFunctionWrapper */; GSLMultiMinFunctionAdapter.h; f#define f(i)Definition RSha256.hxx:104; pwinID h TVirtualViewer3D TVirtualGLPainter pDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiMinFunctionWrapper_8h_source.html:4011,assert,assert,4011,doc/master/GSLMultiMinFunctionWrapper_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiMinFunctionWrapper_8h_source.html,1,['assert'],['assert']
Testability," 970 continue;; 971 }; 972 ; 973 // Count the events after rejection due to cut or NaN value; 974 // (weighted and unweighted); 975 classEventCounts.nEvAfterCut++;; 976 classEventCounts.nWeEvAfterCut += weight;; 977 ; 978 // event accepted, fill temporary ntuple; 979 event_v.push_back(new Event(vars, tgts , vis, cl , weight));; 980 }; 981 }; 982 currentInfo.GetTree()->ResetBranchAddresses();; 983 }; 984 }; 985 ; 986 if (!nanInfWarnings.empty()) {; 987 Log() << kWARNING << ""Found events with NaN and/or +-inf values"" << Endl;; 988 for (const auto &warning : nanInfWarnings) {; 989 auto &log = Log() << kWARNING << warning.first;; 990 if (warning.second > 1) log << "" ("" << warning.second << "" times)"";; 991 log << Endl;; 992 }; 993 Log() << kWARNING << ""These NaN and/or +-infs were all removed by the specified cut, continuing."" << Endl;; 994 Log() << Endl;; 995 }; 996 ; 997 if (!nanInfErrors.empty()) {; 998 Log() << kWARNING << ""Found events with NaN and/or +-inf values (not removed by cut)"" << Endl;; 999 for (const auto &error : nanInfErrors) {; 1000 auto &log = Log() << kWARNING << error.first;; 1001 if (error.second > 1) log << "" ("" << error.second << "" times)"";; 1002 log << Endl;; 1003 }; 1004 Log() << kFATAL << ""How am I supposed to train a NaN or +-inf?!"" << Endl;; 1005 }; 1006 ; 1007 // for output format, get the maximum class name length; 1008 Int_t maxL = dsi.GetClassNameMaxLength();; 1009 ; 1010 Log() << kHEADER << Form(""[%s] : "",dsi.GetName()) << ""Number of events in input trees"" << Endl;; 1011 Log() << kDEBUG << ""(after possible flattening of arrays):"" << Endl;; 1012 ; 1013 ; 1014 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1015 Log() << kDEBUG //<< Form(""[%s] : "",dsi.GetName()); 1016 << "" ""; 1017 << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1018 << "" -- number of events : ""; 1019 << std::setw(5) << eventCounts[cl].nEvBeforeCut; 1020 << "" / sum of weights: "" << std::setw(5) << eventCounts[cl].nWeEvBeforeCut << Endl;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:42513,log,log,42513,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['log'],['log']
Testability," : Building event vectors for type 2 Background; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Likelihood_1_dsi] : Number of events in input trees; : Dataset[Category_Likelihood_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14212,test,testing,14212,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability," : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Fisher_2_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : Number of events in input trees; : Dataset[Category_Fisher_2_dsi] : Signal requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9642,test,testing,9642,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability, ; (; ). inline . Get SB histo RMS. ; Definition at line 84 of file HybridPlot.h. ◆ IsA(). TClass * RooStats::HybridPlot::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 121 of file HybridPlot.h. ◆ Streamer(). void RooStats::HybridPlot::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooStats::HybridPlot::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file HybridPlot.h. Member Data Documentation. ◆ fB_histo. TH1F* RooStats::HybridPlot::fB_histo. private . The b Histo. ; Definition at line 114 of file HybridPlot.h. ◆ fB_histo_shaded. TH1F* RooStats::HybridPlot::fB_histo_shaded. private . The b Histo shaded. ; Definition at line 115 of file HybridPlot.h. ◆ fData_testStat_line. TLine* RooStats::HybridPlot::fData_testStat_line. private . The line for the data value of the test statistic. ; Definition at line 116 of file HybridPlot.h. ◆ fLegend. TLegend* RooStats::HybridPlot::fLegend. private . The legend of the plot. ; Definition at line 117 of file HybridPlot.h. ◆ fPad. TVirtualPad* RooStats::HybridPlot::fPad. private . The pad where it has been drawn. ; Definition at line 118 of file HybridPlot.h. ◆ fSb_histo. TH1F* RooStats::HybridPlot::fSb_histo. private . The sb Histo. ; Definition at line 112 of file HybridPlot.h. ◆ fSb_histo_shaded. TH1F* RooStats::HybridPlot::fSb_histo_shaded. private . The sb Histo shaded. ; Definition at line 113 of file HybridPlot.h. ◆ fVerbose. bool RooStats::HybridPlot::fVerbose. private . verbosity flag ; Definition at line 119 of file HybridPlot.h. Libraries for RooStats::HybridPlot:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/HybridPlot.h; roofit/roostats/src/HybridPlot.cxx. RooStatsHybridPlot. ROOT master - Reference Guide Generated on Tue N,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html:18877,test,test,18877,doc/master/classRooStats_1_1HybridPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html,1,['test'],['test']
Testability," ; (; ). inline . Returns a pointer to the next element of the linked list or NULL if called on last(). ; If called on last() this method returns NULL. Otherwise it will return the option with the same Descriptor::index that follows this option on the command line. ; Definition at line 682 of file OptionParser.h. ◆ nextwrap(). Option * ROOT::option::Option::nextwrap ; (; ). inline . Returns a pointer to the next element of the linked list with wrap-around from last() to first(). ; If called on last() this method returns first(). Otherwise it will return the option with the same Descriptor::index that follows this option on the command line. ; Definition at line 695 of file OptionParser.h. ◆ operator const Option *(). ROOT::option::Option::operator const Option * ; (; ); const. inline . Casts from Option to const Option* but only if this Option is valid. ; If this Option is valid (i.e. desc!=NULL), returns this. Otherwise returns NULL. This allows testing an Option directly in an if-clause to see if it is used: if (options[CREATE]); {; ...; }; It also allows you to write loops like this: for (Option* opt = options[FILE]; opt; opt = opt->next()); fname = opt->arg; ... . Definition at line 736 of file OptionParser.h. ◆ operator Option *(). ROOT::option::Option::operator Option * ; (; ). inline . Casts from Option to Option* but only if this Option is valid. ; If this Option is valid (i.e. desc!=NULL), returns this. Otherwise returns NULL. This allows testing an Option directly in an if-clause to see if it is used: if (options[CREATE]); {; ...; }; It also allows you to write loops like this: for (Option* opt = options[FILE]; opt; opt = opt->next()); fname = opt->arg; ... . Definition at line 757 of file OptionParser.h. ◆ operator=(). Option & ROOT::option::Option::operator= ; (; const Option & ; orig). inline . Makes *this a copy of orig except for the linked list pointers. ; After this operation *this will be a one-element linked list. ; Definition at line 792 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1option_1_1Option.html:10050,test,testing,10050,doc/v632/classROOT_1_1option_1_1Option.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1option_1_1Option.html,2,['test'],['testing']
Testability," ; (; ). privatevirtual . define the options (their key words) that can be set in the option string ; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion ; Implements TMVA::MethodBase.; Definition at line 243 of file MethodLikelihood.cxx. ◆ DeclFileName(). static const char * TMVA::MethodLikelihood::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 154 of file MethodLikelihood.h. ◆ GetHelpMessage(). void TMVA::MethodLikelihood::GetHelpMessage ; (; ); const. protectedvirtual . get help message text ; typical length of text line: ""|--------------------------------------------------------------|"" ; Implements TMVA::IMethod.; Definition at line 997 of file MethodLikelihood.cxx. ◆ GetMvaValue(). Double_t TMVA::MethodLikelihood::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . returns the likelihood estimator for signal fill a new Likelihood branch into the testTree ; Implements TMVA::MethodBase.; Definition at line 453 of file MethodLikelihood.cxx. ◆ HasAnalysisType(). Bool_t TMVA::MethodLikelihood::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ; numberTargets . ). virtual . FDA can handle classification with 2 classes. ; Implements TMVA::IMethod.; Definition at line 216 of file MethodLikelihood.cxx. ◆ Init(). void TMVA::MethodLikelihood::Init ; (; void ; ). privatevirtual . default initialisation called by all constructors ; Implements TMVA::MethodBase.; Definition at line 226 of file MethodLikelihood.cxx. ◆ IsA(). virtual TClass * TMVA::MethodLikelihood::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::MethodBase.; Definition at line 154 of file MethodLikelihood.h. ◆ MakeClassSpecific(). void TMVA::MethodLikelihood::MakeClassSpecific ; (; std::ostream & ; fout, . const TString & ; className . ); const. protectedvirtual . wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:35779,test,testTree,35779,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['test'],['testTree']
Testability," ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemented.. ; Definition at line 87 of file OptimizeConfigParameters.h. ◆ fFOMvsIter. std::vector<Float_t> TMVA::OptimizeConfigParameters::fFOMvsIter. private . graph showing the development of the Figure Of Merit values during the fit ; Definition at line 83 of file OptimizeConfigParameters.h. ◆ fLogger. MsgLogger* TMVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D* TMVA::OptimizeConfigParameters::fMvaBkg. private . MVA distribution for bakgr. events, used for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMvaSig. private . MVA distribution for signal events, used for spline fit. ; Definition at line 89 of file OptimizeConfigParameters.h. ◆ fMvaSigFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaSigFineBin. private . MVA distribution for signal events. ; Definition at line 92 of file OptimizeConfigParameters.h. ◆ fNotDoneYet. Bool_t TMVA::OptimizeConfigParameters::fNotDone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:10967,log,logger,10967,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['log'],['logger']
Testability," ; (; const char * ; name = nullptr, . std::ostream & ; os = std::cout . ). static . Print all the default options including the extra one specific for a given minimizer name. ; If no minimizer name is given, all the extra default options, which have been set and configured will be printed ; Definition at line 244 of file MinimizerOptions.cxx. ◆ PrintLevel(). int ROOT::Math::MinimizerOptions::PrintLevel ; (; ); const. inline . non-static methods for retrieving options ; set print level ; Definition at line 174 of file MinimizerOptions.h. ◆ ResetToDefaultOptions(). void ROOT::Math::MinimizerOptions::ResetToDefaultOptions ; (; ). non-static methods for setting options ; Definition at line 174 of file MinimizerOptions.cxx. ◆ SetDefaultErrorDef(). void ROOT::Math::MinimizerOptions::SetDefaultErrorDef ; (; double ; up). static . Set the default level for computing the parameter errors. ; For example for 1-sigma parameter errors; up = 1 for a chi-squared function; up = 0.5 for a negative log-likelihood function. The value will be used also by Minos when computing the confidence interval ; Definition at line 51 of file MinimizerOptions.cxx. ◆ SetDefaultExtraOptions(). void ROOT::Math::MinimizerOptions::SetDefaultExtraOptions ; (; const IOptions * ; extraoptions). static . Set additional minimizer options as pair of (string,value). ; Extra option defaults can be configured for a specific algorithm and then if a matching with the correct option name exists it will be used whenever creating a new minimizer instance. For example for changing the default number of steps of the Genetic minimizer from 100 to 500 do auto extraOpt = ROOT::Math::MinimizerOptions::Default(""Genetic""); extraOpts.SetValue(""Steps"",500);; and when creating the Genetic minimizer you will have the new value for the option: auto gmin = ROOT::Math::Factory::CreateMinimizer(""Genetic"");; gmin->Options().Print();. Definition at line 79 of file MinimizerOptions.cxx. ◆ SetDefaultMaxFunctionCalls(). void ROOT::Math:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:10463,log,log-likelihood,10463,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['log'],['log-likelihood']
Testability," ; 163 fErrorType = kValueError;; 164 ; 165 if ( nullptr != ex || nullptr != ey || nullptr != ez ); 166 {; 167 fCoordErrorsPtr.resize( 3 );; 168 ; 169 fCoordErrorsPtr[0] = ex;; 170 fCoordErrorsPtr[1] = ey;; 171 fCoordErrorsPtr[2] = ez;; 172 ; 173 fErrorType = kCoordError;; 174 }; 175 }; 176 else; 177 {; 178 fErrorType = kNoError;; 179 }; 180 ; 181 fpTmpCoordErrorVector = new double [ fDim ];; 182 ComputeSums();; 183 }; 184 ; 185 /**; 186 destructor; 187 */; 188 BinData::~BinData(); 189 {; 190 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 191 ; 192 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 193 kAsymError == fErrorType || kNoError == fErrorType );; 194 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 195 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 196 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 197 assert( fMaxPoints == 0 || fDataErrorLow.empty() == fDataErrorHigh.empty() );; 198 assert( fMaxPoints == 0 || fData.empty() || &fData.front() == fDataPtr );; 199 ; 200 for ( unsigned int i=0; i < fDim; i++ ); 201 {; 202 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 203 }; 204 ; 205 if ( fpTmpBinEdgeVector ); 206 {; 207 delete[] fpTmpBinEdgeVector;; 208 fpTmpBinEdgeVector= nullptr;; 209 }; 210 ; 211 if ( fpTmpCoordErrorVector ); 212 {; 213 delete[] fpTmpCoordErrorVector;; 214 fpTmpCoordErrorVector = nullptr;; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:5596,assert,assert,5596,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosity) : fVerbosity(verbosity) {}; 114 ; 115 /// Construct a log channel given its name, which is part of the diagnostics.; 116 RLogChannel(const std::string &name) : fName(name) {}; 117 ; 118 ELogLevel SetVerbosity(ELogLevel verbosity); 119 {; 120 std::swap(fVerbosity, verbosity);; 121 return verbosity;; 122 }; 123 ELogLevel GetVerbosity() const { return fVerbosity; }; 124 ELogLevel GetEffectiveVerbosity(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:3305,log,log,3305,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['log'],['log']
Testability," ; 752 /*! \brief set the drop-out configuration (layer-wise); 753 *; 754 * \param begin begin of an array or vector denoting the drop-out probabilities for each layer; 755 * \param end end of an array or vector denoting the drop-out probabilities for each layer; 756 * \param _dropRepetitions denotes after how many repetitions the drop-out setting (which nodes are dropped out exactly) is changed; 757 */; 758 template <typename Iterator>; 759 void setDropOut (Iterator begin, Iterator end, size_t _dropRepetitions) { m_dropOut.assign (begin, end); m_dropRepetitions = _dropRepetitions; }; 760 ; 761 size_t dropRepetitions () const { return m_dropRepetitions; }; 762 const std::vector<double>& dropFractions () const { return m_dropOut; }; 763 ; 764 void setMonitoring (std::shared_ptr<Monitoring> ptrMonitoring) { fMonitoring = ptrMonitoring; } ///< prepared for monitoring; 765 ; 766 size_t convergenceSteps () const { return m_convergenceSteps; } ///< how many steps until training is deemed to have converged; 767 size_t batchSize () const { return m_batchSize; } ///< mini-batch size; 768 size_t testRepetitions () const { return m_testRepetitions; } ///< how often is the test data tested; 769 double factorWeightDecay () const { return m_factorWeightDecay; } ///< get the weight-decay factor; 770 ; 771 double learningRate () const { return fLearningRate; } ///< get the learning rate; 772 double momentum () const { return fMomentum; } ///< get the momentum (e.g. for SGD); 773 int repetitions () const { return fRepetitions; } ///< how many steps have to be gone until the batch is changed; 774 MinimizerType minimizerType () const { return fMinimizerType; } ///< which minimizer shall be used (e.g. SGD); 775 ; 776 ; 777 ; 778 ; 779 ; 780 ; 781 virtual void testSample (double /*error*/, double /*output*/, double /*target*/, double /*weight*/) {} ///< virtual function to be used for monitoring (callback); 782 virtual void startTrainCycle () ///< callback for monitoring and logging; 783",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:27629,test,testRepetitions,27629,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['test'],"['test', 'testRepetitions', 'tested']"
Testability," ; Implements RooStats::IntervalCalculator.; Definition at line 82 of file MCMCCalculator.h. ◆ SetupBasicUsage(). void MCMCCalculator::SetupBasicUsage ; (; ). protected . Constructor for automatic configuration with basic settings. ; Uses a UniformProposal, 10,000 iterations, 40 burn in steps, 50 bins for each RooRealVar, determines interval by histogram. Finds a 95% confidence interval. ; Definition at line 106 of file MCMCCalculator.cxx. ◆ SetUseKeys(). virtual void RooStats::MCMCCalculator::SetUseKeys ; (; bool ; useKeys). inlinevirtual . set whether to use kernel estimation to determine the interval ; Definition at line 106 of file MCMCCalculator.h. ◆ SetUseSparseHist(). virtual void RooStats::MCMCCalculator::SetUseSparseHist ; (; bool ; useSparseHist). inlinevirtual . set whether to use sparse histogram (if using histogram at all) ; Definition at line 108 of file MCMCCalculator.h. ◆ Size(). double RooStats::MCMCCalculator::Size ; (; ); const. inlineoverridevirtual . Get the size of the test (eg. rate of Type I error) ; Implements RooStats::IntervalCalculator.; Definition at line 48 of file MCMCCalculator.h. ◆ Streamer(). void RooStats::MCMCCalculator::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from RooStats::IntervalCalculator. ◆ StreamerNVirtual(). void RooStats::MCMCCalculator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 204 of file MCMCCalculator.h. Member Data Documentation. ◆ fAxes. RooArgList* RooStats::MCMCCalculator::fAxes. protected . which variables to put on each axis ; Definition at line 180 of file MCMCCalculator.h. ◆ fChainParams. RooArgSet RooStats::MCMCCalculator::fChainParams. protected . parameters to store in the chain (if not specified they are all of them ) ; Definition at line 169 of file MCMCCalculator.h. ◆ fConditionalObs. RooArgSet RooStats::MCMCCalculator::fConditionalObs. protected . conditional observables ; Definition at line 170 of file MCMCCalculator.h. ◆ fData. Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html:27550,test,test,27550,doc/master/classRooStats_1_1MCMCCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html,1,['test'],['test']
Testability," ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TMVA::Timer Class ReferenceTMVA. ; Timing information for training and evaluation of MVA methods. ; Usage:; TMVA::gConfig().SetDrawProgressBar(true);; ; TMVA::Timer timer( Nloops, ""MyClassName"" );; for (Int_t i=0; i<Nloops; i++) {; ... // some code; ; // now, print progress bar:; timer.DrawProgressBar( i );; ; // **OR** text output of left time (never both !); fLogger << "" time left: "" << timer.GetLeftTime( i ) << Endl;; ; }; fLogger << ""MyClassName"" << "": elapsed time: "" << timer.GetElapsedTime(); << Endl;; TMVA::Config::SetDrawProgressBarvoid SetDrawProgressBar(Bool_t d)Definition Config.h:69; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::fLoggerMsgLogger * fLogger! the output loggerDefinition Timer.h:96; int; TMVA::gConfigConfig & gConfig(); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; Remark: in batch mode, the progress bar is quite ugly; you may want to use the text output then; Note that by default in TMVA::Config the drawing of the progress bar is switched off. To have the progress bar visible you need to enable it by calling TMVA::gConfig().SetDrawProgressBar(true) ; Definition at line 58 of file Timer.h. Public Member Functions;  Timer (const char *prefix="""", Bool_t colourfulOutput=kTRUE);  constructor ;  ;  Timer (Int_t ncounts, const char *prefix="""", Bool_t colourfulOutput=kTRUE);  standard constructor: ncounts gives the total number of counts that the loop will iterate through. ;  ; virtual ~Timer (void);  destructor ;  ; void DrawProgressBar (Int_t, const TString &comment="""");  draws progress bar in color or B&W caution: ;  ; void DrawProgressBar (TString);  draws a string in the progress bar ;  ; void Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:1054,log,loggerDefinition,1054,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,1,['log'],['loggerDefinition']
Testability," ; RooCachedReal P.d.f class that wraps another p.d.f and caches its output ; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit ; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for use in RooPlots; RooCustomizer Editing tool for RooAbsArg composite object expressions; RooDLLSignificanceMCSModule MCStudy module to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f ; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:31713,log,log,31713,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['log'],"['log', 'logL']"
Testability," ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::LogInterval Interval definition, continous and discrete; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA_Index.html:1905,Log,LogInterval,1905,root/html534/TMVA_Index.html,https://root.cern,https://root.cern/root/html534/TMVA_Index.html,1,['Log'],['LogInterval']
Testability," ; TMVA::ROCCalc Class ReferenceTMVA. . Definition at line 20 of file ROCCalc.h. Public Member Functions;  ROCCalc (TH1 *mvaS, TH1 *mvaB);  ;  ~ROCCalc ();  destructor ;  ; void ApplySignalAndBackgroundStyle (TH1 *sig, TH1 *bkg, TH1 *any=nullptr);  ; Double_t GetEffSForEffBof (Double_t effBref, Double_t &effSerr);  get the signal efficiency for a particular background efficiency that will be the value of the efficiency retured (does not affect the efficiency-vs-bkg plot which is done anyway. ;  ; TH1 * GetMvaBpdf ();  ; TH1 * GetMvaSpdf ();  ; TH1 * GetPurity (Int_t nStot, Int_t nBtot);  ; TH1D * GetROC ();  get the ROC curve ;  ; Double_t GetROCIntegral ();  code to compute the area under the ROC ( rej-vs-eff ) curve ;  ; Double_t GetSignalReferenceCut ();  ; TH1 * GetSignificance (Int_t nStot, Int_t nBtot);  ; Bool_t GetStatus ();  ; void ResetStatus ();  . Private Member Functions; Double_t GetEffForRoot (Double_t theCut);  returns efficiency as function of cut ;  ; MsgLogger & Log () const;  message logger ;  ; Double_t Root (Double_t);  Root finding using Brents algorithm; taken from CERNLIB function RZERO. ;  . Private Attributes; TH1D * effBvsS;  ; Double_t fAbsTol;  absolute tolerance deviation ;  ; Int_t fCutOrientation;  +1 if larger mva value means more signal like, -1 otherwise ;  ; MsgLogger * fLogger;  ; Int_t fMaxIter;  maximum number of iterations ;  ; TH1 * fmvaB;  the input mva distributions ;  ; TH1 * fmvaBcumul;  ; TH1 * fmvaBpdf;  the normalized (and rebinned) input mva distributions ;  ; TH1 * fmvaS;  ; TH1 * fmvaScumul;  ; TH1 * fmvaSpdf;  ; UInt_t fNbins;  ; Int_t fnBtot;  ; Double_t fNevtS;  number of signal events (used in error calculation) ;  ; Int_t fnStot;  ; TH1 * fPurity;  ; Double_t fSignalCut;  MVA cut value for last demanded background rejection or signal efficiency. ;  ; TH1 * fSignificance;  ; TSpline * fSplB;  ; TSpline * fSpleffBvsS;  ; TSpline * fSplmvaCumB;  spline of cumulated mva distributions ;  ; TSpline * fSplmvaCumS;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ROCCalc.html:1258,log,logger,1258,doc/master/classTMVA_1_1ROCCalc.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ROCCalc.html,1,['log'],['logger']
Testability," ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46170,test,testing,46170,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['testing']
Testability," ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0529 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0218 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.249 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00679 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:53777,test,testing,53777,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['test'],['testing']
Testability," ; The difference in the -log(L) of those two fits can be interpreted as the probability that a statistical background fluctation may result in a signal as large or larger than the signal observed. This interpretation is contingent on underlying normal sampling distributions and a MC study is a good way to test that assumption. ; Definition at line 23 of file RooDLLSignificanceMCSModule.h. Public Member Functions;  RooDLLSignificanceMCSModule (const char *parName, double nullHypoValue=0.0);  Constructor of module with parameter name to be interpreted as nSignal and the value of the null hypothesis for nSignal (usually zero) ;  ;  RooDLLSignificanceMCSModule (const RooDLLSignificanceMCSModule &other);  Copy constructor. ;  ;  RooDLLSignificanceMCSModule (const RooRealVar &param, double nullHypoValue=0.0);  Constructor of module with parameter to be interpreted as nSignal and the value of the null hypothesis for nSignal (usually zero) ;  ;  ~RooDLLSignificanceMCSModule () override;  ; RooDataSet * finalizeRun () override;  Return auxiliary dataset with results of delta(-log(L)) calculations of this module so that it is merged with RooMCStudy::fitParDataSet() by RooMCStudy. ;  ; bool initializeInstance () override;  Initialize module after attachment to RooMCStudy object. ;  ; bool initializeRun (Int_t) override;  Initialize module at beginning of RooCMStudy run. ;  ; TClass * IsA () const override;  ; bool processAfterFit (Int_t) override;  Save likelihood from nominal fit, fix chosen parameter to its null hypothesis value and rerun fit Save difference in likelihood and associated Gaussian significance in auxiliary dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDLLSignificanceMCSModule.html:1637,log,log,1637,doc/master/classRooDLLSignificanceMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooDLLSignificanceMCSModule.html,1,['log'],['log']
Testability, ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 270; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-810.184) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.701119 a1=-0.376392 mean=4.96099 nbkg=126.85 nsig=153.527 sig1frac=0.880449; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-845.198) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.74363 a1=-0.435344 mean=5.01952 nbkg=162.467 nsig=143.571 sig1frac=0.630815; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 260; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 250; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-1003.82) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.674666 a1=-0.383697 mean=5.00365 nbkg=169.829 nsig=179.534 sig1frac=0.921743; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-712.949) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.711808 a1=-0.34088 mean=4.99573 nbkg=115.49 nsig=133.015 sig1frac=0.908627; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 240; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 230; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 220; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 210; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 200; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 190; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 180; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 170; [#0] PROGRESS:Gener,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:23051,log,log,23051,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability," ; p16 = 3.34535 +/- 0.0786714 ; p17 = 662.552 +/- 17.8619 ; p18 = 539.268 +/- 0.122694 ; p19 = 4.56069 +/- 0.113882 ; p20 = 659.417 +/- 16.1804 ; p21 = 948.476 +/- 0.101982 ; p22 = 4.41156 +/- 0.091998 ; p23 = 753.529 +/- 15.2593 ; p24 = 232.585 +/- 0.151403 ; p25 = 6.95019 +/- 0.122555 ; p26 = 645.477 +/- 17.9858 ; p27 = 286.947 +/- 0.140814 ; p28 = 4.98705 +/- 0.133049 ; . ; #include ""TCanvas.h""; #include ""TMath.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TRandom.h""; #include ""TSpectrum.h""; #include ""TVirtualFitter.h""; ; //; // Comment out the line below, if you want ""peaks' heights"".; // Uncomment the line below, if you want ""peaks' areas"".; //; // #define __PEAKS_C_FIT_AREAS__ 1 /* fit peaks' areas */; ; Int_t npeaks = 30;; Double_t fpeaks(Double_t *x, Double_t *par) {; Double_t result = par[0] + par[1]*x[0];; for (Int_t p=0;p<npeaks;p++) {; Double_t norm = par[3*p+2]; // ""height"" or ""area""; Double_t mean = par[3*p+3];; Double_t sigma = par[3*p+4];; #if defined(__PEAKS_C_FIT_AREAS__); norm /= sigma * (TMath::Sqrt(TMath::TwoPi())); // ""area""; #endif /* defined(__PEAKS_C_FIT_AREAS__) */; result += norm*TMath::Gaus(x[0],mean,sigma);; }; return result;; }; void peaks(Int_t np=10) {; npeaks = TMath::Abs(np);; TH1F *h = new TH1F(""h"",""test"",500,0,1000);; // Generate n peaks at random; Double_t par[3000];; par[0] = 0.8;; par[1] = -0.6/1000;; Int_t p;; for (p=0;p<npeaks;p++) {; par[3*p+2] = 1; // ""height""; par[3*p+3] = 10+gRandom->Rndm()*980; // ""mean""; par[3*p+4] = 3+2*gRandom->Rndm(); // ""sigma""; #if defined(__PEAKS_C_FIT_AREAS__); par[3*p+2] *= par[3*p+4] * (TMath::Sqrt(TMath::TwoPi())); // ""area""; #endif /* defined(__PEAKS_C_FIT_AREAS__) */; }; TF1 *f = new TF1(""f"",fpeaks,0,1000,2+3*npeaks);; f->SetNpx(1000);; f->SetParameters(par);; TCanvas *c1 = new TCanvas(""c1"",""c1"",10,10,1000,900);; c1->Divide(1,2);; c1->cd(1);; h->FillRandom(""f"",200000);; h->Draw();; TH1F *h2 = (TH1F*)h->Clone(""h2"");; // Use TSpectrum to find the peak candidates; TSpectrum *s = new TSpect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/peaks_8C.html:2954,test,test,2954,doc/master/peaks_8C.html,https://root.cern,https://root.cern/doc/master/peaks_8C.html,1,['test'],['test']
Testability," ; return of()->asCATLV(of()->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return of()->asCATFUNC(of()->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return of()->asSET(of()->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return of()->asLIST(of()->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return of()->asDATA(of()->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return of()->asDHIST(of()->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return of()->asDSET(of()->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return of()->asOBJ(of()->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return of()->asSTRING(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. const char* autoClassNamePostFix() const; { return _autoClassPostFix.c_str() ; }. void setAutoClassNamePostFix(const char* pfix); { _autoClassPostFix = pfix ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Mon Jul 4 15:22:49 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFactoryWSTool.html:24729,log,logError,24729,root/html530/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html530/RooFactoryWSTool.html,1,['log'],['logError']
Testability," ; return of()->asCATLV(of()->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return of()->asCATFUNC(of()->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return of()->asSET(of()->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return of()->asLIST(of()->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return of()->asDATA(of()->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return of()->asDHIST(of()->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return of()->asDSET(of()->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return of()->asOBJ(of()->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return of()->asSTRING(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. const char* autoClassNamePostFix() const; { return _autoClassPostFix.c_str() ; }. void setAutoClassNamePostFix(const char* pfix); { _autoClassPostFix = pfix ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Thu Nov 3 20:08:07 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFactoryWSTool.html:24729,log,logError,24729,root/html532/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html532/RooFactoryWSTool.html,2,['log'],['logError']
Testability," ; return of()->asCATLV(of()->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return of()->asCATFUNC(of()->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return of()->asSET(of()->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return of()->asLIST(of()->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return of()->asDATA(of()->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return of()->asDHIST(of()->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return of()->asDSET(of()->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return of()->asOBJ(of()->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return of()->asSTRING(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. const char* autoClassNamePostFix() const; { return _autoClassPostFix.c_str() ; }. void setAutoClassNamePostFix(const char* pfix); { _autoClassPostFix = pfix ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Tue Jun 2 15:30:48 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooFactoryWSTool.html:25710,log,logError,25710,root/html604/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html604/RooFactoryWSTool.html,2,['log'],['logError']
Testability," ; selectiona text formula selecting which entries to scan ; firstentryfirst entry to scan ; nentriestotal number of entries to scan (starting from firstentry). Defaults to all entries. . ReturnsThe function returns the number of entries passing the selection.; By default 50 lines are shown and you are asked for <CR> or q to see the next 50 lines. Depending on the Tree structure, one entry might be printed across several lines, distinguished by the Instance column. You can change the default number of lines to be shown before <CR> or q via mytree->SetScanField(maxlines) where maxlines is 50 by default. If maxlines is set to 0 all entries of the Tree are shown, and you are not prompted to press <CR> or q to end the loop.; This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line. . with ROOT 5; root [0] tree->SetScanField(0);; root [1] tree->Scan(""*""); >tree.log; ; with ROOT 6; root [0] tree->SetScanField(0);; root [1] .> tree.log; tree->Scan(""*"");; .>; will create a file tree.log; Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchronized. For example print arr1[4][2] and arr2[2][3] will results in a printing similar to: ***********************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; However, if there is a selection criterion which is an array, then all the formulas will be synchronized with the selection criterion (see TTreePlayer::DrawSelect for more information).; Parameters. optionThe options string can contains the following parameters:. lenmax=dd Where 'dd' is the maximum number of elements per ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:46567,log,log,46567,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['log'],['log']
Testability," ; static voidTObject::SetDtorOnly(void* obj); voidTGeoNode::SetFWExtension(TGeoExtension* ext); voidTGeoNode::SetInvisible()MENU ; voidSetMatrix(const TGeoMatrix* matrix); voidTGeoNode::SetMotherVolume(TGeoVolume* mother); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidTGeoNode::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoAtt::SetOptimization(Option_t* option); voidTGeoNode::SetOverlapping(Bool_t flag = kTRUE); voidTGeoNode::SetOverlaps(Int_t* ovlp, Int_t novlp); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidTGeoNode::SetUserExtension(TGeoExtension* ext); voidTGeoNode::SetVirtual(); voidTGeoAtt::SetVisBranch(); virtual voidTGeoAtt::SetVisContainers(Bool_t flag = kTRUE); voidTGeoAtt::SetVisDaughters(Bool_t vis = kTRUE); virtual voidTGeoNode::SetVisibility(Bool_t vis = kTRUE)MENU ; virtual voidTGeoAtt::SetVisLeaves(Bool_t flag = kTRUE); virtual voidTGeoAtt::SetVisOnly(Bool_t flag = kTRUE); voidTGeoAtt::SetVisRaytrace(Bool_t flag = kTRUE); voidTGeoAtt::SetVisStreamed(Bool_t vis = kTRUE); voidTGeoAtt::SetVisTouched(Bool_t vis = kTRUE); voidTGeoNode::SetVolume(TGeoVolume* volume); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTGeoAtt::TestAttBit(UInt_t f) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); voidTGeoNode::VisibleDaughters(Bool_t vis = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNodeMatrix.html:8418,Test,TestAttBit,8418,root/html534/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html534/TGeoNodeMatrix.html,3,['Test'],"['TestAttBit', 'TestBit', 'TestBits']"
Testability," ; virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPave::SetName(const char* name = """")MENU ; static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPave::SetOption(Option_t* option = ""br""); virtual voidTPave::SetShadowColor(Int_t color)MENU ; virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTBox::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBox::SetX1(Double_t x1); virtual voidTPave::SetX1NDC(Double_t x1); virtual voidTBox::SetX2(Double_t x2); virtual voidTPave::SetX2NDC(Double_t x2); virtual voidTBox::SetY1(Double_t y1); virtual voidTPave::SetY1NDC(Double_t y1); virtual voidTBox::SetY2(Double_t y2); virtual voidTPave::SetY2NDC(Double_t y2); virtual voidShowClassesUsedBy(const char* classes = ""this"")MENU ; virtual voidShowClassesUsing(const char* classes = ""this"")MENU ; virtual voidShowLinks(Option_t* option = ""HMR"")MENU ; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPaveClass.html:9277,Test,TestBit,9277,root/html532/TPaveClass.html,https://root.cern,https://root.cern/root/html532/TPaveClass.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTGraph::SetMaximum(Double_t maximum = -1111)MENU ; virtual voidTGraph::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjectX(TObject* obj); virtual voidSetObjectY(TObject* obj); virtual voidTGraph::SetPoint(Int_t i, Double_t x, Double_t y); virtual voidTGraph::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVarX(const char* varx)MENU ; virtual voidSetVarY(const char* vary)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTGraph::Sort(Bool_t(*)(const TGraph*,Int_t,Int_t) greater = &TGraph::CompareX, Bool_t ascending = kTRUE, Int_t low = 0, Int_t high = -1111); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCutG(); TCutG(const TCutG& cutg); TCutG(const char* name, Int_t n); TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCutG.html:13684,Test,TestBit,13684,root/html602/TCutG.html,https://root.cern,https://root.cern/root/html602/TCutG.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; Optimisation interface; These functions allow RooFit to optimise a computation graph, to keep track of cached values, and to invalidate caches. . virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:21736,test,test,21736,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['test'],['test']
Testability," ;  ; TH1D & operator= (const TH1D &h1);  Operator =. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:12037,test,test,12037,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['test'],['test']
Testability," ;  ; TNeuron * GetInputNeuron (Int_t index);  ; Double_t GetNetworkOutput ();  ; TNeuron * GetOutputNeuron (Int_t index=0);  ; Int_t NumCycles ();  ; std::vector< Int_t > * ParseLayoutString (TString layerSpec);  parse layout specification string and return a vector, each entry containing the number of neurons to go in each successive layer ;  ; void PrintMessage (TString message, Bool_t force=kFALSE) const;  print messages, turn off printing by setting verbose and debug flag appropriately ;  ; void WaitForKeyboard ();  wait for keyboard input, for debugging ;  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVarName (Int_t ivar) const;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the current Data type ;  ; const TString & GetOriginalVarName (Int_t ivar) const;  ; const TString & GetWeightFileDir () const;  ; Bool_t HasTrainingTree () const;  ; Bool_t Help () const;  ; Bool_t IgnoreEventsWithNegWeightsInTraining () const;  ; Bool_t IsConstructedFromWeightFile () const;  ; Bool_t IsNormalised () const;  ; virtual void MakeClassSpecificHeader (std::ostream &, const TString &="""") const;  ; void NoErrorCalc (Double_t *const err, Double_t *const errUpper);  ; void SetNormalised (Bool_t norm);  ; void SetWeightFileDir (TString fileDir);  set directory of weight file ;  ; void SetWeightFileName (TString);  set the weight file name (depreciated) ;  ; void Statistics (Types::ETreeType treeType, const TString &theVarName, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &);  calculates rms,mean, xmin, xmax of the event variable this can be either done for the variables as they are or for normalise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:28962,log,logProgress,28962,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['log'],['logProgress']
Testability," ;  ; constexpr Double_t Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; Double_t Max (Double_t a, Double_t b);  Returns the largest of a and b. ;  ; Float_t Max (Float_t a, Float_t b);  Returns the largest of a and b. ;  ; Int_t Max (Int_t a, Int_t b);  Returns the largest of a and b. ;  ; Long64_t Max (Long64_t a, Long64_t b);  Returns the largest of a and b. ;  ; Long_t Max (Long_t a, Long_t b);  Returns the largest of a and b. ;  ; Short_t Max (Short_t a, Short_t b);  Returns the largest of a and b. ;  ; UInt_t Max (UInt_t a, UInt_t b);  Returns the largest of a and b. ;  ; ULong64_t Max (ULong64_t a, ULong64_t b);  Returns the largest of a and b. ;  ; ULong_t Max (ULong_t a, ULong_t b);  Returns the largest of a and b. ;  ; UShort_t Max (UShort_t a, UShort_t b);  Returns the largest of a and b. ;  ; template<typename T > ; T MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:12820,log,log,12820,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,2,['log'],['log']
Testability," ;  ; virtual TString GetExpFormula (Option_t *option="""") const;  ; virtual TFormula * GetFormula ();  ; virtual const TFormula * GetFormula () const;  ; virtual TH1 * GetHistogram () const;  Return a pointer to the histogram used to visualise the function Note that this histogram is managed by the function and in same case it is automatically deleted when some TF1 functions are called such as TF1::SetParameters, TF1::SetNpx, TF1::SetRange It is then reccomended either to clone the return object or calling again teh GetHistogram function whenever is needed. ;  ; virtual const TObject * GetLinearPart (Int_t i) const;  ; virtual Double_t GetMaximum (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const;  Returns the maximum value of the function. ;  ; virtual Double_t GetMaximumStored () const;  ; virtual Double_t GetMaximumX (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const;  Returns the X value corresponding to the maximum value of the function. ;  ; TMethodCall * GetMethodCall () const;  ; virtual Double_t GetMinimum (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const;  Returns the minimum value of the function on the (xmin, xmax) interval. ;  ; virtual Double_t GetMinimumStored () const;  ; virtual Double_t GetMinimumX (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const;  Returns the X value corresponding to the minimum value of the function on the (xmin, xmax) interval. ;  ; virtual Int_t GetNDF () const;  Return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit. ;  ; virtual Int_t GetNdim () const;  ; virtual Int_t GetNpar () const;  ; virtual Int_t GetNpx () const;  ; virtual Int_t GetNumber () const;  ; virtual Int_t GetNumberFitPoints () const;  ; virtual Int_t GetNumberFreeParameters () const;  Return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:17666,log,logx,17666,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,2,['log'],['logx']
Testability," ;  ; void DivideTrainingSet (UInt_t blockNum);  divide training set ;  ; void EventResult (Bool_t successful, Long64_t evtNumber=-1);  increase the importance sampling weight of the event when not successful and decrease it when successful ;  ; Types::ETreeType GetCurrentType () const;  ; const Event * GetEvent () const;  returns event without transformations ;  ; const Event * GetEvent (Long64_t ievt) const;  ; const Event * GetEvent (Long64_t ievt, Types::ETreeType type) const;  ; const std::vector< Event * > & GetEventCollection (Types::ETreeType type=Types::kMaxTreeType) const;  ; const TTree * GetEventCollectionAsTree ();  ; Long64_t GetNClassEvents (Int_t type, UInt_t classNumber);  ; Long64_t GetNEvents (Types::ETreeType type=Types::kMaxTreeType) const;  ; Long64_t GetNEvtBkgdTest ();  return number of background test events in dataset ;  ; Long64_t GetNEvtBkgdTrain ();  return number of b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:1924,test,test,1924,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['test'],['test']
Testability," ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH2. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:11909,test,test,11909,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,2,['test'],['test']
Testability," ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH3. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:11107,test,test,11107,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,2,['test'],['test']
Testability," ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::unique_ptr< RooRatio > makeRatio (const char *name, const char *title, RooArgList &nr, RooArgList &dr);  Return the RooRatio form of products and denominators of morphing functions. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:56471,log,logging,56471,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['log'],['logging']
Testability," ;  ;  Protected Member Functions inherited from RooAbsTestStatistic; double evaluate () const override;  Calculate and return value of test statistic. ;  ; virtual double getCarry () const;  ; bool initialize ();  One-time initialization of the test statistic. ;  ; void initMPMode (RooAbsReal *real, RooAbsData *data, const RooArgSet *projDeps, std::string const &rangeName, std::string const &addCoefRangeName);  Initialize multi-processor calculation mode. ;  ; void initSimMode (RooSimultaneous *pdf, RooAbsData *data, const RooArgSet *projDeps, std::string const &rangeName, std::string const &addCoefRangeName);  Initialize simultaneous p.d.f processing mode. ;  ; Int_t numSets () const;  ; void printCompactTreeHook (std::ostream &os, const char *indent="""") override;  Add extra information on component test statistics when printing itself as part of a tree structure. ;  ; virtual bool processEmptyDataSets () const;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Forward server redirect calls to component test statistics. ;  ; void setEventCount (Int_t nEvents);  ; void setMPSet (Int_t setNum, Int_t numSets);  Set MultiProcessor set number identification of this instance. ;  ; Int_t setNum () const;  ; void setSimCount (Int_t simCount);  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:52705,test,test,52705,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['test'],['test']
Testability," ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ;  rootalias.CDefines aliases: ;  rootenv.CProduce a picture of the ROOT environment ;  rootlogoff.CExample of rootlogoff.C ;  rootlogon.CExample of rootlogon.C ;  rootmarks.CPrints a summary of all ROOT benchmarks (must be run before) ;  tasks.CExample of TTasks . ROOT 6.16/01 - Reference Guide Generated on Sun Dec 19 2021 22:33:59 (GVA Time) using Doxygen 1.9.3 (234637167bd5d39d32bf51f755d58253441f123a). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:174667,benchmark,benchmarks,174667,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['benchmark'],['benchmarks']
Testability," ;; 263 ; 264 virtual RooAbsGenContext* autoGenContext(const RooArgSet &vars, const RooDataSet* prototype=nullptr, const RooArgSet* auxProto=nullptr,; 265 bool verbose=false, bool autoBinned=true, const char* binnedTag="""") const ;; 266 ; 267 std::unique_ptr<RooAbsArg> compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext & ctx) const override;; 268 ; 269private:; 270 ; 271 std::unique_ptr<RooDataSet> generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype,; 272 double nEvents, bool verbose, bool randProtoOrder, bool resampleProto, bool skipInit=false,; 273 bool extended=false) const ;; 274 ; 275 // Implementation version; 276 virtual RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, bool showConstants=false,; 277 const char *label= """", double xmin=0.65,; 278 double xmax= 0.99,double ymax=0.95, const RooCmdArg* formatCmd=nullptr) ;; 279 ; 280 void logBatchComputationErrors(std::span<const double>& outputs, std::size_t begin) const;; 281 bool traceEvalPdf(double value) const;; 282 ; 283 /// Setter for the _normSet member, which should never be set directly.; 284 inline void setActiveNormSet(RooArgSet const* normSet) const {; 285 _normSet = normSet;; 286 // Also store the unique ID of the _normSet. This makes it possible to; 287 // detect if the pointer was invalidated.; 288 _normSetId = RooFit::getUniqueId(normSet);; 289 }; 290 ; 291protected:; 292 ; 293 virtual std::unique_ptr<RooAbsReal> createNLLImpl(RooAbsData& data, const RooLinkedList& cmdList);; 294 virtual std::unique_ptr<RooFitResult> fitToImpl(RooAbsData& data, const RooLinkedList& cmdList);; 295 ; 296 /// Checks if `normSet` is the currently active normalization set of this; 297 /// PDF, meaning is exactly the same object as the one the `_normSet` member; 298 /// points to (or both are `nullptr`).; 299 inline bool isActiveNormSet(RooArgSet const* normSet) const {; 300 return RooFit::getUniqueId(normSet).value() == _normSetId;; 301 }; 302 ; 303 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:13797,log,logBatchComputationErrors,13797,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['log'],['logBatchComputationErrors']
Testability," << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from RooResolutionModel; RooFormulaVar * _basis = nullptr;  Basis function convolved with this resolution model. ;  ; Int_t _basisCode;  Identifier code for selected basis function. ;  ; bool _ownBasis;  Flag indicating ownership of _basis. ;  ; RooTemplateProxy< RooAbsRealLValue > x;  Dependent/convolution variable. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:72105,test,testArg,72105,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,4,['test'],['testArg']
Testability," << kDEBUG //<< Form(""[%s] : "",dsi.GetName()); 1016 << "" ""; 1017 << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1018 << "" -- number of events : ""; 1019 << std::setw(5) << eventCounts[cl].nEvBeforeCut; 1020 << "" / sum of weights: "" << std::setw(5) << eventCounts[cl].nWeEvBeforeCut << Endl;; 1021 }; 1022 ; 1023 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1024 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1025 << "" "" << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1026 <<"" tree -- total number of entries: ""; 1027 << std::setw(5) << dataInput.GetEntries(dsi.GetClassInfo(cl)->GetName()) << Endl;; 1028 }; 1029 ; 1030 if (fScaleWithPreselEff); 1031 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1032 << ""\tPreselection: (will affect number of requested training and testing events)"" << Endl;; 1033 else; 1034 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1035 << ""\tPreselection: (will NOT affect number of requested training and testing events)"" << Endl;; 1036 ; 1037 if (dsi.HasCuts()) {; 1038 for (UInt_t cl = 0; cl< dsi.GetNClasses(); cl++) {; 1039 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" "" << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1040 << "" requirement: \"""" << dsi.GetClassInfo(cl)->GetCut() << ""\"""" << Endl;; 1041 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" ""; 1042 << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1043 << "" -- number of events passed: ""; 1044 << std::setw(5) << eventCounts[cl].nEvAfterCut; 1045 << "" / sum of weights: "" << std::setw(5) << eventCounts[cl].nWeEvAfterCut << Endl;; 1046 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" ""; 1047 << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1048 << "" -- efficiency : ""; 1049 << std::setw(6) << eventCounts[cl].nWeEvAfterCut/eventCounts[cl].nWeEvBeforeCut << Endl;; 1050 }; 1051 }; 1052",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:44142,test,testing,44142,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testing']
Testability," << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kINFO << Endl;; 1692 ; 1693 // for information purposes; 1694 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1695 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1696 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1697 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1698 ; 1699 ; 1700}; Configurable.h; DataInputHandler.h; DataSetFactory.h; DataSetInfo.h; DataSet.h; Event.h; MsgLogger.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TBranch.h; TEventList.h; TFile.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:79351,test,testingSumSignalWeights,79351,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testingSumSignalWeights']
Testability," <atomic>; 42 ; 43#include ""RtypesCore.h""; 44 ; 45#include ""TString.h""; 46 ; 47namespace TMVA {; 48 ; 49 typedef UInt_t TMVAVersion_t;; 50 ; 51 class MsgLogger;; 52 ; 53 // message types for MsgLogger; 54 // define outside of Types class to facilite access; 55 enum EMsgType {; 56 kDEBUG = 1,; 57 kVERBOSE = 2,; 58 kINFO = 3,; 59 kWARNING = 4,; 60 kERROR = 5,; 61 kFATAL = 6,; 62 kSILENT = 7,; 63 kHEADER = 8; 64 };; 65 ; 66 enum HistType { kMVAType = 0, kProbaType = 1, kRarityType = 2, kCompareType = 3 };; 67 ; 68 //Variable Importance type; 69 enum VIType {kShort=0,kAll=1,kRandom=2};; 70 ; 71 class Types {; 72 ; 73 public:; 74 ; 75 // available MVA methods; 76 enum EMVA {; 77 kVariable = 0,; 78 kCuts ,; 79 kLikelihood ,; 80 kPDERS ,; 81 kHMatrix ,; 82 kFisher ,; 83 kKNN ,; 84 kCFMlpANN ,; 85 kTMlpANN ,; 86 kBDT ,; 87 kDT ,; 88 kRuleFit ,; 89 kSVM ,; 90 kMLP ,; 91 kBayesClassifier,; 92 kFDA ,; 93 kBoost ,; 94 kPDEFoam ,; 95 kLD ,; 96 kPlugins ,; 97 kCategory ,; 98 kDNN ,; 99 kDL ,; 100 kPyRandomForest ,; 101 kPyAdaBoost ,; 102 kPyGTB ,; 103 kPyKeras ,; 104 kPyTorch ,; 105 kC50 ,; 106 kRSNNS ,; 107 kRSVM ,; 108 kRXGB ,; 109 kCrossValidation,; 110 kMaxMethod; 111 };; 112 ; 113 // available variable transformations; 114 enum EVariableTransform {; 115 kIdentity = 0,; 116 kDecorrelated,; 117 kNormalized,; 118 kPCA,; 119 kRearranged,; 120 kGauss,; 121 kUniform,; 122 kMaxVariableTransform; 123 };; 124 ; 125 // type of analysis; 126 enum EAnalysisType {; 127 kClassification = 0,; 128 kRegression,; 129 kMulticlass,; 130 kNoAnalysisType,; 131 kMaxAnalysisType; 132 };; 133 ; 134 enum ESBType {; 135 kSignal = 0, ///< Never change this number - it is elsewhere assumed to be zero !; 136 kBackground,; 137 kSBBoth,; 138 kMaxSBType,; 139 kTrueType; 140 };; 141 ; 142 enum ETreeType {; 143 kTraining = 0,; 144 kTesting,; 145 kMaxTreeType, ///< also used as temporary storage for trees not yet assigned for testing;training...; 146 kValidation, ///< these are placeholders... currently not us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html:3546,test,testing,3546,doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html,1,['test'],['testing']
Testability," <td> Adjust normalization by given scale factor.; 1866/// Interpretation of number depends on code:; 1867/// `RooAbsReal::Relative`: relative adjustment factor; 1868/// `RooAbsReal::NumEvent`: scale to match given number of events.; 1869///; 1870/// <tr><th> Type of argument <th> Misc control; 1871/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1872/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category; 1873/// \f$ \frac{F(+)-F(-)}{F(+)+F(-)} \f$ rather than the PDF projection. Category must have two; 1874/// states with indices -1 and +1 or three states with indices -1,0 and +1.; 1875/// <tr><td> `ShiftToZero(bool flag)` <td> Shift entire curve such that lowest visible point is at exactly zero.; 1876/// Mostly useful when plotting -log(L) or \f$ \chi^2 \f$ distributions; 1877/// <tr><td> `AddTo(const char* name, double_t wgtSelf, double_t wgtOther)` <td> Create a projection of this PDF onto the x-axis, but; 1878/// instead of plotting it directly, add it to an existing curve with given name (and relative weight factors).; 1879/// <tr><td> `Components(const char* names)` <td> When plotting sums of PDFs, plot only the named components (*e.g.* only; 1880/// the signal of a signal+background model).; 1881/// <tr><td> `Components(const RooArgSet& compSet)` <td> As above, but pass a RooArgSet of the components themselves.; 1882///; 1883/// <tr><th> Type of argument <th> Projection control; 1884/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1885/// in set from the projection, i.e. by not integrating over these.; 1886/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1887/// of the PDF at the current value of the category observable.; 1888/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:90432,log,log,90432,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['log']
Testability," = """") const; Statistical test of compatibility in shape between; this histogram and h2, using the Anderson-Darling 2 sample test.; The AD 2 sample test formula are derived from the paper; F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class; It is the same formula ( (6) in the paper), and also shown in this preprint; http://arxiv.org/pdf/0804.0380v1.pdf; Binned data are considered as un-binned data; with identical observation happening in the bin center. option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms. Double_t AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; Same funciton as above but returning also the test statistic value. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; this histogram and h2, using Kolmogorov test.; Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; and not for binned data as in the case of the histogram (see NOTE 3 below).; So, before using this method blindly, read the NOTE 3. Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:114813,test,test,114813,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,6,['test'],['test']
Testability," = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMarginBinsContent(Double_t z = 0.); voidSetMaxIter(Int_t n = 100000); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidCreateTrianglesDataStructure(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tEnclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const; voidFileIt(Int_t P, Int_t N, Int_t M); voidFindHull(); Bool_tInHull(Int_t E, Int_t X) const; Double_tInterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const; voidTObject::MakeZombie(). private:. TGraphDelaunay(const TGraphDelaunay&); TGraphDelaunay&operator=(const TGraphDelaunay&). Data Members; public:. enum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphDelaunay.html:6139,Test,TestBit,6139,root/html534/TGraphDelaunay.html,https://root.cern,https://root.cern/root/html534/TGraphDelaunay.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = """") const; virtual voidPrintValue(Int_t i = 0) const; virtual Int_tTObject::Read(const char* name); virtual voidReadBasket(TBuffer& b); virtual voidReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); virtual voidReadValue(istream& s); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTLeaf::ResetAddress(void* add, Bool_t destructor = kFALSE); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTLeaf::SetBranch(TBranch* branch); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTLeaf::SetLeafCount(TLeaf* leaf); virtual voidTLeaf::SetLen(Int_t len = 1); virtual voidSetMaximum(Int_t max); virtual voidSetMinimum(Int_t min); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTLeaf::SetOffset(Int_t offset = 0); virtual voidTLeaf::SetRange(Bool_t range = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTLeaf::SetUnsigned(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafC.html:6004,Test,TestBit,6004,root/html532/TLeafC.html,https://root.cern,https://root.cern/root/html532/TLeafC.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); booloperator==(const RooStats::HistFactory::EstimateSummary& other) const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(const char* opt = 0) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__EstimateSummary.html:4690,Test,TestBit,4690,root/html534/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__EstimateSummary.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""F"") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetExpDate(TDatime expdate); voidSetID(const char* id); static voidTObject::SetObjectStat(Bool_t stat); voidSetOffSet(Int_t offset); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUser(const char* user); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSecContext.html:5188,Test,TestBit,5188,root/html534/TSecContext.html,https://root.cern,https://root.cern/root/html534/TSecContext.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); Int_tSignal(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tTimedWait(ULong_t secs, ULong_t nanoSecs); Int_tTimedWaitRelative(ULong_t ms); virtual voidTObject::UseCurrentStyle(); Int_tWait(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCondition.html:4496,Test,TestBit,4496,root/html534/TCondition.html,https://root.cern,https://root.cern/root/html534/TCondition.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TPBReadType&operator=(const TPBReadType&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPBReadType(TPBReadType::EReadType type = kReadOpt); TPBReadType(const TPBReadType&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPBReadType.html:4399,Test,TestBit,4399,root/html602/TPBReadType.html,https://root.cern,https://root.cern/root/html602/TPBReadType.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTStreamerElement::SetArrayDim(Int_t dim); voidSetBaseCheckSum(UInt_t cs); voidSetBaseVersion(Int_t v); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetErrorMessage(const char* msg); virtual voidTStreamerElement::SetMaxIndex(Int_t dim, Int_t max); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNewBaseClass(TClass* cl); virtual voidTStreamerElement::SetNewClass(TClass* cl); virtual voidTStreamerElement::SetNewType(Int_t dtype); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTStreamerElement::SetOffset(Int_t offset); virtual voidTStreamerElement::SetSize(Int_t dsize); virtual voidTStreamerElement::SetStreamer(TMemberStreamer* streamer); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTStreamerElement::SetTObjectOffset(Int_t tobjoffset); virtual voidTStreamerElement::SetType(Int_t dtype); virtual voidTStreamerElement::SetTypeName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(const TClass* oldClass, TClass* newClass); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, char* pointer).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerBase.html:6845,Test,TestBit,6845,root/html534/TStreamerBase.html,https://root.cern,https://root.cern/root/html534/TStreamerBase.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = """"); const. overridevirtual . Lists all commands in stack. ; Reimplemented from TQCommand.; Definition at line 901 of file TQCommand.cxx. ◆ PrintCollectionEntry(). void TQUndoManager::PrintCollectionEntry ; (; TObject * ; entry, . Option_t * ; option, . Int_t ; recurse . ); const. overrideprotectedvirtual . Print collection entry. ; Reimplemented from TCollection.; Definition at line 921 of file TQCommand.cxx. ◆ Redo(). void TQUndoManager::Redo ; (; Option_t * ; option = """"). overridevirtual . Performs redo action. Move cursor position forward in history stack. ; Reimplemented from TQCommand.; Definition at line 1053 of file TQCommand.cxx. ◆ SetLimit(). void TQUndoManager::SetLimit ; (; UInt_t ; limit). virtual . Returns a maximum number of commands which could be located in stack. ; Definition at line 1137 of file TQCommand.cxx. ◆ SetLogging(). void TQUndoManager::SetLogging ; (; Bool_t ; on = kTRUE). virtual . Start logging. ; Delete all previous log records Note: logging is not implemented yet ; Definition at line 938 of file TQCommand.cxx. ◆ Streamer(). void TQUndoManager::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TQCommand. ◆ StreamerNVirtual(). void TQUndoManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 133 of file TQCommand.h. ◆ Undo(). void TQUndoManager::Undo ; (; Option_t * ; option = """"). overridevirtual . Performs undo action. Move cursor position backward in history stack. ; Reimplemented from TQCommand.; Definition at line 1021 of file TQCommand.cxx. Member Data Documentation. ◆ fCurrent. TQCommand* TQUndoManager::fCurrent. protected . Definition at line 107 of file TQCommand.h. ◆ fCursor. TObjLink* TQUndoManager::fCursor. protected . Definition at line 106 of file TQCommand.h. ◆ fLimit. UInt_t TQUndoManager::fLimit. protected . Definition at line 108 of file TQCommand.h. ◆ fLogBook. TList* TQUndoManager::fLog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:32480,log,log,32480,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,2,['log'],"['log', 'logging']"
Testability," = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGFrame::SetEditable(Bool_t); virtual voidTGWindow::SetEditDisabled(UInt_t on = kEditDisable); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidTGWindow::SetMapSubwindows(Bool_t); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGTreeLBEntry(const TGTreeLBEntry&); TGTreeLBEntry(const TGWindow* p = 0, TGString* text = 0, const TGPicture* pic = 0, Int_t id = -1, TGString* path = 0, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); virtual voidTGLBEntry::Toggle(); virtual voidTGFrame::UnmapWindow(); virtual voidUpdate(TGLBEntry* e); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTreeLBEntry.html:13025,Test,TestBit,13025,root/html602/TGTreeLBEntry.html,https://root.cern,https://root.cern/root/html602/TGTreeLBEntry.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMatrix(TRotMatrix* matrix = 0); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(TNode* parent); virtual voidSetPosition(Double_t x = 0, Double_t y = 0, Double_t z = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisibility(Int_t vis = 1)MENU ; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateMatrix(); virtual voidUpdateTempMatrix(const Double_t* dx1, const Double_t* rmat1, Double_t x, Double_t y, Double_t z, Double_t* matrix, Double_t* dxnew, Double_t* rmatnew); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNode.html:7310,Test,TestBit,7310,root/html534/TNode.html,https://root.cern,https://root.cern/root/html534/TNode.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTBRIK::Sizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; TTRAP(); TTRAP(const TTRAP&); TTRAP(const char* name, const char* title, const char* material, Float_t dz, Float_t theta, Float_t phi, Float_t h1, Float_t bl1, Float_t tl1, Float_t alpha1, Float_t h2, Float_t bl2, Float_t tl2, Float_t alpha2); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTRAP.html:7561,Test,TestBit,7561,root/html602/TTRAP.html,https://root.cern,https://root.cern/root/html602/TTRAP.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetE(Double_t a); static voidTObject::SetObjectStat(Bool_t stat); voidSetPerp(Double_t); voidSetPhi(Double_t phi); voidSetPtEtaPhiE(Double_t pt, Double_t eta, Double_t phi, Double_t e); voidSetPtEtaPhiM(Double_t pt, Double_t eta, Double_t phi, Double_t m); voidSetPx(Double_t a); voidSetPxPyPzE(Double_t px, Double_t py, Double_t pz, Double_t e); voidSetPy(Double_t a); voidSetPz(Double_t a); voidSetRho(Double_t rho); voidSetT(Double_t a); voidSetTheta(Double_t theta); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVect(const TVector3& vect3); voidSetVectM(const TVector3& spatial, Double_t mass); voidSetVectMag(const TVector3& spatial, Double_t magnitude); voidSetX(Double_t a); voidSetXYZM(Double_t x, Double_t y, Double_t z, Double_t m); voidSetXYZT(Double_t x, Double_t y, Double_t z, Double_t t); voidSetY(Double_t a); voidSetZ(Double_t a); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Double_tT() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tTheta() const; TLorentzVector(); TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); TLorentzVector&Transform(const TRotation&); TLorentzVector&Transform(const TLorentzRotation&); virtual voidTObject::UseCurrentStyle(); TVector3Vect() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const; Double_tZ() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLorentzVector.html:13466,Test,TestBit,13466,root/html602/TLorentzVector.html,https://root.cern,https://root.cern/root/html602/TLorentzVector.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSaveSelf(Bool_t force = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBufferSize(Int_t bufsize); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t opt = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t opt = 0, Int_t bufsize = 0) const; virtual voidWriteDirHeader(); virtual voidWriteKeys(); Int_tTDirectory::WriteObject(const void* obj, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tWriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tWriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tWriteTObject(const TObject* obj, const char* name = 0, Option_t* option = """", Int_t bufsize = 0).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDirectoryFile.html:8169,Test,TestBit,8169,root/html534/TDirectoryFile.html,https://root.cern,https://root.cern/root/html534/TDirectoryFile.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = ""+"" . ). replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?= "" from a string and replace all ::,$,*,/,+,- with M,S,T,D,P,M respectively ; Definition at line 798 of file Tools.cxx. ◆ RMS() [1/2]. template<typename Iterator , typename WeightIterator > . Double_t TMVA::Tools::RMS ; (; Iterator ; first, . Iterator ; last, . WeightIterator ; w . ). Return the Standard Deviation of an array defined by the iterators. ; Note that this function returns the sigma(standard deviation) and not the root mean square of the array. ; Definition at line 1702 of file Tools.cxx. ◆ RMS() [2/2]. template<typename T > . Double_t TMVA::Tools::RMS ; (; Long64_t ; n, . const T * ; a, . const Double_t * ; w = 0 . ). Return the Standard Deviation of an array a with length n. ; Note that this function returns the sigma(standard deviation) and not the root mean square of the array. ; Definition at line 1743 of file Tools.cxx. ◆ ROOTVersionMessage(). void TMVA::Tools::ROOTVersionMessage ; (; MsgLogger & ; logger). prints the ROOT release number and date ; Definition at line 1325 of file Tools.cxx. ◆ Scale() [1/2]. void TMVA::Tools::Scale ; (; std::vector< Double_t > & ; v, . Double_t ; f . ). scales double vector ; Definition at line 519 of file Tools.cxx. ◆ Scale() [2/2]. void TMVA::Tools::Scale ; (; std::vector< Float_t > & ; v, . Float_t ; f . ). scales float vector ; Definition at line 527 of file Tools.cxx. ◆ SetXMLEngineBufferSize(). void TMVA::Tools::SetXMLEngineBufferSize ; (; int ; buffer). inline . Definition at line 264 of file Tools.h. ◆ SplitString(). std::vector< TString > TMVA::Tools::SplitString ; (; const TString & ; theOpt, . const char ; separator . ); const. splits the option string at 'separator' and fills the list 'splitV' with the primitive strings ; Definition at line 1199 of file Tools.cxx. ◆ StringFromDouble(). TString TMVA::Tools::StringFromDouble ; (; Double_t ; d). string tools ; Definition at line 1233 of file Tools.cxx. ◆ StringFrom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:24140,log,logger,24140,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['log'],['logger']
Testability," = ""X""); virtual voidTH1::SetTitleOffset(Float_t offset = 1, Option_t* axis = ""X""); virtual voidTH1::SetTitleSize(Float_t size = 0.02, Option_t* axis = ""X""); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTH1::SetXTitle(const char* title); virtual voidTH1::SetYTitle(const char* title); virtual voidTH1::SetZTitle(const char* title); virtual TH1*TH2::ShowBackground(Int_t niter = 20, Option_t* option = ""same""); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTH2::ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05)MENU ; virtual Int_tTNamed::Sizeof() const; virtual voidTH2::Smooth(Int_t ntimes = 1, Option_t* option = """")MENU ; static voidTH1::SmoothArray(Int_t NN, Double_t* XX, Int_t ntimes = 1); static voidTH1::StatOverflows(Bool_t flag = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTH1::Sumw2(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TH1*TH1::TransformHisto(TVirtualFFT* fft, TH1* h_output, Option_t* option); virtual voidTH1::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddBinToPartition(TH2PolyBin* bin); virtual Int_tTH2::BufferFill(Double_t, Double_t); virtual Int_tTH2::BufferFill(Double_t x, Double_t y, Double_t w); static boolTH1::CheckAxisLimits(const TAxis* a1, const TAxis* a2); static boolTH1::CheckBinLimits(const TAxis* a1, const TAxis* a2); static boolTH1::CheckConsistency(const TH1* h1, const TH1* h2); static boolTH1::CheckConsistentSubAxes(const TAxis* a1, Int_t firstBin1, Int_t lastBin1, const TAxis* a2, Int_t firstBin2 = 0, Int_t lastBin2 = 0); static boolTH1::CheckEqualAxes(const TAxis* a1, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2Poly.html:24978,Test,TestBit,24978,root/html532/TH2Poly.html,https://root.cern,https://root.cern/root/html532/TH2Poly.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiDimFit ();  Empty CTOR. Do not use. ;  ;  TMultiDimFit (Int_t dimension, EMDFPolyType type=kMonomials, Option_t *option="""");  Constructor Second argument is the type of polynomials to use in parameterisation, one of: TMultiDimFit::kMonomials TMultiDimFit::kChebyshev TMultiDimFit::kLegendre. ;  ;  ~TMultiDimFit () override;  Destructor. ;  ; virtual void AddRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization. ;  ; virtual void AddTestRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization. ;  ; void Browse (TBrowser *b) override;  Browse the TMultiDimFit object in the TBrowser. ;  ; void Clear (Option_t *option="""") override;  Clear internal structures and variables. ;  ; void Draw (Option_t *=""d"") override;  Default Draw method for all objects. ;  ; virtual Double_t Eval (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization at point x. ;  ; virtual Double_t EvalError (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization error at point x. ;  ; virtual void FindParameterization (Option_t *option="""");  Find the parameterization. ;  ; virtual void Fit (Option_t *option="""");  Try to fit the found parameterisation to the test sample. ;  ; Double_t GetChi2 () const;  ; const TVectorD * GetCoefficients () const;  ; const TVectorD * GetCoefficientsRMS () const;  ; const TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:19389,test,test,19389,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,2,['test'],['test']
Testability," = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TProof; enum  ESlaves { kAll; , kActive; , kUnique; , kAllUnique; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TProof; static Int_t AssertDataSet (TDSet *dset, TList *input, TDataSetManager *mgr, TString &emsg);  Make sure that dataset is in the form to be processed. ;  ; static void AssertMacroPath (const char *macro);  Make sure that the directory path contained by macro is in the macro path. ;  ; static Bool_t GetFileInCmd (const char *cmd, TString &fn);  Static method to extract the filename (if any) form a CINT command. ;  ; static Int_t GetInputData (TList *input, const char *cachedir, TString &emsg);  Get the input data from the file defined in the input list. ;  ; static Int_t SaveInputData (TQueryResult *qr, const char *cachedir, TString &emsg);  Save input data file from 'cachedir' into the sandbox or create a the file with input data objects. ;  ; static Int_t SendInputData (TQueryResult *qr, TProof *p, TString &emsg);  Send the input data file to the workers. ;  ; static void * SlaveStartupThread (void *arg);  ; static void SystemCmd (const char *cmd, Int_t fdout);  Exec system command 'cmd'. If fdout > -1, append the output to fdout. ;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:41657,sandbox,sandbox,41657,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,3,['sandbox'],['sandbox']
Testability," = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:""); Draw the CPU speedup plot.; opt = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node. Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs""); Draw the CPU speedup plot.; opt = 'std:' Standard scaling plot; 'norm:' Normalized scaling plot; 'stdx:' Standard scaling plot, 1 worker per node; 'normx:' Normalized scaling plot, 1 worker per node; type = 'mbs' MB/s scaling plots (default); 'evts' Event/s scaling plots. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveDataSet(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t MakeDataSet(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBench.html:8843,test,test,8843,root/html530/TProofBench.html,https://root.cern,https://root.cern/root/html530/TProofBench.html,1,['test'],['test']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:22584,test,testArg,22584,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,132,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Roo2DKeysPdf&operator=(const Roo2DKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:22359,test,testArg,22359,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsAnaConvPdf&operator=(const RooAbsAnaConvPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:24356,test,testArg,24356,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:23084,test,testArg,23084,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsSelfCachedPdf&operator=(const RooAbsSelfCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:23135,test,testArg,23135,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAddPdf&operator=(const RooAddPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:23244,test,testArg,23244,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooArgusBG&operator=(const RooArgusBG&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgusBG.html:22025,test,testArg,22025,root/html602/RooArgusBG.html,https://root.cern,https://root.cern/root/html602/RooArgusBG.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBCPEffDecay&operator=(const RooBCPEffDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPEffDecay.html:22832,test,testArg,22832,root/html602/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPEffDecay.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBCPGenDecay&operator=(const RooBCPGenDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPGenDecay.html:22762,test,testArg,22762,root/html602/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPGenDecay.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBDecay&operator=(const RooBDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBDecay.html:22821,test,testArg,22821,root/html602/RooBDecay.html,https://root.cern,https://root.cern/root/html602/RooBDecay.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBMixDecay&operator=(const RooBMixDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBMixDecay.html:22852,test,testArg,22852,root/html602/RooBMixDecay.html,https://root.cern,https://root.cern/root/html602/RooBMixDecay.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBernstein&operator=(const RooBernstein&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBernstein.html:22469,test,testArg,22469,root/html602/RooBernstein.html,https://root.cern,https://root.cern/root/html602/RooBernstein.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBifurGauss&operator=(const RooBifurGauss&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBifurGauss.html:22047,test,testArg,22047,root/html602/RooBifurGauss.html,https://root.cern,https://root.cern/root/html602/RooBifurGauss.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBreitWigner&operator=(const RooBreitWigner&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBreitWigner.html:22065,test,testArg,22065,root/html602/RooBreitWigner.html,https://root.cern,https://root.cern/root/html602/RooBreitWigner.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBukinPdf&operator=(const RooBukinPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBukinPdf.html:22024,test,testArg,22024,root/html602/RooBukinPdf.html,https://root.cern,https://root.cern/root/html602/RooBukinPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1PdfBinding<double,double>&operator=(const RooCFunction1PdfBinding<double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1PdfBinding_double_double_.html:22595,test,testArg,22595,root/html602/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1PdfBinding_double_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1PdfBinding<double,int>&operator=(const RooCFunction1PdfBinding<double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1PdfBinding_double_int_.html:22583,test,testArg,22583,root/html602/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1PdfBinding_double_int_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,double,double>&operator=(const RooCFunction2PdfBinding<double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_double_.html:22623,test,testArg,22623,root/html602/RooCFunction2PdfBinding_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,double,int>&operator=(const RooCFunction2PdfBinding<double,double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html:22611,test,testArg,22611,root/html602/RooCFunction2PdfBinding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,int,double>&operator=(const RooCFunction2PdfBinding<double,int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html:22611,test,testArg,22611,root/html602/RooCFunction2PdfBinding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,int,int>&operator=(const RooCFunction2PdfBinding<double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html:22599,test,testArg,22599,root/html602/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,unsigned int,double>&operator=(const RooCFunction2PdfBinding<double,unsigned int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_unsigned_int_double_.html:22647,test,testArg,22647,root/html602/RooCFunction2PdfBinding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_unsigned_int_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,double,bool>&operator=(const RooCFunction3PdfBinding<double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html:22643,test,testArg,22643,root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,double,double>&operator=(const RooCFunction3PdfBinding<double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html:22651,test,testArg,22651,root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,int,int>&operator=(const RooCFunction3PdfBinding<double,double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_int_int_.html:22627,test,testArg,22627,root/html602/RooCFunction3PdfBinding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_int_int_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,unsigned int,double,double>&operator=(const RooCFunction3PdfBinding<double,unsigned int,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html:22675,test,testArg,22675,root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,unsigned int,double,unsigned int>&operator=(const RooCFunction3PdfBinding<double,unsigned int,double,unsigned int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html:22699,test,testArg,22699,root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,unsigned int,unsigned int,double>&operator=(const RooCFunction3PdfBinding<double,unsigned int,unsigned int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html:22699,test,testArg,22699,root/html602/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4PdfBinding<double,double,double,double,bool>&operator=(const RooCFunction4PdfBinding<double,double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html:22671,test,testArg,22671,root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4PdfBinding<double,double,double,double,double>&operator=(const RooCFunction4PdfBinding<double,double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html:22679,test,testArg,22679,root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4PdfBinding<double,double,double,double,int>&operator=(const RooCFunction4PdfBinding<double,double,double,double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_int_.html:22667,test,testArg,22667,root/html602/RooCFunction4PdfBinding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_int_.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCachedPdf&operator=(const RooCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:22442,test,testArg,22442,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChebychev&operator=(const RooChebychev&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChebychev.html:22000,test,testArg,22000,root/html602/RooChebychev.html,https://root.cern,https://root.cern/root/html602/RooChebychev.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChiSquarePdf&operator=(const RooChiSquarePdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChiSquarePdf.html:22152,test,testArg,22152,root/html602/RooChiSquarePdf.html,https://root.cern,https://root.cern/root/html602/RooChiSquarePdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDecay&operator=(const RooDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDecay.html:22780,test,testArg,22780,root/html602/RooDecay.html,https://root.cern,https://root.cern/root/html602/RooDecay.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDstD0BG&operator=(const RooDstD0BG&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDstD0BG.html:22047,test,testArg,22047,root/html602/RooDstD0BG.html,https://root.cern,https://root.cern/root/html602/RooDstD0BG.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooEffProd&operator=(const RooEffProd&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:22435,test,testArg,22435,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooEfficiency&operator=(const RooEfficiency&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEfficiency.html:22371,test,testArg,22371,root/html602/RooEfficiency.html,https://root.cern,https://root.cern/root/html602/RooEfficiency.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExponential&operator=(const RooExponential&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExponential.html:21980,test,testArg,21980,root/html602/RooExponential.html,https://root.cern,https://root.cern/root/html602/RooExponential.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendPdf&operator=(const RooExtendPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendPdf.html:22621,test,testArg,22621,root/html602/RooExtendPdf.html,https://root.cern,https://root.cern/root/html602/RooExtendPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendedTerm&operator=(const RooExtendedTerm&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedTerm.html:22165,test,testArg,22165,root/html602/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html602/RooExtendedTerm.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctor1DPdfBinding&operator=(const RooFunctor1DPdfBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DPdfBinding.html:22531,test,testArg,22531,root/html602/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DPdfBinding.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctorPdfBinding&operator=(const RooFunctorPdfBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorPdfBinding.html:22523,test,testArg,22523,root/html602/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorPdfBinding.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGamma&operator=(const RooGamma&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGamma.html:21913,test,testArg,21913,root/html602/RooGamma.html,https://root.cern,https://root.cern/root/html602/RooGamma.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGaussian&operator=(const RooGaussian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussian.html:21934,test,testArg,21934,root/html602/RooGaussian.html,https://root.cern,https://root.cern/root/html602/RooGaussian.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGenericPdf&operator=(const RooGenericPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:22764,test,testArg,22764,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistConstraint&operator=(const RooHistConstraint&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:21984,test,testArg,21984,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooIntegralMorph&operator=(const RooIntegralMorph&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:26188,test,testArg,26188,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLandau&operator=(const RooLandau&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLandau.html:21970,test,testArg,21970,root/html602/RooLandau.html,https://root.cern,https://root.cern/root/html602/RooLandau.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLognormal&operator=(const RooLognormal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLognormal.html:22317,test,testArg,22317,root/html602/RooLognormal.html,https://root.cern,https://root.cern/root/html602/RooLognormal.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMomentMorph&operator=(const RooMomentMorph&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMomentMorph.html:21871,test,testArg,21871,root/html602/RooMomentMorph.html,https://root.cern,https://root.cern/root/html602/RooMomentMorph.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMultiVarGaussian&operator=(const RooMultiVarGaussian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:22210,test,testArg,22210,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNDKeysPdf&operator=(const RooNDKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:22936,test,testArg,22936,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNonCPEigenDecay&operator=(const RooNonCPEigenDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:23226,test,testArg,23226,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNonCentralChiSquare&operator=(const RooNonCentralChiSquare&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCentralChiSquare.html:23275,test,testArg,23275,root/html602/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html602/RooNonCentralChiSquare.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNovosibirsk&operator=(const RooNovosibirsk&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNovosibirsk.html:22099,test,testArg,22099,root/html602/RooNovosibirsk.html,https://root.cern,https://root.cern/root/html602/RooNovosibirsk.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParametricStepFunction&operator=(const RooParametricStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParametricStepFunction.html:23108,test,testArg,23108,root/html602/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html602/RooParametricStepFunction.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPoisson&operator=(const RooPoisson&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPoisson.html:21925,test,testArg,21925,root/html602/RooPoisson.html,https://root.cern,https://root.cern/root/html602/RooPoisson.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPolynomial&operator=(const RooPolynomial&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolynomial.html:22227,test,testArg,22227,root/html602/RooPolynomial.html,https://root.cern,https://root.cern/root/html602/RooPolynomial.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProdPdf&operator=(const RooProdPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:22857,test,testArg,22857,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProjectedPdf&operator=(const RooProjectedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProjectedPdf.html:22664,test,testArg,22664,root/html602/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html602/RooProjectedPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:22549,test,testArg,22549,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:22683,test,testArg,22683,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::HistFactorySimultaneous&operator=(const RooStats::HistFactory::HistFactorySimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:23803,test,testArg,23803,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFnPdfBinding&operator=(const RooTFnPdfBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:21991,test,testArg,21991,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUniform&operator=(const RooUniform&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUniform.html:21952,test,testArg,21952,root/html602/RooUniform.html,https://root.cern,https://root.cern/root/html602/RooUniform.html,4,['test'],['testArg']
Testability," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooVoigtian&operator=(const RooVoigtian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVoigtian.html:22449,test,testArg,22449,root/html602/RooVoigtian.html,https://root.cern,https://root.cern/root/html602/RooVoigtian.html,4,['test'],['testArg']
Testability," = 0, RooStats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.050000000000000003); Constructor from a model for B model and a model for S+B.; An HypoTestCalculator (Hybrid of Frequentis) will be created using the; S+B model as the null and the B model as the alternate; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(const RooStats::HypoTestInverter& rhs); copy-constructor; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax, bool scanLog = false) const; Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; run only one point at the given POI value. bool RunLimit(double& limit, double& limitErr, double absTol ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverter.html:9106,test,test,9106,root/html602/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverter.html,6,"['Test', 'test']","['TestStatistic', 'test']"
Testability," = 0, TEvePointSelectorConsumer::ETreeVarType_e tv_type = kTVT_XYZ); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var). protected:. virtual voidTEveElement::AnnihilateRecursively(); voidTAttBBox::AssertBBoxExtents(Float_t epsilon = 0.0050000000000000001); voidTEvePointSet::AssertIntIdsSize(); voidTAttBBox::BBoxCheckPoint(const Float_t* p); voidTAttBBox::BBoxCheckPoint(Float_t x, Float_t y, Float_t z); voidTAttBBox::BBoxClear(); voidTAttBBox::BBoxInit(Float_t infinity = 1.0E+6); voidTAttBBox::BBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidTPointSet3D::CopyIds(const TPointSet3D& t); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); virtual voidTEveElement::PreDelet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveLine.html:22715,Assert,AssertIntIdsSize,22715,root/html602/TEveLine.html,https://root.cern,https://root.cern/root/html602/TEveLine.html,2,['Assert'],['AssertIntIdsSize']
Testability," = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<TMVA::Event*> , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<TMVA::Event*> ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, Int_t iTree, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t Bagging(vector<TMVA::Event*> , Int_t iTree); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" weights to each event. Double_t RegBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<TMVA::Event*> , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H.Drucker 1997). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:31218,test,testing,31218,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,3,['test'],['testing']
Testability," = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod6(Double_t mu, Double_t b, Double_t e, Int_t x, Int_t z, Int_t m); Profile Likelihood function for MODEL 6:; background known/ Efficiency binomial. Double_t EvalLikeMod7(Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what); Calculates the Profile Likelihood for MODEL 7:; background known/Efficiency Gauss; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod7(Double_t mu, Double_t b, Double_t e, Int_t x, Double_t em, Double_t v); Profile Likelihood function for MODEL 6:; background known/ Efficiency gaussian. Double_t EvalPolynomial(Double_t x, const Int_t* coef, Int_t N); evaluate polynomial. Double_t EvalMonomial(Double_t x, const Int_t* coef, Int_t N); evaluate mononomial. Double_t LogFactorial(Int_t n); LogFactorial function (use the logGamma function via the relation Gamma(n+1) = n!. TRolke(Double_t CL = 0.9, Option_t* option = """"); Constructor. Double_t GetCL() const; Get and set the Confidence Level. void SetCL(Double_t CL). void SetCLSigmas(Double_t CLsigmas); Set the Confidence Level in terms of Sigmas. bool GetBounding() const; Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . void SetBounding(const bool bnd); Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . » Last changed: Sat Mar 14 16:48:46 2015 » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRolke.html:26720,log,logGamma,26720,root/html534/TRolke.html,https://root.cern,https://root.cern/root/html534/TRolke.html,4,"['Log', 'log']","['LogFactorial', 'logGamma']"
Testability," = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod6(Double_t mu, Double_t b, Double_t e, Int_t x, Int_t z, Int_t m); Profile Likelihood function for MODEL 6:; background known/ Efficiency binomial. Double_t EvalLikeMod7(Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what); Calculates the Profile Likelihood for MODEL 7:; background known/Efficiency Gauss; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod7(Double_t mu, Double_t b, Double_t e, Int_t x, Double_t em, Double_t v); Profile Likelihood function for MODEL 6:; background known/ Efficiency gaussian. Double_t EvalPolynomial(Double_t x, const Int_t* coef, Int_t N); evaluate polynomial. Double_t EvalMonomial(Double_t x, const Int_t* coef, Int_t N); evaluate mononomial. Double_t LogFactorial(Int_t n); LogFactorial function (use the logGamma function via the relation Gamma(n+1) = n!. TRolke(Double_t CL = 0.9, Option_t* option = """"); Constructor. Double_t GetCL() const; Get and set the Confidence Level. void SetCL(Double_t CL). void SetCLSigmas(Double_t CLsigmas); Set the Confidence Level in terms of Sigmas. bool GetBounding() const; Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . void SetBounding(const bool bnd); Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . » Last changed: Thu Sep 23 20:20:28 2010 » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRolke.html:26632,log,logGamma,26632,root/html528/TRolke.html,https://root.cern,https://root.cern/root/html528/TRolke.html,1,['log'],['logGamma']
Testability," = E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15365,log,log,15365,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,1,['log'],['log']
Testability," = E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15365,log,log,15365,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,1,['log'],['log']
Testability," = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; 2165/// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; 2166/// xmax, xmin and Npx (function points).; 2167/// Possible values are:; 2168/// - ""LOG"" to force usage of log scale for tabulating the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:79602,log,log,79602,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['log']
Testability," = T0, typename T2 = T0, typename T3 = T0, typename T4 = T0, typename T5 = T0, typename T6 = T0, typename T7 = T0, typename Common_t = std::common_type_t<T0, T1, T2, T3, T4, T5, T6, T7>> . Common_t ROOT::VecOps::InvariantMasses_PxPyPzM ; (; const T0 & ; x1, . const T1 & ; y1, . const T2 & ; z1, . const T3 & ; mass1, . const T4 & ; x2, . const T5 & ; y2, . const T6 & ; z2, . const T7 & ; mass2 . ). Return the invariant mass of two particles given x coordinate (px), y coordinate (py), z coordinate (pz) and mass. ; The function computes the invariant mass of two particles with the four-vectors (x1, y2, z1, mass1) and (x2, py2, pz2, mass2). ; Definition at line 3051 of file RVec.hxx. ◆ lgamma(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::lgamma ; (; const RVec< T > & ; v). Definition at line 1875 of file RVec.hxx. ◆ llround(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::llround ; (; const RVec< T > & ; v). Definition at line 1871 of file RVec.hxx. ◆ log(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log ; (; const RVec< T > & ; v). Definition at line 1841 of file RVec.hxx. ◆ log10(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log10 ; (; const RVec< T > & ; v). Definition at line 1842 of file RVec.hxx. ◆ log1p(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log1p ; (; const RVec< T > & ; v). Definition at line 1844 of file RVec.hxx. ◆ log2(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log2 ; (; const RVec< T > & ; v). Definition at line 1843 of file RVec.hxx. ◆ lround(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::lround ; (; const RVec< T > & ; v). Definition at line 1870 of file RVec.hxx. ◆ Map(). template<typename... Args> . auto ROOT::VecOps::Map ; (; Args &&... ; args). Create new collection applying a callable to the elements of the input collection. ; Example code, at the ROOT prompt: using namespace ROOT::VecOps;; RVecF v {1.f, 2.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__vecops.html:56873,log,log,56873,doc/master/group__vecops.html,https://root.cern,https://root.cern/doc/master/group__vecops.html,1,['log'],['log']
Testability," = \lambda_V/\kappa - \ln \kappa\), which is the convention used in the CERNLIB routines, and in the tables by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons: Tabulation of the Vavilov distribution, pp 187-203 in: National Research Council (U.S.), Committee on Nuclear Science: Studies in penetration of charged particles in matter, Nat. Akad. Sci. Publication 1133, Nucl. Sci. Series Report No. 39, Washington (Nat. Akad. Sci.) 1964, 388 pp. Available from Google books; Therefore, for small values of \(\kappa < 0.01\), pdf approaches the Landau distribution.; For values \(\kappa > 10\), the Gauss approximation should be used with \(\mu\) and \(\sigma\) given by Vavilov::mean(kappa, beta2) and sqrt(Vavilov::variance(kappa, beta2).; For values \(\kappa > 10\), the Gauss approximation should be used with \(\mu\) and \(\sigma\) given by Vavilov::mean(kappa, beta2) and sqrt(Vavilov::variance(kappa, beta2).; The original Vavilov pdf is obtained by v.Pdf(lambdaV/kappa-log(kappa))/kappa.; For detailed description see A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution, Nucl. Instr. and Meth. B47 (1990) 215-224, which has been implemented in CERNLIB (G115).; The class stores coefficients needed to calculate \(p(\lambda; \kappa, \beta^2)\) for fixed values of \(\kappa\) and \(\beta^2\). Changing these values is computationally expensive.; The parameter \(\kappa\) must be in the range \(0.01 \le \kappa \le 12\).; The parameter \(\beta^2\) must be in the range \(0 \le \beta^2 \le 1\).; Average times on a Pentium Core2 Duo P8400 2.26GHz:; 9.9us per call to SetKappaBeta2 or constructor; 0.095us per call to Pdf, Cdf; 3.7us per first call to Quantile after SetKappaBeta2 or constructor; 0.137us per subsequent call to Quantile. Benno List, June 2010 ; Definition at line 116 of file VavilovFast.h. Public Member Functions;  VavilovFast (double kappa=1, double beta2=1);  Initialize an object to calculate the Vavilov distribution. ;  ;  ~VavilovFa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovFast.html:2078,log,log,2078,doc/master/classROOT_1_1Math_1_1VavilovFast.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovFast.html,1,['log'],['log']
Testability," = gRandom->Rndm()*(kMaxTrack-1);; ntrack = nt;; sumstat = 0;; // set the values in each track; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; 12.17 Example 4: A Tree with an Event Class; This example is a simplified version of $ROOTSYS/test/MainEvent.cxx and where Event objects are saved in a tree. The full definition of Event is in $ROOTSYS/test/Event.h. To execute this macro, you will need the library $ROOTSYS/test/libEvent.so. If it does not exist you can build the test directory applications by following the instruction in the $ROOTSYS/test/README file.; In this example we will show. the difference in splitting or not splitting a branch; how to read selected branches of the tree,; how to print a selected entry. 12.17.1 The Event Class; Event is a descendent of TObject. As such it inherits the data members of TObject and its methods such as Dump() and Inspect()andWrite(). In addition, because it inherits from TObject it can be a member of a collection. To summarize, the advantages of inheriting from a TObject are:. Inherit the Write, Inspect, and Dump methods; Enables a class to be a member of a ROOT collection; Enables RTTI. Below is the list of the Event data members. It con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:574764,test,test,574764,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability," = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidsetUnitNorm(Bool_t flag); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:31435,Test,TestBit,31435,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['Test'],['TestBit']
Testability," = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:414254,log,log,414254,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['log'],['log']
Testability," = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:414287,log,log,414287,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['log'],['log']
Testability," = newProxy->Allocate(nobjects,true);; 1291 if (nobjects) {; 1292 TActionSequence *actions = newProxy->GetConversionReadMemberWiseActions( oldProxy->GetValueClass(), vClVersion );; 1293 char startbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 1294 char endbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 1295 void *begin = &(startbuf[0]);; 1296 void *end = &(endbuf[0]);; 1297 config->fCreateIterators( alternative, &begin, &end, newProxy);; 1298 // We can not get here with a split vector of pointer, so we can indeed assume; 1299 // that actions->fConfiguration != null.; 1300 buf.ApplySequence(*actions, begin, end);; 1301 if (begin != &(startbuf[0])) {; 1302 // assert(end != endbuf);; 1303 config->fDeleteTwoIterators(begin,end);; 1304 }; 1305 }; 1306 newProxy->Commit(alternative);; 1307 }; 1308 }; 1309 ; 1310 INLINE_TEMPLATE_ARGS void ReadArraySTLMemberWiseChangedClass(TBuffer &buf, void *addr, const TConfiguration *conf, Version_t vers); 1311 {; 1312 // Collection was saved member-wise; 1313 ; 1314 TConfigSTL *config = (TConfigSTL*)conf;; 1315 ; 1316 vers &= ~( TBufferFile::kStreamedMemberWise );; 1317 ; 1318 TClass *newClass = config->fNewClass;; 1319 TClass *oldClass = config->fOldClass;; 1320 ; 1321 if( vers < 8 ) {; 1322 Error( ""ReadSTLMemberWiseChangedClass"", ""Unfortunately, version %d of TStreamerInfo (used in %s) did not record enough information to convert a %s into a %s."",; 1323 vers, buf.GetParent() ? buf.GetParent()->GetName() : ""memory/socket"", oldClass ? oldClass->GetName() : ""(could not find the origin TClass)"", newClass ? newClass->GetName() : ""(could not find the destination TClass)"" );; 1324 } else if (newClass && oldClass) {; 1325 ; 1326 Version_t vClVersion = buf.ReadVersionForMemberWise( oldClass->GetCollectionProxy()->GetValueClass() );; 1327 ; 1328 TVirtualCollectionProxy *newProxy = newClass->GetCollectionProxy();; 1329 TVirtualCollectionProxy *oldProxy = oldClass->GetCollectionProxy();; 1330 ; 1331 int objectSize = newClass->Size();; 13",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:53996,assert,assert,53996,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['assert'],['assert']
Testability, = nullptr;  Pointer to original input dataset. ;  ; bool _doOffset = false;  Apply interval value offset to control numeric precision? ;  ; double _evalCarry = 0.0;  ! carry of Kahan sum in evaluatePartition ;  ; Int_t _extSet = 0;  ! Number of designated set to calculated extended term ;  ; RooAbsReal * _func = nullptr;  Pointer to original input function. ;  ; std::vector< std::unique_ptr< RooAbsTestStatistic > > _gofArray;  ! Array of sub-contexts representing part of the combined test statistic ;  ; GOFOpMode _gofOpMode = Slave;  Operation mode of test statistic instance. ;  ; bool _init = false;  ! Is object initialized ;  ; pRooRealMPFE * _mpfeArray = nullptr;  ! Array of parallel execution frond ends ;  ; RooFit::MPSplit _mpinterl = RooFit::BulkPartition;  Use interleaving strategy rather than N-wise split for partitioning of dataset for multiprocessor-split. ;  ; Int_t _nCPU = 1;  Number of processors to use in parallel calculation mode. ;  ; Int_t _nEvents = 0;  Total number of events in test statistic calculation. ;  ; Int_t _numSets = 1;  Total number of partitions in parallel calculation mode. ;  ; ROOT::Math::KahanSum< double > _offset {0.0};  ! Offset as KahanSum to avoid loss of precision ;  ; RooSetProxy _paramSet;  Parameters of the test statistic (=parameters of the input function) ;  ; const RooArgSet * _projDeps = nullptr;  Pointer to set with projected observables. ;  ; std::string _rangeName;  Name of range in which to calculate test statistic. ;  ; Int_t _setNum = 0;  Partition number of this instance in parallel calculation mode. ;  ; Int_t _simCount = 1;  Total number of component p.d.f.s in RooSimultaneous (if any) ;  ; bool _splitRange = false;  Split rangeName in RooSimultaneous index labels if true. ;  ; const bool _takeGlobalObservablesFromData = false;  If the global observable values are taken from data. ;  ; bool _verbose = false;  Verbose messaging if true. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:62117,test,test,62117,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['test'],['test']
Testability," == 1) && cl->GetCollectionProxy() && !strcmp(sinfo->GetElement(0)->GetName(), ""This"")) {; 6243 // -- Class cl is an STL collection, refuse to split it.; 6244 // Question: Why? We certainly could by switching to the value class.; 6245 // Partial Answer: Only the branch element constructor can split STL containers.; 6246 return 1;; 6247 }; 6248 ; 6249 for (Int_t elemID = 0; elemID < ndata; ++elemID) {; 6250 // -- Loop over all the streamer elements and create sub-branches as needed.; 6251 TStreamerElement* elem = sinfo->GetElement(elemID);; 6252 if (elem->IsA() == TStreamerArtificial::Class()) {; 6253 continue;; 6254 }; 6255 if (elem->TestBit(TStreamerElement::kRepeat)) {; 6256 continue;; 6257 }; 6258 if (elem->TestBit(TStreamerElement::kCache) && !elem->TestBit(TStreamerElement::kWrite)) {; 6259 continue;; 6260 }; 6261 Int_t offset = elem->GetOffset();; 6262 // FIXME: An STL container as a base class gets TStreamerSTL as its class, so this test is not enough.; 6263 // See InitializeOffsets() for the proper test.; 6264 if (elem->IsA() == TStreamerBase::Class()) {; 6265 // -- This is a base class of cl.; 6266 TClass* clOfBase = elem->GetClassPointer();; 6267 if (!clOfBase || ((clOfBase->Property() & kIsAbstract) && cl->InheritsFrom(TCollection::Class()))) {; 6268 // -- Do nothing if we are one of the abstract collection (we know they have no data).; 6269 return -1;; 6270 }; 6271 if ((btype == 31) || (btype == 41)) {; 6272 // -- Elide the base-class sub-branches of a split TClonesArray or STL container.; 6273 //; 6274 // Note: We are eliding the base class here, that is, we never; 6275 // create a branch for it, so the branch hierarchy is not; 6276 // complete.; 6277 // Note: The clParent parameter is the value class of the; 6278 // container which we are splitting. It does not; 6279 // appear in the branch hierarchy either.; 6280 // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.; 6281 Int_t unroll = -1;; 6282 if (!elem->Cann",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:235083,test,test,235083,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['test'],['test']
Testability," ? 1.0 : 0; });  ; std::shared_ptr< std::function< double(double)> > InvTanh = std::make_shared<std::function<double(double)>> ([](double value){ return 1.0 - std::pow (value, 2.0); });  ; std::shared_ptr< std::function< double(double)> > InvTanhShift = std::make_shared<std::function<double(double)>> ([](double value){ return 0.3 + (1.0 - std::pow (value, 2.0)); });  ; std::shared_ptr< std::function< double(double)> > Linear = std::make_shared<std::function<double(double)>> ([](double value){ return value; });  ; std::shared_ptr< std::function< double(double)> > ReLU = std::make_shared<std::function<double(double)>> ([](double value){ const double margin = 0.0; return value > margin ? value-margin : 0; });  ; std::shared_ptr< std::function< double(double)> > Sigmoid = std::make_shared<std::function<double(double)>> ([](double value){ value = std::max (-100.0, std::min (100.0,value)); return 1.0/(1.0 + std::exp (-value)); });  ; std::shared_ptr< std::function< double(double)> > SoftPlus = std::make_shared<std::function<double(double)>> ([](double value){ return std::log (1.0+ std::exp (value)); });  ; std::shared_ptr< std::function< double(double)> > SoftSign = std::make_shared<std::function<double(double)>> ([](double value){ return value / (1.0 + fabs (value)); });  ; std::shared_ptr< std::function< double(double)> > SymmReLU = std::make_shared<std::function<double(double)>> ([](double value){ const double margin = 0.3; return value > margin ? value-margin : value < -margin ? value+margin : 0; });  ; std::shared_ptr< std::function< double(double)> > Tanh = std::make_shared<std::function<double(double)>> ([](double value){ return tanh (value); });  ; std::shared_ptr< std::function< double(double)> > TanhShift = std::make_shared<std::function<double(double)>> ([](double value){ return tanh (value-0.3); });  ; std::shared_ptr< std::function< double(double)> > ZeroFnc = std::make_shared<std::function<double(double)>> ([](double ){ return 0; });  . Typedef Documentation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:17813,log,log,17813,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['log'],['log']
Testability," @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12435,log,log,12435,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['log'],['log']
Testability," A TH2Poly build with Fibonacci numbers ;  fillhistosauto2p.CFill multiple histograms with different functions and automatic binning ;  fillrandom.C Fill a 1-D histogram from a parametric function ;  fillrandom.py Fill a 1-D histogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:125211,log,logscales,125211,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['log'],['logscales']
Testability," A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\anchor GA03; 188## Blank axis; 189To draw only the axis tick marks without the axis body, it is enough to specify; 190the option `""B""`. It useful to superpose axis.; 191 ; 192\anchor GA03a; 193## Arrow on axis; 194\since **ROOT version 6.27/01:**; 195 ; 196To draw an arrow at the end of the axis use the option `"">""`. To draw it at the beginning; 197of the axis use the option `""<""`. To draw it on both ends use `""<>""`.; 198 ; 199Begin_Macro(source); 200{; 201 auto c = new TCanvas(""c"",""c"",0,0,500,500);; 202 c->Range(-11,-11,11,11);; 203 ; 204 auto f2 = new TF1(""x2"",""x*x"",-10,10);; 205 f2->SetLineColor(kRed);; 206 f2->Draw(""same"");; 207 ; 208 auto f3 = new TF1(""x3"",""x*x*x"",-10,10);; 209 f3->SetLineColor(kBlue);; 210 f3->Draw(""same"");; 211 ; 212 // Draw the axis with arrows; 213 auto ox ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:6409,log,logarithmic,6409,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,4,['log'],['logarithmic']
Testability," About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses Introductory Tutorials. Overview; The goal of this tutorial session is to learn how to read a tree from a ROOT file, extract some data from it, display a histogram and then fit it.;  ; Information about the ROOT classes can be found on the ROOT reference guide, and there is also a web based documentation and the Root primer and other manuals available to download.; . Meet a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/introductory-tutorials-1.html:3146,test,tests,3146,d/introductory-tutorials-1.html,https://root.cern,https://root.cern/d/introductory-tutorials-1.html,2,['test'],['tests']
Testability," AddChild(void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false)add child nodeDefinition Tools.cxx:1124; TMVA::Tools::UsefulSortAscendingvoid UsefulSortAscending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:538; TMVA::Tools::GetYMean_binXDouble_t GetYMean_binX(const TH2 &, Int_t bin_x)Compute the mean in Y for a given bin X of a 2D histogram.Definition Tools.cxx:642; TMVA::Tools::CalcCovarianceMatricesstd::vector< TMatrixDSym * > * CalcCovarianceMatrices(const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr)compute covariance matricesDefinition Tools.cxx:1513; TMVA::Tools::TMVACitationvoid TMVACitation(MsgLogger &logger, ECitation citType=kPlainText)kinds of TMVA citationDefinition Tools.cxx:1440; TMVA::Tools::TMVAVersionMessagevoid TMVAVersionMessage(MsgLogger &logger)prints the TMVA release number and dateDefinition Tools.cxx:1316; TMVA::Tools::TMVAWelcomeMessagevoid TMVAWelcomeMessage()direct output, eg, when starting ROOT session -> no use of Logger hereDefinition Tools.cxx:1302; TMVA::Tools::ParseANNOptionStringstd::vector< Int_t > * ParseANNOptionString(TString theOptions, Int_t nvar, std::vector< Int_t > *nodes)parse option string for ANN methods default settings (should be defined in theOption string)Definition Tools.cxx:443; TMVA::Tools::GetIndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:80583,log,logger,80583,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability," AutoExec()Execute the list of Execs when a pad event occurs.Definition TPad.cxx:508; TPad::fAbsCoordBool_t fAbsCoordUse absolute coordinates.Definition TPad.h:102; TPad::fNumPaletteColorInt_t fNumPaletteColorNumber of objects with an automatic color.Definition TPad.h:116; TPad::fCrosshairPosInt_t fCrosshairPosPosition of crosshair.Definition TPad.h:96; TPad::FillCollideGridTGraphvoid FillCollideGridTGraph(TObject *o)Definition TPad.cxx:3360; TPad::SetFixedAspectRatiovoid SetFixedAspectRatio(Bool_t fixed=kTRUE) overrideFix pad aspect ratio to current value if fixed is true.Definition TPad.cxx:6031; TPad::GetBorderSizeShort_t GetBorderSize() const overrideDefinition TPad.h:200; TPad::RedrawAxisvoid RedrawAxis(Option_t *option="""") overrideRedraw the frame axis.Definition TPad.cxx:5450; TPad::DrawDistvoid DrawDist(Rectangle_t aBBox, Rectangle_t bBBox, char mode)Draw Arrows to indicated equal distances of Objects with given BBoxes.Definition TPad.cxx:6266; TPad::fLogxInt_t fLogx(=0 if X linear scale, =1 if log scale)Definition TPad.h:91; TPad::GetAbsWNDCDouble_t GetAbsWNDC() const overrideDefinition TPad.h:222; TPad::YtoAbsPixelInt_t YtoAbsPixel(Double_t y) const overrideConvert Y coordinate to absolute pixel.Definition TPad.cxx:7499; TPad::fUtoPixelDouble_t fUtoPixelxpixel = fUtoPixelk + fUtoPixel*undcDefinition TPad.h:50; TPad::fCrosshairInt_t fCrosshairCrosshair type (0 if no crosshair requested)Definition TPad.h:95; TPad::PaintFillAreaHatchesvoid PaintFillAreaHatches(Int_t n, Double_t *x, Double_t *y, Int_t FillStyle)This function paints hatched fill area according to the FillStyle value The convention for the Hatch ...Definition TPad.cxx:4108; TPad::RangeAxisvoid RangeAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax) overrideSet axis coordinate system for the pad.Definition TPad.cxx:5369; TPad::fUtoAbsPixelkDouble_t fUtoAbsPixelkConversion coefficient for U NDC to absolute pixel.Definition TPad.h:48; TPad::ResetToolTipvoid ResetToolTip(TObject *tip) o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:309721,log,log,309721,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,2,['log'],['log']
Testability," Axis has no parent histogram. Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. Identical to TAxis::FindBin except that if x is an underflow/overflow; no attempt is made to rebin the histogram if TH1::kCanRebin bit is set. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLog(Int_t bin) const; Return center of bin in log; With a log-equidistant binning for a bin with low and up edges, the mean is :; 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; Imagine a bin with low=1 and up=100 :; - the center in lin is (100-1)/2=50.5; - the center in log would be sqrt(1*100)=10 (!=log(50.5)); NB: if the low edge of the bin is negative, the function returns the bin center; as computed by TAxis::GetBinCenter. Double_t GetBinLowEdge(Int_t bin) const; Return low edge of bin. Double_t GetBinUpEdge(Int_t bin) const; Return up edge of bin. Double_t GetBinWidth(Int_t bin) const; Return bin width. void GetCenter(Double_t* center) const; Return an array with the center of all bins. void GetLowEdge(Double_t* edge) const; Return an array with the lod edge of all bins. const char * GetTimeFormatOnly() const; Return *only* the time format from the string fTimeFormat. const char * GetTicks() const; Return the ticks option (see SetTicks). void LabelsOption(Option_t* option = ""h""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAxis.html:14452,log,log,14452,root/html534/TAxis.html,https://root.cern,https://root.cern/root/html534/TAxis.html,4,['log'],['log']
Testability," Bonn, Germany *; 20 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 21 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 22 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 23 * Omar Zapata <Omar.Zapata@cern.ch> - UdeA/ITM Colombia *; 24 * Lorenzo Moneta <Lorenzo.Moneta@cern.ch> - CERN, Switzerland *; 25 * Sergei Gleyzer <Sergei.Gleyzer@cern.ch> - U of Florida & CERN *; 26 * *; 27 * Copyright (c) 2005-2011: *; 28 * CERN, Switzerland *; 29 * U. of Victoria, Canada *; 30 * MPI-K Heidelberg, Germany *; 31 * U. of Bonn, Germany *; 32 * UdeA/ITM, Colombia *; 33 * U. of Florida, USA *; 34 * *; 35 * Redistribution and use in source and binary forms, with or without *; 36 * modification, are permitted according to the terms listed in LICENSE *; 37 * (see tmva/doc/LICENSE) *; 38 **********************************************************************************/; 39 ; 40#ifndef ROOT_TMVA_Factory; 41#define ROOT_TMVA_Factory; 42 ; 43//////////////////////////////////////////////////////////////////////////; 44// //; 45// Factory //; 46// //; 47// This is the main MVA steering class: it creates all MVA methods, //; 48// and guides them through the training, testing and evaluation //; 49// phases //; 50// //; 51//////////////////////////////////////////////////////////////////////////; 52 ; 53#include <vector>; 54#include <map>; 55#include ""TCut.h""; 56 ; 57#include ""TMVA/Configurable.h""; 58#include ""TMVA/Types.h""; 59#include ""TMVA/DataSet.h""; 60 ; 61class TCanvas;; 62class TDirectory;; 63class TFile;; 64class TGraph;; 65class TH1F;; 66class TMultiGraph;; 67class TTree;; 68namespace TMVA {; 69 ; 70 class IMethod;; 71 class MethodBase;; 72 class DataInputHandler;; 73 class DataSetInfo;; 74 class DataSetManager;; 75 class DataLoader;; 76 class ROCCurve;; 77 class VariableTransformBase;; 78 ; 79 ; 80 class Factory : public Configurable {; 81 friend class CrossValidation;; 82 public:; 83 ; 84 typedef std::vector<IMethod*> MVector;; 85 std::map<T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:2278,test,testing,2278,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['test'],['testing']
Testability," Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor. ;  ;  TGeoShape (const char *name);  Default constructor. ;  ;  ~TGeoShape () override;  Destructor. ;  ; virtual void AfterStreamer ();  ; void CheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option="""");  Test for shape navigation methods. ;  ; virtual void ClearThreadData () const;  ; virtual void CreateThreadData (Int_t);  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; Int_t GetId () const;  ; const char * GetName () const override;  Get the shape name. ;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; void InvertShapeBit (UInt_t f);  ; TClass * IsA () const override;  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () const;  ; virtual Bool_t IsReflected () const;  ; Bool_t IsRunTimeShape () const;  ; Bool_t IsValid () const;  ; virtual Bool_t IsVecGeom () const;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; void ResetShapeBit (UInt_t f);  ; void SetId (Int_t id);  ; void SetRuntime (Bool_t flag=kTRUE);  ; void SetShapeBit (UInt_t f);  ; vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:7567,test,testNo,7567,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,2,['test'],['testNo']
Testability," Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVisLevel(Int_t vl); voidSetVisOption(Int_t vo); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tSingleRnrState() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); voidTEveGeoNode::UpdateNode(TGeoNode* node); voidTEveGeoNode::UpdateVolume(TGeoVolume* volume); virtual voidTObject::UseCurrentStyle(); voidUseNodeTrans(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; voidVolumeColChanged(TGeoVolume* volume); voidVolumeVisChanged(TGeoVolume* volume); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTEveGeoNode::WriteExtract(const char* name, Bool_t leafs_only); virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoTopNode.html:14952,Test,TestCSCBits,14952,root/html532/TEveGeoTopNode.html,https://root.cern,https://root.cern/root/html532/TEveGeoTopNode.html,1,['Test'],['TestCSCBits']
Testability," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchSTL.html:9249,Test,TestBit,9249,root/html602/TBranchSTL.html,https://root.cern,https://root.cern/root/html602/TBranchSTL.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:34420,Test,TestBits,34420,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,2,['Test'],['TestBits']
Testability," Bool_t& opened); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); virtual Bool_tRemoveDataSet(const char* uri); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Int_tScanDataSet(const char* uri, const char* opt); virtual Int_tScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); static Int_tScanDataSet(TFileCollection* dataset, Int_t fopt, Int_t sopt = 0, Int_t ropt = 0, Bool_t dbg = kFALSE, Int_t* touched = 0, Int_t* opened = 0, Int_t* disappeared = 0, TList* flist = 0, Long64_t avgsz = -1, const char* mss = 0, Int_t maxfiles = -1, const char* stageopts = 0); static Int_tScanFile(TFileInfo* fileinfo, Bool_t notify); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetScanCounters(Int_t t = -1, Int_t o = -1, Int_t d = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tShowCache(const char* uri); virtual voidShowDataSets(const char* uri = ""*"", const char* opt = """"); virtual voidShowMembers(TMemberInspector&); virtual voidShowQuota(const char* opt); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManager.html:7002,Test,TestBit,7002,root/html534/TDataSetManager.html,https://root.cern,https://root.cern/root/html534/TDataSetManager.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:16651,log,logEvalError,16651,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:18573,log,logEvalError,18573,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,2,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMinuit*minuit(); RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumEval() const; static Int_tRooAbsReal::numEvalErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProfileLL.html:16777,log,logEvalError,16777,root/html532/RooProfileLL.html,https://root.cern,https://root.cern/root/html532/RooProfileLL.html,2,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:16937,log,logEvalError,16937,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,11,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:16385,log,logEvalError,16385,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,57,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::obse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLegendre.html:16255,log,logEvalError,16255,root/html532/RooLegendre.html,https://root.cern,https://root.cern/root/html532/RooLegendre.html,4,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooKeysPdf.html:20350,log,logEvalError,20350,root/html528/RooKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooKeysPdf.html,2,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooKeysPdf.html:20035,log,logEvalError,20035,root/html526/RooKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooKeysPdf.html,1,['log'],['logEvalError']
Testability," Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsOptTestStatistic::isSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:19839,log,logEvalError,19839,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,24,['log'],['logEvalError']
Testability," Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tSingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveScene(const char* n = ""TEveScene"", const char* t = """"); TEveScene(TGLScenePad* gl_scene, const char* n = ""TEveScene"", const char* t = """"); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveScene.html:15808,Test,TestBit,15808,root/html602/TEveScene.html,https://root.cern,https://root.cern/root/html602/TEveScene.html,6,['Test'],"['TestBit', 'TestBits', 'TestCSCBits']"
Testability," Bool_tTEveElement::SetRnrState(Bool_t rnr); virtual voidTEveCaloViz::SetScaleAbs(Bool_t x); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveCaloViz::SetValueIsColor(Bool_t x); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveCalo3D(TEveCaloData* d = 0, const char* n = ""TEveCalo3D"", const char* t = ""xx""); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCalo3D.html:18105,Test,TestBit,18105,root/html602/TEveCalo3D.html,https://root.cern,https://root.cern/root/html602/TEveCalo3D.html,6,['Test'],"['TestBit', 'TestBits', 'TestCSCBits']"
Testability," Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVisLevel(Int_t vl); voidSetVisOption(Int_t vo); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tSingleRnrState() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveGeoTopNode(TGeoManager* manager, TGeoNode* node, Int_t visopt = 1, Int_t vislvl = 3, Int_t maxvisnds = 10000); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); voidTEveGeoNode::UpdateNode(TGeoNode* node); voidTEveGeoNode::UpdateVolume(TGeoVolume* volume); virtual voidTObject::UseCurrentStyle(); voidUseNodeTrans(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; voidVolumeColChanged(TGeoVolume* volume); voidVolumeVisChanged(TGeoVolume* volume); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTEveGeoNode::WriteExtra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGeoTopNode.html:14890,Test,TestCSCBits,14890,root/html602/TEveGeoTopNode.html,https://root.cern,https://root.cern/root/html602/TEveGeoTopNode.html,2,['Test'],['TestCSCBits']
Testability," Bool_tTNamed::IsSortable() const; Bool_tIsValid() const; Bool_tIsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tLoad(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidLogMessage(const char* msg, Bool_t all)SIGNAL ; static voidLogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static TProof*Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); Int_tPing(); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Long64_tProcess(const char* selector, Long64_t nentries, Option_t* option = """"); virtual Long64_tProcess(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); virtual Long64_tProcess(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); virtual Long64_tProcess(const char* dsetname, const char* selector, Option_t* option = """", Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:11046,log,loglevel,11046,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['log'],['loglevel']
Testability," Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsOptTestStatistic::isSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:18382,log,logEvalError,18382,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,2,['log'],['logEvalError']
Testability," Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsOptTestStatistic::isSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:18753,log,logEvalError,18753,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,5,['log'],['logEvalError']
Testability," Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofProgressInfo&operator=(const TProofProgressInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressInfo.html:4777,Test,TestBit,4777,root/html532/TProofProgressInfo.html,https://root.cern,https://root.cern/root/html532/TProofProgressInfo.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSQLObjectDataPool&operator=(const TSQLObjectDataPool&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLObjectDataPool.html:4828,Test,TestBit,4828,root/html532/TSQLObjectDataPool.html,https://root.cern,https://root.cern/root/html532/TSQLObjectDataPool.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSecContextCleanup&operator=(const TSecContextCleanup&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSecContextCleanup.html:4540,Test,TestBit,4540,root/html532/TSecContextCleanup.html,https://root.cern,https://root.cern/root/html532/TSecContextCleanup.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectRefSpy.html:4551,Test,TestBit,4551,root/html602/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html602/TObjectRefSpy.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_tTSelector::ProcessCut(Long64_t); virtual voidTSelectorDraw::ProcessFill(Long64_t entry); virtual voidTSelectorDraw::ProcessFillMultiple(Long64_t entry); virtual voidTSelectorDraw::ProcessFillObject(Long64_t entry); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTSelector::ResetAbort(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSelectorDraw::SetEstimate(Long64_t n); virtual voidTSelector::SetInputList(TList* input); virtual voidTSelector::SetObject(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSelector::SetOption(const char* option); virtual voidTSelector::SetStatus(Long64_t status); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTSelector::SlaveBegin(TTree*); virtual voidTSelector::SlaveTerminate(); virtual UInt_tTSelectorDraw::SplitNames(const TString& varexp, vector<TString>& names); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTSelectorDraw::TakeAction(); virtual voidTSelectorDraw::TakeEstimate(); virtual voidTSelectorDraw::Terminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVersion() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveSelectorToEventList.html:6878,Test,TestBit,6878,root/html534/TEveSelectorToEventList.html,https://root.cern,https://root.cern/root/html534/TEveSelectorToEventList.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Bool_tisFundamental() const; virtual Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueDirtyAndClear() const; Bool_tisValueOrShapeDirtyAndClear() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:8678,test,testArg,8678,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,1,['test'],['testArg']
Testability," Bool_t ; bin, . Long64_t ; size . ). Receive a file, either sent by a client or a master server. ; If bin is true it is a binary file, other wise it is an ASCII file and we need to check for Windows \r tokens. Returns -1 in case of error, 0 otherwise. ; Definition at line 729 of file TApplicationServer.cxx. ◆ Reset(). void TApplicationServer::Reset ; (; const char * ; dir). Reset environment to be ready for execution of next command. ; Definition at line 708 of file TApplicationServer.cxx. ◆ Run(). void TApplicationServer::Run ; (; Bool_t ; retrn = kFALSE). overridevirtual . Main server eventloop. ; Reimplemented from TApplication.; Definition at line 474 of file TApplicationServer.cxx. ◆ SendCanvases(). Int_t TApplicationServer::SendCanvases ; (; ). private . Send any created canvas to client. ; Definition at line 881 of file TApplicationServer.cxx. ◆ SendLogFile(). void TApplicationServer::SendLogFile ; (; Int_t ; status = 0, . Int_t ; start = -1, . Int_t ; end = -1 . ). Send log file to master. ; If start > -1 send only bytes in the range from start to end, if end <= start send everything from start. ; Definition at line 802 of file TApplicationServer.cxx. ◆ Setup(). Int_t TApplicationServer::Setup ; (; ). private . Print the Remote Server logo on standard output. ; Return 0 on success, -1 on failure ; Definition at line 366 of file TApplicationServer.cxx. ◆ Streamer(). void TApplicationServer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TApplication. ◆ StreamerNVirtual(). void TApplicationServer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 94 of file TApplicationServer.h. ◆ Terminate(). void TApplicationServer::Terminate ; (; Int_t ; status). overridevirtual . Terminate the proof server. ; Reimplemented from TApplication.; Definition at line 1028 of file TApplicationServer.cxx. Member Data Documentation. ◆ fInterrupt. Bool_t TApplicationServer::fInterru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:29423,log,log,29423,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['log'],['log']
Testability," Bool_t LooseOptionCheckingEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; PyObject * fClassifier;  ; PyObject * fLocalNS;  ; PyObject * fModule;  ; PyObject * fPyReturn;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static PyObject * fGlobalNS = NULL;  ; static PyObject * fMain = NULL;  ; static PyObject * fModulePickle = NULL;  ; static PyObject * fPickleDumps = NULL;  ; static PyObject * fPickleLoads = NULL;  . Static Private Attributes; static PyObject * fEval = NULL;  ; static PyObject * fModuleBuiltin = NULL;  ; static PyObject * fOpen = NULL;  . Friends; class Factory;  . Additional Inherited Members;  Public Types inherited from TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html:27572,test,testing,27572,doc/master/classTMVA_1_1PyMethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html,2,"['log', 'test']","['logger', 'testing']"
Testability," Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; �[5]� M. Morh�č,� J",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:50276,log,logical,50276,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,10,['log'],['logical']
Testability," C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:10643,log,logging,10643,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['log'],['logging']
Testability," Canvas class.Definition TCanvas.h:23; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TViewSee TView3D.Definition TView.h:25; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; TView::SetRangevirtual void SetRange(const Double_t *min, const Double_t *max)=0; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; lTLine lDefinition textangle.C:4. TPolyLine3D is a basic graphics primitive which ignores the fact the current pad has logarithmic scale(s). It simply draws the 3D line in the current user coordinates. If logarithmic scale is set along one of the three axis, the logarithm of vector coordinates along this axis should be use. Alternatively and higher level class, knowing about logarithmic scales, might be used. For instance TGraph2D with option L. ; Definition at line 32 of file TPolyLine3D.h. Public Member Functions;  TPolyLine3D ();  3-D polyline default constructor. ;  ;  TPolyLine3D (const TPolyLine3D &polylin);  3-D polyline copy ctor. ;  ;  TPolyLine3D (Int_t n, Double_t const *p, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Double_t const *x, Double_t const *y, Double_t const *z, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Float_t const *p, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Float_t const *x, Float_t const *y, Float_t const *z, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Option_t *option="""");  3-D polyline normal constructor with initialization to 0. ;  ;  ~TPolyLine3D () o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPolyLine3D.html:2852,log,logarithmic,2852,doc/master/classTPolyLine3D.html,https://root.cern,https://root.cern/doc/master/classTPolyLine3D.html,2,['log'],"['logarithm', 'logarithmic']"
Testability, Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of Novosibirsk PDF; RooCBShape Cryst,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:24843,test,test,24843,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['test'],['test']
Testability," Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQUndoManager.html:20500,log,logging,20500,root/html604/TQUndoManager.html,https://root.cern,https://root.cern/root/html604/TQUndoManager.html,2,['log'],['logging']
Testability," Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:20500,log,logging,20500,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['log'],['logging']
Testability," Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::KDEKernel. class TMVA::KDEKernel. Function Members (Methods); public:. virtual~KDEKernel(); static TClass*Class(); Float_tGetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); const char*GetName() const; virtual TClass*IsA() const; TMVA::KDEKernelKDEKernel(const TMVA::KDEKernel&); TMVA::KDEKernelKDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__KDEKernel.html:1063,Log,Log,1063,root/html534/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html534/TMVA__KDEKernel.html,1,['Log'],['Log']
Testability," Collection of overlay elements to draw/select together.; TGLOvlSelectRecord Standard GL overlay-selection record.; TGLPShapeObj This object wraps TGLPhysicalShape (not a TObject); TGLPShapeObjEditor GUI for editing attributes of a physical-shape.; TGLPShapeRef Reference to a TGLPhysicalShape object.; TGLPadPainter ; TGLPaintDevice Base class for GL widgets and GL off-screen rendering; TGLParametricEquation Equation of parametric surface.; TGLParametricEquationGL GL renderer for TGLParametricEquation; TGLParametricPlot Parametric plot's painter.; TGLPerspectiveCamera Camera for perspective view.; TGLPhysicalShape a physical (placed, global frame) drawable object; TGLPlane GL plane helper/wrapper class; TGLPlot3D Short description.; TGLPlotBox Back box for plot.; TGLPlotCamera Camera for plot-painters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPainter Base for gl plots; TGLPolyLine a polyline logical shape; TGLPolyMarker a polymarker logical shape; TGLQuadric GL quadric object; TGLRect GL rect helper/wrapper class; TGLRnrCtx Collection of objects and data passes along all rendering calls.; TGLRotateManip GL rotation manipulator widget; TGLSAFrame GUI frame for standalone viewer; TGLSAViewer Standalone GL viewer.; TGLScaleManip GL scaling manipulator widget; TGLScene Standard ROOT OpenGL scene with logial/physical shapes.; TGLScene::TSceneInfo ; TGLSceneBase Base-class for OpenGL scenes.; TGLSceneInfo Data about a scene within a viewer context.; TGLScenePad GL-scene filled via TPad-TVirtualViewer interface.; TGLSelectBuffer OpenGL select buffer with depth sorting.; TGLSelectRecord Standard GL selection record.; TGLSelectRecordBase Base class for GL selection records.; TGLSelectionBuffer Holds color buffer content for selection; TGLSphere a spherical logical shape; TGLStopwatch a GL stopwatch utility class; TGLSurfacePainter Surface painter.; TGLTF3Painter GL TF3 painter.; TGLTH3Composition Composition of TH3 objects.; TGLTH3CompositionPainter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:75431,log,logical,75431,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,20,['log'],['logical']
Testability," Compression; File Size; Write Times; Read Times. 0; 19.75 MB; 6.84 sec.; 0.79 sec. 1; 17.73 MB; 6.44 sec.; 0.90 sec. 2; 13.78 MB; 11.34 sec.; 2.17 sec. 20.2.1.2 Setting the Split Level. Split Level = 0:; Now we execute Event with the split parameter set to 0:; > Event 400 1 0 1; > root; root[] TFile f(""Event.root""); root[] TBrowser T; We notice that only one branch is visible (event). The individual data members of the Event object are no longer visible in the browser. They are contained in the event object on the event branch, because we specified no splitting. Split Level = 1:; Setting the split level to 1 will create a branch for each data member in the Event object. First we execute Event and set the split level to 1 and start the browser to examine the split tree:; > Event 400 1 1 1; > root; root[] TFile f(""Event.root""); root[] TBrowser browser. 20.2.2 stress - Test and Benchmark; The executable stress is created by compiling stress.cxx. It completes sixteen tests covering the following capabilities of the ROOT framework. Functions, Random Numbers, Histogram Fits; Size & compression factor of a ROOT file; Purge, Reuse of gaps in TFile; 2D Histograms, Functions, 2D Fits; Graphics & PostScript; Subdirectories in a ROOT file; TNtuple, Selections, TCutG, TEventList; Split and Compression modes for Trees; Analyze Event.root file of stress 8; Create 10 files starting from Event.root; Test chains of Trees using the 10 files; Compare histograms of test 9 and 11; Merging files of a chain; Check correct rebuilt of Event.root in test 13; Divert Tree branches to separate files; Cling test (3 nested loops) with LHCb trigger. The program stress takes one argument, the number of events to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; Fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1082567,test,tests,1082567,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['tests']
Testability," Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array of minimum and maximum values; By default otherwise the domain is undefined, i.e. is [-inf,+inf]; To remove the domain do a SetDomain(0,0).; There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to; specify un infinite domain in that coordinate. void SetMode(const double* x). set the mode of the distribution (coordinates of the distribution maximum values). const double * GetLowerDomain() const. get the distribution lower domain values. Return a null pointer if domain is not defined. const double * GetUpperDomain() const. get the distribution upper domain values. Return a null pointer if domain is not defined. const double * GetMode() const. get the mode (vector of coordinate positions of the maxima of the distribution); If a mode has not defined return a NULL pointer. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }. » Last changed: root/unuran:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuranMultiContDist.html:3809,log,log,3809,root/html602/TUnuranMultiContDist.html,https://root.cern,https://root.cern/root/html602/TUnuranMultiContDist.html,2,['log'],['log']
Testability," Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array of minimum and maximum values; By default otherwise the domain is undefined, i.e. is [-inf,+inf]; To remove the domain do a SetDomain(0,0).; There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to; specify un infinite domain in that coordinate. void SetMode(const double* x). set the mode of the distribution (coordinates of the distribution maximum values). const double * GetLowerDomain() const. get the distribution lower domain values. Return a null pointer if domain is not defined. const double * GetUpperDomain() const. get the distribution upper domain values. Return a null pointer if domain is not defined. const double * GetMode() const. get the mode (vector of coordinate positions of the maxima of the distribution); If a mode has not defined return a NULL pointer. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnuranMultiContDist.html:3776,log,log,3776,root/html604/TUnuranMultiContDist.html,https://root.cern,https://root.cern/root/html604/TUnuranMultiContDist.html,2,['log'],['log']
Testability," Current pad.Definition TPad.cxx:693; TPad::GetLogyInt_t GetLogy() const overrideDefinition TPad.h:257; TPad::PaintLineNDCvoid PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2) overridePaint line in normalized coordinates.Definition TPad.cxx:4336; TPad::PixeltoYDouble_t PixeltoY(Int_t py) overrideConvert pixel to Y coordinate.Definition TPad.cxx:7397; TPad::Printvoid Print(const char *filename="""") const overrideThis method is equivalent to SaveAs(""filename""). See TPad::SaveAs for details.Definition TPad.cxx:4798; TPad::GetEventXInt_t GetEventX() const overrideGet X event.Definition TPad.cxx:2762; TPad::GetFrameTFrame * GetFrame() overrideGet frame.Definition TPad.cxx:2955; TPad::fYUpNDCDouble_t fYUpNDCDefinition TPad.h:65; TPad::fYtoAbsPixelkDouble_t fYtoAbsPixelkConversion coefficient for Y World to absolute pixel.Definition TPad.h:44; TPad::fXtoPixelkDouble_t fXtoPixelkConversion coefficient for X World to pixel.Definition TPad.h:42; TPad::fLogyInt_t fLogy(=0 if Y linear scale, =1 if log scale)Definition TPad.h:92; TPad::fFrameTFrame * fFrame! Pointer to 2-D frame (if one exists)Definition TPad.h:111; TPad::GetPainterTVirtualPadPainter * GetPainter() overrideGet pad painter from TCanvas.Definition TPad.cxx:7262; TPad::Closedvirtual void Closed()Definition TPad.h:184; TPad::fHNDCDouble_t fHNDCHeight of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:67; TPad::ShowGuidelinesvoid ShowGuidelines(TObject *object, const Int_t event, const char mode='i', const bool cling=true) overrideShows lines to indicate if a TAttBBox2D object is aligned to the center or to another object,...Definition TPad.cxx:6350; TPad::GetCrosshairInt_t GetCrosshair() constReturn the crosshair type (from the mother canvas) crosshair type = 0 means no crosshair.Definition TPad.cxx:6651; TPad::GetRangeAxisvoid GetRangeAxis(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) overrideReturn pad axis coordinates range.Definition TPad.cxx:3043; TPad::SetBorderMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:58355,log,log,58355,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['log'],['log']
Testability," Current pad.Definition TPad.cxx:693; TPad::GetLogyInt_t GetLogy() const overrideDefinition TPad.h:257; TPad::PaintLineNDCvoid PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2) overridePaint line in normalized coordinates.Definition TPad.cxx:4336; TPad::PixeltoYDouble_t PixeltoY(Int_t py) overrideConvert pixel to Y coordinate.Definition TPad.cxx:7397; TPad::Printvoid Print(const char *filename="""") const overrideThis method is equivalent to SaveAs(""filename""). See TPad::SaveAs for details.Definition TPad.cxx:4798; TPad::GetEventXInt_t GetEventX() const overrideGet X event.Definition TPad.cxx:2762; TPad::GetFrameTFrame * GetFrame() overrideGet frame.Definition TPad.cxx:2955; TPad::fYUpNDCDouble_t fYUpNDCDefinition TPad.h:65; TPad::fYtoAbsPixelkDouble_t fYtoAbsPixelkConversion coefficient for Y World to absolute pixel.Definition TPad.h:44; TPad::fXtoPixelkDouble_t fXtoPixelkConversion coefficient for X World to pixel.Definition TPad.h:42; TPad::fLogyInt_t fLogy(=0 if Y linear scale, =1 if log scale)Definition TPad.h:92; TPad::fFrameTFrame * fFrame! Pointer to 2-D frame (if one exists)Definition TPad.h:111; TPad::GetPainterTVirtualPadPainter * GetPainter() overrideGet pad painter from TCanvas.Definition TPad.cxx:7262; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TPad::Closedvirtual void Closed()Definition TPad.h:184; TPad::fHNDCDouble_t fHNDCHeight of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:67; TPad::ShowGuidelinesvoid ShowGuidelines(TObject *object, const Int_t event, const char mode='i', const bool cling=true) overrideShows lines to indicate if a TAttBBox2D object is aligned to the center or to another object,...Definition TPad.cxx:6350; TPad::GetCrosshairInt_t GetCrosshair() constReturn the crosshair type (from the mother canvas) crosshair type = 0 means no crosshair.Definition TPad.cxx:6651; TPad::GetRangeAxisvoid GetRangeAxis(Double_t &xmin, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:314837,log,log,314837,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['log'],['log']
Testability," Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSubString.html:2207,Assert,AssertElement,2207,root/html534/TSubString.html,https://root.cern,https://root.cern/root/html534/TSubString.html,1,['Assert'],['AssertElement']
Testability," DataSetInfo & > TMVAInput_tDefinition DataLoader.h:40; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::fetchValueTmpTString fetchValueTmp(const std::map< TString, TString > &keyValueMap, TString key)Definition MethodDL.cxx:75; TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMVA::TTrainingSettingsAll of the options that can be specified in the training string.Definition MethodDL.h:72; TMVA::TTrainingSettings::batchSizesize_t batchSizeDefinition MethodDL.h:73; TMVA::TTrainingSettings::optimizerParamsstd::map< TString, double > optimizerParamsDefinition MethodDL.h:84; TMVA::TTrainingSettings::optimizerNameTString optimizerNameDefinition MethodDL.h:79; TMVA::TTrainingSettings::optimizerDNN::EOptimizer optimizerDefinition MethodDL.h:78; TMVA::TTrainingSettings::maxEpochssize_t maxEpochsDefinition MethodDL.h:76; TMVA::TTrainingSettings::momentumDouble_t momentumDefinition MethodDL.h:81; TMVA::TTrainingSettings::weightDecayDouble_t weightDecayDefinition MethodDL.h:82; TMVA::TTrainingSettings::testIntervalsize_t testIntervalDefinition MethodDL.h:74; TMVA::TTrainingSettings::regularizationDNN::ERegularization regularizationDefinition MethodDL.h:77; TMVA::TTrainingSettings::convergenceStepssize_t convergenceStepsDefinition MethodDL.h:75; TMVA::TTrainingSettings::dropoutProbabilitiesstd::vector< Double_t > dropoutProbabilitiesDefinition MethodDL.h:83; TMVA::TTrainingSettings::learningRateDouble_t learningRateDefinition MethodDL.h:80; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; t1auto * t1Definition textangle.C:20; Functions.h; Types.h; outputstatic void output(). tmvatmvasrcMethodDL.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:121848,test,testIntervalDefinition,121848,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['test'],['testIntervalDefinition']
Testability," Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProdPdf.html:55274,test,test,55274,root/html530/RooProdPdf.html,https://root.cern,https://root.cern/root/html530/RooProdPdf.html,1,['test'],['test']
Testability," Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Nov 23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:54917,test,test,54917,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,1,['test'],['test']
Testability," DefineSection(1, z1, x1, y1, scale1); // -''- secons section. DefineSection(nz-1, zn, xn, yn, scalen); // parameters for last section. *NOTES*; Currently navigation functionality not fully implemented (only Contains()).; Decomposition in concave polygons not implemented - drawing in solid mode; within x3d produces incorrect end-faces. Function Members (Methods); public:. TGeoXtru(); TGeoXtru(Int_t nz); TGeoXtru(Double_t* param); virtual~TGeoXtru(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Bool_tDefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); virtual voidDefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoXtru.html:2324,test,testNo,2324,root/html532/TGeoXtru.html,https://root.cern,https://root.cern/root/html532/TGeoXtru.html,2,['test'],['testNo']
Testability," Definition at line 145 of file GSLMultiFit.h. ◆ Name(). std::string ROOT::Math::GSLMultiFit::Name ; (; ); const. inline . Definition at line 140 of file GSLMultiFit.h. ◆ operator=() [1/2]. GSLMultiFit & ROOT::Math::GSLMultiFit::operator= ; (; const GSLMultiFit & ; rhs). delete . ◆ operator=() [2/2]. GSLMultiFit & ROOT::Math::GSLMultiFit::operator= ; (; GSLMultiFit && ; rhs). delete . ◆ Set(). template<class Func > . int ROOT::Math::GSLMultiFit::Set ; (; const std::vector< Func > & ; funcVec, . const double * ; x . ). inline . set the solver parameters ; Definition at line 111 of file GSLMultiFit.h. ◆ TestDelta(). int ROOT::Math::GSLMultiFit::TestDelta ; (; double ; absTol, . double ; relTol . ); const. inline . test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ; Definition at line 191 of file GSLMultiFit.h. ◆ TestGradient(). int ROOT::Math::GSLMultiFit::TestGradient ; (; double ; absTol); const. inline . test gradient (ask from solver gradient vector) ; Definition at line 183 of file GSLMultiFit.h. ◆ X(). const double * ROOT::Math::GSLMultiFit::X ; (; ); const. inline . parameter values at the minimum ; Definition at line 151 of file GSLMultiFit.h. Member Data Documentation. ◆ fCov. gsl_matrix* ROOT::Math::GSLMultiFit::fCov. mutableprivate . Definition at line 221 of file GSLMultiFit.h. ◆ fFunc. GSLMultiFitFunctionWrapper ROOT::Math::GSLMultiFit::fFunc. private . Definition at line 216 of file GSLMultiFit.h. ◆ fSolver. gsl_multifit_fdfsolver* ROOT::Math::GSLMultiFit::fSolver. private . Definition at line 217 of file GSLMultiFit.h. ◆ fTmp. gsl_vector* ROOT::Math::GSLMultiFit::fTmp. mutableprivate . Definition at line 220 of file GSLMultiFit.h. ◆ fType. const gsl_multifit_fdfsolver_type* ROOT::Math::GSLMultiFit::fType. private . Definition at line 225 of file GSLMultiFit.h. ◆ fVec. gsl_vector* ROOT::Math::GSLMultiFit::fVec. mutableprivate . Definition at line 219 of file GSLMultiFit.h. math/mathmore/src/GSLMultiFit.h. ROOTMathGSLMul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiFit.html:4501,test,test,4501,doc/master/classROOT_1_1Math_1_1GSLMultiFit.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiFit.html,1,['test'],['test']
Testability," Definition at line 1541 of file TH1.cxx. ◆ CheckConsistency(). int TH1::CheckConsistency ; (; const TH1 * ; h1, . const TH1 * ; h2 . ). staticprotected . Check histogram compatibility. ; Definition at line 1677 of file TH1.cxx. ◆ CheckConsistentSubAxes(). bool TH1::CheckConsistentSubAxes ; (; const TAxis * ; a1, . Int_t ; firstBin1, . Int_t ; lastBin1, . const TAxis * ; a2, . Int_t ; firstBin2 = 0, . Int_t ; lastBin2 = 0 . ). staticprotected . Check that two sub axis are the same. ; The limits are defined by first bin and last bin N.B. no check is done in this case for variable bins ; Definition at line 1640 of file TH1.cxx. ◆ CheckEqualAxes(). bool TH1::CheckEqualAxes ; (; const TAxis * ; a1, . const TAxis * ; a2 . ). staticprotected . Check that the axis are the same. ; Definition at line 1611 of file TH1.cxx. ◆ Chi2Test(). Double_t TH1::Chi2Test ; (; const TH1 * ; h2, . Option_t * ; option = ""UU"", . Double_t * ; res = nullptr . ); const. virtual . \( \chi^{2} \) test for comparing weighted and unweighted histograms. ; Compares the histograms' adjusted (normalized) residuals. Function: Returns p-value. Other return values are specified by the 3rd parameter; Parameters. [in]h2the second histogram ; [in]option; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted); ""NORM"" = to be used when one or both of the histograms is scaled but the histogram originally was unweighted; by default underflows and overflows are not included:; ""OF"" = overflows included; ""UF"" = underflows included. ""P"" = print chi2, ndf, p_value, igood; ""CHI2"" = returns chi2 instead of p-value; ""CHI2/NDF"" = returns \( \chi^{2} \)/ndf . [in]resnot empty - computes normalized residuals and returns them in this array. The current implementation is based on the papers \( \chi^{2} \) test for comparison of weighted and unweighted histograms"" in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:85772,test,test,85772,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability," Definition at line 326 of file NeuralNet.cxx. ◆ endTrainCycle(). void TMVA::DNN::ClassificationSettings::endTrainCycle ; (; double ; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 296 of file NeuralNet.cxx. ◆ setResultComputation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented from TMVA::DNN::Settings.; Definition at line 930 of file NeuralNet.h. ◆ testSample(). void TMVA::DNN::ClassificationSettings::testSample ; (; double ; error, . double ; output, . double ; target, . double ; weight . ). virtual . action to be done after the computation of a test sample (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 304 of file NeuralNet.cxx. Member D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:8533,test,test,8533,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['test'],['test']
Testability," Definition at line 46 of file CvSplit.h. ◆ IsA(). virtual TClass * TMVA::CvSplit::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::CvSplitKFolds.; Definition at line 57 of file CvSplit.h. ◆ MakeKFoldDataSet(). virtual void TMVA::CvSplit::MakeKFoldDataSet ; (; DataSetInfo & ; dsi). pure virtual . Implemented in TMVA::CvSplitKFolds. ◆ NeedsRebuild(). Bool_t TMVA::CvSplit::NeedsRebuild ; (; ). inline . Definition at line 47 of file CvSplit.h. ◆ PrepareFoldDataSet(). void TMVA::CvSplit::PrepareFoldDataSet ; (; DataSetInfo & ; dsi, . UInt_t ; foldNumber, . Types::ETreeType ; tt . ). virtual . Set training and test set vectors of dataset described by dsi. ; Parameters. [in]dsiDataSetInfo for data set to be split ; [in]foldNumberOrdinal of fold to prepare ; [in]ttThe set used to prepare fold. If equal to Types::kTraining splitting will be based off the original train set. If instead equal to Types::kTesting the test set will be used. The original training/test set is the set as defined by DataLoader::PrepareTrainingAndTestSet. Sets the training and test set vectors of the DataSet described by dsi as defined by the split. If tt is eqal to Types::kTraining the split will be based off of the original training set.; Note: Requires MakeKFoldDataSet to have been called first. ; Definition at line 57 of file CvSplit.cxx. ◆ RecombineKFoldDataSet(). void TMVA::CvSplit::RecombineKFoldDataSet ; (; DataSetInfo & ; dsi, . Types::ETreeType ; tt = Types::kTraining . ). virtual . Definition at line 114 of file CvSplit.cxx. ◆ Streamer(). virtual void TMVA::CvSplit::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::CvSplitKFolds. ◆ StreamerNVirtual(). void TMVA::CvSplit::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file CvSplit.h. Member Data Documentation. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplit.html:16199,test,test,16199,doc/master/classTMVA_1_1CvSplit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplit.html,1,['test'],['test']
Testability," Definition at line 594 of file TMath.h. ◆ CosH(). Double_t TMath::CosH ; (; Double_t ; x). inline . Returns the hyperbolic cosine of x. ; Definition at line 612 of file TMath.h. ◆ Cross(). template<typename T > . T * TMath::Cross ; (; const T ; v1[3], . const T ; v2[3], . T ; out[3] . ). Calculates the Cross Product of two vectors: out = [v1 x v2]. ; Definition at line 1197 of file TMath.h. ◆ CUncertainty(). constexpr Double_t TMath::CUncertainty ; (; ). constexpr . Speed of light uncertainty. ; Definition at line 128 of file TMath.h. ◆ DegToRad(). constexpr Double_t TMath::DegToRad ; (; ). constexpr . Conversion from degree to radian: \( \frac{\pi}{180} \). ; Definition at line 79 of file TMath.h. ◆ DiLog(). Double_t TMath::DiLog ; (; Double_t ; x). Modified Struve functions of order 1. ; The DiLogarithm function Code translated by R.Brun from CERNLIB DILOG function C332. ; Definition at line 116 of file TMath.cxx. ◆ E(). constexpr Double_t TMath::E ; (; ). constexpr . Base of natural log: \( e \). ; Definition at line 93 of file TMath.h. ◆ Erf(). Double_t TMath::Erf ; (; Double_t ; x). Computation of the error function erf(x). ; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x ; Definition at line 190 of file TMath.cxx. ◆ Erfc(). Double_t TMath::Erfc ; (; Double_t ; x). Computes the complementary error function erfc(x). ; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity ; Definition at line 199 of file TMath.cxx. ◆ ErfcInverse(). Double_t TMath::ErfcInverse ; (; Double_t ; x). Returns the inverse of the complementary error function. ; x must be 0<x<2 implement using the quantile of the normal distribution instead of ErfInverse for better numerical precision for large x ; Definition at line 242 of file TMath.cxx. ◆ ErfInverse(). Double_t TMath::ErfInverse ; (; Double_t ; x). Returns the inverse error function. ; x must be <-1<x<1 ; Definition at line 208 of file TMath.cxx. ◆ EulerGamma(). constexpr Double_t TMath::EulerGamma ; (; ). c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:38593,log,log,38593,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['log'],['log']
Testability, Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer shall be used (e.g. SGD) ; Definition at line 774 of file NeuralNet.h. ◆ momentum(). double TMVA::DNN::Settings::momentum ; (; ); const. inline . get the momentum (e.g. for SGD) ; Definition at line 772 of file NeuralNet.h. ◆ pads(). void TMVA::DNN::S,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:8868,test,testError,8868,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['test'],['testError']
Testability," Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::LocMaxLong64_t LocMax(Long64_t n, const T *a)Returns index of array with the maximum element.Definition TMath.h:1012; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::GnUncertaintyconstexpr Double_t GnUncertainty()Standard acceleration of gravity uncertainty.Definition TMath.h:181; TMath::Hcgsconstexpr Double_t Hcgs()Definition TMath.h:195; TMath::HUncertaintyconstexpr Double_t HUncertainty()Planck's constant uncertainty.Definition TMath.h:202; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:64995,log,logarithm,64995,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['log'],['logarithm']
Testability," Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; TMVA::DataLoader::GetCorrelationMatrixTH2 * GetCorrelationMatrix(const TString &className)returns the correlation matrix of datasetsDefinition DataLoader.cxx:717; TMVA::DataLoader::DataLoaderCopyfriend void DataLoaderCopy(TMVA::DataLoader *des, TMVA::DataLoader *src); TMVA::DataLoader::UserAssignEventsBool_t UserAssignEvents(UInt_t clIndex)Definition DataLoader.cxx:311; TMVA::DataLoader::AddSignalTrainingEventvoid AddSignalTrainingEvent(const std::vector< Double_t > &event, Double_t weight=1.0)add signal training eventDefinition DataLoader.cxx:228; TMVA::DataLoader::fVerboseBool_t fVerboseverbose modeDefinition DataLoader.h:196; TMVA::DataLoader::AddRegressionTargetvoid AddRegressionTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)Definition DataLoader.h:132; TMVA::DataLoader::AddTestEventvoid AddTestEvent(const TString &className, const std::vector< Double_t > &event, Double_t weight)add signal test eventDefinition DataLoader.cxx:268; TMVA::DataLoader::DataAssignTypeDataAssignTypeDefinition DataLoader.h:199; TMVA::DataLoader::kAssignTrees@ kAssignTreesDefinition DataLoader.h:200; TMVA::DataLoader::kAssignEvents@ kAssignEventsDefinition DataLoader.h:201; TMVA::DataLoader::kUndefined@ kUndefinedDefinition DataLoader.h:199; TMVA::DataLoader::SetSignalTreevoid SetSignalTree(TTree *signal, Double_t weight=1.0)Definition DataLoader.cxx:432; TMVA::DataLoader::fTransformationsTString fTransformationsList of transformations to test.Definition DataLoader.h:195; TMVA::DataLoader::SetInputTreesvoid SetInputTrees(const TString &signalFileName, const TString &backgroundFileName, Double_t signalWeight=1.0, Double_t backgroundWeight=1.0)Definition DataLoader.cxx:464; TMVA::DataLoader::~DataLoadervirtual ~DataLoader()Definition DataLoader.cxx:96; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weigh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8h_source.html:18029,test,test,18029,doc/master/DataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8h_source.html,1,['test'],['test']
Testability," Double_t ovlp); Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:14520,test,testNo,14520,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,7,"['Test', 'test']","['Test', 'testNo']"
Testability," Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameters(const Double_t* params); virtual voidROOT::v5::TFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidROOT::v5::TFormula::SetParName(Int_t ipar, const char* name); virtual voidROOT::v5::TFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; voidSetQuickLoad(Bool_t quick); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const ROOT::v5::TFormula& formula); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const char* name, const char* formula); TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual voidROOT::v5::TFormula::Update(); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:9827,Test,TestBit,9827,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoTubeSeg::SetSegsAndPols(TBuffer3D& buff) const; voidTGeoShape::SetShapeBit(UInt_t f); voidTGeoShape::SetShapeBit(UInt_t f, Bool_t set); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTGeoShape::SetTransform(TGeoMatrix* matrix); voidTGeoTube::SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoTubeSeg::SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); virtual voidTObject::SetUniqueID(UInt_t uid); Int_tTGeoShape::ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidTGeoTubeSeg::Sizeof3D() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTGeoShape::TestShapeBit(UInt_t f) const; Int_tTGeoShape::TestShapeBits(UInt_t f) const; static Double_tTGeoShape::Tolerance(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCtub.html:11565,Test,TestBit,11565,root/html532/TGeoCtub.html,https://root.cern,https://root.cern/root/html532/TGeoCtub.html,4,['Test'],"['TestBit', 'TestBits', 'TestShapeBit', 'TestShapeBits']"
Testability," Double_t valbeg = 0, Double_t valend = 0); Third spline creator given a TGraph with; abscissa in increasing order and possibly end; point conditions. TSpline3(const TH1* h, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); Third spline creator given a TH1. TSpline3(const TSpline3& ); copy constructor. TSpline3& operator=(const TSpline3& ); assignment operator. void SetCond(const char* opt); Check the boundary conditions. void Test(); Test method for TSpline5. n number of data points.; m 2*m-1 is order of spline.; m = 2 always for third spline.; nn,nm1,mm,; mm1,i,k,; j,jj temporary integer variables.; z,p temporary double precision variables.; x[n] the sequence of knots.; y[n] the prescribed function values at the knots.; a[200][4] two dimensional array whose columns are; the computed spline coefficients; diff[3] maximum values of differences of values and; derivatives to right and left of knots.; com[3] maximum values of coefficients. test of TSpline3 with nonequidistant knots and; equidistant knots follows. Int_t FindX(Double_t x) const; Find X. Double_t Eval(Double_t x) const; Eval this spline at x. Double_t Derivative(Double_t x) const; Derivative. void SaveAs(const char* filename, Option_t* option = """") const; write this spline as a C++ function that can be executed without ROOT; the name of the function is the name of the file up to the ""."" if any. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPoint(Int_t i, Double_t x, Double_t y); set point number i. void SetPointCoeff(Int_t i, Double_t b, Double_t c, Double_t d); set point coefficient number i. void BuildCoeff(); subroutine cubspl ( tau, c, n, ibcbeg, ibcend ); from * a practical guide to splines * by c. de boor; ************************ input ***************************; n = number of data points. assumed to be .ge. 2.; (tau(i), c(1,i), i=1,...,n) = abscissae and ordinates of the; data points. tau is assumed to be st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpline3.html:11791,test,test,11791,root/html528/TSpline3.html,https://root.cern,https://root.cern/root/html528/TSpline3.html,10,['test'],['test']
Testability," Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TF2.html:6102,log,logx,6102,root/html530/TF2.html,https://root.cern,https://root.cern/root/html530/TF2.html,5,['log'],['logx']
Testability," Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. TGeoChecker::LegoPlot(ntheta, themin, themax, nphi, phimin, phimax,...). Implementation of TGeoVolume::LegoPlot(). Draws a spherical radiation length; lego plot for a given volume, in a given theta/phi range. 6. TGeoChecker::Weigth(Double_t precision). Implementation of TGeoVolume::Weigth(). Estimates the total weigth of a given; volume by matrial sampling. Accepts as input the desired precision. Overlap checker. /*. */. Function Members (Methods); public:. TGeoChecker(); TGeoChecker(TGeoManager* geom); TGeoChecker(const TGeoChecker&); virtual~TGeoChecker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t ic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoChecker.html:1858,Test,Test,1858,root/html532/TGeoChecker.html,https://root.cern,https://root.cern/root/html532/TGeoChecker.html,2,['Test'],['Test']
Testability," Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. TGeoChecker::LegoPlot(ntheta, themin, themax, nphi, phimin, phimax,...). Implementation of TGeoVolume::LegoPlot(). Draws a spherical radiation length; lego plot for a given volume, in a given theta/phi range. 6. TGeoChecker::Weigth(Double_t precision). Implementation of TGeoVolume::Weigth(). Estimates the total weigth of a given; volume by matrial sampling. Accepts as input the desired precision. Overlap checker. /*. */. Function Members (Methods); public:. virtual~TGeoChecker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:1858,Test,Test,1858,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,2,['Test'],['Test']
Testability," Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tGetProb() const; virtual Int_tGetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*GetXaxis() const; virtual Double_tGetXmax() const; virtual Double_tGetXmin() const; TAxis*GetYaxis() const; TAxis*GetZaxis() const; virtual Double_tGradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidGradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitArgs(const Double_t* x, const Double_t* params); static voidInitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, Double_t epsrel = 9.9999999999999998E-13); virtual Double_tIntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); virtual Double_tIntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:11498,log,logx,11498,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['log'],['logx']
Testability," Double_t&, Double_t&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoam.html:10064,log,logger,10064,root/html530/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoam.html,5,['log'],['logger']
Testability," Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); voidGetCov_BetweenClass(); voidGetCov_Full(); voidGetCov_WithinClass(); voidGetDiscrimPower(); voidGetFisherCoeff(); voidGetMean(); virtual voidInit(); voidInitMatrices(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TMVA::MethodFisher::EFisherMethodkFisher; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMVA::MethodFisher::EFisherMethodkMahalanobis; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFisher.html:17850,test,testing,17850,root/html602/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFisher.html,4,['test'],['testing']
Testability," Double_tPt(const TVector3& p) const; Double_tPx() const; Double_tPy() const; Double_tPz() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidRotate(Double_t, const TVector3&); voidRotateUz(const TVector3&); voidRotateX(Double_t); voidRotateY(Double_t); voidRotateZ(Double_t); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMag(Double_t ma); voidSetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); voidSetPerp(Double_t r); voidSetPhi(Double_t); voidSetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); voidSetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); voidSetTheta(Double_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t xx); voidSetXYZ(Double_t xx, Double_t yy, Double_t zz); voidSetY(Double_t yy); voidSetZ(Double_t zz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tTheta() const; TVector3&Transform(const TRotation&); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVector3.html:10048,Test,TestBit,10048,root/html532/TVector3.html,https://root.cern,https://root.cern/root/html532/TVector3.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:22210,test,testArg,22210,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,6,['test'],['testArg']
Testability," Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooErrorVar&operator=(const RooErrorVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:22057,test,testArg,22057,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,4,['test'],['testArg']
Testability," Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLinearVar&operator=(const RooLinearVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:22557,test,testArg,22557,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,4,['test'],['testArg']
Testability," Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:22382,test,testArg,22382,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,4,['test'],['testArg']
Testability," Double_tSafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidSetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buff) const; voidSetShapeBit(UInt_t f); voidSetShapeBit(UInt_t f, Bool_t set); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidSetTransform(TGeoMatrix* matrix); virtual voidTObject::SetUniqueID(UInt_t uid); Int_tShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestShapeBit(UInt_t f) const; Int_tTestShapeBits(UInt_t f) const; TGeoShape(); TGeoShape(const char* name); TGeoShape(const TGeoShape&); static Double_tTolerance(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShape.html:14904,Test,TestBit,14904,root/html602/TGeoShape.html,https://root.cern,https://root.cern/root/html602/TGeoShape.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," Double_tfRaxial radius; Double_tfRmaxouter radius; Double_tfRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorus(); Default constructor. TGeoTorus(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Constructor without name. TGeoTorus(const char* name, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Constructor with name. TGeoTorus(Double_t* params); Constructor based on an array of parameters.; param[0] = R; param[1] = Rmin; param[2] = Rmax; param[3] = Phi1; param[4] = Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTorus.html:12774,Test,Test,12774,root/html532/TGeoTorus.html,https://root.cern,https://root.cern/root/html532/TGeoTorus.html,1,['Test'],['Test']
Testability," Double_t Hcgs ();  \( erg s \) ;  ; constexpr Double_t HUncertainty ();  Planck's constant uncertainty. ;  ; Double_t Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in arrays x and y, kFALSE otherwise. ;  ; Bool_t IsNaN (Double_t x);  ; Bool_t IsNaN (Float_t x);  ; constexpr Double_t K ();  Boltzmann's constant in \( J K^{-1} \): \( k \). ;  ; constexpr Double_t Kcgs ();  \( erg K^{-1} \) ;  ; Double_t KolmogorovProb (Double_t z);  Calculates the Kolmogorov distribution function,. ;  ; Double_t KolmogorovTest (Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option);  Statistical test whether two one-dimensional sets of points are compatible with coming from the same parent distribution, using the Kolmogorov test. ;  ; template<class Element , typename Size > ; Element KOrdStat (Size n, const Element *a, Size k, Size *work=0);  Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements). ;  ; constexpr Double_t KUncertainty ();  Boltzmann's constant uncertainty. ;  ; Double_t Landau (Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);  The LANDAU function. ;  ; Double_t LandauI (Double_t x);  Returns the cumulative (lower tail integral) of the Landau distribution function at point x. ;  ; Double_t LaplaceDist (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the probability density function of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t LaplaceDistI (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the cumulative distribution function (lower t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:10626,test,test,10626,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,2,['test'],['test']
Testability," Double_t� fA2Init;������������������� //initial value of background a2; parameter(backgroud is estimated as a0+a1*x+a2*x*x); ��; Double_t� fA2Calc;������������������� //calculated value of background a2; parameter; ��; Double_t� fA2Err; ��������������������//error value of background a2 parameter; ��; Bool_t�� *fFixPosition;�������������� //[fNPeaks] array of logical values which; allow to fix appropriate positions (not fit). However they are present in the; estimated functional�� ; ��; Bool_t ��*fFixAmp;������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes (not fit). However they are present in the; estimated functional����� ; ��; Bool_t��� fFixSigma;����������������� //logical value of sigma parameter, which; allows to fix the parameter (not to fit).�� ; ��; Bool_t��� fFixT;��������������������� //logical value of t parameter, which; allows to fix the parameter (not to fit).����� ; ��; Bool_t��� fFixB;��������������������� //logical value of b parameter, which; allows to fix the parameter (not to fit).�� ; ��; Bool_t��� fFixS;��������������������� //logical value of s parameter, which; allows to fix the parameter (not to fit).����� ; ��; Bool_t��� fFixA0;�������������������� //logical value of a0 parameter, which; allows to fix the parameter (not to fit).; ��; Bool_t��� fFixA1;�������������������� //logical value of a1 parameter, which; allows to fix the parameter (not to fit).�� ; ��; Bool_t��� fFixA2;�������������������� //logical value of a2 parameter, which; allows to fix the parameter (not to fit).;  ; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estima",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:25754,log,logical,25754,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,10,['log'],['logical']
Testability," Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t CreateCanvas = kTRUE, Bool_t colors = kTRUE, Bool_t log_colors = kFALSE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - CreateCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. - log_colors - whether to fill cells with colors (logarithmic scale). Example:. The following commands load a mono-target regression foam from; file 'foam.root' and create a ROOT macro 'output.C', which; draws all PDEFoam cells with little boxes. The latter are; filled with colors according to the target value stored in the; cell. Also the cell number is drawn. TFile file(""foam.root"");; TMVA::PDEFoam *foam = (TMVA::PDEFoam*) gDirectory->Get(""MonoTargetRegressionFoam"");; foam->RootPlot2dim(""output.C"",""cell_value,cellnumber"");; gROOT->Macro(""output.C"");. void FillBinarySearchTree(const TMVA::Event* ev, Bool_t NoNegWeights = kFALSE); Insert event to internal foam density PDEFoamDistr. void DeleteBinarySearchTree(); Delete the fDistr object, which contains the binary search tree. void Init(); Initialize binary search tree, stored in object of type; PDEFoamDistr. void SetFoamType(TMVA::EFoamType ft); Set the foam type. This determinates the method of the; calculation of the density during the foam build-up. void ReadStream(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:27379,log,logarithmic,27379,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['log'],['logarithmic']
Testability," EFType::kTemplVec) || (fType == EFType::kFormula && fFormula && fFormula->IsVectorized());; 470 }; 471 /// Return the Chisquare after fitting. See ROOT::Fit::FitResult::Chi2(); 472 Double_t GetChisquare() const; 473 {; 474 return fChisquare;; 475 }; 476 virtual TH1 *GetHistogram() const;; 477 virtual TH1 *CreateHistogram(); 478 {; 479 return DoCreateHistogram(fXmin, fXmax);; 480 }; 481 virtual TFormula *GetFormula(); 482 {; 483 return fFormula.get();; 484 }; 485 virtual const TFormula *GetFormula() const; 486 {; 487 return fFormula.get();; 488 }; 489 virtual TString GetExpFormula(Option_t *option = """") const; 490 {; 491 return (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:21179,log,logx,21179,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['log'],['logx']
Testability," ELogLevel::kDebug; }; 192 bool IsInfo() const { return fLevel == ELogLevel::kInfo; }; 193 bool IsWarning() const { return fLevel == ELogLevel::kWarning; }; 194 bool IsError() const { return fLevel == ELogLevel::kError; }; 195 bool IsFatal() const { return fLevel == ELogLevel::kFatal; }; 196};; 197 ; 198namespace Detail {; 199/**; 200 Builds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder,; 201 where - by definition - the RLogEntry has been completely built.; 202 ; 203 This builder can be used through the utility preprocessor macros R__LOG_ERROR,; 204 R__LOG_WARNING etc like this:; 205~~~ {.cpp}; 206 R__LOG_INFO(ROOT::Experimental::HistLog()) << ""all we know is "" << 42;; 207 const int decreasedInfoLevel = 5;; 208 R__LOG_XDEBUG(ROOT::WebGUILog(), decreasedInfoLevel) << ""nitty-gritty details"";; 209~~~; 210 This will automatically capture the current class and function name, the file and line number.; 211 */; 212 ; 213class RLogBuilder : public std::ostringstream {; 214 /// The log entry to be built.; 215 RLogEntry fEntry;; 216 ; 217public:; 218 RLogBuilder(ELogLevel level, RLogChannel &channel) : fEntry(level, channel) {}; 219 RLogBuilder(ELogLevel level, RLogChannel &channel, const std::string &filename, int line,; 220 const std::string &funcname); 221 : fEntry(level, channel, {filename, funcname, line}); 222 {; 223 }; 224 ; 225 /// Emit the log entry through the static log manager.; 226 ~RLogBuilder(); 227 {; 228 fEntry.fMessage = str();; 229 RLogManager::Get().Emit(fEntry);; 230 }; 231};; 232} // namespace Detail; 233 ; 234/**; 235 Change the verbosity level (global or specific to the RLogChannel passed to the; 236 constructor) for the lifetime of this object.; 237 Example:; 238~~~ {.cpp}; 239 RLogScopedVerbosity debugThis(gFooLog, ELogLevel::kDebug);; 240 Foo::SomethingToDebug();; 241~~~; 242 */; 243class RLogScopedVerbosity {; 244 RLogChannel *fChannel;; 245 ELogLevel fPrevLevel;; 246 ; 247public:; 248 RLogScopedVerbosity(RL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:7685,log,log,7685,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['log'],['log']
Testability," EMsgType GetMinType() const { return fMinType; }; 70 void SetMinType( EMsgType minType ) { fMinType = minType; }; 71 std::string GetSource() const { return fStrSource; }; 72 std::string GetPrintedSource() const;; 73 std::string GetFormattedSource() const;; 74 ; 75 static UInt_t GetMaxSourceSize();; 76 ; 77 // Needed for copying; 78 MsgLogger& operator= ( const MsgLogger& parent );; 79 ; 80 // Stream modifier(s); 81 static MsgLogger& Endmsg( MsgLogger& logger );; 82 ; 83 // Accept stream modifiers; 84 MsgLogger& operator<< ( MsgLogger& ( *_f )( MsgLogger& ) );; 85 MsgLogger& operator<< ( std::ostream& ( *_f )( std::ostream& ) );; 86 MsgLogger& operator<< ( std::ios& ( *_f )( std::ios& ) );; 87 ; 88 // Accept message type specification; 89 MsgLogger& operator<< ( EMsgType type );; 90 ; 91 // For all the ""conventional"" inputs; 92 template <class T> MsgLogger& operator<< ( T arg ) {; 93 *(std::ostringstream*)this << arg;; 94 return *this;; 95 }; 96 ; 97 // Temporally disables all the loggers (Caution! Use with care !); 98 static void InhibitOutput();; 99 static void EnableOutput();; 100 ; 101 private:; 102 ; 103 // private utility routines; 104 void Send();; 105 void InitMaps();; 106 void WriteMsg( EMsgType type, const std::string& line ) const;; 107 ; 108 const TObject* fObjSource; ///< the source TObject (used for name); 109 std::string fStrSource; ///< alternative string source; 110 static const std::string fgPrefix; ///< the prefix of the source name; 111 static const std::string fgSuffix; ///< suffix following source name; 112 EMsgType fActiveType; ///< active type; 113 static const UInt_t fgMaxSourceSize; ///< maximum length of source name; 114 static std::atomic<Bool_t> fgOutputSupressed; ///< disable the output globally (used by generic booster); 115 static std::atomic<Bool_t> fgInhibitOutput; ///< flag to suppress all output; 116 ; 117 static std::atomic<const std::map<EMsgType, std::string>*> fgTypeMap; ///< matches output types with strings; 118 static std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MsgLogger_8h_source.html:3384,log,loggers,3384,doc/master/MsgLogger_8h_source.html,https://root.cern,https://root.cern/doc/master/MsgLogger_8h_source.html,1,['log'],['loggers']
Testability," E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15649,log,log,15649,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,1,['log'],['log']
Testability," E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15649,log,log,15649,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,1,['log'],['log']
Testability, Elapsed time for evaluation of 1000 events: 0.0134 sec ; TFHandler_KNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 3.3352 1.1893 [ 0.00020069 5.0000 ]; : var2: 2.4860 1.4342 [ 0.00071490 5.0000 ]; : fvalue: 163.91 83.651 [ 1.6186 394.84 ]; : -----------------------------------------------------------; : Evaluate regression method: LD; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 9000 events: 0.00655 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 1000 events: 0.00224 sec ; TFHandler_LD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 3.3352 1.1893 [ 0.00020069 5.0000 ]; : var2: 2.4860 1.4342 [ 0.00071490 5.0000 ]; : fvalue: 163.91 83.651 [ 1.6186 394.84 ]; : -----------------------------------------------------------; : Evaluate regression method: DNN_CPU; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 9000 events: 0.23 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 1000 events: 0.0277 sec ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.027271 1.0264 [ -3.3694 5.7307 ]; : var2: 0.0028453 0.98623 [ -5.7307 5.7307 ]; : fvalue: 163.91 83.651 [ 1.6186 394.84 ]; : -----------------------------------------------------------; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.027271 1.0264 [ -3.3694 5.7307 ]; : var2: 0.0028453 0.98623 [ -5.7307 5.7307 ]; : fvalue: 163.91 83.651 [ 1.6186 394.84 ]; : -----------------------------------------------------------; : Evaluate regression method: BDTG; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluatio,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:130927,test,testing,130927,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['test'],['testing']
Testability," Element > TMatrixTAutoloadOps::operator< ; (; const TMatrixT< Element > & ; source1, . const TMatrixTSym< Element > & ; source2 . ). logical operation source1 < source2 ; Definition at line 2705 of file TMatrixT.cxx. ◆ operator<() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator< ; (; const TMatrixTSym< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 < source2 ; Definition at line 2705 of file TMatrixT.cxx. ◆ operator<=() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator<= ; (; const TMatrixT< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 <= source2 ; Definition at line 2705 of file TMatrixT.cxx. ◆ operator<=() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator<= ; (; const TMatrixT< Element > & ; source1, . const TMatrixTSym< Element > & ; source2 . ). logical operation source1 <= source2 ; Definition at line 2705 of file TMatrixT.cxx. ◆ operator<=() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator<= ; (; const TMatrixTSym< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 <= source2 ; Definition at line 2705 of file TMatrixT.cxx. ◆ operator==() [1/2]. template<class Element > . Bool_t TMatrixTAutoloadOps::operator== ; (; const TMatrixTBase< Element > & ; m1, . const TMatrixTBase< Element > & ; m2 . ). Check to see if two matrices are identical. ; Definition at line 855 of file TMatrixTBase.cxx. ◆ operator==() [2/2]. template<class Element > . Bool_t TMatrixTAutoloadOps::operator== ; (; const TVectorT< Element > & ; source1, . const TVectorT< Element > & ; source2 . ). Check to see if two vectors are identical. ; Definition at line 1386 of file TVectorT.cxx. ◆ operator>() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator> ; (; const TMatrixT< Element > & ; sourc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:35259,log,logical,35259,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,1,['log'],['logical']
Testability," Element > TMatrixTAutoloadOps::operator> ; (; const TMatrixT< Element > & ; source1, . const TMatrixTSym< Element > & ; source2 . ). logical operation source1 > source2 ; Definition at line 2612 of file TMatrixT.cxx. ◆ operator>() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator> ; (; const TMatrixTSym< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 > source2 ; Definition at line 2640 of file TMatrixT.cxx. ◆ operator>=() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator>= ; (; const TMatrixT< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 >= source2 ; Definition at line 2649 of file TMatrixT.cxx. ◆ operator>=() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator>= ; (; const TMatrixT< Element > & ; source1, . const TMatrixTSym< Element > & ; source2 . ). logical operation source1 >= source2 ; Definition at line 2677 of file TMatrixT.cxx. ◆ operator>=() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator>= ; (; const TMatrixTSym< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 >= source2 ; Definition at line 2705 of file TMatrixT.cxx. ◆ operator||() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator|| ; (; const TMatrixT< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). Logical OR. ; Definition at line 2525 of file TMatrixT.cxx. ◆ operator||() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator|| ; (; const TMatrixT< Element > & ; source1, . const TMatrixTSym< Element > & ; source2 . ). Logical OR. ; Definition at line 2550 of file TMatrixT.cxx. ◆ operator||() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator|| ; (; const TMatrixTSym< Element > & ; source1, . const TMatrixT< Element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:37450,log,logical,37450,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,1,['log'],['logical']
Testability," Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:48769,log,logger,48769,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability," EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:1879,log,logval,1879,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,2,['log'],"['log', 'logval']"
Testability," EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__TestStatSampler.html:3440,test,test,3440,root/html602/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__TestStatSampler.html,6,"['Test', 'test']","['TestStatistic', 'test', 'testStatistic']"
Testability," EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__TestStatSampler.html:3309,test,test,3309,root/html534/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__TestStatSampler.html,6,"['Test', 'test']","['TestStatistic', 'test', 'testStatistic']"
Testability," EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__TestStatSampler.html:3440,test,test,3440,root/html604/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html604/RooStats__TestStatSampler.html,6,"['Test', 'test']","['TestStatistic', 'test', 'testStatistic']"
Testability," Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;  staff.py example of macro to read data from an ascii file and create a root file with a Tree ;  surfaces.py Surfaces example ;  test.py ;  tornado.pyTornado example ;  tree.py This macro displays the Tree data structures ;  zdemo.py This macro is an example of graphs in log scales with annotations ;  ► pythia;  pythia8.CPythia8 basic example ;  pythiaExample.CUsing Pythia6 with ROOT ;  ► quadp;  portfolio.C This macro shows in detail the use of the quadratic programming package quadp ;  Quad.cxx;  Quad.h;  ► r;  DataFrame.C ;  example.C Simple example on how to use ROOT-R interface ;  Function.C ;  Functor.C Example to create class Functor ;  GlobalMinimization.C Example based in http://cran.r-project.org/web/packages/DEoptim/DEopti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:139014,benchmark,benchmarks,139014,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['benchmark'],['benchmarks']
Testability," FTFont ;  CTGLFontManagerA FreeType GL font manager ;  CTGLFormatEncapsulation of format / contents of an OpenGL buffer ;  CTGLH2PolyPainterPaint TH2Poly ;  CTGLHistPainterThe histogram painter class using OpenGL ;  CTGLineLBEntry;  CTGLineStyleComboBox;  CTGLineWidthComboBox;  CTGLIsoPainter""gliso"" option for TH3 ;  CTGListBox;  CTGListDetailsLayout;  CTGListLayout;  CTGListTree;  CTGListTreeItem;  CTGListTreeItemStd;  CTGListView;  CTGLite;  CTGLiteJob;  CTGLiteJobStatus;  CTGLiteResult;  CTGLLegoPainterPlot-painter implementing LEGO rendering of TH2 histograms in cartesian, polar, cylindrical and spherical coordinates ;  CTGLLevelPalette;  CTGLLightSetEncapsulates a set of lights for OpenGL ;  CTGLLightSetEditor;  CTGLLightSetSubEditorSub-editor for TGLLightSet ;  CTGLLine33D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex' ;  ►CTGLLockableSimple locking interface used by viewer and scene ;  CTUnlocker;  CTGLLogicalShapeAbstract logical shape - a GL 'drawable' - base for all shapes - faceset sphere etc ;  CTGLManager;  CTGLManipAbstract base class for viewer manipulators, which allow direct in viewer manipulation of a (TGlPhysicalShape) object - currently translation, scaling and rotation along/round objects local axes ;  CTGLManipSetCombine all available manipulators in a collection ;  CTGLMatrix16 component (4x4) transform matrix - column MAJOR as per GL ;  CTGlobalGlobal variables class (global variables are obtained from CINT) ;  CTGlobalMappedFunction;  CTGLObjectBase-class for direct OpenGL renderers ;  CTGLongPosition;  CTGLOrthoCameraOrthographic projection camera ;  CTGLOutputWrapper class for GL capture & output routines ;  CTGLOverlayButtonGL-overlay button ;  CTGLOverlayElementAn overlay element ;  CTGLOverlayListManage a collection of overlay elements ;  CTGLOvlSelectRecordSelection record for overlay objects ;  CTGLPadPainter""Delegating"" part of TGLPadPainter ;  CTGLPaintDevice;  CTGLParametricEquati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:151621,log,logical,151621,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,6,['log'],['logical']
Testability," Fit Tests. ; GoFTest class implementing the 1 sample and 2 sample goodness of fit tests for uni-variate distributions and data. ; The class implements the AndersonDarling and the KolmogorovSmirnov tests; In the case of the 1-sample test the user needs to provide:; input data; theoretical distribution. The distribution can be provided as a function object (functor) or an object implementing the ROOT::Math::IGenFunction interface. One can provide either the PDF (default) of the CDF (cumulative distribution) One can also provide a pre-defined function. In that case one needs to give also the distribution parameters otherwise the default values will be used. The pre-defined distributions are:; kGaussian with default parameter mean=0, sigma=1; kExponential with default parameter rate=1; kLogNormal with default parameter meanlog=0, sigmalog=1. Note that one should not use data computed distribution parameters, otherwise the test will be biased. The 1-sample KS test using data computed quantities is called Lilliefors test (see https://en.wikipedia.org/wiki/Lilliefors_test) . Definition at line 65 of file GoFTest.h. Public Types; enum  EDistribution { ;   kUndefined; , kUserDefined; , kGaussian; , kLogNormal; , ;   kExponential. };  H0 distributions for using only with 1-sample tests. More...;  ; enum  ETestType { kAD; , kAD2s; , kKS; , kKS2s; };  Goodness of Fit test types for using with the class's unary functions as a shorthand for the in-built methods. More...;  ; enum  EUserDistribution { kCDF; , kPDF; };  User input distribution option. More...;  . Public Member Functions;  GoFTest (size_t sample1Size, const Double_t *sample1, size_t sample2Size, const Double_t *sample2);  Constructor for 2-samples tests. ;  ;  GoFTest (size_t sampleSize, const Double_t *sample, const IGenFunction &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Constructor for 1-sample tests with a user specified distribution implementing the ROOT::Math::IGenFunction interf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:1367,test,test,1367,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,2,['test'],['test']
Testability," Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; 20.2.3 guitest - A Graphical User Interface. The guitest example, created by compiling guitest.cxx, tests and illustrates the use of the native GUI widgets such as cascading menus, dialog boxes, sliders and tab panels. It is a very useful example to study when designing a GUI. Some examples of the output of guitest are shown next. To run it type guitest at the system prompt in the $ROOTSYS/test directory. We have included an entire chapter on this subject where we explore guitest in detail and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1085552,test,test,1085552,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Test', 'test']","['Test', 'test']"
Testability," Float_t b, Float_t c, Float_t w, Float_t h, Float_t d); voidAddCone(const TEveVector& pos, const TEveVector& dir, Float_t r); virtual voidTEveElement::AddElement(TEveElement* el); voidAddEllipticCone(const TEveVector& pos, const TEveVector& dir, Float_t r, Float_t r2, Float_t angle = 0); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveRGBAPalette*TEveDigitSet::AssertPalette(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveBoxSet.html:2563,Assert,AssertBBox,2563,root/html532/TEveBoxSet.html,https://root.cern,https://root.cern/root/html532/TEveBoxSet.html,4,['Assert'],['AssertBBox']
Testability," Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3510 Int_t theNpoints = theGraph->GetN();; 3511 Double_t *theX = theGraph->GetX();; 3512 Double_t *theY = theGraph->GetY();; 3513 Double_t *theEX = theGraph->GetEX(); if (!theEX) return;; 3514 Double_t *theEY = theGraph->GetEY(); if (!theEY) return;; 3515 ; 3516 if (strchr(option,'X') || strchr(option,'x')) {PaintGraphSimple(theGraph, option); return;}; 3517 Bool_t brackets = kFALSE;; 3518 Bool_t braticks = kFALSE;; 3519 if (strstr(option,""||"") || strstr(option,""[]"")) {; 3520 brackets = kTRUE;; 3521 if (strstr(option,""[]"")) braticks = kTRUE;; 3522 }; 3523 Bool_t endLines = kTRUE;; 3524 if (strchr(option,'z')) endLines = kFALSE;; 3525 if (strchr(option,'Z')) endLines = kFALSE;; 3526 const char *arrowOpt = nullptr;; 3527 if (strchr(option,'>')) arrowOpt = "">"";; 3528 if (strstr(option,""|>"")) arrowOpt = ""|>"";; 3529 ; 3530 Bool_t axis = kFALSE;; 3531 if (strchr(option,'a')) axis = kTRUE;; 3532 if (strchr(option,'A')) axis = kTRUE;; 3533 if (axis) PaintGraphSimple(theGraph, option);; 3534 ; 3535 Bool_t option0 = kFALSE;; 3536 Bool_t option2 = kFALSE;; 3537 Bool_t option3 = kFALSE;; 3538 Bool_t option4 = kFALSE;; 3539 Bool_t option5 = kFALSE;; 3540 if (strchr(option,'0')) option0 = kTRUE;; 3541 if (strchr(option,'2')) option2 = kTRUE;; 3542 if (strchr(option,'3')) option3 = kTRUE;; 3543 if (strchr(option,'4')) {option3 = kTRUE; option4 = kTRUE;}; 3544 if (strchr(option,'5')) {option2 = kTRUE; option5 = kTRUE;}; 3545 ; 3546 // special flags in case of ""reverse plot"" and ""log scale""; 3547 Bool_t xrevlog = kFALSE;; 3548 Bool_t yrevlog = kFALSE;; 3549 if (strstr(option,""-N"")) xrevlog = kTRUE; // along X; 3550 if (strstr(option,""-M"")) yrevlog = kTRUE; // along Y; 3551 ; 3552 if (option3) {; 3553 xline.resize(2*theNpoints);; 3554 yline.resize(2*theNpoints);; 3555 if (xline.empty() || yline.empty()) {; 3556 Error(""PaintGraphErrors"", ""too m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:125741,log,log,125741,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['log'],['log']
Testability," Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPave::SetName(const char* name = """")MENU ; static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPave::SetOption(Option_t* option = ""br""); virtual voidTPave::SetShadowColor(Int_t color)MENU ; virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTBox::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPave::SetX1(Double_t x1); virtual voidTPave::SetX1NDC(Double_t x1); virtual voidTPave::SetX2(Double_t x2); virtual voidTPave::SetX2NDC(Double_t x2); virtual voidTPave::SetY1(Double_t y1); virtual voidTPave::SetY1NDC(Double_t y1); virtual voidTPave::SetY2(Double_t y2); virtual voidTPave::SetY2NDC(Double_t y2); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPaveLabel(); TPaveLabel(const TPaveLabel& pavelabel); TPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = ""br""); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPaveLabel.html:8995,Test,TestBit,8995,root/html602/TPaveLabel.html,https://root.cern,https://root.cern/root/html602/TPaveLabel.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," Float_t ; f . ). scales float vector ; Definition at line 527 of file Tools.cxx. ◆ SetXMLEngineBufferSize(). void TMVA::Tools::SetXMLEngineBufferSize ; (; int ; buffer). inline . Definition at line 264 of file Tools.h. ◆ SplitString(). std::vector< TString > TMVA::Tools::SplitString ; (; const TString & ; theOpt, . const char ; separator . ); const. splits the option string at 'separator' and fills the list 'splitV' with the primitive strings ; Definition at line 1199 of file Tools.cxx. ◆ StringFromDouble(). TString TMVA::Tools::StringFromDouble ; (; Double_t ; d). string tools ; Definition at line 1233 of file Tools.cxx. ◆ StringFromInt(). TString TMVA::Tools::StringFromInt ; (; Long_t ; i). string tools ; Definition at line 1223 of file Tools.cxx. ◆ TMVACitation(). void TMVA::Tools::TMVACitation ; (; MsgLogger & ; logger, . ECitation ; citType = kPlainText . ). kinds of TMVA citation ; Definition at line 1440 of file Tools.cxx. ◆ TMVAVersionMessage(). void TMVA::Tools::TMVAVersionMessage ; (; MsgLogger & ; logger). prints the TMVA release number and date ; Definition at line 1316 of file Tools.cxx. ◆ TMVAWelcomeMessage() [1/2]. void TMVA::Tools::TMVAWelcomeMessage ; (; ). direct output, eg, when starting ROOT session -> no use of Logger here ; Definition at line 1302 of file Tools.cxx. ◆ TMVAWelcomeMessage() [2/2]. void TMVA::Tools::TMVAWelcomeMessage ; (; MsgLogger & ; logger, . EWelcomeMessage ; m = kStandardWelcomeMsg . ). various kinds of welcome messages ASCII text generated by this site: http://www.network-science.de/ascii/ ; Definition at line 1344 of file Tools.cxx. ◆ TransposeHist(). TH2F * TMVA::Tools::TransposeHist ; (; const TH2F & ; h). Transpose quadratic histogram. ; Definition at line 657 of file Tools.cxx. ◆ UsefulSortAscending() [1/2]. void TMVA::Tools::UsefulSortAscending ; (; std::vector< Double_t > & ; v). sort vector ; Definition at line 737 of file Tools.cxx. ◆ UsefulSortAscending() [2/2]. void TMVA::Tools::UsefulSortAscending ; (; std::vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:25498,log,logger,25498,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['log'],['logger']
Testability," Function Documentation. ◆ Class(). static TClass * TRint::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRint::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRint::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 67 of file TRint.h. ◆ DeclFileName(). static const char * TRint::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 67 of file TRint.h. ◆ ExecLogon(). void TRint::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 341 of file TRint.cxx. ◆ GetInputHandler(). TFileHandler * TRint::GetInputHandler ; (; ). inline . Definition at line 65 of file TRint.h. ◆ GetPrompt(). char * TRint::GetPrompt ; (; ). virtual . Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". ; Definition at line 575 of file TRint.cxx. ◆ HandleException(). void TRint::HandleException ; (; Int_t ; sig). overridevirtual . Handle signals (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something different here. ; Reimplemented from TApplication.; Definition at line 704 of file TRint.cxx. ◆ HandleTermInput(). Bool_t TRint::HandleTermInput ; (; ). overridevirtual . Handle input coming from terminal. ; Reimplemented from TApplication.; Definition at line 611 of file TRint.cxx. ◆ Interrupt(). void TRint::Interrupt ; (; ). inline . Definition at line 62 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:23768,log,logon,23768,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['log'],['logon']
Testability," Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MathCore.html:2095,test,tests,2095,doc/master/group__MathCore.html,https://root.cern,https://root.cern/doc/master/group__MathCore.html,2,['test'],['tests']
Testability," G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The formulae are valid only for one POI. If more than one POI exists consider as POI only the; first one. double GetExpectedPValues(double pnull, double palt, double nsigma, bool usecls, bool oneSided = true); function given the null and the alt p value - return the expected one given the N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected one; works for Gaussian, Poisson or LogNormal; assumes mean parameter value is the argument not constant and not depoending on observables; (if more than two arguments are not constant will use first one but printr a warning !); need to iterate on the components of the POisson to get n and nu (nu can be a RooAbsReal); (code from G. Petrucciani and extended by L.M.). RooAbsData * GenerateCountingAsimovData(RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); generate counting Asimov data for the case when the pdf cannot be extended; assume pdf is a RooPoisson or can be decomposed in a product of RooPoisson,; otherwise we cannot know how to make the Asimov data sets in the other cases. RooAbsData * GenerateAsimovDataSinglePdf(const RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); compute the asimov data set for an observable of a pdf; use the number of bins sets in the observables; to do : (possibility to change number of bins); implement integration over bin content. RooAbsData * GenerateAsimovData(const RooAbsP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__AsymptoticCalculator.html:7531,Log,LogNormal,7531,root/html534/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__AsymptoticCalculator.html,3,['Log'],['LogNormal']
Testability," GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:31747,log,logical,31747,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,6,['log'],['logical']
Testability," GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntryField.html:30594,log,logarithmic,30594,root/html528/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html,2,['log'],"['log', 'logarithmic']"
Testability," GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGNumberEntryField.html:30694,log,logarithmic,30694,root/html530/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html530/TGNumberEntryField.html,2,['log'],"['log', 'logarithmic']"
Testability," GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGNumberEntryField.html:30694,log,logarithmic,30694,root/html532/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html532/TGNumberEntryField.html,4,['log'],"['log', 'logarithmic']"
Testability," H1 analysis example ;  mp201_parallelHistoFill.C Parallel fill of a histogram This tutorial shows how a histogram can be filled in parallel with a multiprocess approach ;  mp_H1_lambdas.C Lambdas used to check and fit the result of the H1 analysis ;  mt001_fillHistos.CFill histograms in parallel and write them on file ;  mt101_fillNtuples.CFill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.CFill the same TNtuple from different threads ;  mt201_parallelHistoFill.CParallel fill of a histogram ;  mtbb001_fillHistos.CFill histograms in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:135285,test,test,135285,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability," HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile_c which will; call the same implementation. @ingroup QuantFunc. double gaussian_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #gaussian_quantile_c which will; call the same impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math.html:39699,Log,LogNormalDistribution,39699,root/html532/ROOT__Math.html,https://root.cern,https://root.cern/root/html532/ROOT__Math.html,2,['Log'],['LogNormalDistribution']
Testability, Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:04; This page has b,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TActivationChooser.html:1049,Log,Log,1049,root/html534/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html534/TMVA__TActivationChooser.html,1,['Log'],['Log']
Testability," However they are present in the estimated functional ; Definition at line 101 of file TSpectrum2Fit.h. ◆ fFixAx. Bool_t TSpectrum2Fit::fFixAx. protected . logical value of ax parameter, which allows to fix the parameter (not to fit). ; Definition at line 114 of file TSpectrum2Fit.h. ◆ fFixAy. Bool_t TSpectrum2Fit::fFixAy. protected . logical value of ay parameter, which allows to fix the parameter (not to fit). ; Definition at line 115 of file TSpectrum2Fit.h. ◆ fFixBx. Bool_t TSpectrum2Fit::fFixBx. protected . logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; Definition at line 111 of file TSpectrum2Fit.h. ◆ fFixBy. Bool_t TSpectrum2Fit::fFixBy. protected . logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; Definition at line 112 of file TSpectrum2Fit.h. ◆ fFixPositionX. Bool_t* TSpectrum2Fit::fFixPositionX. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 95 of file TSpectrum2Fit.h. ◆ fFixPositionX1. Bool_t* TSpectrum2Fit::fFixPositionX1. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 97 of file TSpectrum2Fit.h. ◆ fFixPositionY. Bool_t* TSpectrum2Fit::fFixPositionY. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 96 of file TSpectrum2Fit.h. ◆ fFixPositionY1. Bool_t* TSpectrum2Fit::fFixPositionY1. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 98 of file TSpectrum2Fit.h. ◆ fFixRo. Bool_t TSpectrum2Fit::fF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:84650,log,logical,84650,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability," However they are present in the estimated functional ;  ; Bool_t * fFixPositionY1;  [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ;  ; Bool_t fFixRo;  logical value of correlation coefficient, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigmaX;  logical value of sigma x parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigmaY;  logical value of sigma y parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSx;  logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSxy;  logical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSy;  logical value of s parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixTx;  logical value of t parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixTxy;  logical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixTy;  logical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ;  ; Int_t fNPeaks;  number of peaks present in fit, input parameter, it should be > 0 ;  ; Int_t fNumberIterations;  number of iterations in fitting procedure, input parameter, it should be > 0 ;  ; Double_t * fPositionCalcX;  [fNPeaks] array of calculated values of x positions of 2D peaks, output parameters ;  ; Double_t * fPositionCalcX1;  [fNPeaks] array of calculated x positions of 1D ridges, output parameters ;  ; Double_t * fPositionCalcY;  [fNPeaks] array of calculated values of y positions of 2D peaks, output parameters ;  ; Double_t * fPositionCalcY1;  [fNPeaks] array of calculated y positions of 1D ridges, output parameters ;  ; Double_t * fPositionErrX;  [fNPeaks] array of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:28410,log,logical,28410,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability," HypoTestInverterResult::FindIndex ; (; double ; xvalue); const. find the index corresponding at the poi value xvalue If no points is found return -1 Note that a tolerance is used of 10^-12 to find the closest point ; Definition at line 563 of file HypoTestInverterResult.cxx. ◆ FindInterpolatedLimit(). double HypoTestInverterResult::FindInterpolatedLimit ; (; double ; target, . bool ; lowSearch = false, . double ; xmin = 1, . double ; xmax = 0.0 . ). interpolate to find a limit value Use a linear or a spline interpolation depending on the interpolation option ; Definition at line 710 of file HypoTestInverterResult.cxx. ◆ GetAltTestStatDist(). SamplingDistribution * RooStats::HypoTestInverterResult::GetAltTestStatDist ; (; int ; index); const. inline . Definition at line 140 of file HypoTestInverterResult.h. ◆ GetBackgroundTestStatDist(). SamplingDistribution * HypoTestInverterResult::GetBackgroundTestStatDist ; (; int ; index); const. get the background test statistic distribution ; Definition at line 1108 of file HypoTestInverterResult.cxx. ◆ GetExpectedLimit(). double HypoTestInverterResult::GetExpectedLimit ; (; double ; nsig, . bool ; lower, . const char * ; opt = """" . ); const. private . get expected limit (lower/upper) depending on the flag for asymptotic is a special case (the distribution is generated an step in sigma values) distinguish asymptotic looking at the hypotest results if option = ""P"" get expected limit using directly quantiles of p value distribution else (default) find expected limit by obtaining first a full limit distributions The last one is in general more correct ; Definition at line 1313 of file HypoTestInverterResult.cxx. ◆ GetExpectedLowerLimit(). double HypoTestInverterResult::GetExpectedLowerLimit ; (; double ; nsig = 0, . const char * ; opt = """" . ); const. get Limit value corresponding at the desired nsigma level (0) is median -1 sigma is 1 sigma ; Get the expected lower limit nsig is used to specify which expected value of the UpperL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html:28480,test,test,28480,doc/master/classRooStats_1_1HypoTestInverterResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html,1,['test'],['test']
Testability," I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry for details. ; . Can I integrate ROOT into my CMake build? . Absolutely. The CMake command find_package() will set all needed ROOT related variables, which can be used to compile and link one's own code. An example from the ROOT Event example (found in root/test) can be downloaded here. Just un-tar the attached file and run:. cd event/build; cmake ..; make. I use CMake to build my own code, and I would like to use ROOT in that code. Is there a way to wire ROOT into the CMake build files? Something like FindROOT.cmake? ; . Windows: Why must debug (non-debug) compiled code be linked against debug (non-debug) ROOT? . Microsoft's STL classes (std::string, std::vector,...) are different for debug and optimized mode. When calling a ROOT function that expects a STL object as an argument, the caller (e.g. your code) and ROOT must agree on what the object looks like. Thus if you link against ROOT libraries built as debug (non-debug) you must also compile your code as debug (non-debug). ACLiC does that automatically for you. ; . Changing the Displayed Title in Canvas. . Disable the title and add yourself your own title with a TPaveLabel: ; gStyle->SetOptTitle(0);; TPaveLabel *title = new TPaveLabel(.11,.95,.35,.99,""new title"",""brndc"");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:4915,test,test,4915,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['test'],['test']
Testability, IO-intensive PROOF benchmark; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPerfAnalysis Set of tools to analyse the performance tree; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TPro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:122575,log,log,122575,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,6,['log'],['log']
Testability, IO-intensive PROOF benchmark; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:118211,log,log,118211,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['log'],['log']
Testability, IO-intensive PROOF benchmark; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:116750,log,log,116750,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['log'],['log']
Testability," Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::QuickMVAProbEstimator. class TMVA::QuickMVAProbEstimator. Function Members (Methods); public:. virtual~QuickMVAProbEstimator(); voidAddEvent(Double_t val, Double_t weight, Int_t type); static TClass*Class(); static boolcompare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); Double_tGetMVAProbAt(Double_t value); virtual TClass*IsA() const; TMVA::QuickMVAProbEstimator&operator=(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. vector<TMVA::QuickMVAProbEstimator::EventInfo>fEvtVector; Bool_tfIsSorted; TMVA::MsgLogger*fLogger; UInt_tfNMax; UInt_tfNMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddEvent(Double_t val, Double_t weight, Int_t type). Double_t GetMVAProbAt(Double_t value); Well.. if it's fast is actually another question all together, merely; it's a quick and dirty simple kNN approach to the 1-Dim signal/backgr. MVA; distributions. bool compare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); {return e1.eventValue < e2.eventValue;}. QuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); { fLogger = new MsgLogger(""QuickMVAProbEstimator"");}. virtual ~QuickMVAProbEstimator(); {delete fLogger;}. » Last changed: Tue Sep 8 17:45:59 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__QuickMVAProbEstimator.html:1068,Log,Log,1068,root/html604/TMVA__QuickMVAProbEstimator.html,https://root.cern,https://root.cern/root/html604/TMVA__QuickMVAProbEstimator.html,1,['Log'],['Log']
Testability," Int_t * GetPowers () const;  ; Double_t GetPrecision () const;  ; const TVectorD * GetQuantity () const;  ; Double_t GetResidualMax () const;  ; Int_t GetResidualMaxRow () const;  ; Double_t GetResidualMin () const;  ; Int_t GetResidualMinRow () const;  ; Double_t GetResidualSumSq () const;  ; Double_t GetRMS () const;  ; Int_t GetSampleSize () const;  ; const TVectorD * GetSqError () const;  ; Double_t GetSumSqAvgQuantity () const;  ; Double_t GetSumSqQuantity () const;  ; Double_t GetTestError () const;  ; Double_t GetTestPrecision () const;  ; const TVectorD * GetTestQuantity () const;  ; Int_t GetTestSampleSize () const;  ; const TVectorD * GetTestSqError () const;  ; const TVectorD * GetTestVariables () const;  ; const TVectorD * GetVariables () const;  ; TClass * IsA () const override;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; virtual Double_t MakeChi2 (const Double_t *coeff=nullptr);  Calculate Chi square over either the test sample. ;  ; virtual void MakeCode (const char *functionName=""MDF"", Option_t *option="""");  Generate the file <filename> with .C appended if argument doesn't end in .cxx or .C. ;  ; virtual void MakeHistograms (Option_t *option=""A"");  Make histograms of the result of the analysis. ;  ; virtual void MakeMethod (const Char_t *className=""MDF"", Option_t *option="""");  Generate the file <classname>MDF.cxx which contains the implementation of the method: ;  ; void Print (Option_t *option=""ps"") const override;  Print statistics etc. ;  ; void SetBinVarX (Int_t nbbinvarx);  ; void SetBinVarY (Int_t nbbinvary);  ; void SetMaxAngle (Double_t angle=0);  Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit. ;  ; void SetMaxFunctions (Int_t n);  ; void SetMaxPowers (const Int_t *powers);  Set the maximum power to be considered in the fit for each variable. ;  ; void SetMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:22213,test,test,22213,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability," Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBuffer(TBuffer::EMode mode); TBuffer(TBuffer::EMode mode, Int_t bufsiz); TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer.html:12376,Test,TestBit,12376,root/html602/TBuffer.html,https://root.cern,https://root.cern/root/html602/TBuffer.html,2,['Test'],['TestBit']
Testability," Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:22177,log,log,22177,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,2,['log'],['log']
Testability," Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); boolRunAutoScan(double xMin, double xMax, double target, double epsilon = 0.005, unsigned int numAlgorithm = 0); boolRunFixedScan(int nBins, double xMin, double xMax); boolRunOnePoint(double thisX); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidCreateResults(). Data Members; public:. enum TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterOriginal.html:6708,Test,TestBit,6708,root/html534/RooStats__HypoTestInverterOriginal.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterOriginal.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStdExceptionHandler.html:7656,Test,TestBit,7656,root/html534/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html534/TStdExceptionHandler.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Int_toperator()(TBuffer& buffer, void* start_collection, const void* end_collection) const; Int_toperator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const; TStreamerInfoActions::TConfiguredAction&operator=(const TStreamerInfoActions::TConfiguredAction&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidPrintDebug(TBuffer& buffer, void* object) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TStreamerInfoActions::TConfiguredActionTConfiguredAction(); TStreamerInfoActions::TConfiguredActionTConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); TStreamerInfoActions::TConfiguredActionTConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerInfoActions__TConfiguredAction.html:5034,Test,TestBit,5034,root/html532/TStreamerInfoActions__TConfiguredAction.html,https://root.cern,https://root.cern/root/html532/TStreamerInfoActions__TConfiguredAction.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Int_trawBinNumber(Double_t x) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tremoveBoundary(Double_t boundary); virtual voidRooAbsBinning::removeHook(RooAbsRealLValue&) const; voidTObject::ResetBit(UInt_t f); RooBinning(const RooBinning& other, const char* name = 0); RooBinning(Double_t xlo = -RooNumber::infinity(), Double_t xhi = RooNumber::infinity(), const char* name = 0); RooBinning(Int_t nBins, const Double_t* boundaries, const char* name = 0); RooBinning(Int_t nBins, Double_t xlo, Double_t xhi, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsBinning::setMax(Double_t xhi); virtual voidRooAbsBinning::setMin(Double_t xlo); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidsetRange(Double_t xlo, Double_t xhi); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinning.html:7515,Test,TestBit,7515,root/html602/RooBinning.html,https://root.cern,https://root.cern/root/html602/RooBinning.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," Int_t ; n = 100). Set the histogram binning. ; Definition at line 882 of file TParallelCoordVar.cxx. ◆ SetHistogramHeight(). void TParallelCoordVar::SetHistogramHeight ; (; Double_t ; h = 0). Set the height of the bar histogram. ; Definition at line 892 of file TParallelCoordVar.cxx. ◆ SetHistogramLineWidth(). void TParallelCoordVar::SetHistogramLineWidth ; (; Int_t ; lw = 2). inline . Definition at line 101 of file TParallelCoordVar.h. ◆ SetInitMax(). void TParallelCoordVar::SetInitMax ; (; Double_t ; max). inline . Definition at line 108 of file TParallelCoordVar.h. ◆ SetInitMin(). void TParallelCoordVar::SetInitMin ; (; Double_t ; min). inline . Definition at line 107 of file TParallelCoordVar.h. ◆ SetLiveRangesUpdate(). void TParallelCoordVar::SetLiveRangesUpdate ; (; bool ; on). If true, the pad is updated while the motion of a dragged range. ; Definition at line 945 of file TParallelCoordVar.cxx. ◆ SetLogScale(). void TParallelCoordVar::SetLogScale ; (; bool ; log). Set the axis in log scale. ; Definition at line 955 of file TParallelCoordVar.cxx. ◆ SetTitle(). void TParallelCoordVar::SetTitle ; (; const char * ; title). inlineoverridevirtual . Set the title of the TNamed. ; Reimplemented from TNamed.; Definition at line 111 of file TParallelCoordVar.h. ◆ SetValues(). void TParallelCoordVar::SetValues ; (; Long64_t ; length, . Double_t * ; val . ). Set the variable values. ; Definition at line 977 of file TParallelCoordVar.cxx. ◆ SetX(). void TParallelCoordVar::SetX ; (; Double_t ; x, . bool ; gl . ). Set the X position of the axis in the case of a vertical axis. ; and rotate the axis if it was horizontal. ; Definition at line 992 of file TParallelCoordVar.cxx. ◆ SetY(). void TParallelCoordVar::SetY ; (; Double_t ; y, . bool ; gl . ). Set the Y position of the axis in the case of a horizontal axis. ; and rotate the axis if it was vertical. ; Definition at line 1011 of file TParallelCoordVar.cxx. ◆ Streamer(). void TParallelCoordVar::Streamer ; (; TBuffer & ; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordVar.html:29971,log,log,29971,doc/master/classTParallelCoordVar.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordVar.html,1,['log'],['log']
Testability," Int_t GetProtocol () const;  ; TSocket * GetSocket () const;  ; const char * GetUser () const;  ; void HandleSigPipe ();  Called when the client is not alive anymore (i.e. ;  ; void HandleSocketInput ();  Handle input coming from the client or from the master server. ;  ; void HandleUrgentData ();  Handle Out-Of-Band data sent by the master or client. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  ; Longptr_t ProcessLine (const char *line, Bool_t=kFALSE, Int_t *err=nullptr) override;  Parse a command line received from the client, making sure that the files needed for the execution, if any, are available. ;  ; Int_t ReceiveFile (const char *file, Bool_t bin, Long64_t size);  Receive a file, either sent by a client or a master server. ;  ; void Reset (const char *dir);  Reset environment to be ready for execution of next command. ;  ; void Run (Bool_t retrn=kFALSE) override;  Main server eventloop. ;  ; void SendLogFile (Int_t status=0, Int_t start=-1, Int_t end=-1);  Send log file to master. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate (Int_t status) override;  Terminate the proof server. ;  ;  Public Member Functions inherited from TApplication;  TApplication (const char *appClassName, Int_t *argc, char **argv, void *options=nullptr, Int_t numOptions=0);  Create an application environment. ;  ; virtual ~TApplication ();  TApplication dtor. ;  ; virtual const char * ApplicationName () const;  ; Int_t Argc () const;  ; char ** Argv () const;  ; char * Argv (Int_t index) const;  Return specified argument. ;  ; void ClearInputFiles ();  Clear list containing macro files passed as program arguments. ;  ; EExitOnException ExitOnException (EExitOnException opt=kExit);  Set the exit on exception option. ;  ; virtual TApplicationImp * GetApplicationImp ();  ; TApplication * GetAppRemote () const;  ; const char * GetId",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:2129,log,log,2129,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['log'],['log']
Testability," Int_t fAlphaOptim;  optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal ;  ; Double_t * fAmpCalc;  [fNPeaks] array of calculated values of fitted amplitudes, output parameters ;  ; Double_t * fAmpErr;  [fNPeaks] array of amplitude errors ;  ; Double_t * fAmpInit;  [fNPeaks] array of initial values of peaks amplitudes, input parameters ;  ; Double_t * fArea;  [fNPeaks] array of calculated areas of peaks ;  ; Double_t * fAreaErr;  [fNPeaks] array of errors of peak areas ;  ; Double_t fBCalc;  calculated value of b parameter ;  ; Double_t fBErr;  error value of b parameter ;  ; Double_t fBInit;  initial value of b parameter (slope), for details see html manual and references ;  ; Double_t fChi;  here the fitting functions return resulting chi square ;  ; Int_t fFitTaylor;  order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ;  ; Bool_t fFixA0;  logical value of a0 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixA1;  logical value of a1 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixA2;  logical value of a2 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixAmp;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ;  ; Bool_t fFixB;  logical value of b parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixPosition;  [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ;  ; Bool_t fFixS;  logical value of s parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigma;  logical value of sigma parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixT;  logical value of t parameter, which allows to fix the parameter (not to fit). ;  ; Int_t fNPeak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:19348,log,logical,19348,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability," Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for tools setting limits (producing confidence intervals); RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStreamParser Utility class that parses iostream data into tokens; RooStringVar String-valued variable ; RooSuperCategory Lvalue product operator for catategory lvalues; RooTFnBinding RooAbsReal binding to ROOT TF[123] functions; RooTFnPdfBinding RooAbsPdf binding to ROOT TF[123] functions; RooTFoamBinding Function binding to RooAbsReal object; RooTObjWrap Container class for Int_t; RooTable Abstract interface for tables; RooThreshEntry Utility class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:43830,test,test,43830,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['test'],['test']
Testability," Interpolate(Double_t x, Double_t y); Not yet implemented. Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3.html:41190,test,test,41190,root/html602/TH3.html,https://root.cern,https://root.cern/root/html602/TH3.html,4,['test'],['test']
Testability," It also takes; into account the option to generate a binned data set (ie RooDataHist). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(). void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. void AddTestStatistic(RooStats::TestStatistic* t = __null); The pdf can be NULL in which case the density from SetPdf(); is used. The snapshot and TestStatistic is also optional. RooAbsData* GenerateToyData(RooArgSet& paramPoint, RooAbsPdf& pdf) const; generates toy data; without weight. return GenerateToyData(paramPoint, weight, pdf). RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; with weight. { return GenerateToyData(paramPoint,*fPdf); }. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI, int i); Main interface to evaluate the test statistic on a dataset. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); { return EvaluateTestStatistic( data,nullPOI, 0 ); }. TestStatistic* GetTestStatistic(unsigned int i) const. TestStatistic* GetTestStatistic(unsigned int i) const; { return GetTestStatistic(0); }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); Set the Pdf, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. void SetNuisanceParameters(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ToyMCSampler.html:8538,test,test,8538,root/html602/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__ToyMCSampler.html,4,['test'],['test']
Testability," KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting data and; 8155/// saving space, this function has been provided. However, the values of; 8156/// PROB for binned data will be shifted slightly higher than expected,; 8157/// depending on the effects of the binning. For example, when comparing two; 8158/// uniform distributions of 500 events in 100 bins, the v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:319614,test,test,319614,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['test']
Testability," Long64_t TChain::Merge ; (; TCollection * ; list, . TFileMergeInfo * ; info . ). overridevirtual . Merge all chains in the collection. (NOT IMPLEMENTED) ; Reimplemented from TTree.; Definition at line 1899 of file TChain.cxx. ◆ Merge() [4/4]. Long64_t TChain::Merge ; (; TFile * ; file, . Int_t ; basketsize, . Option_t * ; option = """" . ). virtual . Merge all the entries in the chain into a new tree in the current file. ; Note: The ""file"" parameter is not the file where the new tree will be inserted. The new tree is inserted into gDirectory, which is usually the most recently opened file, or the directory most recently cd()'d to.; If option = ""C"" is given, the compression level for all branches in the new Tree is set to the file compression level. By default, the compression level of all branches is the original compression level in the old trees.; If basketsize > 1000, the basket size for all branches of the new tree will be set to basketsize.; Example using the file generated in $ROOTSYS/test/Event merge two copies of Event.root gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:555; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; If the chain is expecting the input tree inside a directory, this directory is NOT created by this routine.; So if you do: TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");; The resulting file will not have subdirectories. In order to preserve the directory structure do the following instead: TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file, 0);; If 'option' contains the word 'fast' the merge will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:84882,test,test,84882,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['test'],['test']
Testability," Long64_t TChain::Merge ; (; TCollection * ; list, . TFileMergeInfo * ; info . ). overridevirtual . Merge all chains in the collection. (NOT IMPLEMENTED) ; Reimplemented from TTree.; Definition at line 1925 of file TChain.cxx. ◆ Merge() [4/4]. Long64_t TChain::Merge ; (; TFile * ; file, . Int_t ; basketsize, . Option_t * ; option = """" . ). virtual . Merge all the entries in the chain into a new tree in the current file. ; Note: The ""file"" parameter is not the file where the new tree will be inserted. The new tree is inserted into gDirectory, which is usually the most recently opened file, or the directory most recently cd()'d to.; If option = ""C"" is given, the compression level for all branches in the new Tree is set to the file compression level. By default, the compression level of all branches is the original compression level in the old trees.; If basketsize > 1000, the basket size for all branches of the new tree will be set to basketsize.; Example using the file generated in $ROOTSYS/test/Event merge two copies of Event.root gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; If the chain is expecting the input tree inside a directory, this directory is NOT created by this routine.; So if you do: TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");; The resulting file will not have subdirectories. In order to preserve the directory structure do the following instead: TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file, 0);; If 'option' contains the word 'fast' the merge will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:85436,test,test,85436,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['test'],['test']
Testability," Long64_t nentries, Long64_t firstentry); virtual TSQLResult*Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Long64_tScan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Bool_tScanRedirected(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEstimate(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualTreePlayer::SetPlayer(const char* player); voidSetScanFileName(const char* name); voidSetScanRedirect(Bool_t on = kFALSE); virtual voidSetTree(TTree* t); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartViewer(Int_t ww, Int_t wh); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TVirtualTreePlayer*TVirtualTreePlayer::TreePlayer(TTree* obj); TTreePlayer(); virtual Int_tUnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreePlayer.html:7031,Test,TestBit,7031,root/html602/TTreePlayer.html,https://root.cern,https://root.cern/root/html602/TTreePlayer.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti, . Int_t ; actw, . Int_t ; tses, . Float_t ; eses . ). Get query progress information. ; Connect a slot to this signal to track progress. ; Definition at line 9246 of file TProof.cxx. ◆ Prompt(). Bool_t TProof::Prompt ; (; const char * ; p). private . Prompt the question 'p' requiring an answer y,Y,n,N Return kTRUE is the answer was y or Y, kFALSE in all other cases. ; Definition at line 7649 of file TProof.cxx. ◆ PutLog(). void TProof::PutLog ; (; TQueryResult * ; qr). Display log of query pq into the log window frame. ; Definition at line 10321 of file TProof.cxx. ◆ QueryResultReady(). void TProof::QueryResultReady ; (; const char * ; ref). Notify availability of a query result. ; Definition at line 9369 of file TProof.cxx. ◆ RecvLogFile(). void TProof::RecvLogFile ; (; TSocket * ; s, . Int_t ; size . ). private . Receive the log file of the slave with socket s. ; Definition at line 6287 of file TProof.cxx. ◆ RedirectWorker(). void TProof::RedirectWorker ; (; TSocket * ; s, . TSlave * ; sl, . Int_t ; output_size . ). private . Redirect output of worker sl to some merger. ; Definition at line 4258 of file TProof.cxx. ◆ RegisterDataSet(). Bool_t TProof::RegisterDataSet ; (; const char * ; dataSetName, . TFileCollection * ; dataSet, . const char * ; optStr = """" . ). virtual . Register the 'dataSet' on the cluster under the current user, group and the given 'dataSetName'. ; If a dataset with the same name already exists the action fails unless 'opts' contains 'O', in which case the old dataset is overwritten, or contains 'U', in which case 'newDataSet' is added to the existing dataset (duplications are ignored, if any). If 'opts' contains 'V' the dataset files are also verified (if the dataset manager is configured to allow so). By default the dataset is not verified. If 'opts' contains 'T' the in the dataset object (statu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:129744,log,log,129744,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability," Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); static voidSetUpSSL(const char* cafile, const char* capath, const char* ucert, const char* ukey); voidTSocket::SetUrl(const char* url); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSocket::Touch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSSLSocket.html:7599,Test,TestBit,7599,root/html532/TSSLSocket.html,https://root.cern,https://root.cern/root/html532/TSSLSocket.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetPar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF12.html:4711,log,logx,4711,root/html534/TF12.html,https://root.cern,https://root.cern/root/html534/TF12.html,2,['log'],['logx']
Testability," Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF2.html:5816,log,logx,5816,root/html534/TF2.html,https://root.cern,https://root.cern/root/html534/TF2.html,2,['log'],['logx']
Testability," Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF3.html:6407,log,logx,6407,root/html534/TF3.html,https://root.cern,https://root.cern/root/html534/TF3.html,2,['log'],['logx']
Testability, LorentzVector operator * ( const Scalar & a) const {; 469 LorentzVector tmp(*this);; 470 tmp *= a;; 471 return tmp;; 472 }; 473 ; 474 /**; 475 Divide a LorentzVector by a scalar quantity; 476 \param a scalar quantity of type a; 477 \return a new mathcoreLorentzVector q = v / a same type as v; 478 */; 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Sca,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16135,log,log,16135,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['log'],['log']
Testability," Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Support Mailing List mode on Discourse. Here is how to enable the ""mailing list mode"" feature on our Discourse forum. If you visit your profile, in Preferences - Emails, you will see:. By ticking ""Enable mailing list mode"", you will automatically receive an email every time a post is made on the forum.; Note: You can reply by email, and you can also mute a topic or category, so it will be excluded (something that regular mailing lists don't do). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/mailing-list-mode-discourse.html:2854,test,tests,2854,d/mailing-list-mode-discourse.html,https://root.cern,https://root.cern/d/mailing-list-mode-discourse.html,1,['test'],['tests']
Testability," Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Code Owners. ROOT consists of several loosely coupled but consistently designed parts. The ""code owners"" of these parts are experts that review pull requests and guide these packages over a couple of years.; An up-to-date, detailed mapping of code versus owners can be found at https://github.com/root-project/root/blob/master/.github/CODEOWNERS. The long-term, coarse list can be found below:; Module; Code Owner; I/O; Philippe Canal (Fermilab);  •  Compression; Oksana Shadura (Nebraska-Lincoln); Math, Statistics, Machine Learning; Lorenzo Moneta (CERN);  •  RooFit; Wouter Verkerke (NIKHEF), Stephan Hageboeck (CERN);  •  New histograms (RHist); Hadrien Grasland (LAL), Axel Naumann (CERN); Graphics; Olivier Couet (CERN), Sergey Linev (GSI); RDataFrame; Enrico Guiraud (CERN); Web-GUI, http Server; Sergey Linev (GSI), Bertrand Bellenot (CERN); Event Display; Matevz Tadel (UCSD), Alja Mrak-Tadel (UCSD); PyROOT; Enric Tejedor (CERN); cling; Axel Naumann (CERN); Build System; Oksana Shadura (Nebraska-Lincoln); C++ Modules; Vassil Vassilev (Princeton), Oksana Shadura (Nebraska-Lincoln); Documentation; Olivier Couet (CERN). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/code-owners.html:3528,test,tests,3528,d/code-owners.html,https://root.cern,https://root.cern/d/code-owners.html,1,['test'],['tests']
Testability," Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TMVA::IFitterTarget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; std::vector< Float_t > fAchievableEff;  ; std::vector< Float_t > fAchievablePur;  ; std::vector< std::vector< Double_t > > fBestCuts;  ; std::vector< Float_t > fClassSumWeights;  ; UInt_t fClassToOptimize;  ; std::vector< UInt_t > fEventClasses;  ; std::vector< Float_t > fEventWeights;  ; MsgLogger * fLogger;  ! message logger ;  ; std::vector< std::vector< Float_t > > fMultiClassValues;  mva values (Results) ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ResultsMulticlass.html:12188,log,logger,12188,doc/master/classTMVA_1_1ResultsMulticlass.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ResultsMulticlass.html,1,['log'],['logger']
Testability," MethodBase.h:651; TMVA::MethodBase::fVerboseBool_t fVerboseverbose flagDefinition MethodBase.h:676; TMVA::MethodBase::fNormaliseBool_t fNormaliseDefinition MethodBase.h:722; TMVA::MethodBase::GetKSTrainingVsTestvirtual Double_t GetKSTrainingVsTest(Char_t SorB, TString opt=""X"")Definition MethodBase.cxx:3392; TMVA::MethodBase::fNbinsInt_t fNbinsDefinition MethodBase.h:591; TMVA::MethodBase::fMethodNameTString fMethodNameDefinition MethodBase.h:615; TMVA::MethodBase::GetMvaValuevirtual Double_t GetMvaValue(Double_t *errLower=nullptr, Double_t *errUpper=nullptr)=0; TMVA::MethodBase::GetFileTFile * GetFile() constDefinition MethodBase.h:370; TMVA::MethodBase::GetSeparationvirtual Double_t GetSeparation(TH1 *, TH1 *) constcompute ""separation"" defined asDefinition MethodBase.cxx:2789; TMVA::MethodBase::fFileDirTString fFileDirunix sub-directory for weight files (default: DataLoader's Name + ""weights"")Definition MethodBase.h:637; TMVA::MethodBase::fTmpDataDataSet * fTmpDatatemporary event when testing on a different DataSet than the own oneDefinition MethodBase.h:446; TMVA::MethodBase::HasTrainingTreeBool_t HasTrainingTree() constDefinition MethodBase.h:513; TMVA::MethodBase::DeclareOptionsvirtual void DeclareOptions()=0; TMVA::MethodBase::SetSilentFilevoid SetSilentFile(Bool_t status)Definition MethodBase.h:378; TMVA::MethodBase::ReadClassesFromXMLvoid ReadClassesFromXML(void *clsnode)read number of classes from XMLDefinition MethodBase.cxx:1917; TMVA::MethodBase::GetInteractiveTrainingErrorTMultiGraph * GetInteractiveTrainingError()Definition MethodBase.h:461; TMVA::MethodBase::SetWeightFileDirvoid SetWeightFileDir(TString fileDir)set directory of weight fileDefinition MethodBase.cxx:2059; TMVA::MethodBase::WriteStateToXMLvoid WriteStateToXML(void *parent) constgeneral method used in writing the header of the weight files where the used variables,...Definition MethodBase.cxx:1331; TMVA::MethodBase::fSilentFileBool_t fSilentFileDefinition MethodBase.h:631; TMVA::MethodBase",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:40667,test,testing,40667,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['test'],['testing']
Testability, MethodCuts.h. ◆ fCutRangeMax. Double_t* TMVA::MethodCuts::fCutRangeMax. private . maximum of allowed cut range ; Definition at line 176 of file MethodCuts.h. ◆ fCutRangeMin. Double_t* TMVA::MethodCuts::fCutRangeMin. private . minimum of allowed cut range ; Definition at line 175 of file MethodCuts.h. ◆ fEffBvsSLocal. TH1* TMVA::MethodCuts::fEffBvsSLocal. private . intermediate eff. background versus eff signal histo ; Definition at line 202 of file MethodCuts.h. ◆ fEffMethod. EEffMethod TMVA::MethodCuts::fEffMethod. private . chosen efficiency calculation method ; Definition at line 170 of file MethodCuts.h. ◆ fEffMethodS. TString TMVA::MethodCuts::fEffMethodS. private . chosen efficiency calculation method (string) ; Definition at line 169 of file MethodCuts.h. ◆ fEffRef. Double_t TMVA::MethodCuts::fEffRef. private . reference efficiency ; Definition at line 192 of file MethodCuts.h. ◆ fEffSMax. Double_t TMVA::MethodCuts::fEffSMax. private . used to test optimized signal efficiency ; Definition at line 174 of file MethodCuts.h. ◆ fEffSMin. Double_t TMVA::MethodCuts::fEffSMin. private . used to test optimized signal efficiency ; Definition at line 173 of file MethodCuts.h. ◆ fFitMethod. EFitMethodType TMVA::MethodCuts::fFitMethod. private . chosen fit method ; Definition at line 168 of file MethodCuts.h. ◆ fFitMethodS. TString TMVA::MethodCuts::fFitMethodS. private . chosen fit method (string) ; Definition at line 167 of file MethodCuts.h. ◆ fFitParams. std::vector<EFitParameters>* TMVA::MethodCuts::fFitParams. private . vector for series of fit methods ; Definition at line 171 of file MethodCuts.h. ◆ fgMaxAbsCutVal. const Double_t TMVA::MethodCuts::fgMaxAbsCutVal = 1.0e30. static . Definition at line 130 of file MethodCuts.h. ◆ fMeanB. std::vector<Double_t>* TMVA::MethodCuts::fMeanB. private . means of variables (background) ; Definition at line 198 of file MethodCuts.h. ◆ fMeanS. std::vector<Double_t>* TMVA::MethodCuts::fMeanS. private . means of variables (signa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:49820,test,test,49820,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['test'],['test']
Testability, MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:158677,test,testing,158677,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['test'],['testing']
Testability," N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : Training Network; : ; : Finalizing handling of Regulator terms, trainE=0.713219 testE=0.724617; : Done with handling of Regulator terms; : Elapsed time for training with 2000 events: 2.56 sec ; MLPBNN : [dataset] : Evaluation of MLPBNN on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0055 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.class.C␛[0m; : Write special histos to file: TMVAC.root:/dataset/Method_MLP/MLPBNN; Factory : Training finished; : ; Factory : Train method: DNN_CPU for Classification; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : Start of deep neural network training on CPU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:44906,test,testE,44906,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['testE']
Testability," NeuralNet.h. ◆ SetIpythonInteractive(). void TMVA::DNN::Net::SetIpythonInteractive ; (; IPythonInteractive * ; fI, . bool * ; fE, . UInt_t * ; M, . UInt_t * ; C . ). inline . Definition at line 1283 of file NeuralNet.h. ◆ setOutputSize(). void TMVA::DNN::Net::setOutputSize ; (; size_t ; sizeOutput). inline . set the output size of the DNN ; Definition at line 1093 of file NeuralNet.h. ◆ train(). template<typename Minimizer > . double TMVA::DNN::Net::train ; (; std::vector< double > & ; weights, . std::vector< Pattern > & ; trainPattern, . const std::vector< Pattern > & ; testPattern, . Minimizer & ; minimizer, . Settings & ; settings . ). start the training ; execute the training until convergence emerges; Parameters. weightsweight vector ; trainPatterntraining pattern ; testPatterntest pattern ; minimizeruse this minimizer for training (e.g. SGD) ; settingssettings used for this training run. Parameters. weightsthe container with the weights (synapses) ; trainPatternthe pattern for the training ; testPatternthe pattern for the testing ; minimizerthe minimizer (e.g. steepest gradient descent) to be used ; settingsthe settings for the training (e.g. multithreading or not, regularization etc.) . Definition at line 712 of file NeuralNet.icc. ◆ trainCycle(). template<typename Iterator , typename Minimizer > . double TMVA::DNN::Net::trainCycle ; (; Minimizer & ; minimizer, . std::vector< double > & ; weights, . Iterator ; itPatternBegin, . Iterator ; itPatternEnd, . Settings & ; settings, . DropContainer & ; dropContainer . ). inline . executes one training cycle ; execute a single training cycle; Parameters. minimizerthe minimizer to be used ; weightsthe weight vector to be used ; itPatternBeginthe pattern to be trained with ; itPatternEndthe pattern to be trained with ; settingsthe settings for the training ; dropContainerthe configuration for DNN drop-out. uses multithreading if turned on; Parameters. minimizerthe minimizer to be used (e.g. SGD) ; weightsthe weight c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:17336,test,testPatternthe,17336,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,2,['test'],"['testPatternthe', 'testing']"
Testability," OS X (PR #68). PyROOT. Fix lookup of templated classes in namespace with arguments that have ‘std::’ in their name ROOT-7448; Use GetTrueTypeName() instead of GetFullTypeName(), as the latter loses namespaces; Strip down number of libraries linked to libPyROOT in order to reduce to the minimum the time needed to import the ROOT module. TFormula, TF1. Allow possibility to automatically normalize itself. If the function TF1::SetNormalized(true) is called, when evaluated, the function will return its value divided by its integral computed in the function range.; Added helper classes TF1NormSum, TF1Convolution.; Fix a bug in calling TF1::Update when changing the parameter values. Fix also the TF1Convolution.; Fix the caching of the parameters in TF1NormSum to avoid recomputing integrals for same parameter values.; Remove unwanted printout from Streamer method. RooFit. Fix for contour computations in RooMinimizer[ROOT-7290]. Dictionary Generation. Uniform style of warnings, use standard ROOT logging facilities rather than cout/cerr.; Do not add as autoparse keys stl classes, stl (nested) containers templated with plain old data or integers. Tree. TTreeReaderArray now supports vector<builtin-type>. Graphics. Fix file corruption in TTeXDump::DrawPolyMarker.; Make sure the line width used to draw #sqrt is always >=1. Release 6.04/04; Build System. Fix generation of PCH with CXX flags with spaces ROOT-7478; Implemented option ‘geocad’ with CMake making use of the OpenCASCADE software package.; Fix option ‘rpath’ for CMake and ensure that works for MacOSX 10.11. Core. Fix the location of include files in ROOTINCDIR/include instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROOT-7478 ROOT-6966; Properly recover from a template instantiation failure when looking up a class in the interpreter ROOT-7462; Do not clear pending instantiations upon unloading; fixes missing symbols due to missing function bodies R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:28322,log,logging,28322,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['log'],['logging']
Testability," On OS X it is easily installed via Homebrew:; brew install tig. Tig pager mode; Many git commands can be piped into tig. When tig is invoked this way, it is in pager mode: output will be colored according to the input format, and colored.; For instance it is possible to pipe the differences of one file like this:; git diff path/to/file.cxx | tig. or see the changes of one revision like this:; git show b204d4c87 | tig. The most important interactive tig commands are:. 'h': opens the help screen; 'q': closes current window; 'Q': closes all windows and exits. Log view; Tig invoked without any argument spawns a full log view with one line per commit including author, date and log message. Heads of the different branches are clearly indicated. To see a graph view indicating branching graphically (just like git log --oneline --graph), do:; tig --all. A log can be selected with Enter to see the revision changes.; An example of useful application of the log view is interactive cherry-picking: just press 'C' to cherry-pick currently selected commit into your current branch.; Blame view; Blame view is extremely useful to see which lines were committed by whom. It is an improved version of the standard git blame command with a much clearer and interactive output.; Each line can be selected to display the associated full commit log and diff. Usage:; tig blame path/to/file.cxx. Interactive staging and current status; tig status opens an interactive display to quickly select files to be staged. Move over the file and press 'u' to (un)stage it. The .gitconfig file; This file contains global (~/.gitconfig) or repository-local configuration settings. You can (eg):. Set user and email information to label commits usefully:; git config --global user.name ""Chris Green"" ; git config --global user.email <email-address>. Set colors for various types of command output.; Set which local branches track which remote branches.; Set pull behavior for branches to be rebase rather than merge.; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:17515,log,log,17515,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['log'],['log']
Testability," OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionFrame.html:23186,log,log,23186,root/html532/TSessionFrame.html,https://root.cern,https://root.cern/root/html532/TSessionFrame.html,4,['log'],['log']
Testability," Opera instead.; [legend]; Member Typedef Documentation. ◆ IModelFunction. typedef ROOT::Math::IParamMultiFunction ROOT::Fit::FitResult::IModelFunction. Definition at line 51 of file FitResult.h. Constructor & Destructor Documentation. ◆ FitResult() [1/2]. ROOT::Fit::FitResult::FitResult ; (; ). Default constructor for an empty (non valid) fit result. ; Definition at line 45 of file FitResult.cxx. ◆ FitResult() [2/2]. ROOT::Fit::FitResult::FitResult ; (; const FitConfig & ; fconfig). Constructor from a fit-config for a dummy fit (e.g. ; when only one fcn evaluation is done) ; Definition at line 52 of file FitResult.cxx. ◆ ~FitResult(). virtual ROOT::Fit::FitResult::~FitResult ; (; ). inlinevirtual . Destructor. ; Definition at line 69 of file FitResult.h. Member Function Documentation. ◆ Chi2(). double ROOT::Fit::FitResult::Chi2 ; (; ); const. inline . Return the Chi2 value after fitting In case of unbinned fits (or not defined one, see the documentation of Fitter::FitFCN) return -1 In case of binned likelihood fits (Poisson Likelihood) return the 2 * negative log-likelihood ratio using the definition of Baker-Cousins. ; Definition at line 153 of file FitResult.h. ◆ Contour(). bool ROOT::Fit::FitResult::Contour ; (; unsigned int ; ipar, . unsigned int ; jpar, . unsigned int & ; npoints, . double * ; pntsx, . double * ; pntsy, . double ; confLevel = 0.683 . ). create contour of two parameters around the minimum pass as option confidence level: default is a value of 0.683 ; Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or is invalid it will return false A array for x and y points should be provided Pass optionally the confidence level, default is 0.683 it is assumed that ErrorDef() defines the right error definition (i.e 1 sigma error for one parameter).; If not the confidence level are scaled to new level ; Definition at line 660 of file FitResult.cxx. ◆ Correlation(). double ROOT::Fit::FitResult::Correlation ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:11042,log,log-likelihood,11042,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,1,['log'],['log-likelihood']
Testability," Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------------------------------------------------------------------|; 2907| "" "" | Default, cartesian coordinates system.|; 2908| ""POL"" | Polar coordinates system.|; 2909| ""CYL"" | Cylindrical coordinates system.|; 2910| ""SPH"" | Spherical coordinates system.|; 2911 ; 2912 ; 2913 ; 2914\anchor HP290; 2915#### TH3 as color boxes; 2916 ; 2917The supported option is:; 2918 ; 2919| Option | Description |; 2920|----------|-------------------------------------------------------------------|; 2921| ""GLCOL"" | H3 is drawn using semi-transparent colored boxes. See `$ROOTSYS/tutorials/gl/glvox1.C`.|; 2922 ; 2923 ; 2924 ; 2925\anchor HP29b; 2926#### TH3 as boxes (spheres); 2927 ; 2928The supported options are:; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:115326,log,logarithmic,115326,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logarithmic']
Testability," Option_t* option = """"); voidSaveUserColor(ostream& out, Option_t*); virtual voidSendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidSetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCleanup(Int_t = kLocalCleanup); voidSetDNDSource(Bool_t onoff); voidSetDNDTarget(Bool_t onoff); virtual voidSetDragType(Int_t type); virtual voidSetDrawOption(Option_t* = """"); virtual voidSetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidSetEditable(Bool_t); virtual voidTGWindow::SetEditDisabled(UInt_t on = kEditDisable); virtual voidSetForegroundColor(Pixel_t); voidSetFrameElement(TGFrameElement* fe); virtual voidSetHeight(UInt_t h); virtual voidSetLayoutBroken(Bool_t = kTRUE); virtual voidTGWindow::SetMapSubwindows(Bool_t); virtual voidSetMaxHeight(UInt_t h); virtual voidSetMaxWidth(UInt_t w); virtual voidSetMinHeight(UInt_t h); virtual voidSetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidSetX(Int_t x); virtual voidSetY(Int_t y); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGFrame.html:13001,Test,TestBit,13001,root/html534/TGFrame.html,https://root.cern,https://root.cern/root/html534/TGFrame.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLCamera::SetCenterVec(Double_t x, Double_t y, Double_t z); voidTGLCamera::SetCenterVecWarp(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGLCamera::SetExternalCenter(Bool_t x); voidTGLCamera::SetFixDefCenter(Bool_t x); voidTGLCamera::SetFixDefCenterVec(Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetup(const TGLBoundingBox& box, Bool_t reset = kTRUE); voidTGLCamera::SetVAxisMinAngle(Float_t x); voidTGLCamera::SetViewport(const TGLRect& viewport); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGLPerspectiveCamera(); TGLPerspectiveCamera(const TGLPerspectiveCamera&); TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); UInt_tTGLCamera::TimeStamp() const; virtual Bool_tTruck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Bool_tTGLCamera::UpdateInterest(Bool_t force); virtual voidTObject::UseCurrentStyle(); TGLVector3TGLCamera::ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Rgl::EOverlapTGLCamera::ViewportOverlap(const TGLBoundingBox& box) const; pair<Bool_t,TGLVertex3>TGLCamera::ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; pair<Bool_t,TGLVertex3>TGLCamera::ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; TGLRectTGLCamera::ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; TGLRectTGLCamera::V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPerspectiveCamera.html:6946,Test,TestBit,6946,root/html602/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html,2,['Test'],['TestBit']
Testability," Option_t* option = ""UU"", Double_t* res = 0) const; test for comparing weighted and unweighted histograms. Function: Returns p-value. Other return values are specified by the 3rd parameter <br>. Parameters:. - h2: the second histogram; - option:; o ""UU"" = experiment experiment comparison (unweighted-unweighted); o ""UW"" = experiment MC comparison (unweighted-weighted). Note that; the first histogram should be unweighted; o ""WW"" = MC MC comparison (weighted-weighted); o ""NORM"" = to be used when one or both of the histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006. Introduction:. A frequently used technique in data analysis is the comparison of; histograms. First suggested by Pearson [1] the test of; homogeneity is used widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:44393,test,test,44393,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,10,['test'],['test']
Testability," PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. ~TProofLite(); Destructor. Int_t GetNumberOfWorkers(const char* url = 0); Static method to determine the number of workers giving priority to users request.; Otherwise use the system information, if available, or just start; the minimal number, i.e. 2 . Int_t SetupWorkers(Int_t opt = 0, TList* wrks = 0); Start up PROOF workers. void NotifyStartUp(const char* action, Int_t done, Int_t tot); Notify setting-up operation message. Int_t SetProofServEnv(const char* ord); Create environment files for worker 'ord'. void ResolveKeywords(TString& s, const char* logfile); Resolve some keywords in 's'; <logfileroot>, <user>, <rootsys>. Int_t CreateSandbox(); Create the sandbox for this session. void Print(Option_t* option = """") const; Print status of PROOF-Lite cluster. TProofQueryResult * MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. Long64_t DrawSelect(TDSet* dset, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:26787,sandbox,sandbox,26787,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,4,['sandbox'],['sandbox']
Testability," PROOF system. The ""options"" and ""numOptions"" arguments are not used,; except if you want to by-pass the argv processing by GetOptions(); in which case you should specify numOptions<0. All options will; still be available via the Argv() method for later use. ~TApplication(); TApplication dtor. void NeedGraphicsLibs(); Static method. This method should be called from static library; initializers if the library needs the low level graphics system. void InitializeGraphics(); Initialize the graphics environment. void ClearInputFiles(); Clear list containing macro files passed as program arguments.; This method is called from TRint::Run() to ensure that the macro; files are only executed the first time Run() is called. char * Argv(Int_t index) const; Return specified argument. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Arguments handled are removed; from the argument array. The following arguments are handled:; -b : run in batch mode without graphics; -x : exit on exception; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:14174,log,logon,14174,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,12,['log'],"['logoff', 'logon']"
Testability," Package"") should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).; The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame.; After building the full geometry tree, the geometry must be closed (see the method **TGeoManager::CloseGeometry()**). Voxelization can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the **TGeoManager** class will register itself to ROOT and the logical/physical structures will become immediately browsable. The Volume Hierarchy; The basic components used for building the logical hierarchy of the geometry are the positioned volumes called nodes. Volumes are fully defined geometrical objects having a given shape and medium and possibly containing a list of nodes. Nodes represent just positioned instances of volumes inside a container volume but users do not directly create them. They are automatically created as a result of adding one volume inside other or dividing a volume. The geometrical transformation held by nodes is always defined with respect to their mother (relative positioning). Reflection matrices are allowed.; A hierarchical element is not fully defined by a node since nodes are not directly linked to each other, but through volumes (a node points to a volume, which at its turn points to a list of nodes):; NodeTop VolTop NodeA VolA ...; One can therefore talk about ""the node or volume hierarchy"", but in fact, an element is made by a pair volume-node. In the line above is represented just a single branch, but of course from any volume other branc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:19093,log,logical,19093,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['log'],['logical']
Testability," Pattern > &testPattern, Minimizer &minimizer, Settings &settings)pre-training for future use; TMVA::DNN::Net::fetchOutputvoid fetchOutput(const LayerData &lastLayerData, OutputContainer &outputContainer) constDefinition NeuralNet.icc:1291; TMVA::DNN::Net::inputSizesize_t inputSize() constinput size of the DNNDefinition NeuralNet.h:1098; TMVA::DNN::Net::clearvoid clear()Definition NeuralNet.h:1251; TMVA::DNN::Net::begin_end_typestd::pair< iterator_type, iterator_type > begin_end_typeDefinition NeuralNet.h:1067; TMVA::DNN::Net::m_eErrorFunctionModeErrorFunction m_eErrorFunctiondenotes the error functionDefinition NeuralNet.h:1269; TMVA::DNN::Net::dEvoid dE(); TMVA::DNN::Net::addLayervoid addLayer(Layer &&layer)Definition NeuralNet.h:1095; TMVA::DNN::Net::numNodessize_t numNodes(size_t trainingStartLayer=0) constreturns the number of nodes in this netDefinition NeuralNet.cxx:556; TMVA::DNN::Net::traindouble train(std::vector< double > &weights, std::vector< Pattern > &trainPattern, const std::vector< Pattern > &testPattern, Minimizer &minimizer, Settings &settings)start the trainingDefinition NeuralNet.icc:712; TMVA::DNN::Net::layersconst std::vector< Layer > & layers() constreturns the layers (structure)Definition NeuralNet.h:1245; TMVA::DNN::Net::prepareLayerDatastd::vector< std::vector< LayerData > > prepareLayerData(LayerContainer &layers, Batch &batch, const DropContainer &dropContainer, ItWeight itWeightBegin, ItWeight itWeightEnd, ItGradient itGradientBegin, ItGradient itGradientEnd, size_t &totalNumWeights) constDefinition NeuralNet.icc:1111; TMVA::DNN::Net::setErrorFunctionvoid setErrorFunction(ModeErrorFunction eErrorFunction)which error function is to be usedDefinition NeuralNet.h:1096; TMVA::DNN::Net::initializeWeightsvoid initializeWeights(WeightInitializationStrategy eInitStrategy, OutIterator itWeight)initialize the weights with the given strategyDefinition NeuralNet.icc:1470; TMVA::DNN::Net::outputSizesize_t outputSize() constoutput size of the DNNDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:67079,test,testPattern,67079,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['test'],['testPattern']
Testability," Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPadEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TPad editor GUI. ~TPadEditor(); Destructor of fill editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used fill attributes. void ActivateBaseClassEditors(TClass* cl); Exclude TAttLineEditor from this interface. void DoEditable(Bool_t on); Slot connected to the check box 'Editable'. void DoCrosshair(Bool_t on); Slot connected to the check box 'Crosshair'. void DoFixedAspectRatio(Bool_t on); Slot connected to the check box 'Fixed aspect ratio'. void DoGridX(Bool_t on); Slot connected to the check box 'GridX'. void DoGridY(Bool_t on); Slot connected to the check box 'GridY'. void DoLogX(Bool_t on); Slot connected to the check box 'LogX'. void DoLogY(Bool_t on); Slot connected to the check box 'LogY'. void DoLogZ(Bool_t on); Slot connected to the check box 'LogZ'. void DoTickX(Bool_t on); Slot connected to the check box 'TickX'. void DoTickY(Bool_t on); Slot connected to the check box 'TickY'. void DoBorderMode(); Slot connected to the border mode settings. void DoBorderSize(Int_t size); Slot connected to the border size settings. » Author: Ilka Antcheva 24/06/04 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPadEditor.html:22079,Log,LogX,22079,root/html534/TPadEditor.html,https://root.cern,https://root.cern/root/html534/TPadEditor.html,3,['Log'],"['LogX', 'LogY', 'LogZ']"
Testability," Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& ); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. UInt_t numStatusHistory() const; { return _statusHistory.size() ; }. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2) const; Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot* frame, const RooAbsArg& par1, const RooAbsArg& par2, const char* options = ""ME"") const; Add objects to a 2D plot. void setMinNLL(Double_t val); { _minNLL = val ; }. void setEDM(Double_t val); { _edm = val ; }. void setStatus(Int_t val); { _status = val ; }. void setCovQual(Int_t val); { _covQual = val ; }. void setNumInvalidNLL(Int_t val); { _numBadNLL=val ; }. void setStatusHistory(vector<pair<string,int> >& hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:18266,log,log,18266,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,4,['log'],['log']
Testability," Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& ); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. UInt_t numStatusHistory() const; { return _statusHistory.size() ; }. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2) const; Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot* frame, const RooAbsArg& par1, const RooAbsArg& par2, const char* options = ""ME"") const; Add objects to a 2D plot. void setMinNLL(Double_t val); { _minNLL = val ; }. void setEDM(Double_t val); { _edm = val ; }. void setStatus(Int_t val); { _status = val ; }. void setCovQual(Int_t val); { _covQual = val ; }. void setNumInvalidNLL(Int_t val); { _numBadNLL=val ; }. void setStatusHistory(vector<std::pair<std::string,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFitResult.html:17245,log,log,17245,root/html534/RooFitResult.html,https://root.cern,https://root.cern/root/html534/RooFitResult.html,2,['log'],['log']
Testability," Profile Likelihood function for MODEL 3:; Gauss background/Gauss Efficiency. Double_t EvalLikeMod4(Double_t mu, Int_t x, Int_t y, Double_t tau, Int_t what); Calculates the Profile Likelihood for MODEL 4:; Poiss background/Efficiency known; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod4(Double_t mu, Double_t b, Int_t x, Int_t y, Double_t tau); Profile Likelihood function for MODEL 4:; Poiss background/Efficiency known. Double_t EvalLikeMod5(Double_t mu, Int_t x, Double_t bm, Double_t sdb, Int_t what); Calculates the Profile Likelihood for MODEL 5:; Gauss background/Efficiency known; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod5(Double_t mu, Double_t b, Int_t x, Double_t bm, Double_t u); Profile Likelihood function for MODEL 5:; Gauss background/Efficiency known. Double_t EvalLikeMod6(Double_t mu, Int_t x, Int_t z, Double_t b, Int_t m, Int_t what); Calculates the Profile Likelihood for MODEL 6:; Background known/Efficiency binomial; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod6(Double_t mu, Double_t b, Double_t e, Int_t x, Int_t z, Int_t m); Profile Likelihood function for MODEL 6:; background known/ Efficiency binomial. Double_t EvalLikeMod7(Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what); Calculates the Profile Likelihood for MODEL 7:; background known/Efficiency Gauss; what = 1: Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRolke.html:25027,Test,Test,25027,root/html532/TRolke.html,https://root.cern,https://root.cern/root/html532/TRolke.html,4,['Test'],['Test']
Testability," Public Member Functions;  MethodC50 (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption="""");  ;  MethodC50 (DataSetInfo &dsi, const TString &theWeightFile);  ;  ~MethodC50 (void);  ; virtual void AddWeightsXMLTo (void *) const;  ; const Ranking * CreateRanking ();  ; void DeclareOptions ();  ; Double_t GetMvaValue (Double_t *errLower=nullptr, Double_t *errUpper=nullptr);  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the current Data type ;  ; Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  ; void Init ();  ; virtual void MakeClass (const TString &classFileName=TString("""")) const;  create reader class for method (classification only at present) ;  ; void ProcessOptions ();  ; void ReadModelFromFile ();  ; virtual void ReadWeightsFromStream (std::istream &);  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *);  ; virtual void TestClassification ();  initialization ;  ; void Train ();  ;  Public Member Functions inherited from TMVA::RMethodBase;  RMethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""", ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ;  RMethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile, ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodC50.html:910,log,logProgress,910,doc/master/classTMVA_1_1MethodC50.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodC50.html,1,['log'],['logProgress']
Testability," Public Member Functions;  MethodRSNNS (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption="""");  ;  MethodRSNNS (DataSetInfo &dsi, const TString &theWeightFile);  ;  ~MethodRSNNS (void);  ; virtual void AddWeightsXMLTo (void *) const;  ; const Ranking * CreateRanking ();  ; void DeclareOptions ();  ; Double_t GetMvaValue (Double_t *errLower=nullptr, Double_t *errUpper=nullptr);  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the current Data type ;  ; Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  ; void Init ();  ; void ProcessOptions ();  ; void ReadModelFromFile ();  ; virtual void ReadWeightsFromStream (std::istream &);  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *);  ; virtual void TestClassification ();  initialization ;  ; void Train ();  ;  Public Member Functions inherited from TMVA::RMethodBase;  RMethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""", ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ;  RMethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile, ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ; virtual ~RMethodBase ();  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html:922,log,logProgress,922,doc/master/classTMVA_1_1MethodRSNNS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html,1,['log'],['logProgress']
Testability," Public Member Functions;  MethodRSVM (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption="""");  ;  MethodRSVM (DataSetInfo &dsi, const TString &theWeightFile);  ;  ~MethodRSVM (void);  ; virtual void AddWeightsXMLTo (void *) const;  ; const Ranking * CreateRanking ();  ; void DeclareOptions ();  ; Double_t GetMvaValue (Double_t *errLower=nullptr, Double_t *errUpper=nullptr);  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the current Data type ;  ; Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  ; void Init ();  ; void ProcessOptions ();  ; void ReadModelFromFile ();  ; virtual void ReadWeightsFromStream (std::istream &);  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *);  ; virtual void TestClassification ();  initialization ;  ; void Train ();  ;  Public Member Functions inherited from TMVA::RMethodBase;  RMethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""", ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ;  RMethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile, ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ; virtual ~RMethodBase ();  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSVM.html:916,log,logProgress,916,doc/master/classTMVA_1_1MethodRSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSVM.html,1,['log'],['logProgress']
Testability," Public Member Functions;  MethodRXGB (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption="""");  ;  MethodRXGB (DataSetInfo &dsi, const TString &theWeightFile);  ;  ~MethodRXGB (void);  ; virtual void AddWeightsXMLTo (void *) const;  ; const Ranking * CreateRanking ();  ; void DeclareOptions ();  ; Double_t GetMvaValue (Double_t *errLower=nullptr, Double_t *errUpper=nullptr);  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the current Data type ;  ; Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  ; void Init ();  ; virtual void MakeClass (const TString &classFileName=TString("""")) const;  create reader class for method (classification only at present) ;  ; void ProcessOptions ();  ; void ReadModelFromFile ();  ; virtual void ReadWeightsFromStream (std::istream &);  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *);  ; virtual void TestClassification ();  initialization ;  ; void Train ();  ;  Public Member Functions inherited from TMVA::RMethodBase;  RMethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""", ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance());  ;  RMethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile, ROOT::R::TRInterface &_r=ROOT::R::TRInterface::Instance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRXGB.html:916,log,logProgress,916,doc/master/classTMVA_1_1MethodRXGB.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRXGB.html,1,['log'],['logProgress']
Testability," Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials The End. You are done - that was the introductory tutorial!. Image by Tangopaso; If you want to go on, have a look at the ROOT Courses section!; . ‹ Using a TSelector with PROOF; up. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/end.html:2953,test,tests,2953,d/end.html,https://root.cern,https://root.cern/d/end.html,1,['test'],['tests']
Testability, Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivationChooser.h 40005 2011-06-27 15:29:10Z ste,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TActivationChooser.html:1030,Log,Log,1030,root/html532/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html532/TMVA__TActivationChooser.html,1,['Log'],['Log']
Testability, RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.0043655 0.99836 [ -3.2801 5.7307 ]; : m_jjj: 0.0044371 0.99827 [ -3.2805 5.7307 ]; : m_lv: 0.0054053 1.0003 [ -3.2810 5.7307 ]; : m_jlv: 0.0044637 0.99837 [ -3.2803 5.7307 ]; : m_bb: 0.0043676 0.99847 [ -3.2797 5.7307 ]; : m_wbb: 0.0042343 0.99744 [ -3.2803 5.7307 ]; : m_wwbb: 0.0046014 0.99948 [ -3.2802 5.7307 ]; : -----------------------------------------------------------; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: PyKeras; : ; PyKeras : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_PyKeras : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 1.0447 0.66216 [ 0.14661 10.222 ]; : m_jjj: 1.0275 0.37015 [ 0.34201 5.6016 ]; : m_lv: 1.0500 0.15582 [ 0.29757 2.8989 ]; : m_jlv: 1.0053 0.39478 [ 0.41660 5.8799 ]; : m_bb: 0.97464 0.52138 [ 0.10941 5.5163 ]; : m_wbb: 1.0296 0.35719 [ 0.38878 3.9747 ]; : m_wwbb: 0.95617 0.30368 [ 0.44118 4.0728 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset DNN_CPU : 0.759; : dataset BDT : 0.754; : dataset PyKeras : 0.752; : dataset Likelihood : 0.698; : dataset Fisher : 0.642; : -------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:54372,test,test,54372,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['test'],['test']
Testability, RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.0043655 0.99836 [ -3.2801 5.7307 ]; : m_jjj: 0.0044371 0.99827 [ -3.2805 5.7307 ]; : m_lv: 0.0054053 1.0003 [ -3.2810 5.7307 ]; : m_jlv: 0.0044637 0.99837 [ -3.2803 5.7307 ]; : m_bb: 0.0043676 0.99847 [ -3.2797 5.7307 ]; : m_wbb: 0.0042343 0.99744 [ -3.2803 5.7307 ]; : m_wwbb: 0.0046014 0.99948 [ -3.2802 5.7307 ]; : -----------------------------------------------------------; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: PyKeras; : ; PyKeras : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_PyKeras : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 1.0447 0.66216 [ 0.14661 10.222 ]; : m_jjj: 1.0275 0.37015 [ 0.34201 5.6016 ]; : m_lv: 1.0500 0.15582 [ 0.29757 2.8989 ]; : m_jlv: 1.0053 0.39478 [ 0.41660 5.8799 ]; : m_bb: 0.97464 0.52138 [ 0.10941 5.5163 ]; : m_wbb: 1.0296 0.35719 [ 0.38878 3.9747 ]; : m_wwbb: 0.95617 0.30368 [ 0.44118 4.0728 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset DNN_CPU : 0.762; : dataset PyKeras : 0.757; : dataset BDT : 0.754; : dataset Likelihood : 0.698; : dataset Fisher : 0.642; : -------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:54876,test,test,54876,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['test'],['test']
Testability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; RooStats::IntervalCalculatorIntervalCalculator(); RooStats::IntervalCalculatorIntervalCalculator(const RooStats::IntervalCalculator&); virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__IntervalCalculator.html:1198,test,test-statistic,1198,root/html602/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__IntervalCalculator.html,4,['test'],['test-statistic']
Testability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__IntervalCalculator.html:1196,test,test-statistic,1196,root/html528/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__IntervalCalculator.html,4,['test'],['test-statistic']
Testability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__IntervalCalculator.html:1196,test,test-statistic,1196,root/html526/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__IntervalCalculator.html,1,['test'],['test-statistic']
Testability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Librari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__IntervalCalculator.html:1198,test,test-statistic,1198,root/html534/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__IntervalCalculator.html,2,['test'],['test-statistic']
Testability," ROOT 7 support (read more). roottest; OFF; Include roottest in the test suit, if roottest exists in root or if it is a sibling directory. ruby; OFF; Ruby ROOT bindings, requires ruby >= 1.8. r; OFF; R ROOT bindings, requires R, Rcpp and RInside. rfio; ON; RFIO support, requires libshift from CASTOR >= 1.5.2. rpath; OFF; Set run-time library load path on executables and shared libraries (at installation area). runtime_cxxmodules; OFF; Enable runtime c++ modules. sapdb; ON; MaxDB/SapDB support, requires libsqlod and libsqlrte. shadowpw; ON; Shadow password support. shared; ON; Use shared 3rd party libraries if possible. soversion; OFF; Set version number in sonames (recommended). sqlite; ON; SQLite support, requires libsqlite3. srp; ON; SRP support, requires SRP source tree. ssl; ON; SSL encryption support, requires openssl. tbb; OFF; TBB multi-threading support, requires TBB. table; *; Build libTable contrib library. tcmalloc; OFF; Using the tcmalloc allocator. testing; OFF; Enable test suit of ROOT with CTest. thread; ON; Using thread library (cannot be disabled). tmva; ON; Build TMVA multi variate analysis library. unuran; *; UNURAN - package for generating non-uniform random numbers. vc; *; Vc adds a few new types for portable and intuitive SIMD programming. vdt; ON; VDT adds a set of fast and vectorisable mathematical functions. winrtdebug; OFF; Link against the Windows debug runtime library. xft; ON; Xft support (X11 antialiased fonts). xml; ON; XML parser interface. xrootd; ON; Build xrootd file server and its client (if supported). x11; *; X11 support. The default value for these options are platform dependent. CMake Generators; CMake can generate, in addition to standard makefiles, specific proejcts for various integrated development environments (IDEs) such as Xcode, Eclipse, Visual Studio, etc.. The available generators depend on the platform for which cmake have been build. To see the list of available generators do cmake --help .; Ninja; Generate a Ninja ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:12560,test,testing,12560,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,2,['test'],"['test', 'testing']"
Testability," ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic = ROOT.RooFit.Tracing, ClassName = ""RooGaussian""). Definition at line 110 of file RooMsgService.h. Classes; struct  StreamConfig;  . Public Member Functions;  ~RooMsgService () override;  ; Int_t addStream (RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Add a message logging stream for message with given RooFit::MsgLevel or higher. ;  ; void clearErrorCount ();  ; Int_t & debugCode ();  ; RooWorkspace * debugWorkspace ();  ; void deleteStream (Int_t id);  Delete stream with given unique ID code. ;  ; Int_t errorCount () const;  ; StreamConfig & getStream (Int_t id);  ; bool getStreamStatus (Int_t id) const;  Get activation status of stream with given unique ID. ;  ; RooFit::MsgLevel globalKillBelow () const;  ; TClass * IsA () const override;  ; template<class T > ; bool isActive (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level);  Check if logging is active for given object/topic/RooFit::MsgLevel combination. ;  ; std::ostream & log (const RooAbsArg *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with RooAbsArg object self at given level and topic. ;  ; std::ostream & log (const TObject *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with TObject object self at given level and topic. ;  ; std::ostream & log (std::nullptr_t, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  ; Int_t numStreams () const;  ; void Print (Option_t *options=nullptr) const override;  Print configuration of message service. ;  ; void reset ();  ; void restoreState ();  Restore last saved state of message service. ;  ; void saveState ();  Save current state of message service. ;  ; void setGlobalKillBelow (RooFit::MsgLevel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:3390,log,logging,3390,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['log'],['logging']
Testability," ROOT; » CORE; » METAUTILS; » TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); stringGetLong64_Name(const char* original); stringGetLong64_Name(const string& original); intGetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); intIsSTLCont(const char* type, int testAlloc = 0); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); intSTLKind(const char* type). Data Members. Class Charts; Function documentation; int IsSTLCont(int testAlloc=0). void ShortType(const char* typeDesc, int mode). std::string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). bool IsDefAlloc(const char* alloc, const char* classname). bool IsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname). bool IsDefComp(const char* comp, const char* classname). bool IsSTLBitset(const char* type). bool IsStdClass(const char* type). bool IsVectorBool(const char* name). std::string GetLong64_Name(const char* original). std::string GetLong64_Name(const string& original). int GetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). int STLKind(const char* type). int STLArgs(int kind). std::string ResolveTypedef(const char* tname, bool resolveAll = false). std::string InsertStd(const char* tname). » Author: Victor Perev 10/04/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClassEdit.html:1222,test,testAlloc,1222,root/html534/TClassEdit.html,https://root.cern,https://root.cern/root/html534/TClassEdit.html,2,['test'],['testAlloc']
Testability," ROOT; » HIST; » HIST; » TFitResultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitResultPtr.html:1360,assert,assert,1360,root/html534/TFitResultPtr.html,https://root.cern,https://root.cern/root/html534/TFitResultPtr.html,4,['assert'],['assert']
Testability," ROOT; » TMVA; » TMVA::CostComplexityPruneTool. class TMVA::CostComplexityPruneTool: public TMVA::IPruneTool. Function Members (Methods); public:. virtual~CostComplexityPruneTool(); virtual TMVA::PruningInfo*CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE); TMVA::CostComplexityPruneToolCostComplexityPruneTool(TMVA::SeparationBase* qualityIndex = __null); TMVA::CostComplexityPruneToolCostComplexityPruneTool(const TMVA::CostComplexityPruneTool&); Double_tTMVA::IPruneTool::GetPruneStrength() const; TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(); TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(const TMVA::IPruneTool&); Bool_tTMVA::IPruneTool::IsAutomatic() const; TMVA::CostComplexityPruneTool&operator=(const TMVA::CostComplexityPruneTool&); voidTMVA::IPruneTool::SetAutomatic(); voidTMVA::IPruneTool::SetPruneStrength(Double_t alpha). private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__CostComplexityPruneTool.html:1242,Log,Log,1242,root/html602/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html602/TMVA__CostComplexityPruneTool.html,1,['Log'],['Log']
Testability," RX allows to draw the X-axis with increasing values from right to left and the RY option allows to draw the Y-axis with increasing values from top to bottom. The following example illustrate how to use these options.; {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");; ; g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);; ; g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);; ; g->GetXaxis()->SetNdivisions(520);; ; g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");; ; c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105. Graphs in logarithmic scale; Like histograms, graphs can be drawn in logarithmic scale along X and Y. When a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy() the points building the graph are converted into logarithmic scale. But only the points not the lines connecting them which stay linear. This can be clearly seen on the following example:; {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph(3);; g->SetPoint(0,xmin,0.1);; g->SetPoint(1,845,0.06504);; g->SetPoint(2,xmax,0.008);; ; // The same graph with n points; Int_t n = 10000;; Double_t dx = (xmax-xmin)/n;; Double_t x = xmin;; auto g2 = new TGraph();; for (Int_t i=0; i<n; i++) {; g2->SetPoint(i, x, g->Eval(x));; x = x + dx;; }; ; auto cv = new TCanvas(""cv"",""cv"",800,600);; cv->SetLogy();; cv->SetGridx();; cv->SetGridy();; g->Draw(""AL*"");; ; g2->SetMarkerColor(kRed);; g2->SetMarkerStyle(1);; g2->Draw(""P"");; }; ; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95. Highlight mode for graph; SinceROOT version 6.15/01. Highlight mode; Highlight mode is implemented for TGraph (and for TH1) class. When h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:24725,log,logarithmic,24725,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,2,['log'],['logarithmic']
Testability," ReferenceInput/Output Library. ; A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). ; TNetFile file names are in standard URL format with protocol ""root"" or ""roots"". The following are valid TNetFile URL's:; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root of the remote file tree is the user's home directory. Therefore an absolute pathname requires a // after the host or port specifier (see last example). Further the expansion of the standard shell characters, like ~, $, .., are handled as expected. TNetFile (actually TUrl) uses 1094 as default port for rootd.; Connecting to a rootd requires the remote user id and password. TNetFile allows three ways for you to provide your login: Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and TAuthenticate::SetGlobalPasswd(); Getting it from the ~/.netrc file (same file as used by ftp); Command line prompt The different methods will be tried in the order given above. On machines with AFS rootd will authenticate using AFS (if it was compiled with AFS support). If the protocol is specified as ""rootk"" kerberos5 will be used for authentication.; The rootd daemon lives in the directory $ROOTSYS/bin. It can be started either via inetd or by hand from the command line (no need to be super user). ; Definition at line 34 of file TNetFile.h. Public Member Functions;  TNetFile ();  ;  TNetFile (const char *url, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create a TNetFile object. ;  ; virtual ~TNetFile ();  TNetFile dtor. Send close message and close socket. ;  ; void Close (Option_t *option="""") override;  Close remote file. ;  ; void Flush () override;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:1242,log,login,1242,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['log'],['login']
Testability," ReferenceTMVA. ; Class to perform cross validation, splitting the dataloader into folds. ; Use html for explicit line breaking; Markdown links? class reference?; ce->BookMethod(dataloader, options);; ce->Evaluate();; Cross-evaluation will generate a new training and a test set dynamically from from K folds. These K folds are generated by splitting the input training set. The input test set is currently ignored.; This means that when you specify your DataSet you should include all events in your training set. One way of doing this would be the following:; dataloader->AddTree( signalTree, ""cls1"" );; dataloader->AddTree( background, ""cls2"" );; dataloader->PrepareTrainingAndTestTree( """", """", ""nTest_cls1=1:nTest_cls2=1"" );. Split Expression; See CVSplit documentation? ; Definition at line 124 of file CrossValidation.h. Public Member Functions;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TFile *outputFile, TString options);  ;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TString options);  ;  ~CrossValidation ();  ; void Evaluate ();  Does training, test set evaluation and performance evaluation of using cross-evalution. ;  ; Factory & GetFactory ();  ; UInt_t GetNumFolds ();  ; const std::vector< CrossValidationResult > & GetResults () const;  ; TString GetSplitExpr ();  ; void InitOptions ();  ; virtual TClass * IsA () const;  ; void ParseOptions ();  Method to parse the internal option string. ;  ; void SetNumFolds (UInt_t i);  ; void SetSplitExpr (TString splitExpr);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html:1413,test,test,1413,doc/master/classTMVA_1_1CrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html,1,['test'],['test']
Testability," Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 445 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:120196,log,logEvalError,120196,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['log'],['logEvalError']
Testability," Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121526,log,logEvalError,121526,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['log'],['logEvalError']
Testability, Returning maximum FCN so far (-712.949) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.711808 a1=-0.34088 mean=4.99573 nbkg=115.49 nsig=133.015 sig1frac=0.908627; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 240; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 230; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 220; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 210; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 200; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 190; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 180; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 170; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 160; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 150; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-750.903) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.726225 a1=-0.429497 mean=5.03871 nbkg=129.53 nsig=136.644 sig1frac=0.687558; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 140; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-740.756) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.899536 a1=-0.345881 mean=5.03897 nbkg=135.176 nsig=129.13 sig1frac=0.899393; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-677.604) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.766597 a1=-0.547838 mean=5.03836 nbkg=119.039 nsig=121.817 sig1frac=0.213703; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 130; RooAbsMinimizerFcn: Mi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:24297,log,log,24297,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability," Returns 0 in case of success and -1 in case of error. ; Definition at line 8258 of file TProof.cxx. ◆ Exec() [1/3]. Int_t TProof::Exec ; (; const char * ; cmd, . Bool_t ; plusMaster = kFALSE . ). Send command to be executed on the PROOF master and/or slaves. ; If plusMaster is kTRUE then exeucte on slaves and master too. Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6521 of file TProof.cxx. ◆ Exec() [2/3]. Int_t TProof::Exec ; (; const char * ; cmd, . const char * ; ord, . Bool_t ; logtomacro = kFALSE . ). Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. If logtomacro is TRUE the text result of the action is saved in the fMacroLog TMacro, accessible via TMacro::GetMacroLog(); Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6589 of file TProof.cxx. ◆ Exec() [3/3]. Int_t TProof::Exec ; (; const char * ; cmd, . ESlaves ; list, . Bool_t ; plusMaster . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6533 of file TProof.cxx. ◆ ExistsDataSet(). Bool_t TProof::ExistsDataSet ; (; const char * ; dataset). virtual . Returns kTRUE if 'dataset' exists, kFALSE otherwise. ; Reimplemented in TProofLite.; Definition at line 10868 of file TProof.cxx. ◆ Feedback(). void TProof::Feedback ; (; TList * ; objs). Get list of feedback objects. ; Connect a slot to this signal to monitor the feedback object. ; Definition at line 9268 of file TProof.cxx. ◆ FinalizationDone(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:88821,log,logtomacro,88821,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['logtomacro']
Testability," ReturnsTClass describing current object ; Reimplemented from TMVA::Results.; Definition at line 82 of file ResultsRegression.h. ◆ Log(). MsgLogger & TMVA::ResultsRegression::Log ; (; ); const. inlineprivate . Definition at line 79 of file ResultsRegression.h. ◆ operator[](). const std::vector< Float_t > & TMVA::ResultsRegression::operator[] ; (; Int_t ; ievt); const. inlineoverridevirtual . Implements TMVA::Results.; Definition at line 67 of file ResultsRegression.h. ◆ QuadraticDeviation(). TH1F * TMVA::ResultsRegression::QuadraticDeviation ; (; UInt_t ; tgtNum, . Bool_t ; truncate = false, . Double_t ; truncvalue = 0. . ). Definition at line 75 of file ResultsRegression.cxx. ◆ Resize(). void TMVA::ResultsRegression::Resize ; (; Int_t ; entries). inline . Definition at line 60 of file ResultsRegression.h. ◆ SetValue(). void TMVA::ResultsRegression::SetValue ; (; std::vector< Float_t > & ; value, . Int_t ; ievt . ). Definition at line 67 of file ResultsRegression.cxx. ◆ Streamer(). void TMVA::ResultsRegression::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TMVA::Results. ◆ StreamerNVirtual(). void TMVA::ResultsRegression::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 82 of file ResultsRegression.h. Member Data Documentation. ◆ fLogger. MsgLogger* TMVA::ResultsRegression::fLogger. mutableprivate . ! message logger ; Definition at line 78 of file ResultsRegression.h. ◆ fRegValues. std::vector<std::vector<Float_t> > TMVA::ResultsRegression::fRegValues. mutableprivate . mva values (Results) ; Definition at line 77 of file ResultsRegression.h. Libraries for TMVA::ResultsRegression:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/ResultsRegression.h; tmva/tmva/src/ResultsRegression.cxx. TMVAResultsRegression. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ResultsRegression.html:15794,log,logger,15794,doc/master/classTMVA_1_1ResultsRegression.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ResultsRegression.html,1,['log'],['logger']
Testability," Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2; param[5] = phi1; param[6] = phi2. ~TGeoConeSeg(); destructor. void AfterStreamer(); Function called after streaming an object of this class. void InitTrigonometry(); Init frequently used trigonometric values. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:16183,test,test,16183,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,6,['test'],['test']
Testability, RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical inte,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:25365,test,test,25365,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['test'],['test']
Testability," RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:19717,test,testArg,19717,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,100,['test'],['testArg']
Testability," RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:19858,test,testArg,19858,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,6,['test'],['testArg']
Testability," RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMoment&operator=(const RooMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:19509,test,testArg,19509,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,4,['test'],['testArg']
Testability," RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidprintMult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:10420,test,testArg,10420,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['test'],['testArg']
Testability," RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:10535,test,testArg,10535,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,1,['test'],['testArg']
Testability," RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:5317,log,logging,5317,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,1,['log'],['logging']
Testability," RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConvCoefVar&operator=(const RooConvCoefVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:19589,test,testArg,19589,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,4,['test'],['testArg']
Testability," RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGenProdProj&operator=(const RooGenProdProj&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:19740,test,testArg,19740,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,4,['test'],['testArg']
Testability," RooAbsData*fDatapointer to the data sets; boolfGenerateBinnedFlag to control binned generation; unsigned intfNToysnumber of Toys MC; const RooArgSet*fNuisanceParametersCollection of the nuisance parameters in the model; RooArgList*fObservablesCollection of the observables of the model; RooAbsPdf*fPriorPdfPrior PDF of the nuisance parameters; RooAbsPdf*fSbModelThe pdf of the signal+background model; unsigned intfTestStatisticsIdxIndex of the test statistics to use; boolfTmpDoExtended; boolfUsePriorPdfuse a prior for nuisance parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridCalculatorOriginal(const char* name = 0); constructor with name and title; set default parameters. HybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor without specifying a data set; the user need to specify the models in the S+B case and B-only case,; the list of observables of the model(s) (for MC-generation), the list of parameters; that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor for performing hypotesis test; the user need to specify the data set, the models in the S+B case and B-only case.; In case of treatment of nuisance parameter, the user need to specify the; the list of parameters that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html:11480,test,testStatistics,11480,root/html602/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html,4,['test'],['testStatistics']
Testability, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-768.847) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.749295 a1=-0.303934 mean=4.98272 nbkg=121.461 nsig=145.338 sig1frac=0.822833; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-798.509) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.791035 a1=-0.287544 mean=4.98693 nbkg=127.577 nsig=149.203 sig1frac=0.914567; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 410; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 400; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 390; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-977.775) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.565967 a1=-0.529635 mean=5.0065 nbkg=153.38 nsig=185.083 sig1frac=0.751239; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 380; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 370; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-945.036) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.824344 a1=-0.338546 mean=5.06339 nbkg=161.705 nsig=169.087 sig1frac=0.910016; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 360; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 350; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 340; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 330; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 320; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 310; RooAbsMinimizerFcn:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:20223,log,log,20223,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-777.498) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.510348 a1=-0.776595 mean=5.09286 nbkg=154.805 nsig=114.979 sig1frac=0.0496841; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 120; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 110; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-796.54) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.702991 a1=-0.414346 mean=5.11911 nbkg=145.466 nsig=141.134 sig1frac=0.532895; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 100; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-920.777) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.726241 a1=-0.424659 mean=5.05565 nbkg=151.228 nsig=170.816 sig1frac=0.771802; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-743.339) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.942558 a1=-0.775768 mean=4.99866 nbkg=187.872 nsig=63.0852 sig1frac=0.868175; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-743.339) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.984478 a1=-0.59938 mean=4.99914 nbkg=173.959 nsig=90.3182 sig1frac=0.461117; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 90; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 80; [#0] PROGRESS:Generatio,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:26953,log,log,26953,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-814.549) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.848973 a1=-0.489149 mean=5.08811 nbkg=132.911 nsig=150.647 sig1frac=0.826731; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 690; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 680; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 670; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-809.662) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.713661 a1=-0.606754 mean=5.02862 nbkg=142.583 nsig=145.399 sig1frac=0.623944; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-861.002) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.744046 a1=-0.311529 mean=5.09799 nbkg=161.409 nsig=148.884 sig1frac=0.512806; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 660; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 650; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 640; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 630; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 620; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 610; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-809.027) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.719517 a1=-0.347533 mean=5.00927 nbkg=127.977 nsig=152.559 sig1frac=0.917291; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 600; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 590; [#0] PROGRESS:Gen,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:15919,log,log,15919,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability," RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,int,int>&operator=(const RooCFunction3PdfBinding<double,double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_int_int_.html:23764,test,testArg,23764,root/html602/RooCFunction3PdfBinding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_int_int_.html,4,['test'],['testArg']
Testability," RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::HistFactorySimultaneous&operator=(const RooStats::HistFactory::HistFactorySimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:24940,test,testArg,24940,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,4,['test'],['testArg']
Testability," RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMinuit*minuit(); RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:17424,test,testArg,17424,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['test'],['testArg']
Testability," RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tRooAbsAnaConvPdf::declareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:9056,test,testArg,9056,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,108,['test'],['testArg']
Testability," RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tdeclareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsAnaConvPdf.html:10225,test,testArg,10225,root/html530/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsAnaConvPdf.html,16,['test'],['testArg']
Testability," RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&RooAbsOptTestStatistic::data(); const RooAbsData&RooAbsOptTestStatistic::data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataWeightedAverage.html:9475,test,testArg,9475,root/html530/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html530/RooDataWeightedAverage.html,18,['test'],['testArg']
Testability," RooArgSetRooStats::CombinedCalculator::fNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetRooStats::CombinedCalculator::fNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetRooStats::CombinedCalculator::fPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*RooStats::CombinedCalculator::fPdf; Double_tRooStats::CombinedCalculator::fSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default dummy constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from the data, a model pdf and the parameter of Interest.; If nuisance parameters are present they should be specified as part of the model; i.e. the model pdf is a combined pdf for the poi and the nuisance; The default test size used is 0.05 ( for a 95% interval); A set for the null parameters (it must be a copied set) can be specified which will be used for; performing the hypothesis test. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from the data and a model configuration (ModelConfig class); If the model configuration contains a Prior pdf it will be included in the full model; used by the profile likelihood calculator.; The default test size used is 0.05 ( for a 95% interval). ~ProfileLikelihoodCalculator(); destructor (delete the contained result of the fit). void DoReset() const; private method to reset and clear fit results; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; private method to perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. LikelihoodInterval* GetInterval() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html:10592,test,test,10592,root/html526/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html,1,['test'],['test']
Testability," RooLinearVar input variable in the same way that RooLinearVar does. More...;  ; class  RooMCIntegrator;  Implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. More...;  ; class  RooMoment;  ; class  RooMsgService;  Singleton class that organizes messages generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:13436,log,log,13436,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['log'],['log']
Testability," RooList(); virtual~RooList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooList.html:1377,Assert,AssertClass,1377,root/html532/RooList.html,https://root.cern,https://root.cern/root/html532/RooList.html,2,['Assert'],['AssertClass']
Testability," RooMinimizer.cxx. ◆ initMinimizer(). void RooMinimizer::initMinimizer ; (; ). private . Definition at line 968 of file RooMinimizer.cxx. ◆ initMinimizerFcnDependentPart(). void RooMinimizer::initMinimizerFcnDependentPart ; (; double ; defaultErrorLevel). private . Initialize the part of the minimizer that is dependent on the function to be minimized. ; Definition at line 151 of file RooMinimizer.cxx. ◆ initMinimizerFirstPart(). void RooMinimizer::initMinimizerFirstPart ; (; ). private . Initialize the part of the minimizer that is independent of the function to be minimized. ; Definition at line 141 of file RooMinimizer.cxx. ◆ IsA(). TClass * RooMinimizer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 247 of file RooMinimizer.h. ◆ lastMinuitFit(). RooFit::OwningPtr< RooFitResult > RooMinimizer::lastMinuitFit ; (; ). Definition at line 738 of file RooMinimizer.cxx. ◆ logfile(). std::ofstream * RooMinimizer::logfile ; (; ). private . Definition at line 827 of file RooMinimizer.cxx. ◆ makeEvalErrorContext(). std::unique_ptr< RooAbsReal::EvalErrorContext > RooMinimizer::makeEvalErrorContext ; (; ); const. private . Definition at line 840 of file RooMinimizer.cxx. ◆ maxFCN(). double & RooMinimizer::maxFCN ; (; ). private . Definition at line 831 of file RooMinimizer.cxx. ◆ migrad(). int RooMinimizer::migrad ; (; ). Execute MIGRAD. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 318 of file RooMinimizer.cxx. ◆ minimize(). int RooMinimizer::minimize ; (; const char * ; type, . const char * ; alg = nullptr . ). Minimise the function passed in the constructor. ; Parameters. [in]typeType of fitter to use, e.g. ""Minuit"" ""Minuit2"". Passing an empty string will select the default minimizer type of the RooMinimizer, as returned by ROOT::Math::MinimizerOptions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:22943,log,logfile,22943,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['log'],['logfile']
Testability," RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:41506,log,logic,41506,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,3,['log'],['logic']
Testability," RooRefArray(); RooRefArray(const RooRefArray& other); virtual~RooRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t i) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRefArray.html:1126,Assert,AssertClass,1126,root/html534/RooRefArray.html,https://root.cern,https://root.cern/root/html534/RooRefArray.html,1,['Assert'],['AssertClass']
Testability," RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observables set to values satisfying the constraints. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); HypoTestCalculatorGeneric(data, altModel, nullModel, 0); {; }. void SetOneSided(bool on); set test statistic for one sided (upper limits). { fOneSided = on; }. void SetTwoSided(); set the test statistics for two sided (in case of upper limits; for discovery does not make really sense). { fOneSided = false; fOneSidedDiscovery = false;}. void SetOneSidedDiscovery(bool on); set the test statistics for one-sided discovery. { fOneSidedDiscovery = on; }. bool IsTwoSided() const; { return (!fOneSided && !fOneSidedDiscovery); }. bool IsOneSidedDiscovery() const; { return fOneSidedDiscovery; }. void SetQTilde(bool on); set using of qtilde, by default is controlled if RoORealVar is limited or not. { fUseQTilde = on; }. const RooArgSet & GetBestFitPoi() const; return snapshot of the best fit parameter. { return fBestFitPoi; }. const RooRealVar * GetMuHat() const; return best fit parameter (firs of poi). { return dynamic_cast<RooRealVar*>(fBestFitPoi.first()); }. const RooArgSet & GetBestFitParams() const; return best fit value for all parameters. { return fBestFitPoi; }. » Author: Sven Kreiss, Kyle Cranmer Nov 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Las",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__AsymptoticCalculator.html:9779,test,test,9779,root/html534/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__AsymptoticCalculator.html,4,['test'],['test']
Testability," RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observables set to values satisfying the constraints. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); HypoTestCalculatorGeneric(data, altModel, nullModel, 0); {; }. void SetOneSided(bool on); set test statistic for one sided (upper limits). { fOneSided = on; }. void SetTwoSided(); set the test statistics for two sided (in case of upper limits; for discovery does not make really sense). { fOneSided = false; fOneSidedDiscovery = false;}. void SetOneSidedDiscovery(bool on); set the test statistics for one-sided discovery. { fOneSidedDiscovery = on; }. void SetNullModel(const RooStats::ModelConfig& nullModel); re-implement setters since they needs to re-initialize the calculator. void SetAlternateModel(const RooStats::ModelConfig& altModel). void SetData(RooAbsData& data). bool IsTwoSided() const; { return (!fOneSided && !fOneSidedDiscovery); }. bool IsOneSidedDiscovery() const; { return fOneSidedDiscovery; }. void SetQTilde(bool on); set using of qtilde, by default is controlled if RoORealVar is limited or not. { fUseQTilde = on; }. const RooArgSet & GetBestFitPoi() const; return snapshot of the best fit parameter. { return fBestFitPoi; }. const RooRealVar * GetMuHat() const; return best fit parameter (firs of poi). { return dynamic_cast<RooRealVar*>(fBestFitPoi.first()); }. const RooArgSet & GetBestFitPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__AsymptoticCalculator.html:10047,test,test,10047,root/html604/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html604/RooStats__AsymptoticCalculator.html,2,['test'],['test']
Testability," RooStats::TestStatSamplerTestStatSampler(const RooStats::TestStatSampler&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__TestStatSampler.html:2939,test,test,2939,root/html602/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__TestStatSampler.html,4,['test'],['test']
Testability," RooStringVar.h. ◆ DeclFileName(). static const char * RooStringVar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 77 of file RooStringVar.h. ◆ fillTreeBranch(). void RooStringVar::fillTreeBranch ; (; TTree & ; t). overrideprotectedvirtual . Fill tree branch associated with this object. ; Implements RooAbsArg.; Definition at line 120 of file RooStringVar.cxx. ◆ getVal(). const char * RooStringVar::getVal ; (; ); const. inline . Definition at line 33 of file RooStringVar.h. ◆ IsA(). TClass * RooStringVar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file RooStringVar.h. ◆ isFundamental(). bool RooStringVar::isFundamental ; (; ); const. inlineoverridevirtual . Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ; Note that this test is subtlely different from the dynamic isDerived() test, e.g. a constant is not derived but is also not fundamental. ; Reimplemented from RooAbsArg.; Definition at line 38 of file RooStringVar.h. ◆ isIdentical(). bool RooStringVar::isIdentical ; (; const RooAbsArg & ; other, . bool ;  . ); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 50 of file RooStringVar.h. ◆ isValid(). bool RooStringVar::isValid ; (; ); const. inlineoverrideprotectedvirtual . WVE (08/21/01) Probably obsolete now. ; Reimplemented from RooAbsArg.; Definition at line 64 of file RooStringVar.h. ◆ isValidString(). virtual bool RooStringVar::isValidString ; (; const char * ; , . bool ;  . ); const. inlineprotectedvirtual . Definition at line 65 of file RooStringVar.h. ◆ operator TString(). virtual RooStringVar::operator TString ; (; ). inlinevirtual . Definition at line 32 of file RooStringVar.h. ◆ operator=(). virtual RooAbsArg & RooStringVar::operator= ; (; const char * ; newVal). inlinevirtual . Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:41602,test,test,41602,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,2,['test'],['test']
Testability," RooUnitTest&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidregPlot(RooPlot* frame, const char* refName); voidregResult(RooFitResult* r, const char* refName); voidregTable(RooTable* t, const char* refName); voidregTH(TH1* h, const char* refName); voidregValue(Double_t value, const char* refName); voidregWS(RooWorkspace* ws, const char* refName); voidTObject::ResetBit(UInt_t f); Bool_trunCompTests(); Bool_trunTest(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDebug(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetMemDir(TDirectory* memDir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetSilentMode(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttestCode(); virtual voidTObject::UseCurrentStyle(); virtual Double_tvtol(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnitTest.html:5846,Test,TestBit,5846,root/html534/RooUnitTest.html,https://root.cern,https://root.cern/root/html534/RooUnitTest.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," RooWorkspace*_debugWorkspace; ostream*_devnull; Int_t_errorCount; map<string,ostream*>_files; RooFit::MsgLevel_globMinLevel; static RooMsgService*_instance; RooFit::MsgLevel_lastMsgLevel; Bool_t_showPid; Bool_t_silentMode; vector<RooMsgService::StreamConfig>_streams; stack<vector<RooMsgService::StreamConfig> >_streamsSaved. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete all global object upon program termination. RooMsgService(); Constructor. Defines names of message levels; and mapping of topic codes to topic names; Install default message streams. ~RooMsgService(); Destructor. Bool_t anyDebug(); Returns true if any debug level stream is active. RooWorkspace* debugWorkspace(). Int_t addStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMsgService.html:9362,log,logging,9362,root/html602/RooMsgService.html,https://root.cern,https://root.cern/root/html602/RooMsgService.html,4,['log'],['logging']
Testability," Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t log",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntry.html:26231,log,log,26231,root/html528/TGNumberEntry.html,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html,10,['log'],['log']
Testability," Set the Pdf, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic, unsigned int i); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetTestStatistic(RooStats::TestStatistic* t); { return SetTestStatistic(t,0); }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation (=> see RooFit::AllBinned() option). { fGenerateBinned = binned; }. void SetGenerateBinnedTag(const char* binnedTag = """"); name of the tag for individual components to be generated binned (=> see RooFit::GenBinned() option). { fGenerateBinnedTag = binnedTag; }. void SetGenerateAutoBinned(Bool_t autoBinned = kTRUE); set auto binned generation (=> see RooFit::AutoBinned() option). { fGenerateAutoBinned = autoBinned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. std::string GetSamplingDistNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ToyMCSampler.html:10032,test,testStatistic,10032,root/html534/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__ToyMCSampler.html,12,"['Test', 'test']","['TestStatistic', 'testStatistic']"
Testability," Set(UInt_t nbits, const Short_t* array); Set all the bytes. void Set(UInt_t nbits, const Int_t* array); Set all the bytes. void Set(UInt_t nbits, const Long64_t* array); Set all the bytes. void Get(Short_t* array) const; Get all the bytes. void Get(Int_t* array) const; Get all the bytes. void Get(Long64_t* array) const; Get all the bytes. void Set(UInt_t nbits, const Short_t* array); make nbytes even so that the loop below is neat. void Set(UInt_t nbits, const Int_t* array); make nbytes a multiple of 4 so that the loop below is neat. void Set(UInt_t nbits, const Long64_t* array); make nbytes a multiple of 8 so that the loop below is neat. void Get(Short_t* array) const; Get all the bytes. void Get(Int_t* array) const; Get all the bytes. void Get(Long64_t* array) const; Get all the bytes. Bool_t operator==(const TBits& other) const; Compare object. void SetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); Set bit number 'bitnumber' to be value. Bool_t TestBitNumber(UInt_t bitnumber) const; Return the current value of the bit. void ResetBitNumber(UInt_t bitnumber). Bool_t operator[](UInt_t bitnumber) const. Bool_t operator~(); Flips the bit. TBits::TReference operator[](UInt_t bitnumber); ----- Accessors and operator. { return TReference(*this,bitnumber); }. TBits& operator&=(const TBits& rhs); { DoAndEqual(rhs); return *this; }. TBits& operator|=(const TBits& rhs); { DoOrEqual(rhs); return *this; }. TBits& operator^=(const TBits& rhs); { DoXorEqual(rhs); return *this; }. TBits& operator<<=(UInt_t rhs); { DoLeftShift(rhs); return *this; }. TBits& operator>>=(UInt_t rhs); { DoRightShift(rhs); return *this; }. TBits operator<<(UInt_t rhs); { return TBits(*this)<<= rhs; }. TBits operator>>(UInt_t rhs); { return TBits(*this)>>= rhs; }. void Set(UInt_t nbits, const Char_t* array); ----- Optimized setters; Each of these will replace the contents of the receiver with the bitvector; in the parameter array. The number of bits is changed to nbits. If nbits; is smaller than fNb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBits.html:10028,Test,TestBitNumber,10028,root/html532/TBits.html,https://root.cern,https://root.cern/root/html532/TBits.html,4,['Test'],['TestBitNumber']
Testability," SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation. { fGenerateBinned = binned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. string GetSamplingDistName(void); { return fSamplingDistName; }. void SetMaxToys(Double_t t); This option forces a maximum number of total toys. { fMaxToys = t; }. void SetToysLeftTail(Double_t toys, Double_t threshold). void SetToysRightTail(Double_t toys, Double_t threshold). void SetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold). void SetImportanceDensity(RooAbsPdf* p); for importance sampling, specifies the pdf to sample from. void SetImporta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSampler.html:8639,test,testStatistic,8639,root/html530/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html,1,['test'],['testStatistic']
Testability," SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation. { fGenerateBinned = binned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. string GetSamplingDistName(void); { return fSamplingDistName; }. void SetMaxToys(Double_t t); This option forces a maximum number of total toys. { fMaxToys = t; }. void SetToysLeftTail(Double_t toys, Double_t threshold). void SetToysRightTail(Double_t toys, Double_t threshold). void SetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold). void SetImportanceDensity(RooAbsPdf* p); for importance sampling, specifies the pdf to sample from. { fImportanceDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSampler.html:7101,test,testStatistic,7101,root/html528/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSampler.html,1,['test'],['testStatistic']
Testability," Ssiz_tTString::ResizeIncrement(Ssiz_t ri = 16); virtual voidTGString::SetString(const char* s); virtual voidShowMembers(TMemberInspector&); virtual Int_tTString::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TSubStringTString::Strip(TString::EStripType s = kTrailing, char c = ' ') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static TStringTString::UItoa(UInt_t value, Int_t base); static TStringTString::ULLtoa(ULong64_t value, Int_t base); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGHotString.html:8170,Assert,AssertElement,8170,root/html534/TGHotString.html,https://root.cern,https://root.cern/root/html534/TGHotString.html,1,['Assert'],['AssertElement']
Testability," Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ***********************************",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1084720,Test,Test,1084720,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Test'],['Test']
Testability," Storage Representation;  Matrix and Vector classesClasses representing Matrices and Vectors of arbitrary type and dimension ;  Unuran;  VecOps;  ▼Monte CarloThe Monte Carlo related packages ;  EGParticle Data Group interface ;  Pythia6The Pythia6 interface ;  Pythia8The Pythia8 interface ;  VMCVirtual Monte Carlo ;  ▼PROOFClasses defining the Parallel ROOT Facility, PROOF, a framework for parallel analysis of ROOT TTrees ;  PROOF kernel LibrariesThe PROOF kernel libraries (libProof, libProofPlayer, libProofDraw) contain the classes defining the kernel of the PROOF facility, i.e ;  PROOF benchmark utilitiesSet of utilities to benchmark a PROOF facility ;  XProofD client LibraryThe XProofD client library, libProofx, contain the classes providing the client to interact with the XRootD-based xproofd daemon ;  TMVAThe Multi Variate Analysis package ;  ▼RoofitRooFit toolkit classes ;  RoofitcoreCore RooFit classes ;  ►RoostatsRooStats toolkit classes ;  HistFactoryFactory classes to create RooFit workspaces from histograms ;  DataFrameROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface ;  Tree LibraryTo store large quantities of same-class objects, ROOT provides the TTree and TNtuple classes ;  ▼TutorialsA collection of macros helping to learn ROOT by example ;  Tutorials specific to Mac/CocoaVarious examples showing graphics done with the Mac graphics system Cocoa. These examples run only on Mac/Os ;  Containers tutorialsExamples showing the ""containers' classes"" usage. ;  Data Frame tutorialsThese examples show the functionalities of RDataFrame: ROOT's declarative analysis interface ;  Event display tutorialsExamples showing the ""Event display classes"" usage. ;  Fast Fourier Transforms tutorialsExample showing the Fast Fourier Transforms interface in ROOT ;  Fit TutorialsThese tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code ;  FITS files interface tutorialsExamples showi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/modules.html:8351,benchmark,benchmark,8351,doc/v616/modules.html,https://root.cern,https://root.cern/doc/v616/modules.html,2,['benchmark'],['benchmark']
Testability," Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of a class with diverse data members.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; The Event class is added to the dictionary by the rootcling utility. This is the rootcling statement in the $ROOTSYS/test/Makefile:; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; The EventDict.cxx file contains the automatically generated Streamerfor Event:; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; When writing an Event object, TClass::WriteBuffer is called. WriteBuffer writes the current version number of the Event class, and its contents into the buffer R__b. The Streamercalls TClass::ReadBuffer when reading an Event object. The ReadBuffer method reads the information from buffer R__b into the Event object.; 11.3.2 Transient Data Members (//!); To prevent a data member from being written to the file, insert a “!” as the first character after the comment marks. It tells ROOT not to save that data member in a root file when saving the class. For example, in this version of Event, the fPt and fTransient data members are not persisten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:468345,test,test,468345,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability," TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile); virtual~TApplicationServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseDirectory(const char* dirname); Int_tBrowseFile(const char* fname); Int_tBrowseKey(const char* keyname); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:582,log,logfile,582,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,7,['log'],['logfile']
Testability," TCandle::fDrawPointsY[kNMAXPOINTS]. protected . y-coord for every outlier, .. ; Definition at line 75 of file TCandle.h. ◆ fHistoPointsX. Double_t TCandle::fHistoPointsX[kNMAXPOINTS]. protected . x-coord for the polyline of the histo ; Definition at line 78 of file TCandle.h. ◆ fHistoPointsY. Double_t TCandle::fHistoPointsY[kNMAXPOINTS]. protected . y-coord for the polyline of the histo ; Definition at line 79 of file TCandle.h. ◆ fHistoWidth. Double_t TCandle::fHistoWidth. protected . The histo width (the height of the max bin) ; Definition at line 61 of file TCandle.h. ◆ fIsCalculated. bool TCandle::fIsCalculated. protected . Definition at line 55 of file TCandle.h. ◆ fIsRaw. bool TCandle::fIsRaw. protected . 0: for TH1 projection, 1: using raw data ; Definition at line 54 of file TCandle.h. ◆ fLogX. int TCandle::fLogX. protected . make the candle appear logx-like ; Definition at line 84 of file TCandle.h. ◆ fLogY. int TCandle::fLogY. protected . make the candle appear logy-like ; Definition at line 85 of file TCandle.h. ◆ fLogZ. int TCandle::fLogZ. protected . make the candle appear logz-like ; Definition at line 86 of file TCandle.h. ◆ fMean. Double_t TCandle::fMean. protected . Position of the mean. ; Definition at line 63 of file TCandle.h. ◆ fMedian. Double_t TCandle::fMedian. protected . Position of the median. ; Definition at line 64 of file TCandle.h. ◆ fMedianErr. Double_t TCandle::fMedianErr. protected . The size of the notch. ; Definition at line 65 of file TCandle.h. ◆ fNDatapoints. Long64_t TCandle::fNDatapoints. protected . Number of Datapoints within this candle. ; Definition at line 72 of file TCandle.h. ◆ fNDrawPoints. Long64_t TCandle::fNDrawPoints. protected . max number of outliers or other point to be shown ; Definition at line 76 of file TCandle.h. ◆ fNHistoPoints. int TCandle::fNHistoPoints. protected . Definition at line 80 of file TCandle.h. ◆ fOption. CandleOption TCandle::fOption. protected . Setting the style of the candle. ; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCandle.html:22305,log,logy-like,22305,doc/master/classTCandle.html,https://root.cern,https://root.cern/doc/master/classTCandle.html,1,['log'],['logy-like']
Testability," TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); Int_tCopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:19753,assert,assert,19753,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,3,['assert'],['assert']
Testability," TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofSuperMaster.html:20088,log,loglevel,20088,root/html528/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html,1,['log'],['loglevel']
Testability," TClass*IsA() const; boolQWidget::isActiveWindow() const; boolQWidget::isAncestorOf(const QWidget* child) const; boolIsDoubleBuffered() const; boolQWidget::isEnabled() const; boolQWidget::isEnabledTo(QWidget*) const; boolQWidget::isEnabledToTLW() const; boolQWidget::isFullScreen() const; boolQWidget::isHidden() const; boolQWidget::isLeftToRight() const; boolQWidget::isMaximized() const; boolQWidget::isMinimized() const; boolQWidget::isModal() const; boolQWidget::isRightToLeft() const; Bool_tIsSignalEventEnabled(UInt_t f) const; boolQWidget::isTopLevel() const; boolQWidget::isVisible() const; boolQWidget::isVisibleTo(QWidget*) const; boolQObject::isWidgetType() const; boolQWidget::isWindow() const; boolQWidget::isWindowModified() const; static QWidget*QWidget::keyboardGrabber(); voidQObject::killTimer(int id); QLayout*QWidget::layout() const; Qt::LayoutDirectionQWidget::layoutDirection() const; QLocaleQWidget::locale() const; intQPaintDevice::logicalDpiX() const; intQPaintDevice::logicalDpiY() const; voidQWidget::lower(); QPointQWidget::mapFrom(QWidget*, const QPoint&) const; QPointQWidget::mapFromGlobal(const QPoint&) const; QPointQWidget::mapFromParent(const QPoint&) const; QPointQWidget::mapTo(QWidget*, const QPoint&) const; QPointQWidget::mapToGlobal(const QPoint&) const; QPointQWidget::mapToParent(const QPoint&) const; QRegionQWidget::mask() const; intQWidget::maximumHeight() const; QSizeQWidget::maximumSize() const; intQWidget::maximumWidth() const; virtual const QMetaObject*metaObject() const; intQWidget::minimumHeight() const; QSizeQWidget::minimumSize() const; virtual QSizeminimumSizeHint() const; intQWidget::minimumWidth() const; static QWidget*QWidget::mouseGrabber(); voidQWidget::move(const QPoint&); voidQWidget::move(int x, int y); voidQObject::moveToThread(QThread* thread); QWidget*QWidget::nativeParentWidget() const; QWidget*QWidget::nextInFocusChain() const; QRectQWidget::normalGeometry() const; intQPaintDevice::numColors() const; QStringQObject::obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:9042,log,logicalDpiY,9042,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,4,['log'],['logicalDpiY']
Testability," TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; ; // Create a pointer to an Event object; Event *event = new Event();; ; // Create two branches, split one.; t4.Branch(""event_split"", &event,16000,99);; t4.Branch(""event_not_split"", &event,16000,0);; ; // a local variable for the event type; char etype[20];; ; // Fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; ; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; ; // fill the matrix; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree4_8C.html:1840,test,test,1840,doc/master/tree4_8C.html,https://root.cern,https://root.cern/doc/master/tree4_8C.html,1,['test'],['test']
Testability," TEveArrow(Float_t xVec = 0, Float_t yVec = 0, Float_t zVec = 1, Float_t xOrg = 0, Float_t yOrg = 0, Float_t zOrg = 0); virtual~TEveArrow(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElement::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveArrow.html:1353,Assert,AssertBBox,1353,root/html532/TEveArrow.html,https://root.cern,https://root.cern/root/html532/TEveArrow.html,2,['Assert'],['AssertBBox']
Testability," TEveGeoPolyShape(); virtual~TEveGeoPolyShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoBBox::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoBBox::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoBBox::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(const Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTGeoBBox::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoPolyShape.html:861,test,testNo,861,root/html534/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html534/TEveGeoPolyShape.html,2,['test'],['testNo']
Testability," TEveGeoPolyShape(); virtual~TEveGeoPolyShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoBBox::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoBBox::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromInside(const Double_t* point, const Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveGeoPolyShape.html:821,test,testNo,821,root/html530/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html530/TEveGeoPolyShape.html,1,['test'],['testNo']
Testability," TEveGeoPolyShape(); virtual~TEveGeoPolyShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoBBox::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoBBox::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoPolyShape.html:821,test,testNo,821,root/html532/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html532/TEveGeoPolyShape.html,2,['test'],['testNo']
Testability," TEveProjectionAxes(TEveProjectionManager* m, Bool_t useColorSet = kTRUE); virtual~TEveProjectionAxes(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElement::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveProjectionAxes.html:1539,Assert,AssertBBox,1539,root/html532/TEveProjectionAxes.html,https://root.cern,https://root.cern/root/html532/TEveProjectionAxes.html,2,['Assert'],['AssertBBox']
Testability," TEveText(const char* txt = """"); virtual~TEveText(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElement::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveText.html:1338,Assert,AssertBBox,1338,root/html532/TEveText.html,https://root.cern,https://root.cern/root/html532/TEveText.html,2,['Assert'],['AssertBBox']
Testability," TF1::kTemplVec@ kTemplVecVectorized free functions or TemplScalar functors evaluating on vectorized parameters,...Definition TF1.h:258; TF1::kInterpreted@ kInterpretedInterpreted functions constructed by name,.Definition TF1.h:257; TF1::SetSavedPointvirtual void SetSavedPoint(Int_t point, Double_t value)Restore value of function saved at point.Definition TF1.cxx:3542; TF1::FixParametervirtual void FixParameter(Int_t ipar, Double_t value)Fix the value of a parameter for a fit operation The specified value will be used in the fit and the ...Definition TF1.cxx:1557; TF1::IsInsidevirtual Bool_t IsInside(const Double_t *x) constreturn kTRUE if the point is inside the function rangeDefinition TF1.h:626; TF1::GetNpxvirtual Int_t GetNpx() constDefinition TF1.h:518; TF1::fXmaxDouble_t fXmaxUpper bounds for the range.Definition TF1.h:264; TF1::GetMaximumXvirtual Double_t GetMaximumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the maximum value of the function.Definition TF1.cxx:1655; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TF1::GetXminvirtual Double_t GetXmin() constDefinition TF1.h:580; TF1::AddToGlobalListvirtual Bool_t AddToGlobalList(Bool_t on=kTRUE)Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the fu...Definition TF1.cxx:847; TF1::GetLinearPartvirtual const TObject * GetLinearPart(Int_t i) constDefinition TF1.h:493; TF1::SetVectorizedvirtual void SetVectorized(Bool_t vectorized)Definition TF1.h:715; TF1::IntegralOneDimvirtual Double_t IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)Return Integral of function between a and b using the given parameter values and relative and absolut...Definition TF1.cxx:2621; TF1::TF1TF1(const char *name, Func f, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault)Definition TF1.h:397; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:68094,log,logx,68094,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['log'],['logx']
Testability," TF1_EvalWrapper::fXDouble_t fX[1]Definition TF1.cxx:231; TF1_EvalWrapper::EvalFirstMomDouble_t EvalFirstMom(Double_t x)Definition TF1.cxx:218; TF1_EvalWrapper::fFuncTF1 * fFuncDefinition TF1.cxx:230; TF1_EvalWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition TF1.cxx:209; TF1_EvalWrapper::EvalNMomDouble_t EvalNMom(Double_t x) constDefinition TF1.cxx:224; TF1_EvalWrapper::TF1_EvalWrapperTF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n=1, Double_t x0=0)Definition TF1.cxx:190; TF1_EvalWrapper::fAbsValBool_t fAbsValDefinition TF1.cxx:233; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:173876,log,logx,173876,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['logx']
Testability," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TF2GL.html:830,log,logx,830,root/html530/TF2GL.html,https://root.cern,https://root.cern/root/html530/TF2GL.html,9,['log'],"['logx', 'logy', 'logz']"
Testability," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF2GL.html:830,log,logx,830,root/html534/TF2GL.html,https://root.cern,https://root.cern/root/html534/TF2GL.html,6,['log'],"['logx', 'logy', 'logz']"
Testability," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF2GL.html:763,log,logx,763,root/html528/TF2GL.html,https://root.cern,https://root.cern/root/html528/TF2GL.html,3,['log'],"['logx', 'logy', 'logz']"
Testability," TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.012591 1.0260 [ -3.3377 5.7307 ]; : var2: 0.0016174 1.0380 [ -4.5569 5.7307 ]; : fvalue: 165.93 84.643 [ 2.0973 391.01 ]; : -----------------------------------------------------------; : Start of deep neural network training on CPU using MT, nthreads = 1; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.012591 1.0260 [ -3.3377 5.7307 ]; : var2: 0.0016174 1.0380 [ -4.5569 5.7307 ]; : fvalue: 165.93 84.643 [ 2.0973 391.01 ]; : -----------------------------------------------------------; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 2 ) Batch size = 50 Loss function = R; Layer 0 DENSE Layer: ( Input = 2 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 50 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 50 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 50 , Width = 1 ) Output = ( 1 , 50 , 1 ) Activation Function = Identity; : Using 800 events for training and 200 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 33494.1; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 34747.6 33079.7 0.0192196 0.00176099 45822.6 0; : 2 Minimum Test error found - save the configuration ; : 2 | 34222.2 32417.1 0.0195047 0.0017702 45109.9 0; : 3 Minimum Test error found - save the configuration ; : 3 | 33496 31618.4 0.019",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:10766,test,testing,10766,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['test'],['testing']
Testability," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLParametricEquationGL.html:980,log,logx,980,root/html530/TGLParametricEquationGL.html,https://root.cern,https://root.cern/root/html530/TGLParametricEquationGL.html,9,['log'],"['logx', 'logy', 'logz']"
Testability," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLParametricEquationGL.html:980,log,logx,980,root/html534/TGLParametricEquationGL.html,https://root.cern,https://root.cern/root/html534/TGLParametricEquationGL.html,6,['log'],"['logx', 'logy', 'logz']"
Testability," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLParametricEquationGL.html:913,log,logx,913,root/html528/TGLParametricEquationGL.html,https://root.cern,https://root.cern/root/html528/TGLParametricEquationGL.html,3,['log'],"['logx', 'logy', 'logz']"
Testability," TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStereoEyeOffsetFac!; Float_tfStereoFrustumAsymFac!; Float_tfStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectfViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLViewer.html:23432,log,logicals,23432,root/html602/TGLViewer.html,https://root.cern,https://root.cern/root/html602/TGLViewer.html,2,['log'],['logicals']
Testability, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:2091,log,logid,2091,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,12,['log'],['logid']
Testability," TGLScenePad(TVirtualPad* pad); virtual~TGLScenePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScenePad.html:670,log,log,670,root/html528/TGLScenePad.html,https://root.cern,https://root.cern/root/html528/TGLScenePad.html,1,['log'],['log']
Testability," TGLScenePad(TVirtualPad* pad); virtual~TGLScenePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log, const Float_t* histColor = 0); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLScenePad.html:670,log,log,670,root/html530/TGLScenePad.html,https://root.cern,https://root.cern/root/html530/TGLScenePad.html,5,['log'],['log']
Testability," TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:23899,log,log,23899,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,2,['log'],['log']
Testability," TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23539,log,log,23539,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,4,['log'],['log']
Testability," TGPicture*TGMainFrame::SetIconPixmap(const char* iconName); voidTGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:16547,Test,TestBit,16547,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," TGSlider::SetScale ; (; Int_t ; scale). inlinevirtual . Definition at line 74 of file TGSlider.h. ◆ SetState(). void TGSlider::SetState ; (; Bool_t ; state). virtual . Set state of widget. If kTRUE=enabled, kFALSE=disabled. ; Definition at line 160 of file TGSlider.cxx. ◆ Streamer(). void TGSlider::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame.; Reimplemented in TGVSlider. ◆ StreamerNVirtual(). void TGSlider::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 88 of file TGSlider.h. Member Data Documentation. ◆ fDisabledPic. const TGPicture* TGSlider::fDisabledPic. protected . picture to draw disabled slider ; Definition at line 51 of file TGSlider.h. ◆ fDragging. Bool_t TGSlider::fDragging. protected . true if in dragging mode ; Definition at line 49 of file TGSlider.h. ◆ fPos. Int_t TGSlider::fPos. protected . logical position between fVmin and fVmax ; Definition at line 43 of file TGSlider.h. ◆ fRelPos. Int_t TGSlider::fRelPos. protected . slider position in pixel coordinates ; Definition at line 44 of file TGSlider.h. ◆ fScale. Int_t TGSlider::fScale. protected . tick mark scale ; Definition at line 48 of file TGSlider.h. ◆ fSliderPic. const TGPicture* TGSlider::fSliderPic. protected . picture to draw slider ; Definition at line 50 of file TGSlider.h. ◆ fType. Int_t TGSlider::fType. protected . slider type bits ; Definition at line 47 of file TGSlider.h. ◆ fVmax. Int_t TGSlider::fVmax. protected . logical upper limit of slider ; Definition at line 46 of file TGSlider.h. ◆ fVmin. Int_t TGSlider::fVmin. protected . logical lower limit of slider ; Definition at line 45 of file TGSlider.h. Libraries for TGSlider:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGSlider.h; gui/gui/src/TGSlider.cxx. TGSlider. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSlider.html:35546,log,logical,35546,doc/master/classTGSlider.html,https://root.cern,https://root.cern/doc/master/classTGSlider.html,2,['log'],['logical']
Testability," TGTextButton*fGrepButtongrep button; TGTextEntry*fGrepTexttext to grep for in the logs; TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23472,log,log,23472,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,4,['log'],['log']
Testability," TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressLog.h 32203 2010-02-03 18:47:34Z ganis $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23961,log,logs,23961,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,6,['log'],"['log', 'logs']"
Testability," TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressLog.h 32203 2010-02-03 18:47:34Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressLog.html:24114,log,logs,24114,root/html530/TProofProgressLog.html,https://root.cern,https://root.cern/root/html530/TProofProgressLog.html,6,['log'],"['log', 'logs']"
Testability," TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressLog.h 32203 2010-02-03 18:47:34Z ganis $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressLog.html:24114,log,logs,24114,root/html532/TProofProgressLog.html,https://root.cern,https://root.cern/root/html532/TProofProgressLog.html,13,"['Log', 'log']","['LogMessage', 'log', 'logs']"
Testability," TGaxis(8,-0.8,8,0.8,0,9000,50510,""+L"");; axis7->SetName(""axis7"");; axis7->SetLabelOffset(0.01);; axis7->Draw();. // one can make axis top->bottom. However because of a problem,; // the two x values should not be equal; TGaxis *axis8 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis8->SetName(""axis8"");; axis8->Draw();; }. The second axis example. The second example shows the use of the second form of the constructor, with axis ticks position determined by a function TF1:; void gaxis3a(); {; gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",2,0,10,2,-2,2);; h2->Draw();; TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",0,800);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505);; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }. An axis example with time display. // strip chart example; void seism() {. TStopwatch sw; sw.Start();; //set time offset; TDatime dtime;; gStyle->SetTimeOffset(dtime.Convert());; TCanvas *c1 = new TCanvas(""c1"",""Time on axis"",10,10,1000,500);; c1->SetFillColor(42);; c1->SetFrameFillColor(33);; c1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:351657,log,logarithmic,351657,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['log'],['logarithmic']
Testability," TGeoArb8(); TGeoArb8(Double_t dz, Double_t* vertices = 0); TGeoArb8(const char* name, Double_t dz, Double_t* vertices = 0); virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:1801,test,testNo,1801,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,2,['test'],['testNo']
Testability," TGeoArb8(); TGeoArb8(Double_t dz, Double_t* vertices = 0); TGeoArb8(const char* name, Double_t dz, Double_t* vertices = 0); virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoArb8.html:1761,test,testNo,1761,root/html530/TGeoArb8.html,https://root.cern,https://root.cern/root/html530/TGeoArb8.html,1,['test'],['testNo']
Testability," TGeoArb8(); TGeoArb8(Double_t dz, Double_t* vertices = 0); TGeoArb8(const char* name, Double_t dz, Double_t* vertices = 0); virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoArb8.html:1761,test,testNo,1761,root/html532/TGeoArb8.html,https://root.cern,https://root.cern/root/html532/TGeoArb8.html,2,['test'],['testNo']
Testability," TGeoCone(); TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:1331,test,testNo,1331,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,2,['test'],['testNo']
Testability," TGeoCone(); TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCone.html:1291,test,testNo,1291,root/html530/TGeoCone.html,https://root.cern,https://root.cern/root/html530/TGeoCone.html,1,['test'],['testNo']
Testability," TGeoCone(); TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCone.html:1291,test,testNo,1291,root/html532/TGeoCone.html,https://root.cern,https://root.cern/root/html532/TGeoCone.html,2,['test'],['testNo']
Testability," TGeoConeSeg(); TGeoConeSeg(Double_t* params); TGeoConeSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:1440,test,testNo,1440,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,2,['test'],['testNo']
Testability," TGeoConeSeg(); TGeoConeSeg(Double_t* params); TGeoConeSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoConeSeg.html:1411,test,testNo,1411,root/html530/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html,1,['test'],['testNo']
Testability," TGeoConeSeg(); TGeoConeSeg(Double_t* params); TGeoConeSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeSeg.html:1411,test,testNo,1411,root/html532/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html,2,['test'],['testNo']
Testability," TGeoCtub(); TGeoCtub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoTubeSeg::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:1884,test,testNo,1884,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,2,['test'],['testNo']
Testability," TGeoCtub(); TGeoCtub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCtub.html:1732,test,testNo,1732,root/html530/TGeoCtub.html,https://root.cern,https://root.cern/root/html530/TGeoCtub.html,1,['test'],['testNo']
Testability," TGeoCtub(); TGeoCtub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCtub.html:1732,test,testNo,1732,root/html532/TGeoCtub.html,https://root.cern,https://root.cern/root/html532/TGeoCtub.html,2,['test'],['testNo']
Testability," TGeoEltu(); TGeoEltu(Double_t* params); TGeoEltu(const TGeoEltu&); TGeoEltu(Double_t a, Double_t b, Double_t dz); TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:1099,test,testNo,1099,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,2,['test'],['testNo']
Testability," TGeoEltu(); TGeoEltu(Double_t* params); TGeoEltu(const TGeoEltu&); TGeoEltu(Double_t a, Double_t b, Double_t dz); TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoEltu.html:1059,test,testNo,1059,root/html530/TGeoEltu.html,https://root.cern,https://root.cern/root/html530/TGeoEltu.html,1,['test'],['testNo']
Testability," TGeoEltu(); TGeoEltu(Double_t* params); TGeoEltu(const TGeoEltu&); TGeoEltu(Double_t a, Double_t b, Double_t dz); TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoEltu.html:1059,test,testNo,1059,root/html532/TGeoEltu.html,https://root.cern,https://root.cern/root/html532/TGeoEltu.html,2,['test'],['testNo']
Testability," TGeoGtra(); TGeoGtra(const TGeoGtra&); TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoGtra(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:2114,test,testNo,2114,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,2,['test'],['testNo']
Testability," TGeoGtra(); TGeoGtra(const TGeoGtra&); TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoGtra(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGtra.html:2074,test,testNo,2074,root/html530/TGeoGtra.html,https://root.cern,https://root.cern/root/html530/TGeoGtra.html,3,['test'],['testNo']
Testability," TGeoHalfSpace(); TGeoHalfSpace(Double_t* params); TGeoHalfSpace(const TGeoHalfSpace&); TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); virtual~TGeoHalfSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:1157,test,testNo,1157,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,2,['test'],['testNo']
Testability," TGeoHalfSpace(); TGeoHalfSpace(Double_t* params); TGeoHalfSpace(const TGeoHalfSpace&); TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); virtual~TGeoHalfSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHalfSpace.html:1117,test,testNo,1117,root/html530/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html,1,['test'],['testNo']
Testability," TGeoHalfSpace(); TGeoHalfSpace(Double_t* params); TGeoHalfSpace(const TGeoHalfSpace&); TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); virtual~TGeoHalfSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHalfSpace.html:1117,test,testNo,1117,root/html532/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html532/TGeoHalfSpace.html,2,['test'],['testNo']
Testability," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:2079,test,testNo,2079,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,2,['test'],['testNo']
Testability," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHype.html:2039,test,testNo,2039,root/html530/TGeoHype.html,https://root.cern,https://root.cern/root/html530/TGeoHype.html,3,['test'],['testNo']
Testability," TGeoManager.cxx:873; TGeoManager::fgMaxXtruVertstatic Int_t fgMaxXtruVertMaximum number of daughters.Definition TGeoManager.h:54; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current point.Definition TGeoManager.cxx:2782; TGeoManager::GetVisOptionInt_t GetVisOption() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2157; TGeoManager::LockGeometrystatic void LockGeometry()Lock current geometry so that no other geometry can be imported.Definition TGeoManager.cxx:4040; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::fNPNEIdInt_t fNPNEIdDefinition TGeoManager.h:141; TGeoManager::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoManager.cxx:3783; TGeoManager::GetUserPaintVolumeTGeoVolume * GetUserPaintVolume() constDefinition TGeoManager.h:216; TGeoManager::IsActivityEnabledBool_t IsActivityEnabled() constDefinition TGeoManager.h:409; TGeoManager::fgMaxLevelstatic Int_t fgMaxLevelVerbosity level for Info messages (no IO).Definition TGeoManager.h:52; TGeoManager::fNpdgInt_t fNpdgcurrent trackDefinition TGeoManager.h:77; TGeoManager::PrintOverlapsvoid PrintOverlaps() constPrints the current list of overlaps.Definition TGeoManager.cxx:3881; TGeoManager::GetNormalconst Double_t * GetNormal() constDefinition TGeoManager.h:506; TGeoManager::MakeTrd1TGeoVolume * MakeTrd1(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz)Make in one step a volume pointing to a TGeoTrd1 shape with given medium.Definition TGeoManager.cxx:3293; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:68957,test,testNo,68957,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['test'],['testNo']
Testability," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIterator.html:1344,log,logical,1344,root/html528/TGeoIterator.html,https://root.cern,https://root.cern/root/html528/TGeoIterator.html,30,['log'],['logical']
Testability," TGeoNavigatorArray(); TGeoNavigatorArray(TGeoManager* mgr); virtual~TGeoNavigatorArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); TGeoNavigator*AddNavigator(); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t i) const; virtual TObject*TObjArray::Before(const TObject* obj) const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigatorArray.html:1676,Assert,AssertClass,1676,root/html532/TGeoNavigatorArray.html,https://root.cern,https://root.cern/root/html532/TGeoNavigatorArray.html,1,['Assert'],['AssertClass']
Testability," TGeoNavigatorArray(); TGeoNavigatorArray(TGeoManager* mgr); virtual~TGeoNavigatorArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); TGeoNavigator*AddNavigator(); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t i) const; virtual TObject*TObjArray::Before(const TObject* obj) const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigatorArray.html:1671,Assert,AssertClass,1671,root/html534/TGeoNavigatorArray.html,https://root.cern,https://root.cern/root/html534/TGeoNavigatorArray.html,1,['Assert'],['AssertClass']
Testability," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIterator.html:1263,log,logical,1263,root/html528/TGeoIterator.html,https://root.cern,https://root.cern/root/html528/TGeoIterator.html,30,['log'],['logical']
Testability," TGeoPara(); TGeoPara(Double_t* param); TGeoPara(const TGeoPara&); TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); virtual~TGeoPara(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:1350,test,testNo,1350,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,2,['test'],['testNo']
Testability," TGeoPara(); TGeoPara(Double_t* param); TGeoPara(const TGeoPara&); TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); virtual~TGeoPara(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPara.html:1310,test,testNo,1310,root/html530/TGeoPara.html,https://root.cern,https://root.cern/root/html530/TGeoPara.html,1,['test'],['testNo']
Testability," TGeoPara(); TGeoPara(Double_t* param); TGeoPara(const TGeoPara&); TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); virtual~TGeoPara(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:1310,test,testNo,1310,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,2,['test'],['testNo']
Testability," TGeoParaboloid(); TGeoParaboloid(Double_t* params); TGeoParaboloid(const TGeoParaboloid&); TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); virtual~TGeoParaboloid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:1594,test,testNo,1594,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,2,['test'],['testNo']
Testability," TGeoParaboloid(); TGeoParaboloid(Double_t* params); TGeoParaboloid(const TGeoParaboloid&); TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); virtual~TGeoParaboloid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:1554,test,testNo,1554,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,1,['test'],['testNo']
Testability," TGeoParaboloid(); TGeoParaboloid(Double_t* params); TGeoParaboloid(const TGeoParaboloid&); TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); virtual~TGeoParaboloid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoParaboloid.html:1554,test,testNo,1554,root/html532/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html532/TGeoParaboloid.html,2,['test'],['testNo']
Testability," TGeoPcon(); TGeoPcon(Double_t* params); TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); virtual~TGeoPcon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:1170,test,testNo,1170,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,2,['test'],['testNo']
Testability," TGeoPcon(); TGeoPcon(Double_t* params); TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); virtual~TGeoPcon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPcon.html:1130,test,testNo,1130,root/html530/TGeoPcon.html,https://root.cern,https://root.cern/root/html530/TGeoPcon.html,1,['test'],['testNo']
Testability," TGeoPcon(); TGeoPcon(Double_t* params); TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); virtual~TGeoPcon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPcon.html:1130,test,testNo,1130,root/html532/TGeoPcon.html,https://root.cern,https://root.cern/root/html532/TGeoPcon.html,2,['test'],['testNo']
Testability," TGeoPgon(); TGeoPgon(Double_t* params); TGeoPgon(const TGeoPgon&); TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); virtual~TGeoPgon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidCon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:1337,test,testNo,1337,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,2,['test'],['testNo']
Testability," TGeoPgon(); TGeoPgon(Double_t* params); TGeoPgon(const TGeoPgon&); TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); virtual~TGeoPgon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPgon.html:1234,test,testNo,1234,root/html530/TGeoPgon.html,https://root.cern,https://root.cern/root/html530/TGeoPgon.html,1,['test'],['testNo']
Testability," TGeoPgon(); TGeoPgon(Double_t* params); TGeoPgon(const TGeoPgon&); TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); virtual~TGeoPgon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPgon.html:1297,test,testNo,1297,root/html532/TGeoPgon.html,https://root.cern,https://root.cern/root/html532/TGeoPgon.html,2,['test'],['testNo']
Testability," TGeoScaledShape(); TGeoScaledShape(const TGeoScaledShape&); TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); virtual~TGeoScaledShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScaledShape.html:1049,test,testNo,1049,root/html534/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html,2,['test'],['testNo']
Testability," TGeoScaledShape(); TGeoScaledShape(const TGeoScaledShape&); TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); virtual~TGeoScaledShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoScaledShape.html:1009,test,testNo,1009,root/html530/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html,1,['test'],['testNo']
Testability," TGeoScaledShape(); TGeoScaledShape(const TGeoScaledShape&); TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); virtual~TGeoScaledShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScaledShape.html:1009,test,testNo,1009,root/html532/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html532/TGeoScaledShape.html,2,['test'],['testNo']
Testability," TGeoShape::CreateThreadDatavirtual void CreateThreadData(Int_t)Definition TGeoShape.h:67; TGeoShape::IsValidBool_t IsValid() constDefinition TGeoShape.h:143; TGeoShape::GetAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::IsSameWithinTolerancestatic Bool_t IsSameWithinTolerance(Double_t a, Double_t b)Check if two numbers differ with less than a tolerance.Definition TGeoShape.cxx:338; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::IsValidBoxvirtual Bool_t IsValidBox() const =0; TGeoShape::GetByteCountvirtual Int_t GetByteCount() const =0; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoShape::ComputeBBoxvirtual void ComputeBBox()=0; TGeoShape::Capacityvirtual Double_t Capacity() const =0; TGeoShape::kGeoSavePrimitive@ kGeoSavePrimitiveDefinition TGeoShape.h:64; TGeoShape::kGeoBad@ kGeoBadDefinition TGeoShape.h:33; TGeoShape::GetMakeRuntimeShapevirtual TGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const =0; TGeoShape::IsAssemblyvirtual Bool_t IsAssembly() constDefinition TGeoShape.h:129; TGeoShape::TestShapeBitBool_t TestShapeBit(UInt_t f) constDefinition TGeoShape.h:167; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeAssembly::MakeAssemblyFromVolumestatic TGeoVolumeAssembly * MakeAssemblyFromVolum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:132302,test,testNo,132302,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['test'],['testNo']
Testability," TGeoShapeAssembly(); TGeoShapeAssembly(TGeoVolumeAssembly* vol); TGeoShapeAssembly(const TGeoShapeAssembly&); virtual~TGeoShapeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:997,test,testNo,997,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,2,['test'],['testNo']
Testability," TGeoShapeAssembly(); TGeoShapeAssembly(TGeoVolumeAssembly* vol); TGeoShapeAssembly(const TGeoShapeAssembly&); virtual~TGeoShapeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoShapeAssembly.html:957,test,testNo,957,root/html530/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html,1,['test'],['testNo']
Testability," TGeoShapeAssembly(); TGeoShapeAssembly(TGeoVolumeAssembly* vol); TGeoShapeAssembly(const TGeoShapeAssembly&); virtual~TGeoShapeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShapeAssembly.html:957,test,testNo,957,root/html532/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html532/TGeoShapeAssembly.html,2,['test'],['testNo']
Testability," TGeoSphere(); TGeoSphere(const TGeoSphere&); TGeoSphere(Double_t* param, Int_t nparam = 6); TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); virtual~TGeoSphere(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:1380,test,testNo,1380,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,2,['test'],['testNo']
Testability," TGeoSphere(); TGeoSphere(const TGeoSphere&); TGeoSphere(Double_t* param, Int_t nparam = 6); TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); virtual~TGeoSphere(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoSphere.html:1340,test,testNo,1340,root/html530/TGeoSphere.html,https://root.cern,https://root.cern/root/html530/TGeoSphere.html,1,['test'],['testNo']
Testability," TGeoSphere(); TGeoSphere(const TGeoSphere&); TGeoSphere(Double_t* param, Int_t nparam = 6); TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); virtual~TGeoSphere(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoSphere.html:1340,test,testNo,1340,root/html532/TGeoSphere.html,https://root.cern,https://root.cern/root/html532/TGeoSphere.html,2,['test'],['testNo']
Testability," TGeoTorus(); TGeoTorus(Double_t* params); TGeoTorus(const TGeoTorus&); TGeoTorus(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoTorus(const char* name, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); virtual~TGeoTorus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:1205,test,testNo,1205,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,2,['test'],['testNo']
Testability," TGeoTorus(); TGeoTorus(Double_t* params); TGeoTorus(const TGeoTorus&); TGeoTorus(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoTorus(const char* name, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); virtual~TGeoTorus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTorus.html:1165,test,testNo,1165,root/html530/TGeoTorus.html,https://root.cern,https://root.cern/root/html530/TGeoTorus.html,1,['test'],['testNo']
Testability," TGeoTorus(); TGeoTorus(Double_t* params); TGeoTorus(const TGeoTorus&); TGeoTorus(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoTorus(const char* name, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); virtual~TGeoTorus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTorus.html:1165,test,testNo,1165,root/html532/TGeoTorus.html,https://root.cern,https://root.cern/root/html532/TGeoTorus.html,2,['test'],['testNo']
Testability," TGeoTrap(); TGeoTrap(const TGeoTrap&); TGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoTrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:2135,test,testNo,2135,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,2,['test'],['testNo']
Testability," TGeoTrap(); TGeoTrap(const TGeoTrap&); TGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoTrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Bro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrap.html:2095,test,testNo,2095,root/html530/TGeoTrap.html,https://root.cern,https://root.cern/root/html530/TGeoTrap.html,3,['test'],['testNo']
Testability," TGeoTrd1(); TGeoTrd1(Double_t* params); TGeoTrd1(const TGeoTrd1&); TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); virtual~TGeoTrd1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1.html:1170,test,testNo,1170,root/html534/TGeoTrd1.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html,2,['test'],['testNo']
Testability," TGeoTrd1(); TGeoTrd1(Double_t* params); TGeoTrd1(const TGeoTrd1&); TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); virtual~TGeoTrd1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd1.html:1130,test,testNo,1130,root/html530/TGeoTrd1.html,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html,1,['test'],['testNo']
Testability," TGeoTrd1(); TGeoTrd1(Double_t* params); TGeoTrd1(const TGeoTrd1&); TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); virtual~TGeoTrd1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd1.html:1130,test,testNo,1130,root/html532/TGeoTrd1.html,https://root.cern,https://root.cern/root/html532/TGeoTrd1.html,2,['test'],['testNo']
Testability," TGeoTrd2(); TGeoTrd2(Double_t* params); TGeoTrd2(const TGeoTrd2&); TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); virtual~TGeoTrd2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd2.html:1211,test,testNo,1211,root/html534/TGeoTrd2.html,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html,2,['test'],['testNo']
Testability," TGeoTrd2(); TGeoTrd2(Double_t* params); TGeoTrd2(const TGeoTrd2&); TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); virtual~TGeoTrd2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd2.html:1171,test,testNo,1171,root/html530/TGeoTrd2.html,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html,1,['test'],['testNo']
Testability," TGeoTrd2(); TGeoTrd2(Double_t* params); TGeoTrd2(const TGeoTrd2&); TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); virtual~TGeoTrd2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd2.html:1171,test,testNo,1171,root/html532/TGeoTrd2.html,https://root.cern,https://root.cern/root/html532/TGeoTrd2.html,2,['test'],['testNo']
Testability," TGeoTube(); TGeoTube(Double_t* params); TGeoTube(const TGeoTube&); TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); virtual~TGeoTube(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:1731,test,testNo,1731,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,2,['test'],['testNo']
Testability," TGeoTube(); TGeoTube(Double_t* params); TGeoTube(const TGeoTube&); TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); virtual~TGeoTube(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTube.html:1581,test,testNo,1581,root/html530/TGeoTube.html,https://root.cern,https://root.cern/root/html530/TGeoTube.html,1,['test'],['testNo']
Testability," TGeoTube(); TGeoTube(Double_t* params); TGeoTube(const TGeoTube&); TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); virtual~TGeoTube(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTube.html:1581,test,testNo,1581,root/html532/TGeoTube.html,https://root.cern,https://root.cern/root/html532/TGeoTube.html,2,['test'],['testNo']
Testability," TGeoTubeSeg(); TGeoTubeSeg(Double_t* params); TGeoTubeSeg(const TGeoTubeSeg&); TGeoTubeSeg(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); virtual~TGeoTubeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:1840,test,testNo,1840,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,2,['test'],['testNo']
Testability," TGeoTubeSeg(); TGeoTubeSeg(Double_t* params); TGeoTubeSeg(const TGeoTubeSeg&); TGeoTubeSeg(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); virtual~TGeoTubeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTubeSeg.html:1701,test,testNo,1701,root/html530/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html,1,['test'],['testNo']
Testability," TGeoTubeSeg(); TGeoTubeSeg(Double_t* params); TGeoTubeSeg(const TGeoTubeSeg&); TGeoTubeSeg(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); virtual~TGeoTubeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTubeSeg.html:1701,test,testNo,1701,root/html532/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoTubeSeg.html,2,['test'],['testNo']
Testability," TGraph2D and TMultiGraph for fitting a collection of Graphs with the same function.; 5.1.1 The TH1::Fit Method; To fit a histogram programmatically, you can use the TH1::Fit method. Here is the signatures of TH1::Fit and an explanation of the parameters:; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax). function a pointer to the fitted function (the fit model) object. One can also use the function name. This name may be one of ROOT pre-defined function names or a user-defined function. See the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is specified.; “+” Add this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept); “B”Use this optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:164769,log,log,164769,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['log'],['log']
Testability," TGridJobStatusList(); virtual~TGridJobStatusList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGridJobStatusList.html:1333,Assert,AssertClass,1333,root/html534/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html534/TGridJobStatusList.html,1,['Assert'],['AssertClass']
Testability," TGridJobStatusList(); virtual~TGridJobStatusList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGridJobStatusList.html:1333,Assert,AssertClass,1333,root/html532/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html532/TGridJobStatusList.html,1,['Assert'],['AssertClass']
Testability," TGridResult(); virtual~TGridResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGridResult.html:1396,Assert,AssertClass,1396,root/html532/TGridResult.html,https://root.cern,https://root.cern/root/html532/TGridResult.html,2,['Assert'],['AssertClass']
Testability," TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TF1::GetLinearPart(Int_t i) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTF1::GetNdim() const; virtual Int_tTF1::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTF1::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tTF1::GetParameter(Int_t ipar) const; virtual Double_tTF1::GetParameter(const TString& name) const; virtual Double_t*TF1::GetParameters() const; virtual voidTF1::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual const Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t ipar, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF12.html:4545,log,logx,4545,root/html604/TF12.html,https://root.cern,https://root.cern/root/html604/TF12.html,2,['log'],['logx']
Testability," TH1.cxx. ◆ AndersonDarlingTest() [2/2]. Double_t TH1::AndersonDarlingTest ; (; const TH1 * ; h2, . Option_t * ; option = """" . ); const. virtual . Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; The AD 2 sample test formula are derived from the paper F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class It is the same formula ( (6) in the paper), and also shown in this preprint; Binned data are considered as un-binned data with identical observation happening in the bin center.; Parameters. [in]h2Pointer to 1D histogram ; [in]optionis a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms . Definition at line 8062 of file TH1.cxx. ◆ AutoP2FindLimits(). Int_t TH1::AutoP2FindLimits ; (; Double_t ; xmi, . Double_t ; xma . ). protectedvirtual . Buffer-based estimate of the histogram range using the power of 2 algorithm. ; Used by the autobin power of 2 algorithm.; Works on arguments (min and max from fBuffer) and internal inputs: fXmin, fXmax, NBinsX (from fXaxis), ... Result save internally in fXaxis.; Overloaded by TH2 and TH3.; Return -1 if internal inputs are inconsistent, 0 otherwise. ; Definition at line 1343 of file TH1.cxx. ◆ AutoP2GetBins(). Int_t TH1::AutoP2GetBins ; (; Int_t ; n). inlinestaticprotected . Auxiliary function to get the next power of 2 integer value larger then n. ; Used by the autobin power of 2 algorithm ; Definition at line 1321 of file TH1.cxx. ◆ AutoP2GetPower2(). Double_t TH1::AutoP2GetPower2 ; (; Double_t ; x, . Bool_t ; next = kTRUE . ). inlinestaticprotected . Auxiliary ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:81050,test,test,81050,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability," TH1F at 1882; key: h6 points to an object of class: TH1F at 2240; key: h7 points to an object of class: TH1F at 2582; key: h8 points to an object of class: TH1F at 2937; key: h9 points to an object of class: TH1F at 3293; key: h10 points to an object of class: TH1F at 3639; key: h11 points to an object of class: TH1F at 3986; key: h12 points to an object of class: TH1F at 4339; key: h13 points to an object of class: TH1F at 4694; key: h14 points to an object of class: TH1F at 5038; In addition to the list of keys, TFile also keeps two other lists: TFile::fFree is a TList of free blocks used to recycle freed up space in the file. ROOT tries to find the best free block. If a free block matches the size of the new object to be stored, the object is written in the free block and this free block is deleted from the list. If not, the first free block bigger than the object is used. TFile::fListHead contains a sorted list (TSortedList) of objects in memory. The diagram below illustrates the logical view of the TFile and TKey. ROOT File/Directory/Key description. 11.2.1 Viewing the Logical File Contents; TFile is a descendent of TDirectory, which means it behaves like a TDirectory. We can list the contents, print the name, and create subdirectories. In a ROOT session, you are always in a directory and the directory you are in is called the current directory and is stored in the global variable gDirectory. Let us look at a more detailed example of a ROOT file and its role as the current directory. First, we create a ROOT file by executing a sample script.; root[] .x $ROOTSYS/tutorials/hsimple.C; Now you should have hsimple.root in your directory. The file was closed by the script so we have to open it again to work with it. We open the file with the intent to update it, and list its contents.; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:445038,log,logical,445038,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['log'],['logical']
Testability," TH1Merger ) ; Definition at line 5164 of file TH1.cxx. ◆ IsHighlight(). virtual Bool_t TH1::IsHighlight ; (; ); const. inlinevirtual . Definition at line 338 of file TH1.h. ◆ KolmogorovTest(). Double_t TH1::KolmogorovTest ; (; const TH1 * ; h2, . Option_t * ; option = """" . ); const. virtual . Statistical test of compatibility in shape between this histogram and h2, using Kolmogorov test. ; Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data and not for binned data as in the case of the histogram (see NOTE 3 below). So, before using this method blindly, read the NOTE 3.; Default: Ignore under- and overflow bins in comparison; Parameters. [in]h2histogram ; [in]optionis a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure: make pseudoexperiments based on random values from the parent distribution, compare the KS distance of the pseudoexperiment to the parent distribution, and count all the KS values above the value obtained from the original data to Monte Carlo distribution. The number of pseudo-experiments nEXPT is by default 1000, and it can be changed by specifying the option as ""X=number"", for example ""X=10000"" for 10000 toys. The function returns the probability. (thanks to Ben Kilminster to submit this procedure). Note that this option ""X"" is much slower. The returned function value is the probability of test (much less than one means NOT compatible); Code adapted by Rene Brun from original HBOOK routine HDIFF; NOTE1 A good description of the Kolmogorov test can be seen at: http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; NOTE2 see also alternative function TH1::Chi2Test The Kolmogorov test is assumed to give better res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:183593,test,test,183593,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability," TH2GL(); virtual~TH2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TH2GL.html:864,log,logx,864,root/html530/TH2GL.html,https://root.cern,https://root.cern/root/html530/TH2GL.html,9,['log'],"['logx', 'logy', 'logz']"
Testability," TH2GL(); virtual~TH2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2GL.html:864,log,logx,864,root/html534/TH2GL.html,https://root.cern,https://root.cern/root/html534/TH2GL.html,6,['log'],"['logx', 'logy', 'logz']"
Testability," TH2GL(); virtual~TH2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2GL.html:797,log,logx,797,root/html528/TH2GL.html,https://root.cern,https://root.cern/root/html528/TH2GL.html,3,['log'],"['logx', 'logy', 'logz']"
Testability," TH3D, TProfile, TProfile2D, TProfile2Poly, and TProfile3D.; Definition at line 444 of file TH1.h. ◆ IsBinOverflow(). Bool_t TH1::IsBinOverflow ; (; Int_t ; bin, . Int_t ; axis = 0 . ); const. Return true if the bin is overflow. ; Definition at line 5182 of file TH1.cxx. ◆ IsBinUnderflow(). Bool_t TH1::IsBinUnderflow ; (; Int_t ; bin, . Int_t ; iaxis = 0 . ); const. Return true if the bin is underflow. ; If iaxis = 0 make OR with all axes otherwise check only for the given axis ; Definition at line 5214 of file TH1.cxx. ◆ IsEmpty(). Bool_t TH1::IsEmpty ; (; ); const. protected . Check if a histogram is empty (this is a protected method used mainly by TH1Merger ) ; Definition at line 5164 of file TH1.cxx. ◆ IsHighlight(). virtual Bool_t TH1::IsHighlight ; (; ); const. inlinevirtual . Definition at line 338 of file TH1.h. ◆ KolmogorovTest(). Double_t TH1::KolmogorovTest ; (; const TH1 * ; h2, . Option_t * ; option = """" . ); const. virtual . Statistical test of compatibility in shape between this histogram and h2, using Kolmogorov test. ; Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data and not for binned data as in the case of the histogram (see NOTE 3 below). So, before using this method blindly, read the NOTE 3.; Default: Ignore under- and overflow bins in comparison; Parameters. [in]h2histogram ; [in]optionis a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure: make pseudoexperiments based on random values from the parent distribution, compare the KS distance of the pseudoexperiment to the parent distribution, and count all the KS values above the value obtained from the original data to Monte Carlo distribution. The number of pseudo-e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:183123,test,test,183123,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['test'],['test']
Testability," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TH3GL.html:838,log,logx,838,root/html530/TH3GL.html,https://root.cern,https://root.cern/root/html530/TH3GL.html,9,['log'],"['logx', 'logy', 'logz']"
Testability," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3GL.html:838,log,logx,838,root/html534/TH3GL.html,https://root.cern,https://root.cern/root/html534/TH3GL.html,6,['log'],"['logx', 'logy', 'logz']"
Testability," TH3GL(); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3GL.html:737,log,logx,737,root/html528/TH3GL.html,https://root.cern,https://root.cern/root/html528/TH3GL.html,3,['log'],"['logx', 'logy', 'logz']"
Testability," THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddBefore(const TObject* before, TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:1130,Assert,AssertClass,1130,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,1,['Assert'],['AssertClass']
Testability," THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THashTable.html:1078,Assert,AssertClass,1078,root/html532/THashTable.html,https://root.cern,https://root.cern/root/html532/THashTable.html,1,['Assert'],['AssertClass']
Testability," THilbertMatrixTSym<double> Template of Symmetric Hilbert Matrix class; THilbertMatrixTSym<float> Template of Symmetric Hilbert Matrix class; THistPainter Helper class to draw histograms; THnSparse Interfaces of sparse n-dimensional histogram; THnSparseArrayChunk chunks of linearized bins; THnSparseT<TArrayC> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayD> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayF> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayI> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayL> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayS> Sparse n-dimensional histogram with templated content; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interface to generic interpreter; TIsAProxy ; TIter Iterator wrapper; TIterator Iterator abstract base class; TKDTree<int,double> KD tree; TKDTree<int,float> KD tree; TKey Header description of a logical record on file.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:93349,log,logical,93349,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['log'],['logical']
Testability," THnT<float> multi-dimensional histogram with templated storage; THnT<int> multi-dimensional histogram with templated storage; THnT<long> multi-dimensional histogram with templated storage; THnT<short> multi-dimensional histogram with templated storage; THnT<unsigned int> multi-dimensional histogram with templated storage; THnT<unsigned long> multi-dimensional histogram with templated storage; THnT<unsigned short> multi-dimensional histogram with templated storage; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; THttpCallArg Arguments for single HTTP call; THttpEngine abstract class which should provide http-based protocol for server; THttpServer HTTP server for ROOT analysis; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interface to generic interpreter; TIsAProxy ; TIter Iterator wrapper; TIterator Iterator abstract base class; TKDE One dimensional semi-parametric Kernel Density Estimation; TKDTree<int,double> ; TKDTree<int,float> ; TKDTreeBinning ; TKSocket General kerberized socket; TKey Header description of a logical record on file.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:97862,log,logical,97862,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['log'],['logical']
Testability, TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TList.html:2717,Assert,AssertClass,2717,root/html532/TList.html,https://root.cern,https://root.cern/root/html532/TList.html,2,['Assert'],['AssertClass']
Testability," TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:26456,log,log,26456,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['log'],['log']
Testability," TLorentzRotation:; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; \]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874447,Test,TestVectors,874447,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Test'],['TestVectors']
Testability," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Event ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::IMetric calculates the ""distance"" between two points; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo samp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TMVA_Index.html:1180,test,testing,1180,root/html526/TMVA_Index.html,https://root.cern,https://root.cern/root/html526/TMVA_Index.html,1,['test'],['testing']
Testability," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::LogInterval Interval definition, continous and discrete; TMVA::MCFitter Fitter using Monte Carlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA_Index.html:1182,test,testing,1182,root/html534/TMVA_Index.html,https://root.cern,https://root.cern/root/html534/TMVA_Index.html,2,['test'],['testing']
Testability," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA_Index.html:1182,test,testing,1182,root/html530/TMVA_Index.html,https://root.cern,https://root.cern/root/html530/TMVA_Index.html,3,['test'],['testing']
Testability," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA_Index.html:1167,test,testing,1167,root/html528/TMVA_Index.html,https://root.cern,https://root.cern/root/html528/TMVA_Index.html,1,['test'],['testing']
Testability," TMVA::DataSet::GetEventCollection ; (; Types::ETreeType ; type = Types::kMaxTreeType); const. inline . Definition at line 216 of file DataSet.h. ◆ GetEventCollectionAsTree(). const TTree * TMVA::DataSet::GetEventCollectionAsTree ; (; ). ◆ GetNClassEvents(). Long64_t TMVA::DataSet::GetNClassEvents ; (; Int_t ; type, . UInt_t ; classNumber . ). Definition at line 168 of file DataSet.cxx. ◆ GetNEvents(). Long64_t TMVA::DataSet::GetNEvents ; (; Types::ETreeType ; type = Types::kMaxTreeType); const. inline . Definition at line 206 of file DataSet.h. ◆ GetNEvtBkgdTest(). Long64_t TMVA::DataSet::GetNEvtBkgdTest ; (; ). return number of background test events in dataset ; Definition at line 435 of file DataSet.cxx. ◆ GetNEvtBkgdTrain(). Long64_t TMVA::DataSet::GetNEvtBkgdTrain ; (; ). return number of background training events in dataset ; Definition at line 451 of file DataSet.cxx. ◆ GetNEvtSigTest(). Long64_t TMVA::DataSet::GetNEvtSigTest ; (; ). return number of signal test events in dataset ; Definition at line 427 of file DataSet.cxx. ◆ GetNEvtSigTrain(). Long64_t TMVA::DataSet::GetNEvtSigTrain ; (; ). return number of signal training events in dataset ; Definition at line 443 of file DataSet.cxx. ◆ GetNSpectators(). UInt_t TMVA::DataSet::GetNSpectators ; (; ); const. access the number of targets through the datasetinfo ; Definition at line 232 of file DataSet.cxx. ◆ GetNTargets(). UInt_t TMVA::DataSet::GetNTargets ; (; ); const. access the number of targets through the datasetinfo ; Definition at line 224 of file DataSet.cxx. ◆ GetNTestEvents(). Long64_t TMVA::DataSet::GetNTestEvents ; (; ); const. inline . Definition at line 69 of file DataSet.h. ◆ GetNTrainingEvents(). Long64_t TMVA::DataSet::GetNTrainingEvents ; (; ); const. inline . Definition at line 68 of file DataSet.h. ◆ GetNVariables(). UInt_t TMVA::DataSet::GetNVariables ; (; ); const. access the number of variables through the datasetinfo ; Definition at line 216 of file DataSet.cxx. ◆ GetResults(). TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:21125,test,test,21125,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['test'],['test']
Testability," TMVA::Factory::fCorrelationsBool_t fCorrelations! enable to calculate correlationsDefinition Factory.h:215; TMVA::Factory::IsModelPersistenceBool_t IsModelPersistence() constDefinition Factory.h:152; TMVA::Factory::fOptionsTString fOptions! option string given by construction (presently only ""V"")Definition Factory.h:211; TMVA::Factory::MVectorstd::vector< IMethod * > MVectorDefinition Factory.h:84; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::VerboseBool_t Verbose(void) constDefinition Factory.h:134; TMVA::Factory::WriteDataInformationvoid WriteDataInformation(DataSetInfo &fDataSetInfo)Definition Factory.cxx:602; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::TrainAllMethodsForClassificationvoid TrainAllMethodsForClassification(void)Definition Factory.h:115; TMVA::Factory::fVerboseBool_t fVerbose! verbose modeDefinition Factory.h:213; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Factory::EvaluateImportanceRandomTH1F * EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2473; TMVA::Factory::GetImportanceTH1F * GetImportance(const int nbits, std::vector< Double_t > importances, std::vector< TString > varNames)Definition Factory.cxx:2591; TMVA::Factory::fROCBool_t fROC! enable to calculate ROC valuesDefinition Factory.h:216; TMVA::Factory::EvaluateAllVariablesvoid EvaluateAllVariables(DataLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:13526,test,testing,13526,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['test'],['testing']
Testability," TMVA::MinuitFitter&operator=(const TMVA::MinuitFitter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidTMVA::Configurable::PrintOptions() const; virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual Double_tRun(vector<Double_t>& pars); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTMVA::Configurable::WriteOptionsToStream(ostream& o, const TString& prefix) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MinuitFitter.html:6077,Test,TestBit,6077,root/html602/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html602/TMVA__MinuitFitter.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," TMVA::MsgLogger Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TMVA::MsgLogger Class ReferenceTMVA. ; ostringstream derivative to redirect and format output ; Definition at line 57 of file MsgLogger.h. Public Member Functions;  MsgLogger (const MsgLogger &parent);  copy constructor ;  ;  MsgLogger (const std::string &source, EMsgType minType=kINFO);  constructor ;  ;  MsgLogger (const TObject *source, EMsgType minType=kINFO);  constructor ;  ;  MsgLogger (EMsgType minType=kINFO);  constructor ;  ;  ~MsgLogger ();  destructor ;  ; std::string GetFormattedSource () const;  make sure the source name is no longer than fgMaxSourceSize: ;  ; EMsgType GetMinType () const;  ; std::string GetPrintedSource () const;  the full logger prefix ;  ; std::string GetSource () const;  ; virtual TClass * IsA () const;  ; MsgLogger & operator<< (EMsgType type);  ; MsgLogger & operator<< (MsgLogger &(*_f)(MsgLogger &));  ; MsgLogger & operator<< (std::ios &(*_f)(std::ios &));  ; MsgLogger & operator<< (std::ostream &(*_f)(std::ostream &));  ; template<class T > ; MsgLogger & operator<< (T arg);  ; MsgLogger & operator= (const MsgLogger &parent);  assignment operator ;  ; void SetMinType (EMsgType minType);  ; void SetSource (const std::string &source);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html:970,log,logger,970,doc/master/classTMVA_1_1MsgLogger.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html,1,['log'],['logger']
Testability," TMVA; » TMVA; » TMVA::CostComplexityPruneTool. class TMVA::CostComplexityPruneTool: public TMVA::IPruneTool. Function Members (Methods); public:. virtual~CostComplexityPruneTool(); virtual TMVA::PruningInfo*CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE); TMVA::CostComplexityPruneToolCostComplexityPruneTool(TMVA::SeparationBase* qualityIndex = __null); TMVA::CostComplexityPruneToolCostComplexityPruneTool(const TMVA::CostComplexityPruneTool&); Double_tTMVA::IPruneTool::GetPruneStrength() const; TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(); TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(const TMVA::IPruneTool&); Bool_tTMVA::IPruneTool::IsAutomatic() const; TMVA::CostComplexityPruneTool&operator=(const TMVA::CostComplexityPruneTool&); voidTMVA::IPruneTool::SetAutomatic(); voidTMVA::IPruneTool::SetPruneStrength(Double_t alpha). private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:1250,Log,Log,1250,root/html604/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html,1,['Log'],['Log']
Testability," TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMap.html:1075,Assert,AssertClass,1075,root/html532/TMap.html,https://root.cern,https://root.cern/root/html532/TMap.html,2,['Assert'],['AssertClass']
Testability," TMath::Hbarconstexpr Double_t Hbar()in :Definition TMath.h:211; TMath::StruveH1Double_t StruveH1(Double_t x)Struve functions of order 0.Definition TMath.cxx:1846; TMath::FreqDouble_t Freq(Double_t x)Computation of the normal frequency function freq(x).Definition TMath.cxx:270; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::LandauIDouble_t LandauI(Double_t x)Returns the cumulative (lower tail integral) of the Landau distribution function at point x.Definition TMath.cxx:2845; TMath::StdDevDouble_t StdDev(Long64_t n, const T *a, const Double_t *w=nullptr)Definition TMath.h:527; TMath::ATanHDouble_t ATanH(Double_t)Returns the area hyperbolic tangent of x.Definition TMath.cxx:95; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72; TMath::BesselI0Double_t BesselI0(Double_t x)Integer order modified Bessel function K_n(x)Definition TMath.cxx:1426; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::StudentIDouble_t StudentI(Double_t T, Double_t ndf)Calculates the cumulative distribution function of Student's t-distribution second parameter stands f...Definition TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::GhbarCconstexpr Double_t GhbarC()inDefinition TMath.h:158; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:72154,log,logarithm,72154,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['log'],['logarithm']
Testability," TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRandom"", ""function:%s has %d negative values: abs assumed"", GetName(), intNegative);; 2129 }; 2130 if (fIntegral[fNpx] == 0) {; 2131 Error(""GetRandom"", ""Integral of function is zero"");; 2132 return kFALSE;; 2133 }; 2134 Double_t total = fIntegral[fNpx];; 2135 for (i = 1; i <= fNpx; i++) { // normalize integral to 1; 2136 fIntegral[i] /= total;; 2137 }; 2138 // the integral r for each bin is approximated by a parabola; 2139 // x = alpha + beta*r +gamma*r**2; 2140 // compute the coefficients alpha, beta, gamma for each bin; 2141 Double_t x0, r1, r2, r3;; 2142 for (i = 0; i < fNpx; i++) {; 2143 x0 = xx[i];; 2144 r2 = fIntegral[i + 1] - fIntegral[i];; 2145 if (logbin); 2146 r1 = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:78671,log,logbin,78671,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['logbin']
Testability," TObjArray(const TObjArray& a); TObjArray(Int_t s = TCollection::kInitCapacity, Int_t lowerBound = 0); virtual~TObjArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TObjArray.html:2408,Assert,AssertClass,2408,root/html532/TObjArray.html,https://root.cern,https://root.cern/root/html532/TObjArray.html,2,['Assert'],['AssertClass']
Testability," TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Long64_tfFromstarting offset of the current content; TProofLog*fLoggerparent TProofLog; TMacro*fMacrocontainer for the log lines; TStringfRolerole (master-submaster-worker); Long64_tfSizebest knowledge of the log file size; Long64_tfToend offset of the current content; static Long64_tfgMaxTransferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Display(const char *ord = ""*"", Int_t from = -10, Int_t to = -1). Int_t Grep(const char *txt, Int_t from = 0). void Print(Option_t* opt = 0) const. void Prt(const char *what, Bool_t newline = kTRUE). Int_t Retrieve(const char *ord = ""*"", TProofLog::ERetrieveOpt opt = TProofLog::kTrailing, const char *fname = 0, const char *pattern = 0). void SetMaxTransferSize(Long64_t maxsz). TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. Long64_t GetMaxTransferSize(). » Author: G. Ganis 31/08/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: 5d579564fccbadad9cd6f81ccb7726dddea80e0d $ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLogElem.html:6798,log,logger,6798,root/html534/TProofLogElem.html,https://root.cern,https://root.cern/root/html534/TProofLogElem.html,2,['log'],['logger']
Testability," TOrdCollection(Int_t capacity = kDefaultCapacity); virtual~TOrdCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidTSeqCollection::Add(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; Int_tBinarySearch(TObject* obj); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TOrdCollection.html:1449,Assert,AssertClass,1449,root/html532/TOrdCollection.html,https://root.cern,https://root.cern/root/html532/TOrdCollection.html,2,['Assert'],['AssertClass']
Testability," TPad.cxx. ◆ SetFixedAspectRatio(). void TPad::SetFixedAspectRatio ; (; Bool_t ; fixed = kTRUE). overridevirtual . Fix pad aspect ratio to current value if fixed is true. ; Implements TVirtualPad.; Definition at line 6031 of file TPad.cxx. ◆ SetGLDevice(). virtual void TPad::SetGLDevice ; (; Int_t ; dev). inlinevirtual . Definition at line 366 of file TPad.h. ◆ SetGrid(). void TPad::SetGrid ; (; Int_t ; valuex = 1, . Int_t ; valuey = 1 . ). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 335 of file TPad.h. ◆ SetGridx(). void TPad::SetGridx ; (; Int_t ; value = 1). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 336 of file TPad.h. ◆ SetGridy(). void TPad::SetGridy ; (; Int_t ; value = 1). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 337 of file TPad.h. ◆ SetLogx(). void TPad::SetLogx ; (; Int_t ; value = 1). overridevirtual . Set Lin/Log scale for X. . value = 0 X scale will be linear; value = 1 X scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other . Implements TVirtualPad.; Definition at line 6086 of file TPad.cxx. ◆ SetLogy(). void TPad::SetLogy ; (; Int_t ; value = 1). overridevirtual . Set Lin/Log scale for Y. . value = 0 Y scale will be linear; value = 1 Y scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other . Implements TVirtualPad.; Definition at line 6100 of file TPad.cxx. ◆ SetLogz(). void TPad::SetLogz ; (; Int_t ; value = 1). overridevirtual . Set Lin/Log scale for Z. ; Implements TVirtualPad.; Definition at line 6111 of file TPad.cxx. ◆ SetMaxPickDistance(). void TPad::SetMaxPickDistance ; (; Int_t ; maxPick = 5). static . static function to set the maximum Pick Distance fgMaxPickDistance This parameter is used in TPad::Pick to select an object if its DistancetoPrimitive returns a value < fgMaxPickDistance The default value is 5 pixels. ; Setting a smaller value will make picking more precise but also more",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:121883,log,logarithmic,121883,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['log'],['logarithmic']
Testability," TParallelCoordSelect(); TParallelCoordSelect(const char* title); virtual~TParallelCoordSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParallelCoordSelect.html:1449,Assert,AssertClass,1449,root/html532/TParallelCoordSelect.html,https://root.cern,https://root.cern/root/html532/TParallelCoordSelect.html,2,['Assert'],['AssertClass']
Testability," TPointSet3D(); TPointSet3D(const TPointSet3D& t); TPointSet3D(Int_t n, Marker_t m = 1, Option_t* opt = """"); TPointSet3D(Int_t n, Float_t* p, Marker_t m = 1, Option_t* opt = """"); TPointSet3D(Int_t n, Double_t* p, Marker_t m = 1, Option_t* opt = """"); virtual~TPointSet3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPointSet3D.html:1427,Assert,AssertBBox,1427,root/html532/TPointSet3D.html,https://root.cern,https://root.cern/root/html532/TPointSet3D.html,2,['Assert'],['AssertBBox']
Testability," TPrincipal::MakeCode and TPrincipal::MakeMethods. The options are: NONE so far. void P2X(const Double_t* p, Double_t* x, Int_t nTest); Calculate x as a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:47; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPrincipal.html:17567,Test,Test,17567,root/html534/TPrincipal.html,https://root.cern,https://root.cern/root/html534/TPrincipal.html,2,['Test'],['Test']
Testability," TPrincipal::MakeCode and TPrincipal::MakeMethods. The options are: NONE so far. void P2X(const Double_t* p, Double_t* x, Int_t nTest); Calculate x as a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:28; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPrincipal.html:18030,Test,Test,18030,root/html604/TPrincipal.html,https://root.cern,https://root.cern/root/html604/TPrincipal.html,2,['Test'],['Test']
Testability," TPrincipal::MakeCode and TPrincipal::MakeMethods. The options are: NONE so far. void P2X(const Double_t* p, Double_t* x, Int_t nTest); Calculate x as a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:25; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPrincipal.html:18030,Test,Test,18030,root/html602/TPrincipal.html,https://root.cern,https://root.cern/root/html602/TPrincipal.html,2,['Test'],['Test']
Testability," TPrincipal::MakeCode and TPrincipal::MakeMethods. The options are: NONE so far. void P2X(const Double_t* p, Double_t* x, Int_t nTest); Calculate x as a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TPrincipal.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPrincipal.html:17548,Test,Test,17548,root/html532/TPrincipal.html,https://root.cern,https://root.cern/root/html532/TPrincipal.html,2,['Test'],['Test']
Testability," TProcessID corresponding to pidf. WARNING1:; If MyClass is the class of the referenced object, The TObject part of MyClass must be Streamed. One should not call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2:; A TRef cannot point to another TRef. ObjectNumber; When an object is referenced (see TRef assignment operator or TRefArray::Add) a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. fUniqueID is some sort of serial object number in the current session. One can retrieve at any time the current value of fgNumber by calling the static function TProcessID::GetObjectCount or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example, one processes many events in a loop, it might be necessary to reset the ObjectNumber at the end of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be saved at the beginning of one event and reset to this original value at the end of the event via TProcessID::SetObjectCount(saveNumber). These actions may be stacked. Action on Demand; The normal behaviour of a TRef has been described above. In addition, TRef supports also ""Actions on Demand"". It may happen that the object referenced is not yet in memory, on a separate file or not yet computed. In this case TRef is able to automatically execute an action:. call to a compiled function (static function of member function); call to an interpreted function; execution of a C++ script. How to select this option? In the definition of the TRef data member in the original class, do: TRef fRef; //EXEC:execName. points to something; When the special keyword ""EXEC:"" is found in the comment field of the member, the next string is assumed to be the name of a TExec object. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:4691,test,test,4691,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['test'],['test']
Testability," TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProof(); voidTObject::AbstractMethod(const char* method) const; Int_tActivateWorker(const char* ord); voidAddChain(TChain* chain); Int_tAddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidAddEnvVar(const char* name, const char* value); voidAddFeedback(const char* name); Int_tAddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidAddInput(TObject* obj); voidAddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tArchive(Int_t query, const char* url); Int_tArchive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); voidcd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClear",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:709,log,loglevel,709,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['log'],['loglevel']
Testability," TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProof(); voidTObject::AbstractMethod(const char* method) const; Int_tActivateWorker(const char* ord, Bool_t save = kTRUE); voidAddChain(TChain* chain); Int_tAddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); static voidAddEnvVar(const char* name, const char* value); voidAddFeedback(const char* name); Int_tAddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); voidAddInput(TObject* obj); voidAddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tArchive(Int_t query, const char* url); Int_tArchive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); virtual Bool_tCancelStagingDataSet(const char* dataset); voidcd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:709,log,loglevel,709,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['log'],['loglevel']
Testability," TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProof(); voidTObject::AbstractMethod(const char* method) const; voidActivateWorker(const char* ord); voidAddChain(TChain* chain); Int_tAddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidAddEnvVar(const char* name, const char* value); voidAddFeedback(const char* name); Int_tAddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidAddInput(TObject* obj); voidAddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tArchive(Int_t query, const char* url); Int_tArchive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); voidcd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:709,log,loglevel,709,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['log'],['loglevel']
Testability," TProof::RestoreActiveList ; (; ). private . Restore saved list of active workers. ; Definition at line 11557 of file TProof.cxx. ◆ Retrieve() [1/2]. Int_t TProof::Retrieve ; (; const char * ; ref, . const char * ; path = 0 . ). Send retrieve request for the query specified by ref. ; If path is defined save it to path. Generic method working for all queries known by the server. ; Definition at line 5967 of file TProof.cxx. ◆ Retrieve() [2/2]. Int_t TProof::Retrieve ; (; Int_t ; qry, . const char * ; path = 0 . ). Send retrieve request for the qry-th query in fQueries. ; If path is defined save it to path. ; Definition at line 5948 of file TProof.cxx. ◆ SaveActiveList(). void TProof::SaveActiveList ; (; ). private . Save current list of active workers. ; Definition at line 11542 of file TProof.cxx. ◆ SaveInputData(). Int_t TProof::SaveInputData ; (; TQueryResult * ; qr, . const char * ; cachedir, . TString & ; emsg . ). staticprotected . Save input data file from 'cachedir' into the sandbox or create a the file with input data objects. ; Definition at line 12311 of file TProof.cxx. ◆ SavePerfTree(). Int_t TProof::SavePerfTree ; (; const char * ; pf = 0, . const char * ; ref = 0 . ). Save performance information from TPerfStats to file 'pf'. ; If 'ref' is defined, do it for query 'ref'. Return 0 on sucecss, -1 in case of any error ; Definition at line 12646 of file TProof.cxx. ◆ SaveWorkerInfo(). void TProof::SaveWorkerInfo ; (; ). protectedvirtual . Save information about the worker set in the file .workers in the working dir. ; Called each time there is a change in the worker setup, e.g. by TProof::MarkBad(). ; Definition at line 11808 of file TProof.cxx. ◆ SendCommand(). Int_t TProof::SendCommand ; (; const char * ; cmd, . ESlaves ; list = kActive . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line command, however commands like "".x file.C"" or "".L file.C"" will not cause the file.C to be transfered to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:135747,sandbox,sandbox,135747,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['sandbox'],['sandbox']
Testability," TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofCondor(); voidTObject::AbstractMethod(const char* method) const; Int_tTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:712,log,loglevel,712,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,3,['log'],['loglevel']
Testability," TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofCondor(); voidTObject::AbstractMethod(const char* method) const; Int_tTProof::ActivateWorker(const char* ord, Bool_t save = kTRUE); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tTProof::CancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:712,log,loglevel,712,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,2,['log'],['loglevel']
Testability," TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofCondor(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:712,log,loglevel,712,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,1,['log'],['loglevel']
Testability," TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofLite(); voidTObject::AbstractMethod(const char* method) const; Int_tTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:705,log,loglevel,705,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,3,['log'],['loglevel']
Testability," TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofLite(); voidTObject::AbstractMethod(const char* method) const; Int_tTProof::ActivateWorker(const char* ord, Bool_t save = kTRUE); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tCancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:705,log,loglevel,705,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,2,['log'],['loglevel']
Testability," TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofLite(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:705,log,loglevel,705,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['log'],['loglevel']
Testability," TProofLog * GetSessionLogs(Int_t ridx = 0, const char* stag = 0, const char* pattern = ""-v \""| SvcMsg\"""", Bool_t rescan = kFALSE); Get logs or log tails from last session associated with this manager; instance.; The arguments allow to specify a session different from the last one:; isess specifies a position relative to the last one, i.e. 1; for the next to last session; the absolute value is taken; so -1 and 1 are equivalent.; stag specifies the unique tag of the wanted session; The special value stag = ""NR"" allows to just initialize the TProofLog; object w/o retrieving the files; this may be useful when the number; of workers is large and only a subset of logs is required.; If 'stag' is specified 'isess' is ignored (unless stag = ""NR"").; If 'pattern' is specified only the lines containing it are retrieved; (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; If 'rescan' is TRUE, masters will rescan the worker sandboxes for the exact; paths, instead of using the save information; may be useful when the; ssave information looks wrong or incomplete.; Returns a TProofLog object (to be deleted by the caller) on success,; 0 if something wrong happened. TObjString * ReadBuffer(const char* file, Long64_t ofs, Int_t len); Read, via the coordinator, 'len' bytes from offset 'ofs' of 'file'.; Returns a TObjString with the content or 0, in case of failure. TObjString * ReadBuffer(const char* file, const char* pattern); Read, via the coordinator, 'fin' filtered. If 'pattern' starts with '|',; it represents a command filtering the output. Elsewhere, it is a grep; pattern. Returns a TObjString with the content or 0 in case of failure. void ShowROOTVersions(); Display what ROOT versions are available on the cluster. Int_t SetROOTVersion(const char* tag); Set the default ROOT version to be used. Int_t SendMsgToUsers(const char* msg, const char* usr = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:13294,sandbox,sandboxes,13294,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,6,['sandbox'],['sandboxes']
Testability," TProofLog * GetSessionLogs(Int_t ridx = 0, const char* stag = 0, const char* pattern = ""-v \""| SvcMsg\"""", Bool_t rescan = kFALSE); Get logs or log tails from last session associated with this manager; instance.; The arguments allow to specify a session different from the last one:; isess specifies a position relative to the last one, i.e. 1; for the next to last session; the absolute value is taken; so -1 and 1 are equivalent.; stag specifies the unique tag of the wanted session; The special value stag = ""NR"" allows to just initialize the TProofLog; object w/o retrieving the files; this may be useful when the number; of workers is large and only a subset of logs is required.; If 'stag' is specified 'isess' is ignored (unless stag = ""NR"").; If 'pattern' is specified only the lines containing it are retrieved; (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; If 'rescan' is TRUE, masters will rescan the worker sandboxes for the exact; paths, instead of using the save information; may be useful when the; ssave information looks wrong or incomplete.; Returns a TProofLog object (to be deleted by the caller) on success,; 0 if something wrong happened. TObjString * ReadBuffer(const char* file, Long64_t ofs, Int_t len); Read, via the coordinator, 'len' bytes from offset 'ofs' of 'file'.; Returns a TObjString with the content or 0, in case of failure. TObjString * ReadBuffer(const char* file, const char* pattern); Read, via the coordinator, lines containing 'pattern' in 'file'.; Returns a TObjString with the content or 0, in case of failure. void ShowROOTVersions(); Display what ROOT versions are available on the cluster. void SetROOTVersion(const char* tag); Set the default ROOT version to be used. Int_t SendMsgToUsers(const char* msg, const char* usr = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the message or the file from where to take; the message.; The second argument specifies the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXProofMgr.html:12600,sandbox,sandboxes,12600,root/html530/TXProofMgr.html,https://root.cern,https://root.cern/root/html530/TXProofMgr.html,3,['sandbox'],['sandboxes']
Testability," TProofLogElem(const TProofLogElem&); TProofLogElem(const char* ord, const char* url, TProofLog* logger); virtual~TProofLogElem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisplay(Int_t from = 0, Int_t to = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLogElem.html:470,log,logger,470,root/html530/TProofLogElem.html,https://root.cern,https://root.cern/root/html530/TProofLogElem.html,5,['log'],['logger']
Testability," TProofLogElem(const TProofLogElem&); TProofLogElem(const char* ord, const char* url, TProofLog* logger); virtual~TProofLogElem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisplay(Int_t from = 0, Int_t to = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLogElem.html:468,log,logger,468,root/html528/TProofLogElem.html,https://root.cern,https://root.cern/root/html528/TProofLogElem.html,1,['log'],['logger']
Testability," TProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofMgr.html:615,log,loglevel,615,root/html528/TProofMgr.html,https://root.cern,https://root.cern/root/html528/TProofMgr.html,2,['log'],['loglevel']
Testability," TProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidClose(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofMgr.html:615,log,loglevel,615,root/html530/TProofMgr.html,https://root.cern,https://root.cern/root/html530/TProofMgr.html,10,['log'],['loglevel']
Testability," TProofMgrLite(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgrLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*TProofMgr::AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*TProofMgr::AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTProofMgr::Cp(const char*, const char* = 0, const char* = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTProofMgr::DetachSession(Int_t, Option_t* = """"); virtual voidTProofMgr::DetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofMgrLite.html:458,log,loglevel,458,root/html528/TProofMgrLite.html,https://root.cern,https://root.cern/root/html528/TProofMgrLite.html,2,['log'],['loglevel']
Testability," TProofMgrLite(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgrLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*TProofMgr::AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*TProofMgr::AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProofMgr::Close(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTProofMgr::Cp(const char*, const char* = 0, const char* = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTProofMgr::DetachSession(Int_t, Option_t* = """"); virtual voidTProofMgr::DetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofMgrLite.html:458,log,loglevel,458,root/html530/TProofMgrLite.html,https://root.cern,https://root.cern/root/html530/TProofMgrLite.html,10,['log'],['loglevel']
Testability," TProofOutputList(const char* dontshow = ""PROOF_*""); TProofOutputList(TObject* o); virtual~TProofOutputList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; voidAttachList(TList* alist); virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofOutputList.html:1459,Assert,AssertClass,1459,root/html532/TProofOutputList.html,https://root.cern,https://root.cern/root/html532/TProofOutputList.html,2,['Assert'],['AssertClass']
Testability," TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofSuperMaster(); voidTObject::AbstractMethod(const char* method) const; Int_tTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofSuperMaster.html:743,log,loglevel,743,root/html530/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofSuperMaster.html,3,['log'],['loglevel']
Testability," TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofSuperMaster(); voidTObject::AbstractMethod(const char* method) const; Int_tTProof::ActivateWorker(const char* ord, Bool_t save = kTRUE); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tTProof::CancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:743,log,loglevel,743,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,2,['log'],['loglevel']
Testability," TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofSuperMaster(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofSuperMaster.html:743,log,loglevel,743,root/html528/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html,1,['log'],['loglevel']
Testability," TQueryResultManager(const TQueryResultManager&); TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0); virtual~TQueryResultManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tApplyMaxQueries(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQueryResultManager.html:546,log,logfile,546,root/html530/TQueryResultManager.html,https://root.cern,https://root.cern/root/html530/TQueryResultManager.html,5,['log'],['logfile']
Testability," TQueryResultManager(const TQueryResultManager&); TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0); virtual~TQueryResultManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tApplyMaxQueries(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQueryResultManager.html:544,log,logfile,544,root/html528/TQueryResultManager.html,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html,1,['log'],['logfile']
Testability," TSelectorList(); ~TSelectorList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tTHashList::AverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTHashList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelectorList.html:1473,Assert,AssertClass,1473,root/html534/TSelectorList.html,https://root.cern,https://root.cern/root/html534/TSelectorList.html,1,['Assert'],['AssertClass']
Testability," TSelectorList(); ~TSelectorList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelectorList.html:1469,Assert,AssertClass,1469,root/html532/TSelectorList.html,https://root.cern,https://root.cern/root/html532/TSelectorList.html,1,['Assert'],['AssertClass']
Testability," TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet *dataset,Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i); if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable(); {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { fTable = 0; }. TChair(TTable *table); { fTable = table; }. TChair(const TChair &org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet *dataset,Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t *option="""", Int_t nentries=1000000000, Int_t firstentry=0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char *varexp, const char *selection, Option_t *option="""", Int_t nentries=1000000000, Int_t firstentry=0). Char_t * GetArray() const; {return (Char_t *)GetThisTable()->GetArray();}. TClass * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChair.html:10918,assert,assert,10918,root/html526/TChair.html,https://root.cern,https://root.cern/root/html526/TChair.html,1,['assert'],['assert']
Testability," TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { return fBaseIcon; }. TGPopupMenu * GetPopupSrv() const; { return fPopupSrv; }. TGPopupMenu * GetPopupQry() const; { return fPopupQry; }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGHProgressBar * GetConnectProg() const; { return fConnectProg; }. TGPopupMenu * GetCascadeMenu() const; { return fCascadeMenu; }. TGPopupMenu * GetOptionsMenu() const; { return fOptionsMenu; }. Bool_t IsBusy() const; { return fBusy; }. Bool_t IsAutoSave() const; { return fAutoSave; }. void SetBusy(Bool_t busy = kTRUE); { fBusy = busy; }. void SetChangePic(Bool_t change); { fChangePic = change;}. void SetLogWindow(TSessionLogView* log); { fLogWindow = log; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionViewer.html:30026,log,log,30026,root/html534/TSessionViewer.html,https://root.cern,https://root.cern/root/html534/TSessionViewer.html,4,['log'],['log']
Testability," TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { return fBaseIcon; }. TGPopupMenu * GetPopupSrv() const; { return fPopupSrv; }. TGPopupMenu * GetPopupQry() const; { return fPopupQry; }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGHProgressBar * GetConnectProg() const; { return fConnectProg; }. TGPopupMenu * GetCascadeMenu() const; { return fCascadeMenu; }. TGPopupMenu * GetOptionsMenu() const; { return fOptionsMenu; }. Bool_t IsBusy() const; { return fBusy; }. Bool_t IsAutoSave() const; { return fAutoSave; }. void SetBusy(Bool_t busy = kTRUE); { fBusy = busy; }. void SetChangePic(Bool_t change); { fChangePic = change;}. void SetLogWindow(TSessionLogView* log); { fLogWindow = log; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSessionViewer.html:31109,log,log,31109,root/html604/TSessionViewer.html,https://root.cern,https://root.cern/root/html604/TSessionViewer.html,4,['log'],['log']
Testability," TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { return fBaseIcon; }. TGPopupMenu * GetPopupSrv() const; { return fPopupSrv; }. TGPopupMenu * GetPopupQry() const; { return fPopupQry; }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGHProgressBar * GetConnectProg() const; { return fConnectProg; }. TGPopupMenu * GetCascadeMenu() const; { return fCascadeMenu; }. TGPopupMenu * GetOptionsMenu() const; { return fOptionsMenu; }. Bool_t IsBusy() const; { return fBusy; }. Bool_t IsAutoSave() const; { return fAutoSave; }. void SetBusy(Bool_t busy = kTRUE); { fBusy = busy; }. void SetChangePic(Bool_t change); { fChangePic = change;}. void SetLogWindow(TSessionLogView* log); { fLogWindow = log; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionViewer.html:31109,log,log,31109,root/html602/TSessionViewer.html,https://root.cern,https://root.cern/root/html602/TSessionViewer.html,4,['log'],['log']
Testability," TSortedList(Bool_t order = kSortAscending); ~TSortedList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidAddAfter(TObjLink*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddBefore(TObjLink*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSortedList.html:1272,Assert,AssertClass,1272,root/html532/TSortedList.html,https://root.cern,https://root.cern/root/html532/TSortedList.html,2,['Assert'],['AssertClass']
Testability," TSpectrum2Fit::fFixAmpX1. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional ; Definition at line 100 of file TSpectrum2Fit.h. ◆ fFixAmpY1. Bool_t* TSpectrum2Fit::fFixAmpY1. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ; Definition at line 101 of file TSpectrum2Fit.h. ◆ fFixAx. Bool_t TSpectrum2Fit::fFixAx. protected . logical value of ax parameter, which allows to fix the parameter (not to fit). ; Definition at line 114 of file TSpectrum2Fit.h. ◆ fFixAy. Bool_t TSpectrum2Fit::fFixAy. protected . logical value of ay parameter, which allows to fix the parameter (not to fit). ; Definition at line 115 of file TSpectrum2Fit.h. ◆ fFixBx. Bool_t TSpectrum2Fit::fFixBx. protected . logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; Definition at line 111 of file TSpectrum2Fit.h. ◆ fFixBy. Bool_t TSpectrum2Fit::fFixBy. protected . logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; Definition at line 112 of file TSpectrum2Fit.h. ◆ fFixPositionX. Bool_t* TSpectrum2Fit::fFixPositionX. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 95 of file TSpectrum2Fit.h. ◆ fFixPositionX1. Bool_t* TSpectrum2Fit::fFixPositionX1. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 97 of file TSpectrum2Fit.h. ◆ fFixPositionY. Bool_t* TSpectrum2Fit::fFixPositionY. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:84198,log,logical,84198,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability," TString &name) const;  ; virtual Double_t GetParameter (Int_t ipar) const;  ; virtual Double_t * GetParameters () const;  ; virtual void GetParameters (Double_t *params);  ; TObject * GetParent () const;  ; virtual Double_t GetParError (Int_t ipar) const;  Return value of parameter number ipar. ;  ; virtual const Double_t * GetParErrors () const;  ; virtual void GetParLimits (Int_t ipar, Double_t &parmin, Double_t &parmax) const;  Return limits for parameter ipar. ;  ; virtual const char * GetParName (Int_t ipar) const;  ; virtual Int_t GetParNumber (const char *name) const;  ; virtual Double_t GetProb () const;  Return the fit probability. ;  ; virtual Int_t GetQuantiles (Int_t n, Double_t *xp, const Double_t *p);  Compute Quantiles for density distribution of this function. ;  ; virtual Double_t GetVariable (const TString &name);  ; virtual Double_t GetX (Double_t y, Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const;  Returns the X value corresponding to the function value fy for (xmin<x<xmax). ;  ; TAxis * GetXaxis () const;  Get x axis of the function. ;  ; virtual Double_t GetXmax () const;  ; virtual Double_t GetXmin () const;  ; TAxis * GetYaxis () const;  Get y axis of the function. ;  ; TAxis * GetZaxis () const;  Get z axis of the function. (In case this object is a TF2 or TF3) ;  ; virtual void GradientPar (const Double_t *x, Double_t *grad, Double_t eps=0.01);  Compute the gradient wrt parameters If the TF1 object is based on a formula expression (TFormula) and TFormula::GenerateGradientPar() has been successfully called automatic differentiation using CLAD is used instead of the default numerical differentiation. ;  ; template<class T > ; void GradientPar (const T *x, T *grad, Double_t eps=0.01);  ; virtual Double_t GradientPar (Int_t ipar, const Double_t *x, Double_t eps=0.01);  Compute the gradient (derivative) wrt a parameter ipar. ;  ; template<class T > ; T GradientPar (Int_t ipar, const T *x, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:18131,log,logx,18131,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,2,['log'],['logx']
Testability," TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) const; 3173{; 3174 R__LOCKGUARD(gInterpreterMutex);; 3175 ; 3176 //FIXME: if we use llvm::sys::fs::make_absolute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:121913,test,test,121913,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['test'],['test']
Testability," TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalcNormalizationParams(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMax! Max of source range; TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableNormalizeTransform.html:8986,log,logger,8986,root/html530/TMVA__VariableNormalizeTransform.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableNormalizeTransform.html,5,['log'],['logger']
Testability," TString&TString::ReplaceAll(const char* s1, Ssiz_t ls1, const char* s2, Ssiz_t ls2); voidTString::Resize(Ssiz_t n); static Ssiz_tTString::ResizeIncrement(Ssiz_t ri = 16); virtual voidShowMembers(TMemberInspector&); virtual Int_tTString::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TSubStringTString::Strip(TString::EStripType s = kTrailing, char c = ' ') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static TStringTString::UItoa(UInt_t value, Int_t base); static TStringTString::ULLtoa(ULong64_t value, Int_t base); virtual const char*what() const; static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveException(const std::string& s); Constructor. TEveException(); {}. TEveException(const TString& s); {}. TEveException(const char* s); {}. TEveException(const std::string& s). virtual ~TEveException(); {}. const char* what() const; { return Data(); }. TEvePadHolder& operator=(const TEveException& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveException.html:7774,Assert,AssertElement,7774,root/html534/TEveException.html,https://root.cern,https://root.cern/root/html534/TEveException.html,1,['Assert'],['AssertElement']
Testability," TStringTNamed::fTitleobject title; Double_t*fZ[fNz] pointer to array of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPcon(); dummy ctor. TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:12839,test,test,12839,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,4,['test'],['test']
Testability," TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; TUnuran::SetEmpiricalDistributionbool SetEmpiricalDistribution(const TUnuranEmpDist &dist)Definition TUnuran.cxx:246; TUnuran::~TUnuran~TUnuran()Destructor.Definition TUnuran.cxx:53; TUnuran::InitPoissonbool InitPoisson(double mu, const std::string &method=""dstd"")Initialize method for the Poisson distribution.Definition TUnuran.cxx:448; TUnuran::fMethodstd::string fMethodDefinition TUnuran.h:310; TUnuran::GetDimensionint GetDimension() constReturn the dimension of unuran generator method.Definition TUnuran.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8cxx_source.html:20403,log,log,20403,doc/master/TUnuran_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html,1,['log'],['log']
Testability," TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:173277,log,logzsav,173277,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logzsav']
Testability," TVirtualCollectionProxy::TPushPop helper( newProxy, (char*)obj );; 1337 Int_t nobjects;; 1338 buf.ReadInt(nobjects);; 1339 void* alternative = newProxy->Allocate(nobjects,true);; 1340 if (nobjects) {; 1341 TActionSequence *actions = newProxy->GetConversionReadMemberWiseActions( oldProxy->GetValueClass(), vClVersion );; 1342 char startbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 1343 char endbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 1344 void *begin = &(startbuf[0]);; 1345 void *end = &(endbuf[0]);; 1346 config->fCreateIterators( alternative, &begin, &end, newProxy);; 1347 // We can not get here with a split vector of pointer, so we can indeed assume; 1348 // that actions->fConfiguration != null.; 1349 buf.ApplySequence(*actions, begin, end);; 1350 if (begin != &(startbuf[0])) {; 1351 // assert(end != endbuf);; 1352 config->fDeleteTwoIterators(begin,end);; 1353 }; 1354 }; 1355 newProxy->Commit(alternative);; 1356 }; 1357 }; 1358 }; 1359 ; 1360 INLINE_TEMPLATE_ARGS void ReadSTLObjectWiseFastArray(TBuffer &buf, void *addr, const TConfiguration *conf, Version_t /* vers */, UInt_t /* start */); 1361 {; 1362 TConfigSTL *config = (TConfigSTL*)conf;; 1363 // Idea: This needs to be unrolled, it currently calls the TGenCollectionStreamer ....; 1364 buf.ReadFastArray(addr,config->fNewClass,conf->fLength,(TMemberStreamer*)0,config->fOldClass);; 1365 }; 1366 INLINE_TEMPLATE_ARGS void ReadSTLObjectWiseStreamer(TBuffer &buf, void *addr, const TConfiguration *conf, Version_t /* vers */, UInt_t /* start */); 1367 {; 1368 TConfigSTL *config = (TConfigSTL*)conf;; 1369 (*config->fStreamer)(buf,addr,conf->fLength);; 1370 }; 1371 INLINE_TEMPLATE_ARGS void ReadSTLObjectWiseFastArrayV2(TBuffer &buf, void *addr, const TConfiguration *conf, Version_t vers, UInt_t start); 1372 {; 1373 // case of old TStreamerInfo; 1374 ; 1375 TConfigSTL *config = (TConfigSTL*)conf;; 1376 // Backward compatibility. Some TStreamerElement's where without; 1377 // Streamer but were not removed f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:56273,assert,assert,56273,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['assert'],['assert']
Testability," TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file). void Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. TStreamerElement * GetElem(Int_t id) const. TStreamerElement * GetElement(Int_t id) const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t GetOffset(Int_t id) const. Int_t GetElementOffset(Int_t id) const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return fIsCompiled; }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") const. TVirtualStreamerInfo * NewInfo(TClass* cl). void * New(void* obj = 0). void * NewArray(Long_t nElements, void* ary = 0). void Destructor(void* p, Bool_t dtorOnly = kFALSE). void DeleteArray(void* p, Bool_t dtorOnly = kFALSE). void SetCheckSum(UInt_t checksum). void SetClass(TClass* cl). void SetClassVersion(Int_t vers). void TagFile(TFile* fFile). void Update(const TClass* oldClass, TClass* newClass). TVirtualCollectionProxy * GenEmulatedProxy(const char* class_name, Bool_t silent). TClassStreamer * GenEmulatedClassStreamer(const char* class_name, Bool_t silent). TVirtualCollectionProxy * GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). TClassStreamer * GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl). » Author: Rene Brun 05/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:41; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualStreamerInfo.html:12826,Test,TestBit,12826,root/html534/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TVirtualStreamerInfo.html,1,['Test'],['TestBit']
Testability," TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file). void Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. TStreamerElement * GetElem(Int_t id) const. TStreamerElement * GetElement(Int_t id) const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t GetOffset(Int_t id) const. Int_t GetElementOffset(Int_t id) const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return fIsCompiled; }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") const. TVirtualStreamerInfo * NewInfo(TClass* cl). void * New(void* obj = 0). void * NewArray(Long_t nElements, void* ary = 0). void Destructor(void* p, Bool_t dtorOnly = kFALSE). void DeleteArray(void* p, Bool_t dtorOnly = kFALSE). void SetCheckSum(UInt_t checksum). void SetClass(TClass* cl). void SetClassVersion(Int_t vers). void TagFile(TFile* fFile). void Update(const TClass* oldClass, TClass* newClass). TVirtualCollectionProxy * GenEmulatedProxy(const char* class_name, Bool_t silent). TClassStreamer * GenEmulatedClassStreamer(const char* class_name, Bool_t silent). TVirtualCollectionProxy * GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). TClassStreamer * GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl). » Author: Rene Brun 05/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:35; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualStreamerInfo.html:16336,Test,TestBit,16336,root/html604/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html604/TVirtualStreamerInfo.html,1,['Test'],['TestBit']
Testability," TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file). void Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. TStreamerElement * GetElem(Int_t id) const. TStreamerElement * GetElement(Int_t id) const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t GetOffset(Int_t id) const. Int_t GetElementOffset(Int_t id) const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return fIsCompiled; }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") const. TVirtualStreamerInfo * NewInfo(TClass* cl). void * New(void* obj = 0). void * NewArray(Long_t nElements, void* ary = 0). void Destructor(void* p, Bool_t dtorOnly = kFALSE). void DeleteArray(void* p, Bool_t dtorOnly = kFALSE). void SetCheckSum(UInt_t checksum). void SetClass(TClass* cl). void SetClassVersion(Int_t vers). void TagFile(TFile* fFile). void Update(const TClass* oldClass, TClass* newClass). TVirtualCollectionProxy * GenEmulatedProxy(const char* class_name, Bool_t silent). TClassStreamer * GenEmulatedClassStreamer(const char* class_name, Bool_t silent). TVirtualCollectionProxy * GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). TClassStreamer * GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl). » Author: Rene Brun 05/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:32; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualStreamerInfo.html:16336,Test,TestBit,16336,root/html602/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TVirtualStreamerInfo.html,1,['Test'],['TestBit']
Testability," TWinNTSystem.; Definition at line 311 of file TSystem.cxx. ◆ Now(). TTime TSystem::Now ; (; ). virtual . Get current time in milliseconds since 0:00 Jan 1 1995. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 463 of file TSystem.cxx. ◆ OpenConnection(). int TSystem::OpenConnection ; (; const char * ; server, . int ; port, . int ; tcpwindowsize = -1, . const char * ; protocol = ""tcp"" . ). virtual . Open a connection to another host. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2336 of file TSystem.cxx. ◆ OpenDirectory(). void * TSystem::OpenDirectory ; (; const char * ; name). virtual . Open a directory. Returns 0 if directory does not exist. ; Reimplemented in TDavixSystem, TNetXNGSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TNetSystem, and TWebSystem.; Definition at line 836 of file TSystem.cxx. ◆ Openlog(). void TSystem::Openlog ; (; const char * ; name, . Int_t ; options, . ELogFacility ; facility . ). virtual . Open connection to system log daemon. ; For the use of the options and facility see the Unix openlog man page. ; Reimplemented in TUnixSystem.; Definition at line 1677 of file TSystem.cxx. ◆ OpenPipe(). FILE * TSystem::OpenPipe ; (; const char * ; command, . const char * ; mode . ). virtual . Open a pipe. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 662 of file TSystem.cxx. ◆ operator=(). TSystem & TSystem::operator= ; (; const TSystem & ; ). privatedelete . ◆ PrependPathName(). const char * TSystem::PrependPathName ; (; const char * ; dir, . TString & ; name . ). virtual . Concatenate a directory and a file name. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1081 of file TSystem.cxx. ◆ ProcessEvents(). Bool_t TSystem::ProcessEvents ; (; ). virtual . Process pending events (GUI, timers, sockets). ; Returns the result of TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()) can be set during the handling of the events. This mechanism allows ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:76040,log,log,76040,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['log'],['log']
Testability," TXMLEngine&operator=(const TXMLEngine&); virtual voidTObject::Paint(Option_t* option = """"); XMLDocPointer_tParseFile(const char* filename, Int_t maxbuf = 100000); XMLDocPointer_tParseString(const char* xmlstring); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); XMLNodePointer_tReadSingleNode(const char* src); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; voidSaveDoc(XMLDocPointer_t xmldoc, const char* filename, Int_t layout = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSingleNode(XMLNodePointer_t xmlnode, TString* res, Int_t layout = 1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetSkipComments(bool on = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidShiftToNext(XMLNodePointer_t& xmlnode, bool tonode = true); virtual voidShowMembers(TMemberInspector& insp); voidSkipEmpty(XMLNodePointer_t& xmlnode); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUnlinkFreeNode(XMLNodePointer_t xmlnode); voidUnlinkNode(XMLNodePointer_t node); virtual voidTObject::UseCurrentStyle(); Bool_tValidateDocument(XMLDocPointer_t, Bool_t = kFALSE); Bool_tValidateVersion(XMLDocPointer_t doc, const char* version = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLEngine.html:7586,Test,TestBit,7586,root/html532/TXMLEngine.html,https://root.cern,https://root.cern/root/html532/TXMLEngine.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," TXNetFile(); TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:1652,log,logicalurl,1652,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,6,['log'],['logicalurl']
Testability," TXProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TXProofMgr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*AttachSession(Int_t id, Bool_t gui = kFALSE); virtual TProof*AttachSession(TProofDesc* d, Bool_t gui = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char* src, const char* dst = 0, const char* opts = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*TProofMgr::CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofMgr.html:642,log,loglevel,642,root/html528/TXProofMgr.html,https://root.cern,https://root.cern/root/html528/TXProofMgr.html,2,['log'],['loglevel']
Testability," TXProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TXProofMgr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*AttachSession(Int_t id, Bool_t gui = kFALSE); virtual TProof*AttachSession(TProofDesc* d, Bool_t gui = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProofMgr::Close(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char* src, const char* dst = 0, const char* opts = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*TProofMgr::CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXProofMgr.html:642,log,loglevel,642,root/html530/TXProofMgr.html,https://root.cern,https://root.cern/root/html530/TXProofMgr.html,10,['log'],['loglevel']
Testability," TXSocket(const TXSocket& xs); TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0); virtual~TXSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreate(Bool_t attach = kFALSE); static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); voidCtrlC(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableTimeout(); voidDisconnectSession(Int_t id, Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSocket.html:512,log,logbuf,512,root/html528/TXSocket.html,https://root.cern,https://root.cern/root/html528/TXSocket.html,2,['log'],"['logbuf', 'loglevel']"
Testability," TXSocket(const TXSocket& xs); TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0); virtual~TXSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreate(Bool_t attach = kFALSE); static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); voidCtrlC(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableTimeout(); voidDisconnectSession(Int_t id, Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:514,log,logbuf,514,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,6,['log'],"['logbuf', 'loglevel']"
Testability," TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0); virtual~TXSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreate(Bool_t attach = kFALSE); static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); voidCtrlC(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableTimeout(); voidDisconnectSession(Int_t id, Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSocket.html:484,log,logbuf,484,root/html534/TXSocket.html,https://root.cern,https://root.cern/root/html534/TXSocket.html,4,['log'],"['logbuf', 'loglevel']"
Testability," Template FunctionsThese function apply to matrices (and also Matrix expression) and can return a matrix expression of a particular defined type, like in the matrix multiplication or a vector, like in the matrix-vector product or a scalar like in the Similarity vector-matrix product ;  SMatrix Storage Representation;  Matrix and Vector classesClasses representing Matrices and Vectors of arbitrary type and dimension ;  Unuran;  ▼Monte CarloThe Monte Carlo related packages ;  EGParticle Data Group interface ;  Pythia6The Pythia6 interface ;  Pythia8The Pythia8 interface ;  VMCVirtual Monte Carlo ;  ▼PROOFClasses defining the Parallel ROOT Facility, PROOF, a framework for parallel analysis of ROOT TTrees ;  PROOF kernel LibrariesThe PROOF kernel libraries (libProof, libProofPlayer, libProofDraw) contain the classes defining the kernel of the PROOF facility, i.e ;  PROOF benchmark utilitiesSet of utilities to benchmark a PROOF facility ;  XProofD client LibraryThe XProofD client library, libProofx, contain the classes providing the client to interact with the XRootD-based xproofd daemon ;  RooFitRooFit toolkit classes. For documentation see (The RooFit Toolkit for Data Modeling)[http://root.cern.ch/drupal/content/roofit] ;  RooFitCoreCore RooFit classes ;  RooStatsRooStats is a package containing statistical tools built on top of RooFit ;  Tree LibraryTo store large quantities of same-class objects, ROOT provides the TTree and TNtuple classes ;  ▼TutorialsA collection of macros illustrating many aspect of ROOT ;  Cocoa tutorialsVarious examples showing graphics done with Cocoa ;  Containers tutorialsExamples showing the ""containers' classes"" usage. ;  Event display tutorialsExamples showing the ""Event display classes"" usage. ;  Fast Fourier Transforms tutorialsExample showing the Fast Fourier Transforms interface in ROOT ;  Fit TutorialsThese tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code ;  FITS files i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/modules.html:8076,benchmark,benchmark,8076,doc/v608/modules.html,https://root.cern,https://root.cern/doc/v608/modules.html,2,['benchmark'],['benchmark']
Testability," The TRint environment provides an interface to the WM manager functionality and eventloop via inheritance of TApplication and in addition provides interactive access to the Cling C++ interpreter via the command line. ; Definition at line 171 of file TRint.cxx. ◆ ~TRint(). TRint::~TRint ; (; ). virtual . Destructor. ; Definition at line 316 of file TRint.cxx. Member Function Documentation. ◆ Class(). static TClass * TRint::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRint::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRint::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 67 of file TRint.h. ◆ DeclFileName(). static const char * TRint::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 67 of file TRint.h. ◆ ExecLogon(). void TRint::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 341 of file TRint.cxx. ◆ GetInputHandler(). TFileHandler * TRint::GetInputHandler ; (; ). inline . Definition at line 65 of file TRint.h. ◆ GetPrompt(). char * TRint::GetPrompt ; (; ). virtual . Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". ; Definition at line 575 of file TRint.cxx. ◆ HandleException(). void TRint::HandleException ; (; Int_t ; sig). overridevirtual . Handle signals (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:23434,log,logon,23434,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['log'],['logon']
Testability," The conditional `RLogBuilder` use prevents stream operators from being called if; 333 verbosity is too low, i.e.:; 334 ~~~; 335 RLogScopedVerbosity silence(RLogLevel::kFatal);; 336 R__LOG_DEBUG(7) << WillNotBeCalled();; 337 ~~~; 338 - To update counts of warnings / errors / fatal errors, those RLogEntries must; 339 always be created, even if in the end their emission will be silenced. This; 340 should be fine, performance-wise, as they should not happen frequently.; 341 - Use `(condition) && RLogBuilder(...)` instead of `if (condition) RLogBuilder(...)`; 342 to prevent ""ambiguous else"" in invocations such as `if (something) R__LOG_DEBUG()...`.; 343 */; 344#define R__LOG_TO_CHANNEL(SEVERITY, CHANNEL) \; 345 ((SEVERITY < ROOT::Experimental::ELogLevel::kInfo + 0) || \; 346 ROOT::Experimental::Internal::GetChannelOrManager(CHANNEL).GetEffectiveVerbosity( \; 347 ROOT::Experimental::RLogManager::Get()) >= SEVERITY) && \; 348 ROOT::Experimental::Detail::RLogBuilder(SEVERITY, ROOT::Experimental::Internal::GetChannelOrManager(CHANNEL), \; 349 __FILE__, __LINE__, R__LOG_PRETTY_FUNCTION); 350 ; 351/// \name LogMacros; 352/// Macros to log diagnostics.; 353/// ~~~ {.cpp}; 354/// R__LOG_INFO(ROOT::Experimental::HistLog()) << ""all we know is "" << 42;; 355///; 356/// RLogScopedVerbosity verbose(kDebug + 5);; 357/// const int decreasedInfoLevel = 5;; 358/// R__LOG_DEBUG(ROOT::WebGUILog(), decreasedInfoLevel) << ""nitty-gritty details"";; 359/// ~~~; 360///\{; 361#define R__LOG_FATAL(...) R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kFatal, __VA_ARGS__); 362#define R__LOG_ERROR(...) R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kError, __VA_ARGS__); 363#define R__LOG_WARNING(...) R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kWarning, __VA_ARGS__); 364#define R__LOG_INFO(...) R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kInfo, __VA_ARGS__); 365#define R__LOG_DEBUG(DEBUGLEVEL, ...) R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kDebug + DEBUGLEVEL, __VA_ARGS__); 366///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:13211,log,log,13211,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['log'],['log']
Testability," The job is named root-release-<version> and is multi-configuration job. It builds ROOT for a given 'tagged' version using the source distribution tar-file and produces binaries for a number of configurations, which are installed automatically in the download ROOT server.; other procedures. cling-periodic; cling-clone-repo; cling-repo-sync; root-test; root-staticAnalysis-master. Basic operations; Understanding information for a single build; The Status shows a summary for the build. In case of multi-configuration jobs it it also show the configuration matrix that can be used to select a contrete configuration. See the following figure: ; For each individual build (select one cell in the matrix) the following information is provided:. Status. Shows a summary of the build (changes, errors, warnings, git revision, test results, etc.); Changes. Shows the details about the changes since the last build.; Console Output/View as plain text. Shows the full log of the build including all the steps (checkout, configuration, build, running tests, etc.); Parsed Console Output. The same as previous but with warnings and errors selected.; Parameters. The parameters used for the job.; Environment variables. A table with all the environment variables defined for the job.; Test Result. An interface to the CTest tests results. All test, failing and not failing can be shown with their output. Starting and stopping jobs. New jobs can be launched at any time independently of their automatic scheduling (time based or triggered by changes in the GIT repository). This is done by selecting Build with Parameters from the selected project page. This only enabled when your are logged in. Typically the default parameters should be sufficient unless you want to launch a special job.; Jobs (single or multi-configuration) can be stopped by pressing the small cross in the job build history or in the job status page. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-use-root-jenkins.html:4699,log,log,4699,d/how-use-root-jenkins.html,https://root.cern,https://root.cern/d/how-use-root-jenkins.html,2,"['log', 'test']","['log', 'tests']"
Testability," The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:30739,log,log,30739,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,6,['log'],['log']
Testability," The value of the test statistic \( \chi^{2} \) is equal to 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of the two histograms can be accepted for 0.05 significant level. The behavior of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot (see Fig. 1d) of residuals are regular and we cannot identify the outliers or bins with a big influence on \( \chi^{2} \).; The second example presents the same two histograms but 17 events was added to content of bin number 15 in unweighted histogram. Fig.2 shows the result of comparison of the unweighted histogram with 217 events (minimal expected frequency equal to one) and the weighted histogram with 500 events (minimal expected frequency equal to 25); ///. Fig 2. An example of comparison of the unweighted histogram with 217 events and the weighted histogram with 500 events:; unweighted histogram;; weighted histogram;; normalized residuals plot;; normal Q-Q plot of residuals. The value of the test statistic \( \chi^{2} \) is equal to 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of the two histograms is rejected for 0.05 significant level. The behavior of the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see Fig. 2d) of residuals are not regular and we can identify the outlier or bin with a big influence on \( \chi^{2} \).; References:. [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to Association and Normal Correlation. Drapers' Co. Memoirs, Biometric Series No. 1, London.; [2] Gagunashvili, N., 2006. \( \sigma^{2} \) test for comparison of weighted and unweighted histograms. Statistical Problems in Particle Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05, Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44. Gagunashvili,N., Comparison of weighted and unweighted histograms, arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics. Princeton University Press,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:97570,test,test,97570,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability," These are our assumptions: we would like to do selective plotting and loop through each entry of the tree and tracks. We chose a simple example: we want to plot fPx of the first 100 tracks of each entry. We have a ROOT tree with a branch for each data member in the “Event” object. To build this file and tree follow the instructions on how to build the examples in $ROOTSYS/test. Execute Event and instruct it to split the object with this command (from the UNIX command line).; > $ROOTSYS/test/Event 400 1 2 1; This creates an Event.root file with 400 events, compressed, split, and filled.; See $ROOTSYS/test/MainEvent.cxx for more info.; The person who designed the tree makes a shared library available to you, which defines the classes needed. In this case, the classes are Event, EventHeader, and Track and they are defined in the shared library libEvent.so. The designer also gives you the Event.h file to see the definition of the classes. You can locate Event.h in $ROOTSYS/test, and if you have not yet built libEvent.so, please see the instructions of how to build it (typing make in $ROOTSYS/test is enough). If you have already built it, you can now use it again.; 12.21.1 Creating a Class with MakeClass; First, we load the shared library and open Event.root.; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; We can see there is a tree “T”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches.; root[] T->Print();; From the output of print we can see that the tree has one branch for each data member of Event, Track, and EventHeader. Now we can use TTree::MakeClass on our tree “T”. MakeClass takes one parameter, a string containing the name of the class to be made. In the command below, the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:635504,test,test,635504,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability," This situation happens when the top level object; 1790/// has two or more members referencing the same class.; 1791/// For example, if a Tree has two branches B1 and B2 corresponding; 1792/// to objects of the same class MyClass, one can do:; 1793/// ~~~ {.cpp}; 1794/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 1795/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 1796/// ~~~; 1797/// if MyClass has 3 members a,b,c, the two instructions above will generate; 1798/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 1799///; 1800/// Example:; 1801/// ~~~ {.cpp}; 1802/// {; 1803/// TTree T(""T"",""test list"");; 1804/// TList *list = new TList();; 1805///; 1806/// TObjArray *a1 = new TObjArray();; 1807/// a1->SetName(""a1"");; 1808/// list->Add(a1);; 1809/// TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; 1810/// TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; 1811/// a1->Add(ha1a);; 1812/// a1->Add(ha1b);; 1813/// TObjArray *b1 = new TObjArray();; 1814/// b1->SetName(""b1"");; 1815/// list->Add(b1);; 1816/// TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; 1817/// TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; 1818/// b1->Add(hb1a);; 1819/// b1->Add(hb1b);; 1820///; 1821/// TObjArray *a2 = new TObjArray();; 1822/// a2->SetName(""a2"");; 1823/// list->Add(a2);; 1824/// TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; 1825/// TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; 1826/// a2->Add(ha2a);; 1827/// a2->Add(ha2b);; 1828///; 1829/// T.Branch(list,16000,2);; 1830/// T.Print();; 1831/// }; 1832/// ~~~; 1833 ; 1834Int_t TTree::Branch(TCollection* li, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */, const char* name /* = """" */); 1835{; 1836 ; 1837 if (!li) {; 1838 return 0;; 1839 }; 1840 TObject* obj = nullptr;; 1841 Int_t nbranches = GetListOfBranches()->GetEntries();; 1842 if (li->InheritsFrom(TClonesArray::Class())) {; 1843 Error(""Branch"", ""Cannot call this constructor for a TClonesArray"");; 1844 return 0;; 1845 }; 1846 Int_t nch = strlen(name);; 1847 TString branchname;; 1848 TI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:70965,test,test,70965,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['test'],['test']
Testability," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16873,log,log,16873,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['log'],['log']
Testability," To calculate the integral over mean, just interchange the respective values of x and mean. Parameters. xMinMinimum value of variable to integrate wrt. ; xMaxMaximum value of of variable to integrate wrt. ; meanMean. ; sigmaSigma. . ReturnsThe integral of an un-normalized RooGaussian over the value in x. ; Definition at line 418 of file MathFuncs.h. ◆ getUniformBinning(). unsigned int RooFit::Detail::MathFuncs::getUniformBinning ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins . ). inline . Definition at line 172 of file MathFuncs.h. ◆ interpolate1d(). double RooFit::Detail::MathFuncs::interpolate1d ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins, . double const * ; vals . ). inline . Definition at line 178 of file MathFuncs.h. ◆ landau(). double RooFit::Detail::MathFuncs::landau ; (; double ; x, . double ; mu, . double ; sigma . ). inline . Definition at line 331 of file MathFuncs.h. ◆ logNormal(). double RooFit::Detail::MathFuncs::logNormal ; (; double ; x, . double ; k, . double ; m0 . ). inline . Definition at line 338 of file MathFuncs.h. ◆ logNormalIntegral(). double RooFit::Detail::MathFuncs::logNormalIntegral ; (; double ; xMin, . double ; xMax, . double ; m0, . double ; k . ). inline . Definition at line 627 of file MathFuncs.h. ◆ logNormalIntegralStandard(). double RooFit::Detail::MathFuncs::logNormalIntegralStandard ; (; double ; xMin, . double ; xMax, . double ; mu, . double ; sigma . ). inline . Definition at line 638 of file MathFuncs.h. ◆ logNormalStandard(). double RooFit::Detail::MathFuncs::logNormalStandard ; (; double ; x, . double ; sigma, . double ; mu . ). inline . Definition at line 343 of file MathFuncs.h. ◆ nll(). double RooFit::Detail::MathFuncs::nll ; (; double ; pdf, . double ; weight, . int ; binnedL, . int ; doBinOffset . ). inline . Definition at line 353 of file MathFuncs.h. ◆ poisson(). double RooFit::Detail::MathFuncs::poisson ; (; double ; x, . double ; par . ). inline . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html:8745,log,logNormal,8745,doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,https://root.cern,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,1,['log'],['logNormal']
Testability," To retrieve a function by name from this list, do: TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);; or TF1 *f1 = h->GetFunction(name);; Associated functions are automatically painted when an histogram is drawn. To avoid the painting of the associated functions the option HIST should be added to the list of the options used to paint the histogram. Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D graphics library. The plotting options start with GL keyword. In addition, in order to inform canvases that OpenGL should be used to render 3D representations, the following option should be set: gStyle->SetCanvasPreferGL(true);; General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. Option Description . ""GLLEGO"" Draw a lego plot. It works also for TH2Poly. . ""GLLEGO2"" Bins with color levels. . ""GLLEGO3"" Cylindrical bars. . Lego painter in cartesian supports logarithmic scales for X, Y, Z. In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. Option Description . ""GLSURF"" Draw a surface. . ""GLSURF1"" Surface with color levels . ""GLSURF2"" The same as ""GLSURF1"" but without polygon outlines. . ""GLSURF3"" Color level projection on top of plot (works only in cartesian coordinate system). . ""GLSURF4"" Same as ""GLSURF"" but without polygon outlines. . The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. Option Description . "" "" Default, cartesian coordinates system. . ""POL"" Polar coordinates system. . ""CYL"" Cylindrical coordinates system. . ""SPH"" Spherical coordinates system. . TH3 as color boxes; The supported option is:. Option Description . ""GLCOL"" H3 is drawn using semi-transp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:123964,log,logarithmic,123964,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['log'],['logarithmic']
Testability, Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation ROOT User Guides and Manuals. ROOT Guides. Title; Quick Link; All Links. Reference Guide; head / 6.08; all releases. User's Guide; 6 Series (html); all formats and series. ROOT Primer - Notebook Version (beta); html pdf GitHub / SWAN; *. ROOT Primer; 6 Series (html); all formats and series. ROOT Primer 5; 5 Series (pdf). Topical Manuals. Title; Quick Link; All Links. RooFit; Manual (pdf) / Quick Start Guide (pdf); other formats. HTTP Server; 6 Series (html); all versions. JSROOT; 6 Series (html); all versions. CERNLib; (pdf); -. Minuit; (pdf); -. Minuit2; 6 Series (html); all formats and series. TSpectrum; 6 Series (html); all formats and series. TMVA; 6 Series (pdf); other links. PROOF; Drupal Book; other resources. VMC; Drupal Book; -. In a Nutshell. Title; Link. Input and Output; Drupal. Trees in 5 steps; Drupal. Interpreter; Drupal Book. Cling; Drupal Book. Math Libraries; Drupal Book. 2D-graphics; Drupal Book. 3D-graphics; Drupal Book. RooFit in 20 Minutes; Drupal. The ROOT GUI Classes; Drupal. Introduction to Cint; Drupal. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-user-guides-and-manuals.html:3461,test,tests,3461,d/root-user-guides-and-manuals.html,https://root.cern,https://root.cern/d/root-user-guides-and-manuals.html,1,['test'],['tests']
Testability," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:7694,test,testing,7694,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,5,['test'],['testing']
Testability," Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Release Checklist. Steps to be followed to produce a new ROOT release are:; Prerequisites. Get the 'green' light from all main developers; Check that all the Jenkins builds / CDash builds are green; Verify that no performance regressions exist in the benchmark system; Update versions in JIRA. 'Release' the version in the project configuration; Create the next development version. root.git. Update the release notes in README/ReleaseNotes/vXXX/index.md. Edit release notes patches section; From the list the versions in JIRA, select the version and then 'release notes'; git commit README/ReleaseNotes/vXXX/index.md. Modify version number and modify all necessary files. edit build/version_number (even patch number for releases); Run from the build directory $ make version. Tag main ROOT repository. $ git tag -a vX-YY-ZZ; Run $ cmake . to update etc/gitinfo.txt. Create the source tarball. Run from the build directory $ make distsrc not on a MacOS machine; $ scp ../root_vX.YY.ZZ.source.tar.gz sftnight@root:/home/www/root/download. Update the release notes in README/ReleaseNotes/vXXX/index.md again. edit README/ReleaseNotes/vXXX/index.md; possibly copying from README/ReleaseNotes/em",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/release-checklist.html:2117,benchmark,benchmark,2117,d/release-checklist.html,https://root.cern,https://root.cern/d/release-checklist.html,1,['benchmark'],['benchmark']
Testability, Two-dimensional kernel estimation p.d.f.; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-d,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:25393,test,test,25393,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['test'],['test']
Testability," Typedefs |; Enumerations |; Functions |; Variables ; ROOT::Experimental Namespace Reference. Namespaces; namespace  Detail;  ; namespace  EveGlu;  ; namespace  Hist;  ; namespace  Internal;  ; namespace  XRooFit;  xRooFit is a high-level API for RooFit. ;  . Classes; struct  HasCollectionProxyMemberType;  ; struct  HasCollectionProxyMemberType< T, typename std::enable_if< std::is_same< typename T::IsCollectionProxy, std::true_type >::value >::type >;  ; struct  IsCollectionProxy;  The point here is that we can only tell at run time if a class has an associated collection proxy. More...;  ; class  RArrayAsRVecField;  A field for fixed-size arrays that are represented as RVecs in memory. More...;  ; class  RArrayField;  The generic field for fixed size arrays, which do not need an offset column. More...;  ; class  RAtomicField;  ; class  RAttrAggregation;  Base class for attributes aggregations like lines or fill attributes. More...;  ; class  RAttrAxis;  All supported axes attributes for: line, ticks, labels, title, min/max, log, reverse, ... More...;  ; class  RAttrAxisLabels;  Axis labels drawing attributes. More...;  ; class  RAttrAxisTicks;  Axis ticks attributes. More...;  ; class  RAttrAxisTitle;  Axis title and its drawing attributes. More...;  ; class  RAttrBase;  Base class for all attributes, used with RDrawable. More...;  ; class  RAttrBorder;  Drawing line attributes for different objects. More...;  ; class  RAttrFill;  Drawing fill attributes for different objects. More...;  ; class  RAttrFont;  A font attributes, used together with text attributes. More...;  ; class  RAttrLine;  Drawing line attributes for different objects. More...;  ; class  RAttrLineEnding;  Attributes for line ending. More...;  ; class  RAttrMap;  ; class  RAttrMargins;  A margins attributes. Only relative and pixel coordinates are allowed. More...;  ; class  RAttrMarker;  A marker attributes. More...;  ; class  RAttrText;  A text attributes. More...;  ; class  RAttrValue;  Template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:1193,log,log,1193,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['log'],['log']
Testability," UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!); static Bool_tfgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLogicalShape(); Constructor. TGLLogicalShape(TObject* obj); Constructor with external object. TGLLogicalShape(const TBuffer3D& buffer); Constructor from TBuffer3D. ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:5571,log,logical,5571,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,4,['log'],['logical']
Testability," Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; . Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent. Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. Philip R. Bevin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiDimFit.html:11640,Test,Testing,11640,root/html532/TMultiDimFit.html,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html,1,['Test'],['Testing']
Testability," Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ; Definition at line 2860 of file RooAbsReal.cxx. ◆ preferredObservableScanOrder(). void RooAbsReal::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. virtual . Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ; The observables to be ordered are offered in argument 'obs' and should be copied in their preferred order into argument 'orderedObs', This default implementation indicates no preference and copies the original order of 'obs' into 'orderedObs' ; Reimplemented in RooIntegralMorph, and RooCachedPdf.; Definition at line 3694 of file RooAbsReal.cxx. ◆ printEvalErrors(). void RooAbsReal::printEvalErrors ; (; std::ostream & ; os = std::cout, . Int_t ; maxPerNode = 10000000 . ). static . Print all outstanding logged evaluation error on the given ostream. ; If maxPerNode is zero, only the number of errors for each source (object with unique name) is listed. If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown per source of errors. A truncation message is shown if there were more errors logged than shown. ; Definition at line 3582 of file RooAbsReal.cxx. ◆ printMultiline(). void RooAbsReal::printMultiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Structure printing. ; Reimplemented from RooAbsArg.; Reimplemented in RooGenericPdf, RooResolutionModel, RooAbsRealLValue, RooFormulaVar, RooRealIntegral, and RooRealVar.; Definition at line 455 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 445 of file RooAbsReal.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:141317,log,logged,141317,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['log'],['logged']
Testability," V >;  CTSplitterSelector< TH3C, V >;  CTSplitterSelector< TH3D, V >;  CTSplitterSelector< TH3F, V >;  CTSplitterSelector< TH3I, V >;  CTSplitterSelector< TH3S, V >;  CTSplitterSelector< TKDEFGT, V >;  ►NPad;  CBoundingRect;  CFillAttribSet;  CGLLimits;  CLineAttribSet;  CMarkerPainter;  CMeshPatch_t;  COffScreenDevice;  CPolygonStippleSet;  CTesselator;  CPlotTranslation;  CTGuardBase;  CTOneArgGuard;  CTTwoArgsGuard;  ►NRooStatsNamespace for the RooStats classes ;  ►NHistFactory;  CAsimov;  CChannel;  CConfigParser;  CData;  ►CEstimateSummary;  CNormFactor;  CShapeSys;  CFlexibleInterpVar;  Chf_exc;  CHistFactoryNavigation;  CHistFactorySimultaneous;  CHistoFactor;  CHistoSys;  CHistoToWorkspaceFactory;  CHistoToWorkspaceFactoryFast;  CHistRef;  CLinInterpVar;  CMeasurement;  CNormFactor;  COverallSys;  CPreprocessFunction;  ►CRooBarlowBeestonLL;  CBarlowCache;  CSample;  CShapeFactor;  CShapeSys;  CStatError;  CStatErrorConfig;  CAcceptanceRegion;  CAsymptoticCalculatorHypothesis Test Calculator based on the asymptotic formulae for the profile likelihood ratio ;  CBayesianCalculatorBayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregator;  CFeldmanCousins(like the Feldman-Cousins technique) is essentially a specific configuration of the more general NeymanConstruction ;  CFrequentistCalculatorHypothesis Test Calculator using a full frequentist procedure for s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:3754,Test,Test,3754,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['Test'],['Test']
Testability," Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual void AddWeightsXMLTo (void *parent) const =0;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false)=0;  get all the MVA values for the events of the current Data type ;  ; void PyRunString (TString code, TString errorMessage=""Failed to run python code"", int start=256);  Execute Python code from string. ;  ; virtual void ReadModelFromFile ()=0;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *wghtnode)=0;  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVarName (Int_t ivar) const;  ; const TString & GetOriginalVarName (Int_t ivar) const;  ; const TString & GetWeightFileDir () const;  ; Bool_t HasTrainingTree () const;  ; Bool_t Help () const;  ; Bool_t IgnoreEventsWithNegWeightsInTraining () const;  ; Bool_t IsConstructedFromWeightFile () con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html:24163,log,logProgress,24163,doc/master/classTMVA_1_1PyMethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html,1,['log'],['logProgress']
Testability, [#0] PROGRESS:Generation -- RooMCStudy::run: sample 440; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 430; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-926.481) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.653979 a1=-0.469539 mean=5.00078 nbkg=160.963 nsig=166.526 sig1frac=0.628924; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 420; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-768.847) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.749295 a1=-0.303934 mean=4.98272 nbkg=121.461 nsig=145.338 sig1frac=0.822833; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-798.509) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.791035 a1=-0.287544 mean=4.98693 nbkg=127.577 nsig=149.203 sig1frac=0.914567; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 410; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 400; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 390; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-977.775) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.565967 a1=-0.529635 mean=5.0065 nbkg=153.38 nsig=185.083 sig1frac=0.751239; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 380; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 370; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-945.036) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.82434,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:19713,log,log,19713,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability," [1/2]. TMVA::SVKernelMatrix::SVKernelMatrix ; (; ). constructor ; Definition at line 53 of file SVKernelMatrix.cxx. ◆ SVKernelMatrix() [2/2]. TMVA::SVKernelMatrix::SVKernelMatrix ; (; std::vector< TMVA::SVEvent * > * ; inputVectors, . SVKernelFunction * ; kernelFunction . ). constructor ; Definition at line 64 of file SVKernelMatrix.cxx. ◆ ~SVKernelMatrix(). TMVA::SVKernelMatrix::~SVKernelMatrix ; (; ). destructor ; Definition at line 87 of file SVKernelMatrix.cxx. Member Function Documentation. ◆ GetColumn(). Float_t * TMVA::SVKernelMatrix::GetColumn ; (; UInt_t ; col). inline . Definition at line 54 of file SVKernelMatrix.h. ◆ GetElement(). Float_t TMVA::SVKernelMatrix::GetElement ; (; UInt_t ; i, . UInt_t ; j . ). returns an element of the kernel matrix ; Definition at line 119 of file SVKernelMatrix.cxx. ◆ GetLine(). Float_t * TMVA::SVKernelMatrix::GetLine ; (; UInt_t ; line). returns a row of the kernel matrix ; Definition at line 100 of file SVKernelMatrix.cxx. ◆ Log(). MsgLogger & TMVA::SVKernelMatrix::Log ; (; ); const. inlineprivate . Definition at line 64 of file SVKernelMatrix.h. Member Data Documentation. ◆ fKernelFunction. SVKernelFunction* TMVA::SVKernelMatrix::fKernelFunction. private . kernel function ; Definition at line 60 of file SVKernelMatrix.h. ◆ fLogger. MsgLogger* TMVA::SVKernelMatrix::fLogger. mutableprivate . ! message logger ; Definition at line 63 of file SVKernelMatrix.h. ◆ fSize. UInt_t TMVA::SVKernelMatrix::fSize. private . matrix size ; Definition at line 59 of file SVKernelMatrix.h. ◆ fSVKernelMatrix. Float_t** TMVA::SVKernelMatrix::fSVKernelMatrix. private . kernel matrix ; Definition at line 61 of file SVKernelMatrix.h. Libraries for TMVA::SVKernelMatrix:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/SVKernelMatrix.h; tmva/tmva/src/SVKernelMatrix.cxx. TMVASVKernelMatrix. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:43 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SVKernelMatrix.html:2486,log,logger,2486,doc/master/classTMVA_1_1SVKernelMatrix.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SVKernelMatrix.html,1,['log'],['logger']
Testability," []. Important tip: log messages have an optional structure, since many git commands only look at the first line. Get into the habit of putting only a short synopsis on the first line of a log message and putting more detailed information on subsequent lines. You can omit the -m option entirely and an editor (as specified with VISUAL or EDITOR) will be started.; This command is extremely versatile. You may want to have a couple of aliases defined in your .gitconfig file (see attached gitconfig for ideas). Working in your local repository. Obtain differences with; git status. Move files from one part of your directory tree to another:; git mv <old-path> <new-path>. Delete unwanted tracked files:; git rm <path>. Add un-tracked files:; git add <un-tracked-file>. Stage a modified file for commit:; git add <file>. Commit currently-staged files:; git commit -m <log-message>. Commit only specific files (regardless of what is staged):; git commit -m <log-message>. Commit all modified files:; git commit -a -m <log-message>. Un-stage a previously staged (but not yet committed) file:; git reset HEAD <file>. Examine a representation of your change tree with log files and patch descriptions:; gitk. Get differences with respect to the committed (or staged) version of a file:; git diff <file>. Get differences between local file and committed version:; git diff --cached <file>. Basic interaction with local branches. Create (but do not switch to) a new local branch based on the current branch:; git branch <new-branch>. Create and switch to a local branch based on the current branch:; git checkout -b <new-branch>. Change to an existing local branch:; git checkout <branch>. Examine the list of commits in the current branch not reflected in another branch:; git cherry -v <branch>. Merge another branch into the current one:; git merge <branch>. Delete a local branch (eg after merging):; git branch -d <branch>. OR (if changes have not been completely merged but you're sure you want to de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:7947,log,log-message,7947,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['log'],['log-message']
Testability," \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:48637,log,logger,48637,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability, ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: MLPBNN; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; MLPBNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: DNN_CPU; : ; DNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: SVM; : ; TFHandler_SVM : Variable Mean RMS [ Min Max ]; : -----,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:75432,test,test,75432,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['test']
Testability," _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:49680,log,logger,49680,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability," _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:49792,log,logger,49792,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability," a 3D box.; TGLBContainer Listbox container; TGLBEntry Basic listbox entry; TGLBoundingBox a 3D orientated bounding box; TGLBoxCut Cuts away part of a plot.; TGLBoxPainter Box painter; TGLCamera Camera abstract base class.; TGLCameraGuide Short description.; TGLCameraOverlay Show coorinates of current camera frustum.; TGLClip abstract clipping object; TGLClipBox clipping box; TGLClipPlane clipping plane; TGLClipSet A collection of supported clip-objects; TGLClipSetEditor GUI editor for TGLClipSet.; TGLClipSetSubEditor Sub-editor for TGLClipSet.; TGLColor Color in preferred GL format - RGBA.; TGLColorSet Collection of colors used for GL rendering.; TGLContext Control internal gl-context resources.; TGLContextIdentity Identity of a shared GL context.; TGLCylinder a cylinderical logical shape; TGLEmbeddedViewer Embedded GL viewer.; TGLEventHandler Base-class and default implementation of event-handler for TGLViewer.; TGLFBO Frame-buffer object.; TGLFaceSet a faceset logical shape; TGLFaderHelper ; TGLFont A wrapper class for FTFont.; TGLFontManager A FreeType GL font manager.; TGLFormat Describes GL buffer format.; TGLH2PolyPainter Painter class for TH2Poly.; TGLHistPainter Proxy class for GL hist painters.; TGLIsoPainter Iso option for TH3.; TGLLegoPainter Lego painter; TGLLightSet A set of OpenGL lights.; TGLLightSetEditor Editor for TGLLightSet.; TGLLightSetSubEditor Sub-editor for TGLLightSet.; TGLLine3 GL line wrapper class; TGLLockable Lock for viewers and scenes.; TGLLogicalShape a logical (non-placed, local frame) drawable object; TGLManager Interface for OpenGL manager; TGLManip abstract base GL manipulator widget; TGLManipSet A collection of available manipulators.; TGLMatrix GL matrix helper/wrapper class; TGLObject Base-class for direct OpenGL renderers; TGLOrthoCamera Camera for orthographic view.; TGLOutput Wrapper class for GL capture & output routines; TGLOverlayButton GL-overlay button.; TGLOverlayElement Base class for GL overlay elements.; TGLOverlay",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:76510,log,logical,76510,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,9,['log'],['logical']
Testability," a ModelConfig. ; constructor from a Model Config with a basic settings package configured by SetupBasicUsage(); Uses a UniformProposal, 10,000 iterations, 40 burn in steps, 50 bins for each RooRealVar, determines interval by histogram, and finds a 95% confidence interval. Any of these basic settings can be overridden by calling one of the Set...() methods. ; Definition at line 72 of file MCMCCalculator.cxx. Member Function Documentation. ◆ Class(). static TClass * RooStats::MCMCCalculator::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooStats::MCMCCalculator::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooStats::MCMCCalculator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 204 of file MCMCCalculator.h. ◆ ConfidenceLevel(). double RooStats::MCMCCalculator::ConfidenceLevel ; (; ); const. inlineoverridevirtual . Get the Confidence level for the test. ; Implements RooStats::IntervalCalculator.; Definition at line 50 of file MCMCCalculator.h. ◆ DeclFileName(). static const char * RooStats::MCMCCalculator::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 204 of file MCMCCalculator.h. ◆ GetInterval(). MCMCInterval * MCMCCalculator::GetInterval ; (; ); const. overridevirtual . Main interface to get a ConfInterval. ; Main interface to get a RooStats::ConfInterval. ; Implements RooStats::IntervalCalculator.; Definition at line 139 of file MCMCCalculator.cxx. ◆ IsA(). TClass * RooStats::MCMCCalculator::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooStats::IntervalCalculator.; Definition at line 204 of file MCMCCalculator.h. ◆ SetAxes(). virtual void RooStats::MCMCCalculator::SetAxes ; (; RooArgList & ; axes). inlinevirtual . set which variables to put on each axis ; Definition at line 103 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html:19346,test,test,19346,doc/master/classRooStats_1_1MCMCCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html,1,['test'],['test']
Testability, a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  SQLiteIPLocation.C ;  SQLitePlatformDistribution.C ;  SQLiteTimeVersionOfRoot.C ;  SQLiteVersionsOfRoot.C ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the gen,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:164842,test,testing,164842,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['test'],['testing']
Testability," a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:12059,test,test,12059,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['test'],['test']
Testability," a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:55563,test,test,55563,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['test'],['test']
Testability," a copy of the GNU General Public License *; 20 * along with this library (see file COPYING); if not, write *; 21 * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; 22 * 330, Boston, MA 02111-1307 USA, or contact the author. *; 23 * *; 24 **********************************************************************/; 25 ; 26// Implementation file for class Vavilov; 27//; 28// Created by: blist at Thu Apr 29 11:19:00 2010; 29//; 30// Last update: Thu Apr 29 11:19:00 2010; 31//; 32 ; 33 ; 34#include ""Math/Vavilov.h""; 35#include ""Math/VavilovAccurate.h""; 36#include ""Math/SpecFuncMathCore.h""; 37#include ""Math/SpecFuncMathMore.h""; 38 ; 39#include <cmath>; 40 ; 41namespace ROOT {; 42namespace Math {; 43 ; 44static const double eu = 0.577215664901532860606; // Euler's constant; 45 ; 46Vavilov::Vavilov(); 47{; 48}; 49 ; 50Vavilov::~Vavilov(); 51{; 52 // destructor (clean up resources); 53}; 54 ; 55 ; 56double Vavilov::Mode() const {; 57 double x = -4.22784335098467134e-01-std::log(GetKappa())-GetBeta2();; 58 if (x>-0.223172) x = -0.223172;; 59 double eps = 0.01;; 60 double dx;; 61 ; 62 do {; 63 double p0 = Pdf (x - eps);; 64 double p1 = Pdf (x);; 65 double p2 = Pdf (x + eps);; 66 double y1 = 0.5*(p2-p0)/eps;; 67 double y2 = (p2-2*p1+p0)/(eps*eps);; 68 dx = - y1/y2;; 69 x += dx;; 70 if (fabs(dx) < eps) eps = 0.1*fabs(dx);; 71 } while (fabs(dx) > 1E-5);; 72 return x;; 73}; 74 ; 75double Vavilov::Mode(double kappa, double beta2) {; 76 SetKappaBeta2 (kappa, beta2);; 77 return Mode();; 78}; 79 ; 80double Vavilov::Mean() const {; 81 return Mean (GetKappa(), GetBeta2());; 82}; 83 ; 84double Vavilov::Mean(double kappa, double beta2) {; 85 return eu-1-std::log(kappa)-beta2;; 86}; 87 ; 88double Vavilov::Variance() const {; 89 return Variance (GetKappa(), GetBeta2());; 90}; 91 ; 92double Vavilov::Variance(double kappa, double beta2) {; 93 return (1-0.5*beta2)/kappa;; 94}; 95 ; 96double Vavilov::Skewness() const {; 97 return Skewness (GetKappa(), GetBeta2());; 98}; 99 ; 100dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Vavilov_8cxx_source.html:1969,log,log,1969,doc/master/Vavilov_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Vavilov_8cxx_source.html,1,['log'],['log']
Testability," a log transformation"");; 370 return *this;; 371 }; 372 ; 373 fData[i] = std::log( val );; 374 ; 375 if( kNoError == fErrorType ); 376 {; 377 fDataError[i] = val;; 378 }; 379 else if ( kValueError == fErrorType ); 380 {; 381 fDataError[i]*= val;; 382 }; 383 else if ( kCoordError == fErrorType ); 384 {; 385 fDataError[i]/= val;; 386 }; 387 else if ( kAsymError == fErrorType ); 388 {; 389 fDataErrorHigh[i]/= val;; 390 fDataErrorLow[i]/= val;; 391 }; 392 else; 393 assert(false);; 394 }; 395 ; 396 if ( kNoError == fErrorType ); 397 {; 398 fErrorType = kValueError;; 399 }; 400 ; 401 return *this;; 402 }; 403 ; 404 ; 405 /**; 406 add one dim data with only coordinate and values; 407 */; 408 void BinData::Add( double x, double y ); 409 {; 410 assert( kNoError == fErrorType );; 411 ; 412 assert( !fData.empty() && fDataPtr );; 413 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 414 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 415 assert( fDataError.empty() && !fDataErrorPtr );; 416 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 417 ; 418 fData[ fNPoints ] = y;; 419 ; 420 FitData::Add( x );; 421 fSumContent += y;; 422 }; 423 ; 424 /**; 425 add one dim data with no error in the coordinate (x); 426 in this case store the inverse of the error in the value (y); 427 */; 428 void BinData::Add( double x, double y, double ey ); 429 {; 430 assert( kValueError == fErrorType );; 431 assert( !fData.empty() && fDataPtr );; 432 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444 if (!fIsWeighted); 445 if (y != 0 && std::abs( ey*ey/y ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:12072,assert,assert,12072,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability," a patch for retrieval later. Also the act of putting changes onto this stack.; Tag: human-readable label for a particular state of the tree. Tags may be simple (in which case they are actually branches) or annotated (analogous to a CVS tag), with an associated SHA1 hash and message. Annotated tags are preferable in general.; Tracking branch: a branch on a remote which is the default source / sink for pull / push operations respectively for the current branch. For instance, origin/master is the tracking branch for the local master in a local repository.; Tree-ish: a ref pointing to either a commit object, a tree object, or a tag object pointing to a tag or commit or tree object.; Un-tracked: not known currently to git. Initializing a repository; git clone <repository-spec> <local-dir>. or; mkdir <local-dir>; cd <local-dir>; git init. or (FNAL Redmine-specific); rclone [-r <repo>] <project> <local-name>. where rclone is defined in cet-chg:export:unix-admin/profile.d/rclone.sh ; Basic log information.>; git log []. Important tip: log messages have an optional structure, since many git commands only look at the first line. Get into the habit of putting only a short synopsis on the first line of a log message and putting more detailed information on subsequent lines. You can omit the -m option entirely and an editor (as specified with VISUAL or EDITOR) will be started.; This command is extremely versatile. You may want to have a couple of aliases defined in your .gitconfig file (see attached gitconfig for ideas). Working in your local repository. Obtain differences with; git status. Move files from one part of your directory tree to another:; git mv <old-path> <new-path>. Delete unwanted tracked files:; git rm <path>. Add un-tracked files:; git add <un-tracked-file>. Stage a modified file for commit:; git add <file>. Commit currently-staged files:; git commit -m <log-message>. Commit only specific files (regardless of what is staged):; git commit -m <log-message>. Commit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:6904,log,log,6904,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['log'],['log']
Testability," a pseudorapidity smaller or equal to 2 and with a transverse momentum greater than 10 GeV. Such a selection would require, among the other things, the management of an explicit loop, for example: std::vector<float> goodMuons_pt;; const auto size = mu_charge.size();; for (size_t i=0; i < size; ++i) {; if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; goodMuons_pt.emplace_back(mu_pt[i]);; }; }; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::VecOps::absRVec< PromoteType< T > > abs(const RVec< T > &v)Definition RVec.hxx:1832; These operations become straightforward with RVec - we just need to write what we mean: auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; Now the clean collection of transverse momenta can be used within the rest of the data analysis, for example to fill a histogram. Arithmetic operations, logical operations and mathematical functions; Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied. RVec<double> v1 {1.,2.,3.,4.};; RVec<float> v2 {5.f,6.f,7.f,8.f};; auto v3 = v1+v2;; auto v4 = 3 * v1;; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; v2@ v2Definition rootcling_impl.cxx:3690; v4@ v4Definition rootcling_impl.cxx:3692; v3@ v3Definition rootcling_impl.cxx:3691; v1@ v1Definition rootcling_impl.cxx:3689; The supported operators are; +, -, *, /; +=, -=, *=, /=; <, >, ==, !=, <=, >=, &&, ||; ~, !; &, |, ^; &=, |=, ^=; <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is availab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:3274,log,logical,3274,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,1,['log'],['logical']
Testability," a pseudorapidity smaller or equal to 2 and with a transverse momentum greater than 10 GeV. Such a selection would require, among the other things, the management of an explicit loop, for example: std::vector<float> goodMuons_pt;; const auto size = mu_charge.size();; for (size_t i=0; i < size; ++i) {; if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; goodMuons_pt.emplace_back(mu_pt[i]);; }; }; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::VecOps::absRVec< PromoteType< T > > abs(const RVec< T > &v)Definition RVec.hxx:1832; These operations become straightforward with RVec - we just need to write what we mean: auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; Now the clean collection of transverse momenta can be used within the rest of the data analysis, for example to fill a histogram. Arithmetic operations, logical operations and mathematical functions; Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied. RVec<double> v1 {1.,2.,3.,4.};; RVec<float> v2 {5.f,6.f,7.f,8.f};; auto v3 = v1+v2;; auto v4 = 3 * v1;; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; v2@ v2Definition rootcling_impl.cxx:3702; v4@ v4Definition rootcling_impl.cxx:3704; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; The supported operators are; +, -, *, /; +=, -=, *=, /=; <, >, ==, !=, <=, >=, &&, ||; ~, !; &, |, ^; &=, |=, ^=; <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is availab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html:3275,log,logical,3275,doc/master/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html,1,['log'],['logical']
Testability," a, Int_t first, Int_t last); static voidTSeqCollection::QSort(TObject** a, TObject** b, Int_t first, Int_t last); static voidTSeqCollection::QSort(TObject** a, Int_t nBs, TObject*** b, Int_t first, Int_t last); Int_tRank(const TObject* obj) const; virtual Int_tTObject::Read(const char* name); virtual voidTCollection::RecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); virtual voidTSeqCollection::RemoveAfter(TObject* after); voidTCollection::RemoveAll(); virtual voidTCollection::RemoveAll(TCollection* col); virtual TObject*TSeqCollection::RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTCollection::SetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBtree.html:14469,Test,TestBit,14469,root/html532/TBtree.html,https://root.cern,https://root.cern/root/html532/TBtree.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," a,Double_t x);; 42 Double_t GamSer(Double_t a,Double_t x);; 43 Double_t VavilovDenEval(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype);; 44 void VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt);; 45 ; 46}; 47 ; 48////////////////////////////////////////////////////////////////////////////////; 49/// Returns `sqrt(x*x + y*y)`; 50 ; 51Long_t TMath::Hypot(Long_t x, Long_t y); 52{; 53 return (Long_t) (hypot((Double_t)x, (Double_t)y) + 0.5);; 54}; 55 ; 56////////////////////////////////////////////////////////////////////////////////; 57/// Returns `sqrt(x*x + y*y)`; 58 ; 59Double_t TMath::Hypot(Double_t x, Double_t y); 60{; 61 return hypot(x, y);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Returns the area hyperbolic sine of `x`.; 66 ; 67Double_t TMath::ASinH(Double_t x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112/////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:2442,log,log,2442,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['log'],['log']
Testability," a; Hidden Line Mode eRotate about yy b; Hidden Surface Mode rRotate about zz c; Move object down uAuto-rotate about x1 2 3; Move object up iAuto-rotate about y4 5 6; Move object left lAuto-rotate about z7 8 9; Move object right hToggle controls styleo; Move object forward jToggle stereo displays; Move object backward kToggle blue stereo viewd; Adjust focus (stereo mode) [ ] { }Toggle double bufferf; Rotate object Left mouse button down + move.; 9.13.4 Common 3D Viewer Architecture; The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.; Producer code free of explicit drawing commands & viewer specific branching.; Support differing viewers and clients capabilities, e.g.; Mix of native (in viewer) shapes and generic client side tessellation.; Local/global frame object description; Bounding boxes; Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to add objects, test preferences etc.; TBuffer3D class hierarchy: Used to describe 3D objects (“shapes”) - filled /added by negotiation with viewer via TVirtualViewer3D. A typical interaction between viewer and client using these, taken from TGeoPainter is:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:402190,log,logical,402190,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['log'],['logical']
Testability," actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:18753,log,logging,18753,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,6,['log'],['logging']
Testability," adding the object h2 to the pad’s list of primitives. It does not paint the object on the screen. However, TTree::Draw when called with option “same” gets the current pad coordinates to build an intermediate histogram with the right limits. Since nothing has been painted in the pad yet, the pad limits have not been computed. Calling pad->Update() forces the painting of the pad and allows TTree::Draw to compute the right limits for the intermediate histogram.; 12.20.6 Setting the Range in TTree::Draw; There are two more optional parameters to the TTree::Draw method: one is the number of entries and the second one is the entry to start with. For example, this command draws 1000 entries starting with entry 100:; myTree->Draw(""Cost:Age"", """","""",1000,100);; 12.20.7 TTree::Draw Examples; The examples below use the Event.root file generated by the $ROOTSYS/test/Event executable and the Event, Track, and EventHeader class definitions are in $ROOTSYS/test/Event.h. The commands have been tested on the split-levels 0, 1, and 9. Each command is numbered and referenced by the explanations immediately following the examples.; // Data members and methods; 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""fMatrix - fVertex"");; 16 tree->Draw(""fMatrix[2][1] - fVertex[5][1]"");; 17 tree->Draw(""fMatrix[ ][1] - fVertex[5][1]"");; 18 tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:592734,test,tested,592734,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['tested']
Testability," addition provides interactive access to the Cling C++ interpreter via the command line. ; Definition at line 171 of file TRint.cxx. ◆ ~TRint(). TRint::~TRint ; (; ). virtual . Destructor. ; Definition at line 316 of file TRint.cxx. Member Function Documentation. ◆ Class(). static TClass * TRint::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRint::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRint::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 67 of file TRint.h. ◆ DeclFileName(). static const char * TRint::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 67 of file TRint.h. ◆ ExecLogon(). void TRint::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 341 of file TRint.cxx. ◆ GetInputHandler(). TFileHandler * TRint::GetInputHandler ; (; ). inline . Definition at line 65 of file TRint.h. ◆ GetPrompt(). char * TRint::GetPrompt ; (; ). virtual . Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". ; Definition at line 575 of file TRint.cxx. ◆ HandleException(). void TRint::HandleException ; (; Int_t ; sig). overridevirtual . Handle signals (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something different here. ; Reimplemented from TApplication.; Definition at line 704 of file TRint.cxx. ◆ HandleTermInput(). Bool_t TRint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:23570,log,logon,23570,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['log'],['logon']
Testability," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:2133,test,test,2133,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,20,['test'],['test']
Testability," adjusted on tick mark.; (default is centered); chopt='L': labels are Left adjusted on tick mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGaxis.html:18007,log,log,18007,root/html528/TGaxis.html,https://root.cern,https://root.cern/root/html528/TGaxis.html,8,['log'],['log']
Testability," after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:3306/dbname"";; const char* username = ""username"";; const char* userpass = ""userpass"";. // Clean data base and create primary tables; TSQLFile* f = new TSQLFile(dbname, ""recreate"", username, userpass);; // Write with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:5339,test,tested,5339,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,9,['test'],['tested']
Testability," all arrays will be stored in raw format If limit<0, all array values will be stored in column form Default value is 21. ;  ; void SetEND (Long64_t) final;  ; void SetTablesType (const char *table_type);  Defines tables type, which is used in CREATE TABLE statements Now is only used for MySQL database, where following types are supported: ""BDB"", ""HEAP"", ""ISAM"", ""InnoDB"", ""MERGE"", ""MRG_MYISAM"", ""MYISAM"" Default for TSQLFile is ""InnoDB"". ;  ; void SetUseIndexes (Int_t use_type=kIndexesBasic);  Specify usage of indexes for data tables. ;  ; void SetUseSuffixes (Bool_t on=kTRUE);  enable/disable uasge of suffixes in columns names can be changed before first object is saved into file ;  ; void SetUseTransactions (Int_t mode=kTransactionsAuto);  Defines usage of transactions statements for writing objects data to database. ;  ; Int_t Sizeof () const final;  Return the size in bytes of the file header. ;  ; void SkipArrayLimit ();  ; void StartLogFile (const char *fname);  start logging of all SQL statements in specified file ;  ; Bool_t StartTransaction ();  Start user transaction. ;  ; void StopLogFile ();  close logging file ;  ; void Streamer (TBuffer &) override;  Streamer for TSQLFile class. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Write (const char *=nullptr, Int_t=0, Int_t=0) const final;  One can not save a const TDirectory object. ;  ; Int_t Write (const char *=nullptr, Int_t=0, Int_t=0) final;  Write memory objects to this file. ;  ; Bool_t WriteBuffer (const char *, Int_t) final;  Write a buffer to the file. ;  ; void WriteFree () final;  Write FREE linked list on the file. ;  ; void WriteHeader () final;  Write file info like configurations, title, UUID and other. ;  ; void WriteStreamerInfo () final;  Store all TVirtualStreamerInfo, used in file, in sql database. ;  ;  Public Member Functions inherited from TFile;  TFile ();  File default Constructor. ;  ;  TFile (const char *fname, Option_t *option="""", const char *ftitle=""""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:14591,log,logging,14591,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['log'],['logging']
Testability," all its leaf nodes, fill max depth reached in the tree at the same time. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static BinarySearchTree * CreateFromXML (void *node, UInt_t tmva_Version_Code=262657);  re-create a new tree (decision tree or search tree) from XML ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::BinaryTree; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; void DestroyNode (BinarySearchTreeNode *);  ; void Insert (const Event *, Node *);  private internal function to insert a event (node) at the proper position ;  ; Bool_t InVolume (const std::vector< Float_t > &, Volume *) const;  test if the data points are in the given volume ;  ; void NormalizeTree (std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator, std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator, UInt_t);  normalises the binary-search tree to reduce the branch length and hence speed up the search procedure (on average). ;  ; BinarySearchTreeNode * Search (Event *, Node *) const;  Private, recursive, function for searching. ;  ; Double_t SearchVolume (Node *, Volume *, Int_t, std::vector< const TMVA::BinarySearchTreeNode * > *events);  recursively walk through the daughter nodes and add up all weights of events that lie within the given volume ;  . Private Attributes; Bool_t fCanNormalize;  the tree can be normalised ;  ; UInt_t fCurrentDepth;  internal variable, counting the depth of the tree during insertion ;  ; std::vector< Float_t > fMax [2];  RMS for signal and background for each variable. ;  ; std::vector< Float_t > fMeans [2];  mean for signal and background for each variable ;  ; std::vector< Float_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:5139,test,test,5139,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,1,['test'],['test']
Testability," all methods; <HEADER> Factory : Evaluate classifier: BDTG; : ; <HEADER> BDTG : [datasetBkg1] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.13613 0.97981 [ -2.0823 2.9998 ]; : var2: 0.38548 0.81654 [ -1.3349 2.5106 ]; : var3: 0.66949 0.88808 [ -1.4774 3.9796 ]; : var4: 0.33525 1.2442 [ -2.9030 3.3317 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : datasetBkg1 BDTG : 0.993; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : datasetBkg1 BDTG : 0.000 (0.985) 0.985 (0.987) 0.989 (0.991); : -------------------------------------------------------------------------------------------------------------------; : ; <HEADER> Dataset:datasetBkg1 : Created tree 'TestTree' with 200 events; : ; <HEADER> Dataset:datasetBkg1 : Created tree 'TrainTree' with 200 events; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.html; <HEADER> DataSetInfo : [datasetBkg2] : Added class ""Signal""; : Add Tree TreeS of type Signal with 200 events; <HEADER> DataSetInfo : [datasetBkg2] : Added class ""Background""; : Add Tree Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html:18844,test,test,18844,doc/master/TMVAMultipleBackgroundExample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html,1,['test'],['test']
Testability," allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixAmpY1;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ;  ; Bool_t fFixAx;  logical value of ax parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixAy;  logical value of ay parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixBx;  logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixBy;  logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixPositionX;  [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixPositionX1;  [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixPositionY;  [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixPositionY1;  [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ;  ; Bool_t fFixRo;  logical value of correlation coefficient, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigmaX;  logical value of sigma x parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigmaY;  logical value of sigma y parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSx;  logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSxy;  logical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:27188,log,logical,27188,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability," also cleared, since there is no more content in the bins. ; Definition at line 2517 of file TH1.cxx. ◆ Clone(). TObject * TH1::Clone ; (; const char * ; newname = """"); const. overridevirtual . Make a complete copy of the underlying object. ; If 'newname' is set, the copy's name will be set to that name. ; Reimplemented from TObject.; Reimplemented in TH2Poly.; Definition at line 2752 of file TH1.cxx. ◆ ComputeIntegral(). Double_t TH1::ComputeIntegral ; (; Bool_t ; onlyPositive = false). virtual . Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. If the routine is called with the onlyPositive flag set an error will be produced in case of negative bin content and a NaN value returned Returns1 if success, 0 if integral is zero, NAN if onlyPositive-test fails ; Reimplemented in TH2Poly.; Definition at line 2537 of file TH1.cxx. ◆ Copy(). void TH1::Copy ; (; TObject & ; obj); const. overridevirtual . Copy this histogram structure to newth1. ; Note that this function does not copy the list of associated functions. Use TObject::Clone to make a full copy of a histogram.; Note also that the histogram it will be created in gDirectory (if AddDirectoryStatus()=true) or will not be added to any directory if AddDirectoryStatus()=false independently of the current directory stored in the original histogram ; Reimplemented from TObject.; Reimplemented in TH1C, TH1S, TH1I, TH1L, TH1F, TH1D, TH2, TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH3, TH3C, TH3S, TH3I, TH3L, TH3F, TH3D, TProfile, TProfile2D, TProfile3D, TH2Poly, and TH1K.; Definition at line 2671 of file TH1.cxx. ◆ DeclFileName(). static const char * TH1::DeclFileName ; (; ). inlinestatic . ReturnsName of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:103116,test,test,103116,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability," an other TLorentzRotation,; by a pure TRotation or by a boost:;   TLorentzRotation l;      // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |    ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLorentzRotation.html:2216,test,test,2216,root/html528/TLorentzRotation.html,https://root.cern,https://root.cern/root/html528/TLorentzRotation.html,10,['test'],['test']
Testability," an un-normalized RooGaussian over x. ; To calculate the integral over mean, just interchange the respective values of x and mean. Parameters. xMinMinimum value of variable to integrate wrt. ; xMaxMaximum value of of variable to integrate wrt. ; meanMean. ; sigmaSigma. . ReturnsThe integral of an un-normalized RooGaussian over the value in x. ; Definition at line 418 of file MathFuncs.h. ◆ getUniformBinning(). unsigned int RooFit::Detail::MathFuncs::getUniformBinning ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins . ). inline . Definition at line 172 of file MathFuncs.h. ◆ interpolate1d(). double RooFit::Detail::MathFuncs::interpolate1d ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins, . double const * ; vals . ). inline . Definition at line 178 of file MathFuncs.h. ◆ landau(). double RooFit::Detail::MathFuncs::landau ; (; double ; x, . double ; mu, . double ; sigma . ). inline . Definition at line 331 of file MathFuncs.h. ◆ logNormal(). double RooFit::Detail::MathFuncs::logNormal ; (; double ; x, . double ; k, . double ; m0 . ). inline . Definition at line 338 of file MathFuncs.h. ◆ logNormalIntegral(). double RooFit::Detail::MathFuncs::logNormalIntegral ; (; double ; xMin, . double ; xMax, . double ; m0, . double ; k . ). inline . Definition at line 627 of file MathFuncs.h. ◆ logNormalIntegralStandard(). double RooFit::Detail::MathFuncs::logNormalIntegralStandard ; (; double ; xMin, . double ; xMax, . double ; mu, . double ; sigma . ). inline . Definition at line 638 of file MathFuncs.h. ◆ logNormalStandard(). double RooFit::Detail::MathFuncs::logNormalStandard ; (; double ; x, . double ; sigma, . double ; mu . ). inline . Definition at line 343 of file MathFuncs.h. ◆ nll(). double RooFit::Detail::MathFuncs::nll ; (; double ; pdf, . double ; weight, . int ; binnedL, . int ; doBinOffset . ). inline . Definition at line 353 of file MathFuncs.h. ◆ poisson(). double RooFit::Detail::MathFuncs::poisson ; (; double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html:8698,log,logNormal,8698,doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,https://root.cern,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,1,['log'],['logNormal']
Testability," and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_th1.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ;  rootalias.CDefines aliases: ;  rootenv.CProduce a picture of the ROOT environment ;  rootlogoff.CExample of rootlogoff.C ;  rootlogon.CExample of rootlogon.C ;  rootmarks.CPrints a summary of all ROOT benchmarks (must be run before) ;  tasks.CExample of TTasks . ROOT 6.12/07 - Reference Guide Generated on Sat Sep 29 2018 23:44:47 (GVA Time) using Doxygen 1.8.13. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:163103,benchmark,benchmarks,163103,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['benchmark'],['benchmarks']
Testability," and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; The options 'cpopt' define if to copy things from cache to sandbox and what.; To retrieve from the cache the binaries associated with the file TProof::kCpBin; must be set in cpopt; the default is copy everything.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); Send a file to master or slave servers. Returns number of slaves; the file was sent to, maybe 0 in case master and slaves have the same; file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t Echo(const TObject* obj); Sends an object to master and workers and expect them to send back a; message with the output of its TObject::Print(). Returns -1 on error, the; number of workers that received the objects on success. Int_t Echo(const char* str); Sends a string to master and wo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:67619,sandbox,sandbox,67619,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,4,['sandbox'],['sandbox']
Testability," and compiler version, e.g. '53403_linuxx8664gcc_gcc46' . ; Definition at line 6702 of file TProofServ.cxx. ◆ RestartComputeTime(). void TProofServ::RestartComputeTime ; (; ). Reset the compute time. ; Definition at line 1126 of file TProofServ.cxx. ◆ Run(). void TProofServ::Run ; (; Bool_t ; retrn = kFALSE). overridevirtual . Main server eventloop. ; Reimplemented from TApplication.; Definition at line 2650 of file TProofServ.cxx. ◆ SendAsynMessage(). void TProofServ::SendAsynMessage ; (; const char * ; msg, . Bool_t ; lf = kTRUE . ). Send an asychronous message to the master / client . ; Masters will forward up the message to the client. The client prints 'msg' of stderr and adds a '\n'/'\r' depending on 'lf' being kTRUE (default) or kFALSE. Returns the return value from TSocket::Send(TMessage &) . ; Definition at line 5989 of file TProofServ.cxx. ◆ SendLogFile(). void TProofServ::SendLogFile ; (; Int_t ; status = 0, . Int_t ; start = -1, . Int_t ; end = -1 . ). virtual . Send log file to master. ; If start > -1 send only bytes in the range from start to end, if end <= start send everything from start. ; Definition at line 2665 of file TProofServ.cxx. ◆ SendParallel(). void TProofServ::SendParallel ; (; Bool_t ; async = kFALSE). Send number of parallel nodes to master or client. ; Definition at line 2780 of file TProofServ.cxx. ◆ SendResults(). Int_t TProofServ::SendResults ; (; TSocket * ; sock, . TList * ; outlist = 0, . TQueryResult * ; pq = 0 . ). private . Sends all objects from the given list to the specified socket. ; Definition at line 4244 of file TProofServ.cxx. ◆ SendStatistics(). void TProofServ::SendStatistics ; (; ). Send statistics of slave server to master or client. ; Definition at line 2760 of file TProofServ.cxx. ◆ SetErrorHandlerFile(). FILE * TProofServ::SetErrorHandlerFile ; (; FILE * ; ferr). static . Set the file stream where to log (default stderr). ; If ferr == 0 the default is restored. Returns current setting. ; Definition at line 5744 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:53272,log,log,53272,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['log'],['log']
Testability," and phi Phi is restricted to be in the range [-PI,PI); See alsoOverview of the physics vector library ; Definition at line 48 of file CylindricalEta3D.h. Public Types; typedef T Scalar;  . Public Member Functions;  CylindricalEta3D ();  Default constructor with rho=eta=phi=0. ;  ; template<class CoordSystem > ;  CylindricalEta3D (const CoordSystem &v);  Construct from any Vector or coordinate system implementing Rho(), Eta() and Phi() ;  ;  CylindricalEta3D (const CylindricalEta3D &v);  copy constructor ;  ;  CylindricalEta3D (Scalar rho, Scalar eta, Scalar phi);  Construct from rho eta and phi values. ;  ; T Eta () const;  ; void GetCoordinates (Scalar &rho, Scalar &eta, Scalar &phi) const;  get internal data into 3 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 3 Scalar numbers ;  ; T Mag2 () const;  ; void Negate ();  negate the vector ;  ; bool operator!= (const CylindricalEta3D &rhs) const;  ; template<class CoordSystem > ; CylindricalEta3D & operator= (const CoordSystem &c);  generic assignment operator from any coordinate system ;  ; CylindricalEta3D & operator= (const CylindricalEta3D &v);  assignment operator ;  ; bool operator== (const CylindricalEta3D &rhs) const;  Exact component-by-component equality Note: Peculiar representations of the zero vector such as (0,1,0) will not test as equal to one another. ;  ; T Perp2 () const;  ; T Phi () const;  ; T R () const;  ; T Rho () const;  ; void Scale (T a);  scale by a scalar quantity a – for cylindrical eta coords, as long as a >= 0, only rho changes! ;  ; void SetCoordinates (const Scalar src[]);  Set internal data based on an array of 3 Scalar numbers. ;  ; void SetCoordinates (Scalar rho, Scalar eta, Scalar phi);  Set internal data based on 3 Scalar numbers. ;  ; void SetEta (T eta);  set the eta coordinate value keeping rho and phi constant ;  ; void SetPhi (T phi);  set the phi coordinate value keeping rho and eta constant ;  ; void SetRho (T rho);  se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1CylindricalEta3D.html:2090,test,test,2090,doc/master/classROOT_1_1Math_1_1CylindricalEta3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1CylindricalEta3D.html,1,['test'],['test']
Testability," and ranges that are meant to be tuned. ;  ; void PrintHelpMessage () const;  prints out method-specific help method ;  ; void ProcessSetup ();  process all options the ""CheckForUnusedOptions"" is done in an independent call, since it may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ;  ; void ReadStateFromFile ();  Function to write options and weights to file. ;  ; void ReadStateFromStream (std::istream &tf);  read the header from the weight files of the different MVA methods ;  ; void ReadStateFromStream (TFile &rf);  write reference MVA distributions (and other information) to a ROOT type weight file ;  ; void ReadStateFromXMLString (const char *xmlstr);  for reading from memory ;  ; void RerouteTransformationHandler (TransformationHandler *fTargetTransformation);  ; virtual void SetAnalysisType (Types::EAnalysisType type);  ; void SetBaseDir (TDirectory *methodDir);  ; void SetFile (TFile *file);  ; void SetMethodBaseDir (TDirectory *methodDir);  ; void SetMethodDir (TDirectory *methodDir);  ; void SetModelPersistence (Bool_t status);  ; void SetSignalReferenceCut (Double_t cut);  ; void SetSignalReferenceCutOrientation (Double_t cutOrientation);  ; void SetSilentFile (Bool_t status);  ; void SetTestTime (Double_t testTime);  ; void SetTestvarName (const TString &v="""");  ; void SetTrainTime (Double_t trainTime);  ; virtual void SetTuneParameters (std::map< TString, Double_t > tuneParameters);  set the tuning parameters according to the argument This is just a dummy . ;  ; void SetupMethod ();  setup of methods ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void TestClassification ();  initialization ;  ; virtual void TestMulticlass ();  test multiclass classification ;  ; virtual void TestRegression (Double_t &bias, Double_t &biasT, Double_t &dev, Double_t &devT, Double_t &rms, Double_t &rmsT, Double_t &mInf, Double_t &mInfT, Double_t &corr, Types::ETreeType typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCrossValidation.html:10190,test,testTime,10190,doc/master/classTMVA_1_1MethodCrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCrossValidation.html,2,['test'],['testTime']
Testability," and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TApplicationServer.html:16881,log,logon,16881,root/html604/TApplicationServer.html,https://root.cern,https://root.cern/root/html604/TApplicationServer.html,7,"['Log', 'log']","['Logon', 'logfile', 'logon']"
Testability," and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:16881,log,logon,16881,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,7,"['Log', 'log']","['Logon', 'logfile', 'logon']"
Testability," and/or slaves.; If plusMaster is kTRUE then exeucte on slaves and master too.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char *cmd, ESlaves list, Bool_t plusMaster); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); Send command to be executed on node of ordinal 'ord' (use ""0"" for master).; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster.; If logtomacro is TRUE the text result of the action is saved in the fMacroLog; TMacro, accessible via TMacro::GetMacroLog();; Returns -1 in case of error, >=0 in case of succes. Int_t SendCommand(const char* cmd, TProof::ESlaves list = kActive); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command, however commands; like "".x file.C"" or "".L file.C"" will not cause the file.C to be; transfered to the PROOF cluster. In that case use TProof::Exec().; Returns the status send by the remote server as part of the; kPROOF_LOGDONE message. Typically this is the return code of the; command on the remote side. Returns -1 in case of error. TString Getenv(const char* env, const char* ord = ""0""); Get value of environment variable 'env' on node 'ord'. Int_t GetRC(const char* RCenv, Int_t& env, const char* ord = ""0""); Get into 'env' the value of integer RC env variable 'rcenv' on node 'ord'. Int_t GetRC(const char* RCenv, Double_t& env, const char* ord = ""0""); Get into 'env' the value of double RC env variable 'rcenv' on node 'ord'. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:62228,log,logtomacro,62228,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['log'],['logtomacro']
Testability," any generic model function If data set is binned a least square fit is performed If data set is unbinned a maximum likelihood fit (not extended) is done Pre-requisite on the function: it must implement the 1D or multidimensional parametric function interface. ; Note that both the input data and the function object are copied by the Fitter. ; Definition at line 144 of file Fitter.h. ◆ Fit() [3/5]. bool ROOT::Fit::Fitter::Fit ; (; const std::shared_ptr< BinData > & ; data, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit a binned data set using a least square fit. ; Pass the input data using a shared_ptr for NOT copying the input data. ; Definition at line 165 of file Fitter.h. ◆ Fit() [4/5]. bool ROOT::Fit::Fitter::Fit ; (; const std::shared_ptr< UnBinData > & ; data, . bool ; extended = false, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit an un-binned data set using the negative log-likelihood method. ; This function uses a shared_ptr to avoid copying the input data. ; Definition at line 195 of file Fitter.h. ◆ Fit() [5/5]. bool ROOT::Fit::Fitter::Fit ; (; const UnBinData & ; data, . bool ; extended = false, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit an un-binned data set using the negative log-likelihood method. ; This function copies the input data. ; Definition at line 188 of file Fitter.h. ◆ FitFCN() [1/6]. bool ROOT::Fit::Fitter::FitFCN ; (; ). Perform a fit with the previously set FCN function. ; Require SetFCN before ; Definition at line 269 of file Fitter.cxx. ◆ FitFCN() [2/6]. bool ROOT::Fit::Fitter::FitFCN ; (; const ROOT::Math::FitMethodFunction & ; fcn, . const double * ; params = nullptr . ). Fit using a FitMethodFunction interface. ; Same as method above, but now extra information can be taken from the function class ; Definition at line 226 of file Fitter.cxx. ◆ FitFCN()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:23272,log,log-likelihood,23272,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['log'],['log-likelihood']
Testability," approximate number; of lines to be retrieved is given by 'lines', with the convention that; 0 means 'all', a positive number means the first 'lines' and a negative; number means the last '-lines'. Default is -1000.; If opt == TProofLog::kGrep only the lines containing 'pattern' are; retrieved (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; Return 0 on success, -1 in case of any error. void Display(Int_t from = 0, Int_t to = -1); Display the current content starting from line 'from' to line 'to'; inclusive.; A negative value for 'from' indicates lines counted from the end; (tail action); 'to' is ignored in such a case.; TProofLog::Prt is called to display: the location (screen, file, box); is defined there.; Return 0 on success, -1 in case of any error. void Print(Option_t* opt = 0) const; Print a line with the relevant info. void Prt(const char* what); Special printing procedure. Int_t Grep(const char* txt, TString& res, Int_t from = 0); Search lines containing 'txt', starting from line 'from'. Return; their blanck-separated list into 'res'.; Return the number of lines found, or -1 in case of error. TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. » Author: G. Ganis 31/08/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: 5d579564fccbadad9cd6f81ccb7726dddea80e0d $ » Last generated: 2015-06-30 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLogElem.html:8424,log,logger,8424,root/html602/TProofLogElem.html,https://root.cern,https://root.cern/root/html602/TProofLogElem.html,2,['log'],['logger']
Testability," approximate number; of lines to be retrieved is given by 'lines', with the convention that; 0 means 'all', a positive number means the first 'lines' and a negative; number means the last '-lines'. Default is -1000.; If opt == TProofLog::kGrep only the lines containing 'pattern' are; retrieved (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; Return 0 on success, -1 in case of any error. void Display(Int_t from = 0, Int_t to = -1); Display the current content starting from line 'from' to line 'to'; inclusive.; A negative value for 'from' indicates lines counted from the end; (tail action); 'to' is ignored in such a case.; TProofLog::Prt is called to display: the location (screen, file, box); is defined there.; Return 0 on success, -1 in case of any error. void Print(Option_t* opt = 0) const; Print a line with the relevant info. void Prt(const char* what); Special printing procedure. Int_t Grep(const char* txt, TString& res, Int_t from = 0); Search lines containing 'txt', starting from line 'from'. Return; their blanck-separated list into 'res'.; Return the number of lines found, or -1 in case of error. TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. » Author: G. Ganis 31/08/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: 5d579564fccbadad9cd6f81ccb7726dddea80e0d $ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofLogElem.html:8424,log,logger,8424,root/html604/TProofLogElem.html,https://root.cern,https://root.cern/root/html604/TProofLogElem.html,2,['log'],['logger']
Testability," area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800/// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; 1801/// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; 1802/// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; 1803///; 1804/// ### Sources; 1805/// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; 1806/// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon; 1807 ; 1808Double_t TGraph::Integral(Int_t first, Int_t last) const; 1809{; 1810 if (first < 0) first = 0;; 1811 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:64418,test,test,64418,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['test'],['test']
Testability," arithmetic does not always work perfectly, and the Abs doesn't hurt ;  ; double fEpsilon = -1;  acceptable error for Keys interval determination ;  ; RooArgSet fGlobalObs;  global observables ;  ; enum MCMCInterval::IntervalType fIntervalType = MCMCInterval::kShortest;  ; double fLeftSideTF = -1;  left side tail-fraction for interval ;  ; RooArgSet fNuisParams;  nuisance parameters for interval (not really used) ;  ; Int_t fNumBins = 0;  set the number of bins to create for each axis when constructing the interval ;  ; Int_t fNumBurnInSteps = 0;  number of iterations to discard as burn-in, starting from the first ;  ; Int_t fNumIters = 0;  number of iterations to run metropolis algorithm ;  ; RooAbsPdf * fPdf;  pointer to common PDF (owned by the workspace) ;  ; RooArgSet fPOI;  parameters of interest for interval ;  ; RooAbsPdf * fPriorPdf;  pointer to prior PDF (owned by the workspace) ;  ; ProposalFunction * fPropFunc;  Proposal function for MCMC integration. ;  ; double fSize = -1;  size of the test (eg. specified rate of Type I error) ;  ; bool fUseKeys = false;  whether to use kernel estimation to determine interval ;  ; bool fUseSparseHist = false;  whether to use sparse histogram (if using hist at all) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html:16729,test,test,16729,doc/master/classRooStats_1_1MCMCCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html,1,['test'],['test']
Testability," as a Postscript file ;  latex2.C This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex3.C Example illustrating a TPaveText with Latex inside ;  latex4.C Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files ;  latex5.C This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files ;  mandelbrot.C Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set ;  manyaxis.C Show several TGaxis formats ;  markerwarning.C This script illustrates the danger of using asymmetric symbols ;  mass_spectrum.C This macro makes use of some basic graphics primitives such as line, arrow and text ;  palettes.C This macro draws all the high definition palettes available in ROOT ;  pavetext.C Draw a pave text ;  piechart.C Pie chart example ;  polytest1.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:113580,test,testing,113580,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['test'],['testing']
Testability," as a Postscript file ;  latex2.C This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex3.C Example illustrating a TPaveText with Latex inside ;  latex4.C Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files ;  latex5.C This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files ;  mandelbrot.C Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set ;  manyaxis.C Show several TGaxis formats ;  markerwarning.C This script illustrates the danger of using asymmetric symbols ;  mass_spectrum.C This macro makes use of some basic graphics primitives such as line, arrow and text ;  palettes.C This macro draws all the high definition palettes available in ROOT ;  pavetext.C Draw a pave text ;  piechart.C Pie chart example ;  polytest1.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:115327,test,testing,115327,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testing']
Testability," as a Postscript file ;  latex2.C This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex3.C Example illustrating a TPaveText with Latex inside ;  latex4.C Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files ;  latex5.C This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files ;  mandelbrot.C Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set ;  manyaxis.C Show several TGaxis formats ;  markerwarning.C This script illustrates the danger of using asymmetric symbols ;  mass_spectrum.C This macro makes use of some basic graphics primitives such as line, arrow and text ;  palettes.C This macro draws all the high definition palettes available in ROOT ;  pavetext.C Draw a pave text ;  piechart.C Pie chart example ;  polytest1.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:115002,test,testing,115002,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testing']
Testability," asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethodCall&operator=(const TMethodCall& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetParam(); TMethodCall::EReturnTypeReturnType(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetParam(Long_t l); voidSetParam(Double_t d); voidSetParam(Long64_t ll); voidSetParam(ULong64_t ull); voidSetParamPtrs(void* paramArr, Int_t nparam = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMethodCall.html:5949,Test,TestBit,5949,root/html534/TMethodCall.html,https://root.cern,https://root.cern/root/html534/TMethodCall.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tRooAbsIntegrator::printEvalCounter() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Bool_tsetLimits(Double_t* xmin, Double_t* xmax); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsIntegrator::setPrintEvalCounter(Bool_t value); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Bool_tsetUseIntegrandLimits(Bool_t flag); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAdaptiveGaussKronrodIntegrator1D.html:6579,Test,TestBit,6579,root/html534/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html534/RooAdaptiveGaussKronrodIntegrator1D.html,14,['Test'],"['TestBit', 'TestBits']"
Testability," asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPaint(Option_t* chopt = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* chopt = """") const; virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetMaximum(Double_t maximum = -1111); virtual voidSetMinimum(Double_t minimum = -1111); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiGraph.html:11367,Test,TestBit,11367,root/html532/TMultiGraph.html,https://root.cern,https://root.cern/root/html532/TMultiGraph.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HybridPlot&operator=(const RooStats::HybridPlot&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HybridPlot.html:5684,Test,TestBit,5684,root/html602/RooStats__HybridPlot.html,https://root.cern,https://root.cern/root/html602/RooStats__HybridPlot.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf__GenSpec.html:4307,assert,assert,4307,root/html602/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html,4,['assert'],['assert']
Testability," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t exten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf__GenSpec.html:4307,assert,assert,4307,root/html530/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html,1,['assert'],['assert']
Testability," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf__GenSpec.html:4307,assert,assert,4307,root/html532/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf__GenSpec.html,1,['assert'],['assert']
Testability," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& wha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf__GenSpec.html:4307,assert,assert,4307,root/html534/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html,2,['assert'],['assert']
Testability," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:4299,assert,assert,4299,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,9,['assert'],['assert']
Testability," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:4299,assert,assert,4299,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['assert'],['assert']
Testability," at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:1870,test,tests,1870,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['test'],['tests']
Testability," at line 167 of file TGeoShape.cxx. ◆ TGeoShape() [2/2]. TGeoShape::TGeoShape ; (; const char * ; name). Default constructor. ; Definition at line 182 of file TGeoShape.cxx. ◆ ~TGeoShape(). TGeoShape::~TGeoShape ; (; ). override . Destructor. ; Definition at line 197 of file TGeoShape.cxx. Member Function Documentation. ◆ AfterStreamer(). virtual void TGeoShape::AfterStreamer ; (; ). inlinevirtual . Reimplemented in TGeoConeSeg, and TGeoTubeSeg.; Definition at line 93 of file TGeoShape.h. ◆ Big(). static Double_t TGeoShape::Big ; (; ). inlinestatic . Definition at line 87 of file TGeoShape.h. ◆ Capacity(). virtual Double_t TGeoShape::Capacity ; (; ); const. pure virtual . Implemented in TGeoArb8, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ CheckShape(). void TGeoShape::CheckShape ; (; Int_t ; testNo, . Int_t ; nsamples = 10000, . Option_t * ; option = """" . ). Test for shape navigation methods. ; Summary for test numbers:. 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2) . Definition at line 211 of file TGeoShape.cxx. ◆ Class(). static TClass * TGeoShape::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoShape::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoShape::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 171 of file TGeoShape.h. ◆ ClearThreadData(). virtual void TGeoShape::ClearThreadData ; (; ); const. inlinevirtual . Reimplemented in TGeoCompositeShape, TGeoPgon, and TGeoXtru.; Definition at line 66 of file TGeoShape.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:27637,test,testNo,27637,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['test'],['testNo']
Testability," at line 17 of file TGeoHalfSpace.h. Public Member Functions;  TGeoHalfSpace ();  Dummy constructor. ;  ;  TGeoHalfSpace (const char *name, Double_t *p, Double_t *n);  Constructor with name, point on the plane and normal. ;  ;  TGeoHalfSpace (Double_t *params);  Default constructor specifying minimum and maximum radius. ;  ;  ~TGeoHalfSpace () override;  destructor ;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Compute normal to closest surface from POINT. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  test if point is inside the half-space ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  A half-space does not have a mesh primitive. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from inside point to the plane ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from inside point to the plane ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:1897,test,test,1897,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['test'],['test']
Testability," at line 240 of file TFile.h. ◆ GetReadaheadSize(). Int_t TFile::GetReadaheadSize ; (; ). static . Static function returning the readahead buffer size. ; Definition at line 4599 of file TFile.cxx. ◆ GetReadCalls(). virtual Int_t TFile::GetReadCalls ; (; ); const. inlinevirtual . Definition at line 244 of file TFile.h. ◆ GetReadStreamerInfo(). Bool_t TFile::GetReadStreamerInfo ; (; ). static . If the streamerinfos are to be read at file opening. ; See TFile::SetReadStreamerInfo for more documentation. ; Definition at line 3742 of file TFile.cxx. ◆ GetRecordHeader(). Int_t TFile::GetRecordHeader ; (; char * ; buf, . Long64_t ; first, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header starting at a certain postion. ; Parameters. [in]bufpointer to buffer ; [in]firstread offset ; [in]maxbytesBytes which are read into buf. ; [out]nbytesNumber of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first ; [out]objlenUncompressed object size ; [out]keylenLength of logical record header. The function reads nread bytes where nread is the minimum of maxbytes and the number of bytes before the end of file. The function returns nread. Note that the arguments objlen and keylen are returned only if maxbytes >=16 ; Definition at line 1301 of file TFile.cxx. ◆ GetRelOffset(). Long64_t TFile::GetRelOffset ; (; ); const. inline . Definition at line 251 of file TFile.h. ◆ GetSeekFree(). virtual Long64_t TFile::GetSeekFree ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 252 of file TFile.h. ◆ GetSeekInfo(). virtual Long64_t TFile::GetSeekInfo ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 253 of file TFile.h. ◆ GetSize(). Long64_t TFile::GetSize ; (; ); const. virtual . Returns the current file size. ; Returns -1 in case the file could not be stat'ed. ; Reimplemented in TDavixFile, TSQL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:68485,log,logical,68485,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['log'],['logical']
Testability," at line 29 of file TBenchmark.h. Public Member Functions;  TBenchmark ();  Benchmark default constructor. ;  ; virtual ~TBenchmark ();  Benchmark destructor. ;  ; Int_t GetBench (const char *name) const;  Returns index of Benchmark name. ;  ; Float_t GetCpuTime (const char *name);  Returns Cpu time used by Benchmark name. ;  ; Float_t GetRealTime (const char *name);  Returns Realtime used by Benchmark name. ;  ; TClass * IsA () const override;  ; void Print (Option_t *name="""") const override;  Prints parameters of Benchmark name. ;  ; virtual void Reset ();  Reset all Benchmarks. ;  ; virtual void Show (const char *name);  Stops Benchmark name and Prints results. ;  ; virtual void Start (const char *name);  Starts Benchmark with the specified name. ;  ; virtual void Stop (const char *name);  Terminates Benchmark with specified name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Summary (Float_t &rt, Float_t &cp);  Prints a summary of all benchmarks. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBenchmark.html:1487,benchmark,benchmarks,1487,doc/master/classTBenchmark.html,https://root.cern,https://root.cern/doc/master/classTBenchmark.html,1,['benchmark'],['benchmarks']
Testability," at line 373 of file DataSetInfo.cxx. ◆ SetDataSetManager(). void TMVA::DataSetInfo::SetDataSetManager ; (; DataSetManager * ; dsm). inlineprivate . Definition at line 198 of file DataSetInfo.h. ◆ SetMsgType(). void TMVA::DataSetInfo::SetMsgType ; (; EMsgType ; t); const. Definition at line 106 of file DataSetInfo.cxx. ◆ SetNormalization(). void TMVA::DataSetInfo::SetNormalization ; (; const TString & ; norm). inline . Definition at line 132 of file DataSetInfo.h. ◆ SetRootDir(). void TMVA::DataSetInfo::SetRootDir ; (; TDirectory * ; d). inline . Definition at line 189 of file DataSetInfo.h. ◆ SetSplitOptions(). void TMVA::DataSetInfo::SetSplitOptions ; (; const TString & ; so). inline . Definition at line 185 of file DataSetInfo.h. ◆ SetTestingSumBackgrWeights(). void TMVA::DataSetInfo::SetTestingSumBackgrWeights ; (; Double_t ; testingSumBackgrWeights). inline . Definition at line 139 of file DataSetInfo.h. ◆ SetTestingSumSignalWeights(). void TMVA::DataSetInfo::SetTestingSumSignalWeights ; (; Double_t ; testingSumSignalWeights). inline . Definition at line 138 of file DataSetInfo.h. ◆ SetTrainingSumBackgrWeights(). void TMVA::DataSetInfo::SetTrainingSumBackgrWeights ; (; Double_t ; trainingSumBackgrWeights). inline . Definition at line 137 of file DataSetInfo.h. ◆ SetTrainingSumSignalWeights(). void TMVA::DataSetInfo::SetTrainingSumSignalWeights ; (; Double_t ; trainingSumSignalWeights). inline . Definition at line 134 of file DataSetInfo.h. ◆ SetWeightExpression(). void TMVA::DataSetInfo::SetWeightExpression ; (; const TString & ; exp, . const TString & ; className = """" . ). set the weight expressions for the classes if class name is specified, set only for this class if class name is unknown, register new class with this name ; Definition at line 346 of file DataSetInfo.cxx. ◆ Streamer(). virtual void TMVA::DataSetInfo::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::Dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetInfo.html:29682,test,testingSumSignalWeights,29682,doc/master/classTMVA_1_1DataSetInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetInfo.html,1,['test'],['testingSumSignalWeights']
Testability," at line 45 of file TSpectrumFit.h. ◆ fBErr. Double_t TSpectrumFit::fBErr. protected . error value of b parameter ; Definition at line 46 of file TSpectrumFit.h. ◆ fBInit. Double_t TSpectrumFit::fBInit. protected . initial value of b parameter (slope), for details see html manual and references ; Definition at line 44 of file TSpectrumFit.h. ◆ fChi. Double_t TSpectrumFit::fChi. protected . here the fitting functions return resulting chi square ; Definition at line 29 of file TSpectrumFit.h. ◆ fFitTaylor. Int_t TSpectrumFit::fFitTaylor. protected . order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; Definition at line 27 of file TSpectrumFit.h. ◆ fFixA0. Bool_t TSpectrumFit::fFixA0. protected . logical value of a0 parameter, which allows to fix the parameter (not to fit). ; Definition at line 65 of file TSpectrumFit.h. ◆ fFixA1. Bool_t TSpectrumFit::fFixA1. protected . logical value of a1 parameter, which allows to fix the parameter (not to fit). ; Definition at line 66 of file TSpectrumFit.h. ◆ fFixA2. Bool_t TSpectrumFit::fFixA2. protected . logical value of a2 parameter, which allows to fix the parameter (not to fit). ; Definition at line 67 of file TSpectrumFit.h. ◆ fFixAmp. Bool_t* TSpectrumFit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ; Definition at line 60 of file TSpectrumFit.h. ◆ fFixB. Bool_t TSpectrumFit::fFixB. protected . logical value of b parameter, which allows to fix the parameter (not to fit). ; Definition at line 63 of file TSpectrumFit.h. ◆ fFixPosition. Bool_t* TSpectrumFit::fFixPosition. protected . [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ; Definition at line 59 of file TSpectrumFit.h. ◆ fFixS. Bool_t TSpectrumFit::fFixS. protected . logical value of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:53163,log,logical,53163,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability," at line 88 of file FitterBase.cxx. ◆ GetFitterTarget(). IFitterTarget & TMVA::FitterBase::GetFitterTarget ; (; ); const. inline . Definition at line 64 of file FitterBase.h. ◆ GetName(). const char * TMVA::FitterBase::GetName ; (; ); const. inlinevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 70 of file FitterBase.h. ◆ GetNpars(). Int_t TMVA::FitterBase::GetNpars ; (; ); const. inline . Definition at line 67 of file FitterBase.h. ◆ IsA(). virtual TClass * TMVA::FitterBase::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::GeneticFitter, TMVA::MCFitter, TMVA::MinuitFitter, and TMVA::SimulatedAnnealingFitter.; Definition at line 97 of file FitterBase.h. ◆ Log(). MsgLogger & TMVA::FitterBase::Log ; (; ); const. inlineprotected . message logger ; Definition at line 89 of file FitterBase.h. ◆ Run() [1/2]. Double_t TMVA::FitterBase::Run ; (; ). estimator function interface for fitting ; Definition at line 74 of file FitterBase.cxx. ◆ Run() [2/2]. virtual Double_t TMVA::FitterBase::Run ; (; std::vector< Double_t > & ; pars). pure virtual . Implemented in TMVA::GeneticFitter, TMVA::MCFitter, TMVA::MinuitFitter, and TMVA::SimulatedAnnealingFitter. ◆ SetIPythonInteractive(). void TMVA::FitterBase::SetIPythonInteractive ; (; bool * ; ExitFromTraining, . UInt_t * ; fIPyMaxIter_, . UInt_t * ; fIPyCurrentIter_ . ). inline . Definition at line 73 of file FitterBase.h. ◆ Streamer(). virtual void TMVA::FitterBase::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::GeneticFitter, TMVA::MCFitter, TMVA::MinuitFitter, and TMVA::SimulatedAnnealingFitter. ◆ StreamerNVirtual(). void TMVA::FitterBase::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1FitterBase.html:17205,log,logger,17205,doc/master/classTMVA_1_1FitterBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1FitterBase.html,1,['log'],['logger']
Testability," average rate on same plot (default); dofit = 0 no fit; 1 fit with the relevant '1st degree related' function; 2 fit with the relevant '2nd degree related' function; 3 fit with varying rcpu function; n0 = for dofit == 3, number of real cores; n1 = for dofit == 3, number of total cores (real + hyperthreaded). TGraphErrors * GetGraph(TDirectory* d, const char* pfn, Int_t& nb, Double_t& xmi, Double_t& xmx, Double_t& ymi, Double_t& ymx, Int_t& kmx, TProfile*& pf); Get from TDirectory 'd' the TProfile named 'pfn' and create the graph.; Return also the max y in mx. void AssertFittingFun(Double_t mi, Double_t mx); Make sure that the fitting functions are defined. void GetPerfSpecs(const char* path = ""."", Int_t degfit = 1); Get performance specs. Check file 'path', or files in directory 'path'; (default current directory).; The degree of the polynomial used for the fit is 'degfit' (default 1). Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard plot; 'stdx:' draw standard plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same plot (default); type = 'mbs' MB/s scaling plots (default); 'evts' Event/s scaling plots; dofit = 0 no fit; 1 fit with default 3 parameter saturated I/O formula; 2 fit with 4 par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:11345,test,test,11345,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,6,['test'],['test']
Testability," axis = ""X""); virtual voidTH1::SetTitleSize(Float_t size = 0.02, Option_t* axis = ""X""); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTH1::SetXTitle(const char* title); virtual voidTH1::SetYTitle(const char* title); virtual voidTH1::SetZTitle(const char* title); virtual TH1*TH1::ShowBackground(Int_t niter = 20, Option_t* option = ""same"")MENU ; virtual voidShowMembers(TMemberInspector&); virtual Int_tTH1::ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05)MENU ; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; virtual voidTH1::Smooth(Int_t ntimes = 1, Option_t* option = """")MENU ; static voidTH1::SmoothArray(Int_t NN, Double_t* XX, Int_t ntimes = 1); static voidTH1::StatOverflows(Bool_t flag = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTH1::Sumw2(Bool_t flag = kTRUE); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TH1*TH1::TransformHisto(TVirtualFFT* fft, TH1* h_output, Option_t* option); virtual voidTH1::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; static voidTArray::WriteArray(TBuffer& b, const TArray* a). protected:. Bool_tTArray::BoundsOk(const char* where, Int_t at) const; virtual Int_tTH3::BufferFill(Double_t, Double_t); virtual Int_tTH3::BufferFill(Double_t, Double_t, Double_t); virtual Int_tTH3::BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); static boolTH1::CheckAxisLimits(const TAxis* a1, const TAxis* a2); static boolTH1::CheckBinLabels(const TAxis* a1, const TAxis* a2); static boolTH1::CheckBinLimits(const TAxis* a1, const TAxis* a2); static boolTH1::CheckConsistency(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLTH3Composition.html:21314,Test,TestBit,21314,root/html534/TGLTH3Composition.html,https://root.cern,https://root.cern/root/html534/TGLTH3Composition.html,12,['Test'],"['TestBit', 'TestBits']"
Testability," axis = ""xz"" set the two axes. Alphanumeric labels; Axis labels can be any alphanumeric character strings. Such axis can be produced only with histograms because the labels'definition is stored in TAxis. The following example demonstrates how to create such labels.; ; TCanvas *hlabels2(); {; const Int_t nx = 12;; const Int_t ny = 20;; const char *month[nx] = {""January"",""February"",""March"",""April"",""May"",; ""June"",""July"",""August"",""September"",""October"",""November"",; ""December""};; const char *people[ny] = {""Jean"",""Pierre"",""Marie"",""Odile"",""Sebastien"",; ""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",""Bjarne"",""Anton"",; ""Otto"",""Eddy"",""Peter"",""Pasha"",""Philippe"",""Suzanne"",""Jeff"",; ""Valery""};; TCanvas *c1 = new TCanvas(""c1"",""demo bin labels"",10,10,600,600);; c1->SetGrid();; c1->SetLeftMargin(0.15);; c1->SetBottomMargin(0.15);; TH2F *h = new TH2F(""h"",""test"",3,0,3,2,0,2);; h->SetCanExtend(TH1::kAllAxes);; h->SetStats(0);; gRandom->SetSeed();; for (Int_t i=0;i<15000;i++) {; Int_t rx = gRandom->Rndm()*nx;; Int_t ry = gRandom->Rndm()*ny;; h->Fill(people[ry],month[rx],1);; }; h->LabelsDeflate(""X"");; h->LabelsDeflate(""Y"");; h->LabelsOption(""v"");; h->Draw(""text"");; ; TPaveText *pt = new TPaveText(0.6,0.85,0.98,0.98,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Use the axis Context Menu LabelsOption"");; pt->AddText("" \""a\"" to sort by alphabetic order"");; pt->AddText("" \"">\"" to sort by decreasing values"");; pt->AddText("" \""<\"" to sort by increasing values"");; pt->Draw();; return c1;; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TH1::kAllAxes@ kAllAxesDefinition TH1.h:76; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:12442,test,test,12442,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['test'],['test']
Testability," axis->GetXmin();; 769 xmax[i] = axis->GetXmax();; 770 }; 771 ; 772 // Put default options, needed for the likelihood fitting of sparse; 773 // data.; 774 ROOT::Fit::DataOptions& dopt = dv.Opt();; 775 //dopt.fUseEmpty = true;; 776 // when using sparse data need to set option to use normalized bin volume, because sparse bins are merged together; 777 //if (!dopt.fIntegral) dopt.fBinVolume = true;; 778 dopt.fBinVolume = true;; 779 dopt.fNormBinVolume = true;; 780 ; 781 // Get the sparse data; 782 ROOT::Fit::SparseData d(ndim, &xmin[0], &xmax[0]);; 783 ROOT::Fit::FillData(d, s1, func);; 784 ; 785// std::cout << ""FillData(BinData & dv, const THnBase * s1, TF1 * func) (1)"" << std::endl;; 786 ; 787 // Create the bin data from the sparse data; 788 d.GetBinDataIntegral(dv);; 789 ; 790}; 791 ; 792void FillData ( BinData & dv, const TGraph * gr, TF1 * func ) {; 793 // fill the data vector from a TGraph. Pass also the TF1 function which is; 794 // needed in case to exclude points rejected by the function; 795 assert(gr != nullptr);; 796 ; 797 // get fit option; 798 DataOptions & fitOpt = dv.Opt();; 799 ; 800 BinData::ErrorType type = GetDataType(gr,fitOpt);; 801 // adjust option according to type; 802 fitOpt.fErrors1 = (type == BinData::kNoError);; 803 // set this if we want to have error=1 for points with zero errors (by default they are skipped); 804 // fitOpt.fUseEmpty = true;; 805 ; 806 // use coordinate or asym errors in case option is set and type is consistent; 807 fitOpt.fCoordErrors &= (type == BinData::kCoordError) || (type == BinData::kAsymError) ;; 808 fitOpt.fAsymErrors &= (type == BinData::kAsymError);; 809 ; 810 ; 811 // if data are filled already check if there are consistent - otherwise do nothing; 812 if (dv.Size() > 0 && dv.NDim() == 1 ) {; 813 // check if size is correct otherwise flag an errors; 814 if ( dv.GetErrorType() != type ) {; 815 Error(""FillData"",""Inconsistent TGraph with previous data set- skip all graph data"");; 816 return;; 817 }; 818 }; 819 ; 82",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:25773,assert,assert,25773,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['assert'],['assert']
Testability," be able to stop and launch new jobs) please send a request to Patricia Mendez to obtain an account.; ROOT jobs; Each project in the SFT Jenkins has a specific 'tab' for the defined project jobs. The ROOT tab contains all the defined jobs for ROOT. They are organized as follow:. nightly builds: The jobs are named root-nightly-<version> and they are implemented as multi-configuration project. They are run once a day (around after midnight CET) but they can be started by hand at any time of the day (see later) and select for what configurations to run.; incremental builds: The jobs are named root-incremental-<version> and they are implemented as multi-configuration project. They are run as soon new commits appear in the ROOT git repository and the builds are incremental by default. A full re-build can be triggered by checking the option EMPTY_BINARY.; documentation generation. The jobs are named root-makedoc-<version>. They are started automatically once a day during the day.; testing installations. The job is named root-install and builds ROOT for a number of platforms, produces the installation tar-file or installation kit, installs it in a different place nd runs the tests against the installation (needed to delete the build and source area).; building releases. The job is named root-release-<version> and is multi-configuration job. It builds ROOT for a given 'tagged' version using the source distribution tar-file and produces binaries for a number of configurations, which are installed automatically in the download ROOT server.; other procedures. cling-periodic; cling-clone-repo; cling-repo-sync; root-test; root-staticAnalysis-master. Basic operations; Understanding information for a single build; The Status shows a summary for the build. In case of multi-configuration jobs it it also show the configuration matrix that can be used to select a contrete configuration. See the following figure: ; For each individual build (select one cell in the matrix) the following",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-use-root-jenkins.html:3444,test,testing,3444,d/how-use-root-jenkins.html,https://root.cern,https://root.cern/d/how-use-root-jenkins.html,1,['test'],['testing']
Testability," be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGraphTime, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 498 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:42497,log,logarithmic,42497,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['log'],['logarithmic']
Testability," be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context hol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:13660,log,logicals,13660,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,6,['log'],['logicals']
Testability," be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t[4] rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScene.html:14297,log,logicals,14297,root/html602/TGLScene.html,https://root.cern,https://root.cern/root/html602/TGLScene.html,4,['log'],['logicals']
Testability," before, the per-event analysis happens in Process(). Here again, you need to get the tree entry before you can access the corresponding data members of your selector.; Fitting and Drawing the Histogram; Here again, once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2"").; See the documentation of TSelector on where to do the fitting, i.e. which function of your selector gets called after the whole tree has been processed. You should first fit and then draw, to see the fit together with the histogram.; At the end, you should get the same result than the figure 6 in Histogramming; If, for any reason, you don't manage to get it working, you can download the working selector file here: FullEventDataSelector.C (or; wget http://root-mirror.github.io/training/intro/FullEventDataSelector.C); Note: You will have to use it that way:; EventTree->Process(""FullEventDataSelector.C""). . ‹ Accessing a TTree With a TSelector; up; Using a TSelector with PROOF ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming-selector.html:5276,test,tests,5276,d/histogramming-selector.html,https://root.cern,https://root.cern/d/histogramming-selector.html,1,['test'],['tests']
Testability," bestSignificance); 447 {; 448 bestSignificance = significance;; 449 bestCutSignificance = currentCut;; 450 }; 451 ; 452 addPoint (""Significance"", currentCut, significance);; 453 // m_histSignificance->Fill (currentCut, significance);; 454 }; 455 ; 456 m_significances.push_back (bestSignificance);; 457 ; 458 clear (""OutputSig"");; 459 clear (""OutputBkg"");; 460 for (size_t i = 0; i < numBinsData; ++i); 461 {; 462 addPoint (""OutputSig"", x.at (i), datSig.at (i)/sumWeightsSig);; 463 addPoint (""OutputBkg"", x.at (i), datBkg.at (i)/sumWeightsBkg);; 464 // m_histOutputSignal->Fill (x.at (i), datSig.at (1)/sumWeightsSig);; 465 // m_histOutputBackground->Fill (x.at (i), datBkg.at (1)/sumWeightsBkg);; 466 }; 467 ; 468 ; 469 if (fMonitoring); 470 {; 471 plot (""ROC"", """", 2, kRed);; 472 plot (""Significance"", """", 3, kRed);; 473 plot (""OutputSig"", """", 4, kRed);; 474 plot (""OutputBkg"", ""same"", 4, kBlue);; 475 fMonitoring->ProcessEvents ();; 476 }; 477 ; 478 m_cutValue = bestCutSignificance;; 479 }; 480 ; 481 ; 482 /** \brief check for convergence ; 483 *; 484 */; 485 bool Settings::hasConverged (double testError); 486 {; 487 // std::cout << ""check convergence; minError "" << m_minError << "" current "" << testError; 488 // << "" current convergence count "" << m_convergenceCount << std::endl;; 489 if (testError < m_minError*0.999); 490 {; 491 m_convergenceCount = 0;; 492 m_minError = testError;; 493 }; 494 else; 495 {; 496 ++m_convergenceCount;; 497 m_maxConvergenceCount = std::max (m_convergenceCount, m_maxConvergenceCount);; 498 }; 499 ; 500 ; 501 if (m_convergenceCount >= convergenceSteps () || testError <= 0); 502 return true;; 503 ; 504 return false;; 505 }; 506 ; 507 ; 508 ; 509 /** \brief set the weight sums to be scaled to (preparations for monitoring output); 510 *; 511 */; 512 void ClassificationSettings::setWeightSums (double sumOfSigWeights, double sumOfBkgWeights); 513 {; 514 m_sumOfSigWeights = sumOfSigWeights; m_sumOfBkgWeights = sumOfBkgWeights;; 515 }; 516 ; 517 /** \brie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:16841,test,testError,16841,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,3,['test'],['testError']
Testability," bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. TH1D * GetOutput(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive unfolding result as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive bias as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive unfolding result folded back by the matrix; name: name of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:28579,log,logTauX,28579,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,16,['log'],"['logTauX', 'logTauY']"
Testability," binning (if any) is always to make the value of PROB; slightly too big. That is, setting an acceptance criterion of (PROB>0.05; will assure that at most 5% of truly compatible histograms are rejected,; and usually somewhat less."". Note also that for GoF test of unbinned data ROOT provides also the class; ROOT::Math::GoFTest. The class has also method for doing one sample tests; (i.e. comparing the data with a given distribution). void SetContent(const Double_t* content); -*-*-*-*-*-*Replace bin contents by the contents of array content*-*-*-*. Int_t GetContour(Double_t* levels = 0); Return contour values into array levels if pointer levels is non zero. The function returns the number of contour levels.; see GetContourLevel to return one contour only. Double_t GetContourLevel(Int_t level) const; Return value of contour number level; see GetContour to return the array of all contour levels. Double_t GetContourLevelPad(Int_t level) const; Return the value of contour number ""level"" in Pad coordinates ie: if the Pad; is in log scale along Z it returns le log of the contour level value.; see GetContour to return the array of all contour levels. void SetBuffer(Int_t buffersize, Option_t* option = """"); set the maximum number of entries to be kept in the buffer. void SetContour(Int_t nlevels, const Double_t* levels = 0); Set the number and values of contour levels. By default the number of contour levels is set to 20. The contours values; in the array ""levels"" should be specified in increasing order. if argument levels = 0 or missing, equidistant contours are computed. void SetContourLevel(Int_t level, Double_t value); Set value for one contour level. Double_t GetMaximum(Double_t maxval = FLT_MAX) const; Return maximum value smaller than maxval of bins in the range,; unless the value has been overridden by TH1::SetMaximum,; in which case it returns that value. (This happens, for example,; when the histogram is drawn and the y or z axis limits are changed. To get the maximum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:119153,log,log,119153,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,4,['log'],['log']
Testability," bits per element).Definition TArrayD.h:27; TF11-Dim function classDefinition TF1.h:233; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetRangevirtual void GetRange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetMaximumXYvirtual Double_t GetMaximumXY(Double_t &x, Double_t &y) constCompute the X and Y values corresponding to the maximum value of the function.Definition TF2.cxx:440; TF2::FindMinMaxvirtual Double_t FindMinMax(Double_t *x, bool findmax) constReturn minimum/maximum value of the function.Definition TF2.cxx:363; TF2::~TF2~TF2() overrideF2 default destructor.Definition TF2.cxx:195; TF2::GetMinimumvirtual Double_t GetMinimum(Double_t *x) constReturn minimum/maximum value of the function.Definition TF2.cxx:465; TF2::Copyvoid Copy(TObject &f2) const overrideCopy this F2 to a new F2.Definition TF2.cxx:210; TF2::GetRandom2virtual void GetRandom2(Double_t &xrandom, Double_t &yrandom, TRandom *rng=nullptr)Return 2 random numbers following this function shape.Definition TF2.cxx:547; TF2::GetSaveDouble_t GetSave(const Double_t *x) overrideGet value correspondin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8h_source.html:9884,log,logx,9884,doc/master/TF2_8h_source.html,https://root.cern,https://root.cern/doc/master/TF2_8h_source.html,1,['log'],['logx']
Testability," bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; Optimisation interface; These functions allow RooFit to optimise a computation graph, to keep track of cached values, and to invalidate caches. . virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:21473,test,test,21473,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['test'],['test']
Testability," bool importWorkspaceHook (RooWorkspace &ws);  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::ostream &os, const char *indent="""", const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on given ostream. ;  ; virtual void printCompactTreeHook (std::ostream &os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:17007,test,testArg,17007,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['test'],['testArg']
Testability," box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function. Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.; For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. The viewer indicates this through the interface method PreferLocalFrame(); TVirtualViewer3D::PreferLocalFramevirtual Bool_t PreferLocalFrame() const =0; If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:7521,log,logical,7521,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['log'],['logical']
Testability," buffer, Int_t length, ESendRecvOptions opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidTSocket::SetUrl(const char* url); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSocket::Touch(); TPSocket(TInetAddress address, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(TInetAddress address, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPSocket.html:7261,Test,TestBit,7261,root/html602/TPSocket.html,https://root.cern,https://root.cern/root/html602/TPSocket.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," bufsize); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual Int_tTDirectoryFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDirectoryFile::Write(const char* name = 0, Int_t opt = 0, Int_t bufsize = 0); virtual Int_tTDirectoryFile::Write(const char* name = 0, Int_t opt = 0, Int_t bufsize = 0) const; virtual voidTDirectoryFile::WriteDirHeader(); virtual voidTDirectoryFile::WriteKeys(); Int_tTDirectory::WriteObject(const void* obj, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteTObject(const TObject* obj, const char* name = 0, Option_t* option = """", Int_t bufsize = 0); RooWorkspace::WSDirWSDir(const char* name, const char* title, RooWo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace__WSDir.html:9485,Test,TestBits,9485,root/html534/RooWorkspace__WSDir.html,https://root.cern,https://root.cern/root/html534/RooWorkspace__WSDir.html,1,['Test'],['TestBits']
Testability," but I can't include Type.h here. size_t FunctionMemberSize(Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const. * FunctionMemberByNameAndSignature will return the member with the name,; * optionally the signature of the function may be given as a type; * @param name of function member; * @param signature of the member function; * @modifiers_mask When matching, do not compare the listed modifiers; * @return reflection information of the function member. this overloading is unfortunate but I can't include Type.h here. * FunctionMemberSize will return the number of function members of; * this type; * @return number of function members. void GenerateDict(Reflex::DictionaryGenerator& generator) const. * GenerateDict will produce the dictionary information of this type; * @param generator a reference to the dictionary generator instance. bool HasBase(const Reflex::Type& cl) const. * HasBase will check whether this class has a base class given; * as argument; * @param cl the base-class to check for; * @return the Base info if it is found, an empty base otherwise (can be tested for bool). bool IsPrivate() const. * IsPrivate will check if the scope access is private; * @return true if scope access is private. bool IsProtected() const. * IsProtected will check if the scope access is protected; * @return true if scope access is protected. bool IsPublic() const. * IsPublic will check if the scope access is public; * @return true if scope access is public. Member LookupMember(const string& nam) const. * LookupMember will lookup a member in the current scope; * @param nam the string representation of the member to lookup; * @return if a matching member is found return it, otherwise return empty member. Type LookupType(const string& nam) const. * LookupType will lookup a type in the current scope; * @param nam the string representation of the type to lookup; * @return if a matching type is found return it, otherwise return empty type. Scope LookupScope(const string& nam) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__Scope.html:14009,test,tested,14009,root/html526/Reflex__Scope.html,https://root.cern,https://root.cern/root/html526/Reflex__Scope.html,6,['test'],['tested']
Testability," by Rene Brun. ; Definition at line 1846 of file TMath.cxx. ◆ StruveL0(). Double_t TMath::StruveL0 ; (; Double_t ; x). Struve functions of order 1. ; Modified Struve Function of Order 0.; AuthorKirill Filimonov. ; Definition at line 1923 of file TMath.cxx. ◆ StruveL1(). Double_t TMath::StruveL1 ; (; Double_t ; x). Modified Struve functions of order 0. ; Modified Struve Function of Order 1.; AuthorKirill Filimonov. ; Definition at line 1970 of file TMath.cxx. ◆ Student(). Double_t TMath::Student ; (; Double_t ; T, . Double_t ; ndf . ). Computes density function for Student's t- distribution (the probability function (integral of density) is computed in StudentI). ; First parameter stands for x - the actual variable of the density function p(x) and the point at which the density is calculated. Second parameter stands for number of degrees of freedom.; About Student distribution: Student's t-distribution is used for many significance tests, for example, for the Student's t-tests for the statistical significance of difference between two sample means and for confidence intervals for the difference between two population means.; Example: suppose we have a random sample of size n drawn from normal distribution with mean Mu and st.deviation Sigma. Then the variable; t = (sample_mean - Mu)/(sample_deviation / sqrt(n)); has Student's t-distribution with n-1 degrees of freedom.; NOTE that this function's second argument is number of degrees of freedom, not the sample size.; As the number of degrees of freedom grows, t-distribution approaches Normal(0,1) distribution.; AuthorAnna Kreshuk ; Definition at line 2623 of file TMath.cxx. ◆ StudentI(). Double_t TMath::StudentI ; (; Double_t ; T, . Double_t ; ndf . ). Calculates the cumulative distribution function of Student's t-distribution second parameter stands for number of degrees of freedom, not for the number of samples if x has Student's t-distribution, the function returns the probability of x being less than T. ; This is e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:85091,test,tests,85091,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,2,['test'],['tests']
Testability," by default, standard Cauchy distribution is used (t=0, s=1) ;  ; constexpr Double_t Ccgs ();  \( cm s^{-1} \) ;  ; Double_t Ceil (Double_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t E ();  Base of natural log: \( e \). ;  ; Double_t Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t EulerGamma ();  Euler-Mascheroni Constant. ;  ; Bool_t Even (Long_t a);  Returns true if a is even. ;  ; Double_t Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:5893,log,log,5893,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['log'],['log']
Testability," by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); public:. virtual~ProfileLikelihoodCalculator(); static TClass*Class(); RooStats::CombinedCalculatorRooStats::CombinedCalculator::CombinedCalculator(); RooStats::CombinedCalculatorRooStats::CombinedCalculator::CombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorRooStats::CombinedCalculator::CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorRooStats::CombinedCalculator::CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_tRooStats::CombinedCalculator::ConfidenceLevel() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html:2164,test,test-statistic,2164,root/html602/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html,4,['test'],['test-statistic']
Testability," by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); public:. virtual~ProfileLikelihoodCalculator(); static TClass*Class(); virtual Double_tRooStats::CombinedCalculator::ConfidenceLevel() const; virtual RooStats::HypoTestResult*GetHypoTest() const; virtual RooStats::LikelihoodInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::ProfileLikelihoodCalculator&operator=(const RooStats::ProfileLikelihoodCalculator&); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(const RooStats::ProfileLikelihoodCalculator&); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ProfileLikelihoodCalculator.html:2154,test,test-statistic,2154,root/html528/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__ProfileLikelihoodCalculator.html,6,['test'],['test-statistic']
Testability," by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); public:. virtual~ProfileLikelihoodCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tRooStats::CombinedCalculator::ConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html:2179,test,test-statistic,2179,root/html526/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html,1,['test'],['test-statistic']
Testability," by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Function Selection Based on Residual; . Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function.; ; The sum of squares of residuals can be written as; . (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by; . (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not.; . Test 1; . Denoting by the subspace spanned by; ; the function ; is; by construction (see (4)) the projection of the function; onto the direction perpendicular to . Now, if the; length of ; (given by ; ); is very small compared to the length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:7371,test,test,7371,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,6,['test'],['test']
Testability," bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59361,Test,TestBit,59361,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Test'],['TestBit']
Testability," c#define c(i)Definition RSha256.hxx:101; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; v@ vDefinition rootcling_impl.cxx:3699; Example: gStyle->SetOptFit(1011);; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to gStyle->SetOptFit(111). Statistics box editing; The following example show how to remove and add a line in a statistics box.; ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; kRed@ kRedDefinition Rtypes.h:66; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaveStats.html:7024,test,test,7024,doc/master/classTPaveStats.html,https://root.cern,https://root.cern/doc/master/classTPaveStats.html,2,['test'],['test']
Testability," cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:29630,log,logical,29630,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,4,['log'],['logical']
Testability," cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBasket.html:11644,log,logical,11644,root/html534/TBasket.html,https://root.cern,https://root.cern/root/html534/TBasket.html,6,['log'],['logical']
Testability," cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBasket.html:11591,log,logical,11591,root/html532/TBasket.html,https://root.cern,https://root.cern/root/html532/TBasket.html,2,['log'],['logical']
Testability," calculation. This function accepts the following optional arguments; FrameRange(double lo, double hi) -- Set range of frame to given specification; FrameBins(int bins) -- Set default number of bins of frame to given number; Frame(...) -- Pass supplied named arguments to RooAbsRealLValue::frame() function. See frame() function; for list of allowed arguments; FitGauss(Bool_t flag) -- Add a gaussian fit to the frame. If no frame specifications are given, the AutoSymRange() feature will be used to set the range; Any other named argument is passed to the RooAbsData::plotOn() call. See that function for allowed options. RooPlot* makeFrameAndPlotCmd(const RooRealVar& param, RooLinkedList& cmdList, Bool_t symRange = kFALSE) const; Internal function. Construct RooPlot from given parameter and modify the list of named; arguments 'cmdList' to only contain the plot arguments that should be forwarded to; RooAbsData::plotOn(). RooPlot* plotNLL(Double_t lo, Double_t hi, Int_t nBins = 100); Create a RooPlot of the -log(L) distribution in the range lo-hi; with 'nBins' bins. RooPlot* plotError(const RooRealVar& param, Double_t lo, Double_t hi, Int_t nbins = 100); Create a RooPlot of the distribution of the fitted errors of the given parameter.; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins. RooPlot* plotPull(const RooRealVar& param, Double_t lo = -3., Double_t hi = 3., Int_t nbins = 25, Bool_t fitGauss = kFALSE); Create a RooPlot of the pull distribution for the given; parameter. The range lo-hi is plotted in nbins. If fitGauss is; set, an unbinned ML fit of the distribution to a Gaussian p.d.f; is performed. The fit result is overlaid on the returned RooPlot; and a box with the fitted mean and sigma is added. RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMCStudy.html:26637,log,log,26637,root/html602/RooMCStudy.html,https://root.cern,https://root.cern/root/html602/RooMCStudy.html,4,['log'],['log']
Testability," calculation. This function accepts the following optional arguments; FrameRange(double lo, double hi) -- Set range of frame to given specification; FrameBins(int bins) -- Set default number of bins of frame to given number; Frame(...) -- Pass supplied named arguments to RooAbsRealLValue::frame() function. See frame() function; for list of allowed arguments; FitGauss(Bool_t flag) -- Add a gaussian fit to the frame. If no frame specifications are given, the AutoSymRange() feature will be used to set the range; Any other named argument is passed to the RooAbsData::plotOn() call. See that function for allowed options. RooPlot* makeFrameAndPlotCmd(const RooRealVar& param, RooLinkedList& cmdList, Bool_t symRange = kFALSE) const; Internal function. Construct RooPlot from given parameter and modify the list of named; arguments 'cmdList' to only contain the plot arguments that should be forwarded to; RooAbsData::plotOn(). RooPlot* plotNLL(Double_t lo, Double_t hi, Int_t nBins = 100); Create a RooPlot of the -log(L) distribution in the range lo-hi; with 'nBins' bins. RooPlot* plotError(const RooRealVar& param, Double_t lo, Double_t hi, Int_t nbins = 100); Create a RooPlot of the distribution of the fitted errors of the given parameter.; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins. RooPlot* plotPull(const RooRealVar& param, Double_t lo = -3.0, Double_t hi = 3.0, Int_t nbins = 25, Bool_t fitGauss = kFALSE); Create a RooPlot of the pull distribution for the given; parameter. The range lo-hi is plotted in nbins. If fitGauss is; set, an unbinned ML fit of the distribution to a Gaussian p.d.f; is performed. The fit result is overlaid on the returned RooPlot; and a box with the fitted mean and sigma is added. RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:25686,log,log,25686,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['log'],['log']
Testability," calculation. This function accepts the following optional arguments; FrameRange(double lo, double hi) -- Set range of frame to given specification; FrameBins(int bins) -- Set default number of bins of frame to given number; Frame(...) -- Pass supplied named arguments to RooAbsRealLValue::frame() function. See frame() function; for list of allowed arguments; FitGauss(Bool_t flag) -- Add a gaussian fit to the frame. If no frame specifications are given, the AutoSymRange() feature will be used to set the range; Any other named argument is passed to the RooAbsData::plotOn() call. See that function for allowed options. RooPlot* makeFrameAndPlotCmd(const RooRealVar& param, RooLinkedList& cmdList, Bool_t symRange = kFALSE) const; Internal function. Construct RooPlot from given parameter and modify the list of named; arguments 'cmdList' to only contain the plot arguments that should be forwarded to; RooAbsData::plotOn(). RooPlot* plotNLL(Double_t lo, Double_t hi, Int_t nBins = 100); Create a RooPlot of the -log(L) distribution in the range lo-hi; with 'nBins' bins. RooPlot* plotError(const RooRealVar& param, Double_t lo, Double_t hi, Int_t nbins = 100); Create a RooPlot of the distribution of the fitted errors of the given parameter.; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins. RooPlot* plotPull(const RooRealVar& param, Double_t lo = -3.0, Double_t hi = 3.0, Int_t nbins = 25, Bool_t fitGauss = kFALSE); Create a RooPlot of the pull distribution for the given; parameter. The range lo-hi is plotted in nbins. If fitGauss is; set, an unbinned ML fit of the distribution to a Gaussian p.d.f; is performed. The fit result is overlaid on the returned RooPlot; and a box with the fitted mean and sigma is added. RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMCStudy.html:26100,log,log,26100,root/html528/RooMCStudy.html,https://root.cern,https://root.cern/root/html528/RooMCStudy.html,6,['log'],['log']
Testability," canvas as a Postscript file. ;  ; file  latex3.C;   Example illustrating a TPaveText with Latex inside. ;  ; file  latex4.C;   Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files. ;  ; file  latex5.C;   This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files. ;  ; file  mandelbrot.C;   Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set. ;  ; file  markerwarning.C;   This script illustrates the danger of using asymmetric symbols. ;  ; file  mass_spectrum.C;   This macro makes use of some basic graphics primitives such as line, arrow and text. ;  ; file  palettes.C;   This macro draws all the high definition palettes available in ROOT. ;  ; file  pavetext.C;   Draw a pave text. ;  ; file  perceptualcolormap.C;   A “Perceptual” colormap explicitly identifies a fixed value in the data ;  ; file  piechart.C;   Pie chart example. ;  ; file  polytest1.C;   This macro is testing the ""compacting"" algorithm in TPadPainter. ;  ; file  polytest2.C;   This macro is testing the ""compacting"" algorithm in TPadPainter. ;  ; file  pstable.C;   Display all possible types of ROOT/Postscript characters. ;  ; file  psview.C;   An example how to display PS, EPS, PDF files in canvas. ;  ; file  quarks.C;   Example illustrating divided pads and Latex. ;  ; file  save_batch.C;  This macro demonstrates batch image mode of web canvas When enabled - several images converted into JSON before all together provided to headless browser to produce image files. ;  ; file  saveall.C;   Creates many canvases and save as images or pdf. ;  ; file  schroedinger_hydrogen.C;   Plot the Amplitude of a Hydrogen Atom. ;  ; file  tmathtext.C;  This macro draws various formula in a canvas. ;  ; file  tmathtext2.C;   This macro draw all possible symbols provided by TMathtext. ;  ; file  tornado.C;   Show 3-d polymarker. ;  ; file  transparency.C;   This macro demonstrates the use of color transparency. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__graphics.html:3271,test,testing,3271,doc/master/group__tutorial__graphics.html,https://root.cern,https://root.cern/doc/master/group__tutorial__graphics.html,1,['test'],['testing']
Testability," capacity. If nc != current capacity Clone() the string; in a string with the desired capacity. int CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; Compare a string to char *cs2. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend characters to self. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const char* s1, Ssiz_t ls1, const char* s2, Ssiz_t ls2); Find & Replace ls1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TString.html:10103,test,tested,10103,root/html528/TString.html,https://root.cern,https://root.cern/root/html528/TString.html,1,['test'],['tested']
Testability," case of empty bin they could be merged in a single larger bin; 514 Return a NULL pointer if the bin width is not stored; 515 */; 516 // not threadsafe, to be replaced with never constructs!; 517 // for example: just return std::array or std::vector, there's; 518 // is going to be only minor overhead in c++11.; 519 const double* BinUpEdge( unsigned int ipoint ) const; 520 {; 521 if ( fBinEdge.empty() || ipoint > fBinEdge.front().size() ); 522 return nullptr;; 523 ; 524 GetBinUpEdgeCoordinates(ipoint, fpTmpBinEdgeVector);; 525 ; 526 return fpTmpBinEdgeVector;; 527 }; 528 ; 529 /**; 530 * Thread save version of function retrieving the bin up-edge in case of multidimensions; 531 */; 532 void GetBinUpEdgeCoordinates(unsigned int ipoint, double * x) const; 533 {; 534 if (fBinEdge.empty() || ipoint > fBinEdge.front().size()) return;; 535 assert(!fBinEdge.empty());; 536 assert(ipoint < fMaxPoints);; 537 for (unsigned int i = 0; i < fDim; i++) {; 538 x[i] = fBinEdge[i][ipoint];; 539 }; 540 }; 541 ; 542 /**; 543 query if the data store the bin edges instead of the center; 544 */; 545 bool HasBinEdges() const {; 546 return fBinEdge.size() == fDim && !fBinEdge[0].empty();; 547 }; 548 ; 549 /**; 550 retrieve the reference volume used to normalize the data when the option bin volume is set; 551 */; 552 double RefVolume() const { return fRefVolume; }; 553 ; 554 /**; 555 set the reference volume used to normalize the data when the option bin volume is set; 556 */; 557 void SetRefVolume(double value) { fRefVolume = value; }; 558 ; 559 /**; 560 retrieve the errortype; 561 */; 562 ErrorType GetErrorType( ) const; 563 {; 564 return fErrorType;; 565 }; 566 ; 567 /**; 568 compute the total sum of the data content; 569 (sum of weights in case of weighted data set); 570 */; 571 double SumOfContent() const { return fSumContent; }; 572 ; 573 /**; 574 compute the total sum of the error square; 575 (sum of weight square in case of a weighted data set); 576 */; 577 double SumOfError2() const { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:19118,assert,assert,19118,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability," case. ; Implements RooAbsLValue.; Definition at line 133 of file RooErrorVar.cxx. ◆ getValV(). double RooErrorVar::getValV ; (; const RooArgSet * ; set = nullptr); const. overridevirtual . Return value, i.e. error on input variable. ; Reimplemented from RooAbsReal.; Definition at line 70 of file RooErrorVar.cxx. ◆ hasBinning(). bool RooErrorVar::hasBinning ; (; const char * ; name); const. overridevirtual . Return true if we have binning with given name. ; Implements RooAbsRealLValue.; Definition at line 80 of file RooErrorVar.cxx. ◆ IsA(). TClass * RooErrorVar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsRealLValue.; Definition at line 101 of file RooErrorVar.h. ◆ isFundamental(). bool RooErrorVar::isFundamental ; (; ); const. inlineoverridevirtual . Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ; Note that this test is subtlely different from the dynamic isDerived() test, e.g. a constant is not derived but is also not fundamental. ; Reimplemented from RooAbsArg.; Definition at line 51 of file RooErrorVar.h. ◆ operator=(). RooAbsArg & RooAbsRealLValue::operator= ; (; double ; newValue). virtual . Assignment operator from a double. ; Reimplemented from RooAbsRealLValue.; Definition at line 46 of file RooAbsRealLValue.cxx. ◆ readFromStream(). bool RooErrorVar::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from given stream. ; Reimplemented from RooAbsRealLValue.; Definition at line 289 of file RooErrorVar.cxx. ◆ removeMax(). void RooErrorVar::removeMax ; (; const char * ; name = nullptr). Remove upper bound from named binning, or default binning if name is null. ; Definition at line 152 of file RooErrorVar.cxx. ◆ removeMin(). void RooErrorVar::removeMin ; (; const char * ; name = nullptr). Remove lower bound from named binning, or defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:73373,test,test,73373,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,2,['test'],['test']
Testability," cbShape(double m, double m0, double sigma, double alpha, double n)Definition MathFuncs.h:382; RooFit::Detail::MathFuncs::polynomialdouble polynomial(double const *coeffs, int nCoeffs, int lowestOrder, double x)In pdfMode, a coefficient for the constant term of 1.0 is implied if lowestOrder > 0.Definition MathFuncs.h:130; RooFit::Detail::MathFuncs::recursiveFractiondouble recursiveFraction(double *a, unsigned int n)Definition MathFuncs.h:371; RooFit::Detail::MathFuncs::constraintSumdouble constraintSum(double const *comp, unsigned int compSize)Definition MathFuncs.h:163; RooFit::Detail::MathFuncs::cbShapeIntegraldouble cbShapeIntegral(double mMin, double mMax, double m0, double sigma, double alpha, double n)Definition MathFuncs.h:649; RooFit::Detail::MathFuncs::fast_fmadouble fast_fma(double x, double y, double z) noexceptuse fast FMA if available, fall back to normal arithmetic if notDefinition MathFuncs.h:500; RooFit::Detail::MathFuncs::logNormalIntegralStandarddouble logNormalIntegralStandard(double xMin, double xMax, double mu, double sigma)Definition MathFuncs.h:638; RooFit::Detail::MathFuncs::landaudouble landau(double x, double mu, double sigma)Definition MathFuncs.h:331; RooFit::Detail::MathFuncs::gaussiandouble gaussian(double x, double mean, double sigma)Function to evaluate an un-normalized RooGaussian.Definition MathFuncs.h:86; RooFit::Detail::MathFuncs::productdouble product(double const *factors, std::size_t nFactors)Definition MathFuncs.h:93; RooFit::Detail::MathFuncs::chebychevdouble chebychev(double *coeffs, unsigned int nCoeffs, double x_in, double xMin, double xMax)Definition MathFuncs.h:139; RooFit::Detail::MathFuncs::poissondouble poisson(double x, double par)Definition MathFuncs.h:198; RooFit::Detail::MathFuncs::binomialdouble binomial(int n, int k)Calculates the binomial coefficient n over k.Definition MathFuncs.h:31; RooFit::Detail::MathFuncs::getUniformBinningunsigned int getUniformBinning(double low, double high, double val, unsigned int num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:28132,log,logNormalIntegralStandarddouble,28132,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,2,['log'],"['logNormalIntegralStandard', 'logNormalIntegralStandarddouble']"
Testability," chaine, Int_t& err, Int_t offset = 0); Check if the chain as function call. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. void Analyze(const char* schain, Int_t& err, Int_t offset = 0); Analyze a sub-expression in one formula. Expressions in one formula are recursively analyzed.; Result of analysis is stored in the object tables. Table of function codes and errors. * functions :. + 1 pow 20; - 2 sq 21; * 3 sqrt 22; / 4 strstr 23; % 5 min 24; max 25; log 30; cos 10 exp 31; sin 11 log10 32; tan 12; acos 13 abs 41; asin 14 sign 42; atan 15 int 43; atan2 16; fmod 17 rndm 50. cosh 70 acosh 73; sinh 71 asinh 74; tanh 72 atanh 75. expo 100 gaus 110 gausn (see note below); expo(0) 100 0 gaus(0) 110 0 gausn(0); expo(1) 100 1 gaus(1) 110 1 gausn(1); xexpo 100 x xgaus 110 x xgausn; yexpo 101 x ygaus 111 x ygausn; zexpo 102 x zgaus 112 x zgausn; xyexpo 105 x xygaus 115 x xygausn; yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2). landau 120 x landaun (see note below); landau(0) 120 0 landaun(0); landau(1) 120 1 landaun(1); xlandau 120 x xlandaun; ylandau 121 x ylandaun; zlandau 122 x zlandaun; xylandau 125 x xylandaun; ylandau(5) 121 5 ylandaun(5); xylandau(2) 125 2 xylandaun(2). pol0 130 x pol1 130 1xx; pol0(0) 130 0 pol1(0) 130 100; pol0(1) 130 1 pol1(1) 130 101; xpol0 130 x xpol1 130 101; ypol0 131 x ypol1 131 101; zpol0 132 x zpol1 132 1xx; ypol0(5) 131 5 ypol1(5) 131 105. pi 40. && 60 < 64; || 61 > 65; == 62 <= 66; != 63 => 67; !",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:15152,log,log,15152,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,6,['log'],['log']
Testability," char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  ~TMultiLayerPerceptron () override;  Destructor. ;  ; void ComputeDEDw () const;  Compute the DEDw = sum on all training events of dedw for each weight normalized by the number of events. ;  ; void Draw (Option_t *option="""") override;  Draws the network structure. ;  ; void DrawResult (Int_t index=0, Option_t *option=""test"") const;  Draws the neural net output It produces an histogram with the output for the two datasets. ;  ; Bool_t DumpWeights (Option_t *filename=""-"") const;  Dumps the weights to a text file. ;  ; Double_t Evaluate (Int_t index, Double_t *params) const;  Returns the Neural Net for a given set of input parameters #parameters must equal #input neurons. ;  ; void Export (Option_t *filename=""NNfunction"", Option_t *language=""C++"") const;  Exports the NN as a function for any non-ROOT-dependant co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:11198,test,test,11198,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['test'],['test']
Testability," char *value);  add attribute to node ;  ; void * AddChild (void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false);  add child node ;  ; Bool_t AddComment (void *node, const char *comment);  ; Bool_t AddRawLine (void *node, const char *raw);  XML helpers. ;  ; std::vector< TMatrixDSym * > * CalcCovarianceMatrices (const std::vector< const Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr);  ; std::vector< TMatrixDSym * > * CalcCovarianceMatrices (const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr);  compute covariance matrices ;  ; Bool_t CheckForSilentOption (const TString &) const;  check for ""silence"" option in configuration option string ;  ; Bool_t CheckForVerboseOption (const TString &) const;  check if verbosity ""V"" set in option ;  ; Bool_t CheckSplines (const TH1 *, const TSpline *);  check quality of splining by comparing splines and histograms in each bin ;  ; const TString & Color (const TString &);  human readable color strings ;  ; void ComputeStat (const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE);  sanity check ;  ; Double_t ComputeVariance (Double_t sumx2, Double_t sumx, Int_t nx);  compute variance from given sums ;  ; Bool_t ContainsRegularExpression (const TString &s);  check if regular expression helper function to search for ""$!%^&()'<>?= "" in a string ;  ; void FormattedOutput (const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"");  formatted output of simple table ;  ; void FormattedOutput (const TMatrixD &, const std::vector< TString > &, MsgLogger &logger);  formatted output of matrix (with labels) ;  ; void FormattedOutput (const TMatrixD &, const std::vector< TString > &vert, const std::vector< TString > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:2724,log,logger,2724,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['log'],['logger']
Testability," char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; TString Getenv (const char *env, const char *ord=""0"");  Get value of environment variable 'env' on node 'ord'. ;  ; TList * GetFeedbackList () const;  Return feedback list. ;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TList * GetInputList ();  Get input list. ;  ; TMacro * GetLastLog ();  Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ;  ; TList * GetListOfEnabledPackages ();  Get from the master the list of names of the packages enabled. ;  ; TList * GetListOfPackages ();  Get from the master the list of names of the packages available. ;  ; TList * GetListOfSlaveInfos ();  Returns list of TSlaveInfo's. In case of error return 0. ;  ; TList * GetLoadedMacros () const;  ; void GetLog (Int_t start=-1, Int_t end=-1);  Ask for remote logs in the range [start, end]. ;  ; Int_t GetLogLevel () const;  ; TMacro * GetMacroLog ();  ; TProofMgr * GetManager ();  ; const char * GetMaster () const;  ; void GetMaxQueries ();  Get max number of queries whose full results are kept in the remote sandbox. ;  ; TFileCollection * GetMissingFiles (TQueryResult *qr=0);  Get a TFileCollection with the files missing in the query described by 'qr' or the last query if qr is null (default). ;  ; Int_t GetNumberOfDrawQueries ();  ; Int_t GetNumberOfQueries ();  Number of queries processed by this session. ;  ; TObject * GetOutput (const char *name);  Get specified object that has been produced during the processing (see Process()). ;  ; TList * GetOutputList ();  Get list with all object created during processing (see Process()). ;  ; TList * GetOutputNames ();  FIXME: to be written. ;  ; Int_t GetParallel () const;  Returns number of slaves active in parallel mode. ;  ; TObject * GetParameter (const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:11573,log,logs,11573,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['log'],['logs']
Testability," char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:18719,log,loglevel,18719,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,4,['log'],['loglevel']
Testability," char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TDocMacroDirective&operator=(const TDocMacroDirective&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDocMacroDirective.html:5293,Test,TestBit,5293,root/html532/TDocMacroDirective.html,https://root.cern,https://root.cern/root/html532/TDocMacroDirective.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:17100,Test,TestBit,17100,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2009-12-07 13:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:15698,log,logon,15698,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,1,['log'],['logon']
Testability," char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2010-10-06 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplicationServer.html:15857,log,logon,15857,root/html528/TApplicationServer.html,https://root.cern,https://root.cern/root/html528/TApplicationServer.html,1,['log'],['logon']
Testability," char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TApplicationServer.html:16008,log,logon,16008,root/html530/TApplicationServer.html,https://root.cern,https://root.cern/root/html530/TApplicationServer.html,1,['log'],['logon']
Testability," char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TApplicationServer.html:16008,log,logon,16008,root/html532/TApplicationServer.html,https://root.cern,https://root.cern/root/html532/TApplicationServer.html,2,['log'],['logon']
Testability," char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TApplicationServer.html:16793,log,logon,16793,root/html604/TApplicationServer.html,https://root.cern,https://root.cern/root/html604/TApplicationServer.html,2,['log'],['logon']
Testability," char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:16793,log,logon,16793,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,2,['log'],['logon']
Testability," char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetFile(TFile* file); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheWrite.html:4978,Test,TestBit,4978,root/html534/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* opt = """") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TParticleClassPDG(const char* name = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParticleClassPDG.html:4627,Test,TestBit,4627,root/html602/TParticleClassPDG.html,https://root.cern,https://root.cern/root/html602/TParticleClassPDG.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTMVA::Configurable::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidBuildKDEPDF(); voidBuildSplinePDF(); voidCheckHist() const; voidFillHistToGraph(); voidFillSplineToHist(); voidFindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; Double_tGetIntegral() const; Double_tGetPdfHistBinWidth() const; static TMVA::PDF*&GetThisPdfThreadLocal(); static Double_tIGetVal(Double_t*, Double_t*); TMVA::MsgLogger&Log() const; voidSmoothHistogram(); static TMVA::PDF*ThisPDF(); Bool_tUseHistogram() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMVA::PDF::EInterpolateMethodkKDE; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TMVA::P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDF.html:7819,Log,Log,7819,root/html602/TMVA__PDF.html,https://root.cern,https://root.cern/root/html602/TMVA__PDF.html,2,['Log'],['Log']
Testability," char* name); const TGPicture*TGMainFrame::SetIconPixmap(const char* iconName); voidTGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressLog.html:16509,Test,TestBit,16509,root/html532/TProofProgressLog.html,https://root.cern,https://root.cern/root/html532/TProofProgressLog.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerTestStatSampler(); RooStats::TestStatSamplerTestStatSampler(const RooStats::TestStatSampler&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__TestStatSampler.html:2545,test,testStatistic,2545,root/html602/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__TestStatSampler.html,4,['test'],['testStatistic']
Testability," char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRegisterCommand(const char* cmdname, const char* method, const char* icon); Bool_tRegisterObject(const char* subfolder, TObject* obj); voidTObject::ResetBit(UInt_t f); voidRestrict(const char* path, const char* options); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store, Bool_t only_fields = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentCallArg(THttpCallArg* arg); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tSetItemField(const char* fullname, const char* name, const char* value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadOnly(Bool_t on = kTRUE); voidSetScanGlobalDir(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TRootSniffer(const TRootSniffer&); TRootSniffer(const char* name, const char* objpath = ""Objects""); Bool_tUnregisterObject(TObject* obj); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSniffer.html:6535,Test,TestBit,6535,root/html604/TRootSniffer.html,https://root.cern,https://root.cern/root/html604/TRootSniffer.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTGLEventHandler::RemoveTooltip(); virtual voidTGLEventHandler::Repaint(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGEventHandler::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLEventHandler::SetDoInternalSelection(Bool_t x); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLego(TEveCaloLego* x); voidTGLEventHandler::SetMouseOverSelectDelay(Int_t ms); voidTGLEventHandler::SetMouseOverTooltipDelay(Int_t ms); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGLEventHandler::SetSecSelType(Int_t t); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidTGLEventHandler::SetTooltipPixelTolerance(Int_t t); voidSetTransTheta(Float_t h); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidTGLEventHandler::StartMouseTimer(); virtual voidTGLEventHandler::StopMouseTimer(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGLEventHandler::TriggerTooltip(const char* text); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveLegoEventHandler.html:9336,Test,TestBit,9336,root/html532/TEveLegoEventHandler.html,https://root.cern,https://root.cern/root/html532/TEveLegoEventHandler.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tSendFileCloseEvent(TFile*); virtual Bool_tSendFileOpenProgress(TFile*, TList*, const char*, Bool_t = kFALSE); virtual Bool_tSendFileReadProgress(TFile*); virtual Bool_tSendFileWriteProgress(TFile*); virtual Bool_tSendInfoDescription(const char*); virtual Bool_tSendInfoStatus(const char*); virtual Bool_tSendInfoTime(); virtual Bool_tSendInfoUser(const char* = 0); virtual Bool_tSendParameters(TList*, const char* = 0); virtual Bool_tSendProcessingProgress(Double_t, Double_t, Bool_t = kFALSE); virtual Bool_tSendProcessingStatus(const char*, Bool_t = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLogLevel(const char* = ""WARNING""); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMonitoringWriter.html:5308,Test,TestBit,5308,root/html534/TVirtualMonitoringWriter.html,https://root.cern,https://root.cern/root/html534/TVirtualMonitoringWriter.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::v5::TFormulaPrimitive::GenFunc0 fpointer); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::v5::TFormulaPrimitive::GenFunc10 fpointer); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::v5::TFormulaPrimitive::GenFunc110 fpointer); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::v5::TFormulaPrimitive::GenFunc1110 fpointer); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::v5::TFormulaPrimitive::TFunc0 fpointer); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::v5::TFormulaPrimitive::TFunc10 fpointer); ROOT::v5::TFormulaPrimitiveTFormulaPrimitive(const char* name, const char* formula, ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TFormulaPrimitive.html:5720,Test,TestBit,5720,root/html604/ROOT__v5__TFormulaPrimitive.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TFormulaPrimitive.html,1,['Test'],['TestBit']
Testability," char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TFormulaPrimitive(); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::GenFunc0 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::GenFunc10 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::GenFunc110 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::GenFunc1110 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::TFunc0 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::TFunc10 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::TFunc110 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::TFunc1110 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::TFuncG fpointer); TFormulaPrimitive(const char* name, const char* form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFormulaPrimitive.html:5650,Test,TestBit,5650,root/html602/TFormulaPrimitive.html,https://root.cern,https://root.cern/root/html602/TFormulaPrimitive.html,1,['Test'],['TestBit']
Testability," char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTableSorter(); TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableSorter.html:7938,Test,TestBit,7938,root/html602/TTableSorter.html,https://root.cern,https://root.cern/root/html602/TTableSorter.html,2,['Test'],['TestBit']
Testability," char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tTProofPlayer::AssertSelector(const char* selector_file); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Bool_tTProofPlayer::CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofPlayer::DrawCanvas(TObject* obj); virtual void*TProofPlayer::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); voidTProofPlayer::MapOutputListToDataMembers() const; virtual voidTProofPlayer::MergeOutput(); virtual voidSetupFeedback(); virtual voidStopFeedback(). Data Members; public:. static TVirtualProofPlayer::EExitStatusTVirtualProofPlayer::kAborted; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TProofPlayer::EStatusBitsTProofPlayer::kDispatchOneEvent; static TVirtualProofPlayer::EExitStatusTVirtualProofPlayer::kFinished; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:12521,Assert,AssertSelector,12521,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,1,['Assert'],['AssertSelector']
Testability," char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tTProofPlayer::AssertSelector(const char* selector_file); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Bool_tTProofPlayer::CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofPlayer::DrawCanvas(TObject* obj); virtual void*TProofPlayer::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); voidTProofPlayer::MapOutputListToDataMembers() const; virtual voidTProofPlayer::MergeOutput(); virtual voidSetupFeedback(); virtual voidStopFeedback(). private:. virtual Bool_tHandleTimer(TTimer* timer). Data Members; public:. static TVirtualProofPlayer::EExitStatusTVirtualProofPlayer::kAborted; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TProofPlayer::EStatusBitsTProofPlayer::kDispatchOneEvent; static TVirtualProofPlayer::EExitStatusTVirtualProofPlayer::kFinished; static TObject::EStatusBitsTObject::kHasUU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:12415,Assert,AssertSelector,12415,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,1,['Assert'],['AssertSelector']
Testability," char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); TProofCondor(const TProofCondor&); TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:19274,Test,TestBits,19274,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,2,['Test'],['TestBits']
Testability," char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); TProofSuperMaster(const TProofSuperMaster&); TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofSuperMaster.html:19109,Test,TestBits,19109,root/html602/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofSuperMaster.html,2,['Test'],['TestBits']
Testability," char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDefined(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUsed(Bool_t flag = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tZ() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoElement.html:5408,Test,TestBit,5408,root/html532/TGeoElement.html,https://root.cern,https://root.cern/root/html532/TGeoElement.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSharedPropertiesList&operator=(const RooSharedPropertiesList&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooSharedProperties*registerProperties(RooSharedProperties*, Bool_t canDeleteIncoming = kTRUE); voidTObject::ResetBit(UInt_t f); RooSharedPropertiesList(); RooSharedPropertiesList(const RooSharedPropertiesList&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidunregisterProperties(RooSharedProperties*); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSharedPropertiesList.html:4623,Test,TestBit,4623,root/html602/RooSharedPropertiesList.html,https://root.cern,https://root.cern/root/html602/RooSharedPropertiesList.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," char* t); virtual voidTEveTrack::SetTrackParams(const TEveTrack& t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveTrack::SortPathMarksByTime(); voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveTrackProjected(); virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveTrack::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrackProjected.html:23492,Test,TestBit,23492,root/html602/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html602/TEveTrackProjected.html,6,['Test'],"['TestBit', 'TestBits', 'TestCSCBits']"
Testability," char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; Bool_tStartTransaction(); voidStopLogFile()MENU ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TSQLFile(); TSQLFile(const TSQLFile&); TSQLFile(const char* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* = 0, Int_t = 0, Int_t = 0); virtual Int_tWrite(const char* = 0, Int_t = 0, Int_t = 0) const; virtual Bool_tWriteBuffer(const char*, Int_t); virtual voidTDirectoryFile::WriteDirHeader(); virtual voidWriteFree(); virtual voidWriteHeader(); virtual voidTDirectoryFile::WriteKeys(); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual UShort_tTFile::WriteProcessID(TProcessID* pid); virtual voidWriteStreamerInfo(); virtual Int_tTDirectoryFile::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:21006,Test,TestBits,21006,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,2,['Test'],['TestBits']
Testability," char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveWindowFrame(TGFrame* frame, const char* n = ""TEveWindowFrame"", const char* t = """"); voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindowFrame.html:16903,Test,TestBit,16903,root/html602/TEveWindowFrame.html,https://root.cern,https://root.cern/root/html602/TEveWindowFrame.html,2,['Test'],['TestBit']
Testability," char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveWindowTab(TGTab* tab, const char* n = ""TEveWindowTab"", const char* t = """"); voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindowTab.html:16853,Test,TestBit,16853,root/html602/TEveWindowTab.html,https://root.cern,https://root.cern/root/html602/TEveWindowTab.html,2,['Test'],['TestBit']
Testability," char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If true, the pad is updated while the motion of a dragged range. void SetVertDisplay(Bool_t vert = kTRUE); Set the vertical or horizontal display. void UnzoomAll(); Unzoom all variables. TParallelCoord(). Bool_t GetCandleChart(); {return TestBit(kCandleChart);}. Long64_t GetCurrentFirst(); {return fCurrentFirst;}. Long64_t GetCurrentN(); {return fCurrentN;}. Bool_t GetCurveDisplay() const; {return TestBit(kCurveDisplay);}. Int_t GetDotsSpacing() const; {return fDotsSpacing;}. Bool_t GetGlobalScale(); {return TestBit(kGlobalScale);}. Bool_t GetGlobalLogScale(); {return TestBit(kGlobalLogScale);}. Color_t GetLineColor(); {return fLineColor;}. Width_t GetLineWidth(); {return fLineWidth;}. UInt_t GetNvar(); {return fNvar;}. Long64_t GetNentries(); {return fNentries;}. TList * GetSelectList(); {return fSelectList;}. TList * GetVarList(); {return fVarList;}. Bool_t GetVertDisplay() const; {return TestBit(kVertDisplay);}. Int_t GetWeightCut() const; {return fWeightCut;}. void SetCurveDisplay(Bool_t curve = 1); {SetBit(kCurveDisplay,curve);}. void SetCurrentEntries(TEntryList* entries); {fCurrentEntries = entries;}. void SetInitEntries(TEntryList* entries); {fInitEntries = entries;}. void SetLineColor(Color_t col); {fLineColor = col;}. void SetLineWidth(Width_t wid); {fLineWidth = wid;}. void SetNentries(Long64_t n); {fNentries = n;}. void SetTree(TTree* tree); {fTree = tree;}. void SetWeightCut(Int_t w = 0); {fWeightCut = w;}. » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParallelCoord.html:17509,Test,TestBit,17509,root/html532/TParallelCoord.html,https://root.cern,https://root.cern/root/html532/TParallelCoord.html,1,['Test'],['TestBit']
Testability," chart example ;  splines_test.C Examples of use of the spline classes ;  surfaces.C Draw 2-Dim functions ;  timeonaxis.C This macro illustrates the use of the time mode on the axis with different time intervals and time formats ;  timeonaxis2.C Define the time offset as 2003, January 1st ;  timeonaxis3.C This example compares what the system time function gmtime and localtime give with what gives TGaxis ;  timeSeriesFromCSV.C This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  timeSeriesFromCSV.py This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  timeSeriesFromCSV_TDF.C This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  waves.C Hint: Spherical waves ;  zdemo.C This macro is an example of graphs in log scales with annotations ;  zones.C Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  zones.py Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  ► gui;  buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ;  buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ;  buttonsLayout.CThis macro gives an example of different buttons' layout ;  buttonTest.CThis macro gives an example of how to set/change text button attributes ;  calendar.CThis macro gives an example of how to use html widget to display tabular data ;  CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ;  customContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:116920,log,log,116920,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['log'],['log']
Testability, charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivationChooser.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TActivationChooser.html:1211,log,logger,1211,root/html532/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html532/TMVA__TActivationChooser.html,2,['log'],['logger']
Testability," class ; Definition at line 47 of file TGObject.h. ◆ DeclFileName(). static const char * TGObject::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 47 of file TGObject.h. ◆ GetClient(). TGClient * TGObject::GetClient ; (; ); const. inline . Definition at line 42 of file TGObject.h. ◆ GetId(). Handle_t TGObject::GetId ; (; ); const. inline . Definition at line 41 of file TGObject.h. ◆ Hash(). ULong_t TGObject::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TGObject::HashULong_t Hash() const overrideReturn hash value for this object.Definition TGObject.h:43; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 43 of file TGObject.h. ◆ IsA(). TClass * TGObject::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGObject.html:12449,log,logarithmic,12449,doc/master/classTGObject.html,https://root.cern,https://root.cern/doc/master/classTGObject.html,1,['log'],['logarithmic']
Testability," class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; THStack::THStackTHStack()Definition THStack.h:57; TTextBase class for several text objects.Definition TText.h:22; h1TH1F * h1Definition legend1.C:5. A more complex example:; ; void hstack(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; auto cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");; ; cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; auto a = new THStack(""a"",""Stacked 2D histograms"");; auto f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params1[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5,; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params1);; auto h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHStack.html:3608,test,test,3608,doc/master/classTHStack.html,https://root.cern,https://root.cern/doc/master/classTHStack.html,3,['test'],['test']
Testability, class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interfa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:111052,log,log,111052,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['log'],['log']
Testability, class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite Local worker PROOF Ser,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:109106,log,log,109106,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['log']
Testability," clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch with the same name as this; 3022/// object. If no double branch is found with the name of this; 3023/// object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc; 3024/// branch. If any of these are found, a TreeReadBuffer; 3025/// that branch is created, and saved in _treeReadBuffer.; 3026/// TreeReadBuffer::operator double() can be used to convert the value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:130265,assert,assert,130265,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['assert'],['assert']
Testability," clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:11066,log,logical,11066,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,10,['log'],['logical']
Testability," clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 40096 2011-07-01 10:08:17Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:11195,test,test,11195,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,1,['test'],['test']
Testability," clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 41455 2011-10-18 13:23:21Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverter.html:11712,test,test,11712,root/html532/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverter.html,2,['test'],['test']
Testability," collection classes. ctorture.cxx; Test program for the class TComplex. tstring.cxx; Example usage of the ROOT string class. vmatrix.cxx; Verification program for the TMatrix class. vvector.cxx; Verification program for the TVectorclass. vlazy.cxx; Verification program for lazy matrices. hworld.cxx; Small program showing basic graphics. guitest.cxx; Example usage of the ROOT GUI classes. gui viewer .cxx; Another ROOT GUI example program. Hello.cxx; Dancing text example. Aclock.cxx; Analog clock (a la X11 xclock). Tetris.cxx; The known Tetris game based on the ROOT graphics. stress.cxx; Important ROOT stress testing program. stress*.cxx; Stress testing of different ROOT classes. bench.cxx; STL and ROOT container test and benchmarking program. QpRandomDriver.cx x; Verification program for Quadratic programming classes in Quadp library. DrawTest.sh; Entry script to extensive TTree query test suite. dt_*; Scripts used by DrawTest.sh. The $ROOTSYS/test directory is a gold mine of root-wisdom nuggets, and we encourage you to explore and exploit it. These instructions will compile all programs in $ROOTSYS/test:; If you do not have write permission in the $ROOTSYS/test directory, copy the entire $ROOTSYS/test directory to your area. The Makefile is a useful example of how ROOT applications are linked and built. Edit the Makefile to specify your architecture by changing the ARCH variable, for example, on an SGI machine type:ARCH = sgikcc.; Now compile all programs:; % gmake; This will build several applications and shared libraries. We are especially interested in Event, stress, and guitest.; 20.2.1 Event - An Example of a ROOT Application; Event is created by compiling MainEvent.cxx, and Event.cxx. It creates a ROOT file with a tree and two histograms. When running Event we have four optional arguments with defaults:. Argument; Default. 1; Number of Events (1 … n); 400. 2; Compression level:; 0: no compression at all.; 1: If the split level is set to zero, everything is comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1077066,test,test,1077066,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability," color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidSetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); virtual voidSetTheta(Double_t theta = 30); virtual voidSetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetTickx(Int_t value = 1); virtual voidSetTicky(Int_t value = 1); virtual voidSetTitle(const char* title = """"); virtual voidSetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVertical(Bool_t vert = kTRUE); virtual voidSetView(TView* view = 0); virtual voidSetViewer3D(TVirtualViewer3D*); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(); virtual voidTObject::UseCurrentStyle(); virtual Int_tUtoAbsPixel(Double_t u) const; virtual Int_tUtoPixel(Double_t u) const; virtual Int_tVtoAbsPixel(Double_t v) const; virtual Int_tVtoPixel(Double_t v) const; virtual TObject*WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tXtoAbsPixel(Double_t x) const; virtual Double_tXtoPad(Double_t x) const; virtual Int_tXtoPixel(Double_t x) const; virtual Int_tYtoAbsPixel(Double_t y) const; virtual Double_tYtoPad(Double_t y) const; virtual Int_tYtoPixel(Double_t y) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualPad.html:17610,Test,TestBit,17610,root/html532/TVirtualPad.html,https://root.cern,https://root.cern/root/html532/TVirtualPad.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," color, rMin, rMax, dz);; break;; }; case 2: {; volumes[i] = geom->MakeTubs(name, medSolid, rMin, rMax, dz,; phi1, phi2);; printf(""Volume %d : Color %d, Tube Seg, Inner Radius %f, ""; ""Outer Radius %f, Length %f, Phi1 %f, Phi2 %f\n"",; i, color, rMin, rMax, dz, phi1, phi2);; break;; }; case 3: {; Double_t n1[3], n2[3];; n1[0] = gRandom->Rndm()*.5;; n1[1] = gRandom->Rndm()*.5; n1[2] = -1.0 + gRandom->Rndm()*.5;; n2[0] = gRandom->Rndm()*.5;; n2[1] = gRandom->Rndm()*.5; n2[2] = 1.0 - gRandom->Rndm()*.5;; ; volumes[i] = geom->MakeCtub(name, medSolid, rMin, rMax, dz,; phi1, phi2, n1[0], n1[1], n1[2],; n2[0], n2[1], n2[2]);; printf(""Volume %d : Color %d, Cut Tube, Inner Radius %f, ""; ""Outer Radius %f, Length %f, Phi1 %f, Phi2 %f, ""; ""n1 (%f,%f,%f), n2 (%f,%f,%f)\n"",; i, color, rMin, rMax, dz, phi1, phi2,; n1[0], n1[1], n1[2], n2[0], n2[1], n2[2]);; break;; }; default: {; assert(kFALSE);; }; }; ; volumes[i]->SetLineColor(color);; }; ; printf(""\nCreated %d volumes\n\n"", volumeCount);; ; // Scatter reqSpheres placed sphere randomly in space; Double_t x, y, z;; for (i = 0; i < reqNodes; i++) {; // Pick random volume; UInt_t useVolume = gRandom->Integer(volumeCount);; ; TGeoTranslation * trans;; TGeoRotation * rot;; if (randomDist) {; // Random translation; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; trans = new TGeoTranslation(x*worldRadius, y*worldRadius, z*worldRadius);; ; // Random rotation; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; rot = new TGeoRotation(""rot"", x*360.0, y*360.0, z*360.0);; } else {; UInt_t perSide = pow(reqNodes,1.0/3.0)+0.5;; Double_t distance = sizeBase*5.0;; UInt_t xi, yi, zi;; zi = i / (perSide*perSide);; yi = (i / perSide) % perSide;; xi = i % perSide;; trans = new TGeoTranslation(xi*distance,yi*distance,zi*distance);; rot = new TGeoRotation(""rot"",0.0, 0.0, 0.0);; }; top->AddNode(volumes[useVolume], i, new TGeoCombiTrans(*trans, *rot));; //printf(""Added node %d (Volume %d)\n"", i, useVolume);; }; geom->CloseGeometry();; top->Draw(""ogl"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glViewerLOD_8C.html:3358,assert,assert,3358,doc/master/glViewerLOD_8C.html,https://root.cern,https://root.cern/doc/master/glViewerLOD_8C.html,1,['assert'],['assert']
Testability," compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:165602,log,logical,165602,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['log'],['logical']
Testability," comparing weighted and unweighted histograms. ; Compares the histograms' adjusted (normalized) residuals. Function: Returns p-value. Other return values are specified by the 3rd parameter; Parameters. [in]h2the second histogram ; [in]option; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted); ""NORM"" = to be used when one or both of the histograms is scaled but the histogram originally was unweighted; by default underflows and overflows are not included:; ""OF"" = overflows included; ""UF"" = underflows included. ""P"" = print chi2, ndf, p_value, igood; ""CHI2"" = returns chi2 instead of p-value; ""CHI2/NDF"" = returns \( \chi^{2} \)/ndf . [in]resnot empty - computes normalized residuals and returns them in this array. The current implementation is based on the papers \( \chi^{2} \) test for comparison of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123 by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; Introduction:; A frequently used technique in data analysis is the comparison of histograms. First suggested by Pearson [1] the \( \chi^{2} \) test of homogeneity is used widely for comparing usual (unweighted) histograms. This paper describes the implementation modified \( \chi^{2} \) tests for comparison of weighted and unweighted histograms and two weighted histograms [2] as well as usual Pearson's \( \chi^{2} \) test for comparison two usual (unweighted) histograms.; Overview:; Comparison of two histograms expect hypotheses that two histograms represent identical distributions. To make a decision p-value should be calculated. The hypotheses of identity is rejected if the p-value is lower then some significance level. Traditionally significance levels 0.1, 0.05 and 0.01 are used. The co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:86729,test,test,86729,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability," comparison:. A simple modification of the ideas described above can be used for the; comparison of the usual (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as well; as the original one [3], has a restriction on the expected frequencies. The; expected frequencies recommended for the weighted histogram is more than 25.; The value of the minimal expected frequency can be decreased down to 10 for; the case when the weights of the events are close to constant. In the case; of a weighted histogram if the number of events is unknown, then we can; apply this recommendation for the equivalent number of events as. The minimal expected frequency for an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that have constant weights equal to 1.; The variance of the difference between the weight wi; and the estimated expectation value of the weight is approximately equal to:. The residuals. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:48857,test,test,48857,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,10,['test'],['test']
Testability, computation of the weight. Int_t GetNdaughters() const; {if (!fNodes) return 0; return (fNodes->GetEntriesFast());}. void ClearNodes(); {fNodes = 0;}. Bool_t Contains(const Double_t* point) const; {return fShape->Contains(point);}. Bool_t IsRunTime() const; {return fShape->IsRunTimeShape();}. Bool_t IsVolumeMulti() const; {return kFALSE;}. Int_t GetRefCount() const; {return fRefCount;}. TGeoExtension * GetUserExtension() const; {return fUserExtension;}. TGeoExtension * GetFWExtension() const; {return fFWExtension;}. void Grab(); {fRefCount++;}. void Release(); {fRefCount--; if (fRefCount==0) delete this;}. Bool_t IsActive() const; {return TGeoAtt::IsActive();}. Bool_t IsActiveDaughters() const; {return TGeoAtt::IsActiveDaughters();}. Bool_t IsAdded() const; {return TObject::TestBit(kVolumeAdded);}. Bool_t IsOverlappingCandidate() const; {return TObject::TestBit(kVolumeOC);}. Bool_t IsReplicated() const; {return TObject::TestBit(kVolumeReplicated);}. Bool_t IsSelected() const; {return TObject::TestBit(kVolumeSelected);}. Bool_t IsCylVoxels() const; {return TObject::TestBit(kVoxelsCyl);}. Bool_t IsXYZVoxels() const; {return TObject::TestBit(kVoxelsXYZ);}. Bool_t IsValid() const; {return fShape->IsValid();}. Bool_t IsVisible() const; {return TGeoAtt::IsVisible();}. Bool_t IsVisibleDaughters() const; {return TGeoAtt::IsVisDaughters();}. Bool_t IsVisContainers() const; {return TGeoAtt::IsVisContainers();}. Bool_t IsVisLeaves() const; {return TGeoAtt::IsVisLeaves();}. Bool_t IsVisOnly() const; {return TGeoAtt::IsVisOnly();}. Int_t GetCurrentNodeIndex() const; {return -1;}. Int_t GetNextNodeIndex() const; {return -1;}. TObjArray * GetNodes(); {return fNodes;}. Int_t GetNtotal() const; {return fNtotal;}. TGeoManager * GetGeoManager() const; {return fGeoManager;}. TGeoMaterial * GetMaterial() const; {return GetMedium()->GetMaterial();}. TGeoMedium * GetMedium() const; {return (fMedium)?fMedium:DummyMedium();}. TObject * GetField() const; {return fField;}. TGeoPatternFinder ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:44758,Test,TestBit,44758,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,3,['Test'],['TestBit']
Testability," configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual void preferredObservableScanOrder (const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:25952,log,logEvalError,25952,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,2,['log'],['logEvalError']
Testability," configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:26918,log,logEvalError,26918,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['log'],['logEvalError']
Testability," const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDerivative&operator=(const RooDerivative&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:19544,test,testArg,19544,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,4,['test'],['testArg']
Testability," const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const RooAbsArg& var5, const RooAbsArg& var6, const RooAbsArg& var7, const RooAbsArg& var8, const RooAbsArg& var9, const char* name = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); RooAbsCollection*RooAbsCollection::selectByAttrib(const char* name, Bool_t value) const; RooAbsCollection*RooAbsCollection::selectByName(const char* nameList, Bool_t verbose = kFALSE) const; RooAbsCollection*RooAbsCollection::selectCommon(const RooAbsCollection& refColl) const; voidRooAbsCollection::setAttribAll(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsCollection::setHashTableSize(Int_t i); voidRooAbsCollection::setName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; RooAbsCollection*RooAbsCollection::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgList.html:11335,Test,TestBit,11335,root/html602/RooArgList.html,https://root.cern,https://root.cern/root/html602/RooArgList.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const SourceTypeList_t &source, MembersTypeMap_t &members, std::string &className, std::string &mappedName, std::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  . Detailed Description; This file contains a specialised ROOT message handler to test for diagnostic in unit tests. ; Class RooRealSumFunc implements a PDF constructed from a sum of functions:; A space to attach TBranches.; Namespace for new ROOT classes and functions.; VSD Structures.; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7; AuthorStephan Hageboeck steph.nosp@m.an.h.nosp@m.agebo.nosp@m.eck@.nosp@m.cern..nosp@m.ch; Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents. In the present version coef_i may not depend on x, but this limitation may be removed in the future. Differ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:14323,test,test,14323,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,2,['test'],"['test', 'tests']"
Testability," const TGeoBBox* box2, const TGeoMatrix* mat2); Check if 2 positioned boxes overlap. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal to closest surface from POINT. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const; Decides fast if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBBox.html:14583,Test,Test,14583,root/html532/TGeoBBox.html,https://root.cern,https://root.cern/root/html532/TGeoBBox.html,1,['Test'],['Test']
Testability," const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidTMVA::Configurable::PrintOptions() const; voidProcessOptions(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidReadXML(void* pdfnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetReadingVersion(UInt_t rv); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); voidValidatePDF(TH1* original = 0) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTMVA::Configurable::WriteOptionsToStream(ostream& o, const TString& prefix) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__PDF.html:6295,Test,TestBit,6295,root/html532/TMVA__PDF.html,https://root.cern,https://root.cern/root/html532/TMVA__PDF.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrappi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:94034,test,testio,94034,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['test'],['testio']
Testability," const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrappi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:94035,test,testio,94035,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['test'],['testio']
Testability," const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCanvas.html:46225,Test,TestBit,46225,root/html532/TCanvas.html,https://root.cern,https://root.cern/root/html532/TCanvas.html,4,['Test'],['TestBit']
Testability," const char * ; comment = 0 . ). virtual . Create a reference to a class documentation page. ; str encloses the text to create the reference for (e.g. name of instance). comment will be added e.g. as tooltip text. After the reference is put into str.String(), str will enclose the reference and the original text. Example: Input: str.String(): ""a gHtml test"" str.Begin(): 2 str.Length(): 5 Output: str.String(): ""a <a href=""THtml.html"">gHtml</a> test"" str.Begin(): 2 str.Length(): 30 ; Definition at line 1788 of file TDocOutput.cxx. ◆ ReferenceEntity() [2/4]. void TDocOutput::ReferenceEntity ; (; TSubString & ; str, . TDataMember * ; entity, . const char * ; comment = 0 . ). virtual . Create a reference to a data member documentation page. ; str encloses the text to create the reference for (e.g. name of instance). comment will be added e.g. as tooltip text. After the reference is put into str.String(), str will enclose the reference and the original text. Example: Input: str.String(): ""a gHtml test"" str.Begin(): 2 str.Length(): 5 Output: str.String(): ""a <a href=""THtml.html"">gHtml</a> test"" str.Begin(): 2 str.Length(): 30 ; Definition at line 1814 of file TDocOutput.cxx. ◆ ReferenceEntity() [3/4]. void TDocOutput::ReferenceEntity ; (; TSubString & ; str, . TDataType * ; entity, . const char * ; comment = 0 . ). virtual . Create a reference to a type documentation page. ; str encloses the text to create the reference for (e.g. name of instance). comment will be added e.g. as tooltip text. After the reference is put into str.String(), str will enclose the reference and the original text. Example: Input: str.String(): ""a gHtml test"" str.Begin(): 2 str.Length(): 5 Output: str.String(): ""a <a href=""THtml.html"">gHtml</a> test"" str.Begin(): 2 str.Length(): 30 ; Definition at line 1866 of file TDocOutput.cxx. ◆ ReferenceEntity() [4/4]. void TDocOutput::ReferenceEntity ; (; TSubString & ; str, . TMethod * ; entity, . const char * ; comment = 0 . ). virtual . Create a reference to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocOutput.html:24338,test,test,24338,doc/master/classTDocOutput.html,https://root.cern,https://root.cern/doc/master/classTDocOutput.html,1,['test'],['test']
Testability," const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TLibraryDocInfo&operator=(const TLibraryDocInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLibraryDocInfo.html:4758,Test,TestBit,4758,root/html532/TLibraryDocInfo.html,https://root.cern,https://root.cern/root/html532/TLibraryDocInfo.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TRootGuiFactory&operator=(const TRootGuiFactory&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootGuiFactory.html:5715,Test,TestBit,5715,root/html532/TRootGuiFactory.html,https://root.cern,https://root.cern/root/html532/TRootGuiFactory.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Int_tSize() const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDataType.html:5278,Test,TestBit,5278,root/html532/TDataType.html,https://root.cern,https://root.cern/root/html532/TDataType.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBaseClass.html:5116,Test,TestBit,5116,root/html534/TBaseClass.html,https://root.cern,https://root.cern/root/html534/TBaseClass.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidReflect(Bool_t flag = kTRUE); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDivIndex(Int_t index); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetNext(Int_t index); static voidTObject::SetObjectStat(Bool_t stat); voidSetRange(Double_t start, Double_t step, Int_t ndivisions); voidSetSpacedOut(Bool_t flag); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVolume(TGeoVolume* vol); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateMatrix(Int_t, TGeoHMatrix&) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPatternFinder.html:6235,Test,TestBit,6235,root/html532/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html532/TGeoPatternFinder.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRuleSet&operator=(const ROOT::TSchemaRuleSet&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveRule(ROOT::TSchemaRule* rule); voidRemoveRules(TObjArray* rules); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClass(TClass* cls); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ROOT::TSchemaRuleSetTSchemaRuleSet(); ROOT::TSchemaRuleSetTSchemaRuleSet(const ROOT::TSchemaRuleSet&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRuleSet.html:5245,Test,TestBit,5245,root/html602/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRuleSet.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); THilbertMatrixTSym<double>&operator=(const THilbertMatrixTSym<double>&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; THilbertMatrixTSym<double>(); THilbertMatrixTSym<double>(Int_t no_rows); THilbertMatrixTSym<double>(const THilbertMatrixTSym<double>&); THilbertMatrixTSym<double>(Int_t row_lwb, Int_t row_upb); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THilbertMatrixTSym_double_.html:4562,Test,TestBit,4562,root/html602/THilbertMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html602/THilbertMatrixTSym_double_.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TRootSnifferStore&operator=(const TRootSnifferStore&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetField(Int_t, const char*, const char*, Bool_t); static voidTObject::SetObjectStat(Bool_t stat); voidSetResult(void* _res, TClass* _rescl, TDataMember* _resmemb, Int_t _res_chld); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TRootSnifferStore(); TRootSnifferStore(const TRootSnifferStore&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSnifferStore.html:4822,Test,TestBit,4822,root/html602/TRootSnifferStore.html,https://root.cern,https://root.cern/root/html602/TRootSnifferStore.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual Int_tParseBuffer(const char* contents, Int_t len); virtual Int_tParseFile(const char* filename); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetReplaceEntities(Bool_t val = kTRUE); voidSetStopOnError(Bool_t stop = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetValidate(Bool_t val = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopParser(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TXMLParser(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLParser.html:7943,Test,TestBit,7943,root/html602/TXMLParser.html,https://root.cern,https://root.cern/root/html602/TXMLParser.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const char* comment). void* GetParent(void* child); get parent node. void* GetChild(void* parent, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Tools.html:11818,Log,Logger,11818,root/html534/TMVA__Tools.html,https://root.cern,https://root.cern/root/html534/TMVA__Tools.html,3,['Log'],['Logger']
Testability," const char* comment). void* GetParent(void* child); get parent node. void* GetChild(void* parent, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); compute covariance matrices. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Tools.html:11584,Log,Logger,11584,root/html532/TMVA__Tools.html,https://root.cern,https://root.cern/root/html532/TMVA__Tools.html,1,['Log'],['Logger']
Testability," const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTProof::IsDataReady(Long64_t& totalbytes, Long64_t& bytesready); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTProof::IsFolder() const; Bool_tTProof::IsIdle() const; Bool_tTProof::IsLite() const; Bool_tTProof::IsMaster() const; Bool_tTObject::IsOnHeap() const; Bool_tTProof::IsParallel() const; Bool_tTProof::IsProofd() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTProof::IsValid() const; Bool_tTProof::IsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tTProof::Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidTProof::LogMessage(const char* msg, Bool_t all)SIGNAL ; static voidTProof::LogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*TProof::Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static TProof*TProof::Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:11275,Log,LogViewer,11275,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,2,['Log'],['LogViewer']
Testability," const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:18842,test,testArg,18842,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,6,['test'],['testArg']
Testability," const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFirstMoment&operator=(const RooFirstMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:18532,test,testArg,18532,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,4,['test'],['testArg']
Testability," const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMoment&operator=(const RooMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:18507,test,testArg,18507,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,4,['test'],['testArg']
Testability," const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:18537,test,testArg,18537,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,4,['test'],['testArg']
Testability," const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TRefTable&operator=(const TRefTable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReadBuffer(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(Option_t* = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetParent(const TObject* parent, Int_t branchID); static voidSetRefTable(TRefTable* table); virtual voidSetUID(UInt_t uid, TProcessID* context = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRefTable.html:6232,Test,TestBit,6232,root/html534/TRefTable.html,https://root.cern,https://root.cern/root/html534/TRefTable.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:17028,Test,TestBits,17028,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['Test'],['TestBits']
Testability," const char*); virtual TObjString*ReadBuffer(const char*, Long64_t, Int_t); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReset(Bool_t hard = kFALSE, const char* usr = 0); voidTObject::ResetBit(UInt_t f); virtual Int_tRm(const char*, const char* = 0, const char* = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSendMsgToUsers(const char*, const char* = 0); virtual voidSetAlias(const char* alias = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInvalid(); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetROOTVersion(const char*); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidSetTXProofMgrHook(TProofMgr_t pmh); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowROOTVersions(); virtual voidShowWorkers(); virtual voidShutdownSession(Int_t id); virtual voidShutdownSession(TProof* p); virtual Int_tTNamed::Sizeof() const; virtual Int_tStat(const char*, FileStat_t&, const char* = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTail(const char*, const char* = 0, const char* = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMgr.html:7032,Test,TestBit,7032,root/html532/TProofMgr.html,https://root.cern,https://root.cern/root/html532/TProofMgr.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const. The meaning of the vector of parameters is of course defined by the user,; who uses the values of those parameters to calculate their function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FCNBase.html:2405,log,log,2405,root/html602/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FCNBase.html,2,['log'],['log']
Testability," const. The meaning of the vector of parameters is of course defined by the user,; who uses the values of those parameters to calculate their function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Minuit2__FCNBase.html:2405,log,log,2405,root/html604/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html604/ROOT__Minuit2__FCNBase.html,2,['log'],['log']
Testability," const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; RooStats::HistFactory::LinInterpVarLinInterpVar(); RooStats::HistFactory::LinInterpVarLinInterpVar(const RooStats::HistFactory::LinInterpVar&); RooStats::HistFactory::LinInterpVarLinInterpVar(const char* name, const char* title); RooStats::HistFactory::LinInterpVarLinInterpVar(const RooStats::HistFactory::LinInterpVar&, const char*); RooStats::HistFactory::LinInterpVarLinInterpVar(const char* name, const char* title, const RooArgList& _paramList, double nominal, vector<double> low, vector<double> high); Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:17714,log,logEvalError,17714,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,4,['log'],['logEvalError']
Testability," const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:19618,test,testArg,19618,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,4,['test'],['testArg']
Testability," const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2Binding<double,int,int>&operator=(const RooCFunction2Binding<double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html:19988,test,testArg,19988,root/html602/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html,4,['test'],['testArg']
Testability," const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGPicturePool(const TGClient* client, const char* path); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPicturePool.html:4779,Test,TestBit,4779,root/html602/TGPicturePool.html,https://root.cern,https://root.cern/root/html602/TGPicturePool.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTreeDensity(); {}. PDEFoamDecisionTreeDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDecisionTreeDensity(const TMVA::PDEFoamDecisionTreeDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is not used in the decision tree like PDEFoam,; instead FillHist() is used. void FillHistograms(TMVA::Volume& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& ); Fill the given histograms with signal and background events,; which are found in the volume. Parameters:. - volume - volume box to search in. - hsig, hbkg, hsig_unw, hbkg_unw - histograms with weighted and; unweighte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamDecisionTreeDensity.html:7038,log,logger,7038,root/html602/TMVA__PDEFoamDecisionTreeDensity.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamDecisionTreeDensity.html,4,['log'],['logger']
Testability," const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminantDensity(); {}. PDEFoamDiscriminantDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDiscriminantDensity(const TMVA::PDEFoamDiscriminantDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average number density of events of type fClass within the; range-searching volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights) of type fClass, which were; found in the range-searching volume at point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamDiscriminantDensity.html:6985,log,logger,6985,root/html602/TMVA__PDEFoamDiscriminantDensity.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamDiscriminantDensity.html,4,['log'],['logger']
Testability," const; Int_tLayout(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGraphStruct&operator=(const TGraphStruct&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMargin(Double_t m = 10); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphStruct.html:6694,Test,TestBit,6694,root/html532/TGraphStruct.html,https://root.cern,https://root.cern/root/html532/TGraphStruct.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; Int_tTMVA::VariableTransformBase::GetNClasses() const; UInt_tTMVA::VariableTransformBase::GetNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; identity transform returns same event. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariableIdentityTransform.html:7667,log,logger,7667,root/html528/TMVA__VariableIdentityTransform.html,https://root.cern,https://root.cern/root/html528/TMVA__VariableIdentityTransform.html,1,['log'],['logger']
Testability," const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions random",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoChecker.html:15131,Test,Test,15131,root/html532/TGeoChecker.html,https://root.cern,https://root.cern/root/html532/TGeoChecker.html,4,['Test'],['Test']
Testability," const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10. » Author: David Gonzalez Maline 2/2008 » Copyright (c) 2004 Maline, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: BrentMinimizer1D.h 41847 2011-11-09 18:03:47Z rdm $ » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:4665,log,log,4665,root/html532/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html,2,['log'],['log']
Testability," const; RooStats::TestStatSampler*GetTestStatSampler(); RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(); RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(const RooStats::IntervalCalculator&); virtual TClass*IsA() const; RooStats::NeymanConstructionNeymanConstruction(const RooStats::NeymanConstruction&); RooStats::NeymanConstructionNeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); RooStats::NeymanConstruction&operator=(const RooStats::NeymanConstruction&); voidSaveBeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); voidSetLeftSideTailFraction(Double_t leftSideFraction = 0.); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetTestSize(Double_t size); voidSetTestStatSampler(RooStats::TestStatSampler& sampler); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). Data Members; private:. boolfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; boolfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Double_tfLeftSideFraction; RooStats::ModelConfig&fModel; RooAbsData*fPointsToTest; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::TestStatSampler*fTestStatSampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NeymanConstruction(RooAbsData& data, RooStats::ModelConf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__NeymanConstruction.html:3727,Test,TestStatSampler,3727,root/html602/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html602/RooStats__NeymanConstruction.html,2,['Test'],['TestStatSampler']
Testability," const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::GSLRandomEngine(); ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::GSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::GSLRandomEngine(const ROOT::Math::GSLRandomEngine& eng); ROOT::Math::GSLRngGFSR4GSLRngGFSR4(); ROOT::Math::GSLRngGFSR4GSLRngGFSR4(const ROOT::Math::GSLRngGFSR4&); voidROOT::Math::GSLRandomEngine::Initialize(); doubleROOT::Math::GSLRandomEngine::Landau() const; doubleROOT::Math::GSLRandomEngine::LogNormal(double zeta, double sigma) const; vector<unsigned int>ROOT::Math::GSLRandomEngine::Multinomial(unsigned int ntot, const vector<double>& p) const; stringROOT::Math::GSLRandomEngine::Name() const; unsigned intROOT::Math::GSLRandomEngine::NegativeBinomial(double p, double n) const; doubleROOT::Math::GSLRandomEngine::operator()() const; ROOT::Math::GSLRngGFSR4&operator=(const ROOT::Math::GSLRngGFSR4&); unsigned intROOT::Math::GSLRandomEngine::Poisson(double mu) const; voidROOT::Math::GSLRandomEngine::RandomArray(double* begin, double* end) const; unsigned intROOT::Math::GSLRandomEngine::RndmInt(unsigned int max) const; voidROOT::Math::GSLRandomEngine::SetSeed(unsigned int seed) const; unsigned intROOT::Math::GSLRandomEngine::Size() const; doubleROOT::Math::GSLRandomEngine::tDist(double nu) const; voidROOT::Math::GSLRandomEngine::Terminate().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLRngGFSR4.html:2489,Log,LogNormal,2489,root/html534/ROOT__Math__GSLRngGFSR4.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngGFSR4.html,1,['Log'],['LogNormal']
Testability," const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::GSLRandomEngine(); ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::GSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::GSLRandomEngine(const ROOT::Math::GSLRandomEngine& eng); ROOT::Math::GSLRngRanLuxGSLRngRanLux(); ROOT::Math::GSLRngRanLuxGSLRngRanLux(const ROOT::Math::GSLRngRanLux&); ROOT::Math::GSLRngRanLuxGSLRngRanLux(ROOT::Math::GSLRngRanLux&&); voidROOT::Math::GSLRandomEngine::Initialize(); doubleROOT::Math::GSLRandomEngine::Landau() const; doubleROOT::Math::GSLRandomEngine::LogNormal(double zeta, double sigma) const; vector<unsigned int>ROOT::Math::GSLRandomEngine::Multinomial(unsigned int ntot, const vector<double>& p) const; stringROOT::Math::GSLRandomEngine::Name() const; unsigned intROOT::Math::GSLRandomEngine::NegativeBinomial(double p, double n) const; doubleROOT::Math::GSLRandomEngine::operator()() const; ROOT::Math::GSLRngRanLux&operator=(const ROOT::Math::GSLRngRanLux&); ROOT::Math::GSLRngRanLux&operator=(ROOT::Math::GSLRngRanLux&&); unsigned intROOT::Math::GSLRandomEngine::Poisson(double mu) const; voidROOT::Math::GSLRandomEngine::RandomArray(double* begin, double* end) const; unsigned intROOT::Math::GSLRandomEngine::RndmInt(unsigned int max) const; voidROOT::Math::GSLRandomEngine::SetSeed(unsigned int seed) const; unsigned intROOT::Math::GSLRandomEngine::Size() const; doubleROOT::Math::GSLRandomEngine::tDist(double nu) const; voidROOT::Math::GSLRandomEngine::Terminate().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLRngRanLux.html:2571,Log,LogNormal,2571,root/html602/ROOT__Math__GSLRngRanLux.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLRngRanLux.html,2,['Log'],['LogNormal']
Testability," const; internal function compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1; scan the poi values and evaluate the posterior at each point; and save the result in a cloned TF1; For each point the posterior is evaluated by integrating the nuisance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iteratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:16283,test,test,16283,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,3,['test'],['test']
Testability," const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; intProcessCard(const char* filename); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HLFactory.html:5329,Test,TestBit,5329,root/html534/RooStats__HLFactory.html,https://root.cern,https://root.cern/root/html534/RooStats__HLFactory.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeIndex.html:5505,Test,TestBit,5505,root/html534/TTreeIndex.html,https://root.cern,https://root.cern/root/html534/TTreeIndex.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector&); voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:6128,Test,TestBit,6128,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tRooAbsHiddenReal::isHidden() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindCPAsymVar.html:18092,log,logEvalError,18092,root/html534/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html534/RooUnblindCPAsymVar.html,24,['log'],['logEvalError']
Testability," const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tjacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:21621,log,logEvalError,21621,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,6,['log'],['logEvalError']
Testability," const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; Int_tLoadPlugin(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* opt = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPluginHandler.html:7429,Test,TestBit,7429,root/html532/TPluginHandler.html,https://root.cern,https://root.cern/root/html532/TPluginHandler.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TExMap.html:5003,Test,TestBit,5003,root/html532/TExMap.html,https://root.cern,https://root.cern/root/html532/TExMap.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::PDEFoamKernelBase&operator=(const TMVA::PDEFoamKernelBase&); virtual voidTObject::Paint(Option_t* option = """"); TMVA::PDEFoamKernelBasePDEFoamKernelBase(); TMVA::PDEFoamKernelBasePDEFoamKernelBase(const TMVA::PDEFoamKernelBase&); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamKernelBase.html:4969,Test,TestBit,4969,root/html602/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamKernelBase.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObjString&operator=(const TObjString&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t*) const; virtual Int_tTObject::Read(const char* name); voidReadBuffer(char*& buffer); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetString(const char* s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TString&String(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TObjString(const char* s = """"); TObjString(const TObjString& s); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjString.html:4403,Test,TestBit,4403,root/html602/TObjString.html,https://root.cern,https://root.cern/root/html602/TObjString.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TRecWinPair&operator=(const TRecWinPair&); TRecWinPair&operator=(TRecWinPair&&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TRecWinPair(TRecWinPair&&); TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecWinPair.html:6659,Test,TestBit,6659,root/html602/TRecWinPair.html,https://root.cern,https://root.cern/root/html602/TRecWinPair.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSQLObjectDataPool&operator=(const TSQLObjectDataPool&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TSQLObjectDataPool(); TSQLObjectDataPool(const TSQLObjectDataPool&); TSQLObjectDataPool(TSQLClassInfo* info, TSQLResult* data); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLObjectDataPool.html:4726,Test,TestBit,4726,root/html602/TSQLObjectDataPool.html,https://root.cern,https://root.cern/root/html602/TSQLObjectDataPool.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstVar.html:16564,log,logEvalError,16564,root/html532/RooConstVar.html,https://root.cern,https://root.cern/root/html532/RooConstVar.html,2,['log'],['logEvalError']
Testability," const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*GetParent() const; virtual Double_tGetParError(Int_t ipar) const; virtual Double_t*GetParErrors() const; virtual voidGetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:10033,log,logx,10033,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['log'],['logx']
Testability," const; virtual voidPrintValue(Int_t i = 0) const; virtual Int_tTObject::Read(const char* name); virtual voidReadBasket(TBuffer& b); virtual voidReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); virtual voidReadValue(istream& s); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTLeaf::ResetAddress(void* add, Bool_t destructor = kFALSE); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTLeaf::SetBranch(TBranch* branch); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTLeaf::SetLeafCount(TLeaf* leaf); virtual voidTLeaf::SetLen(Int_t len = 1); virtual voidSetMaximum(Long64_t max); virtual voidSetMinimum(Long64_t min); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTLeaf::SetOffset(Int_t offset = 0); virtual voidTLeaf::SetRange(Bool_t range = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTLeaf::SetUnsigned(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafL.html:5983,Test,TestBit,5983,root/html532/TLeafL.html,https://root.cern,https://root.cern/root/html532/TLeafL.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsBinning::printValue(ostream& os) const; virtual Int_tRooAbsBinning::rawBinNumber(Double_t x) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRooAbsBinning::removeHook(RooAbsRealLValue&) const; voidTObject::ResetBit(UInt_t f); RooUniformBinning(const char* name = 0); RooUniformBinning(const RooUniformBinning& other, const char* name = 0); RooUniformBinning(Double_t xlo, Double_t xhi, Int_t nBins, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsBinning::setMax(Double_t xhi); virtual voidRooAbsBinning::setMin(Double_t xlo); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidsetRange(Double_t xlo, Double_t xhi); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUniformBinning.html:7120,Test,TestBit,7120,root/html602/RooUniformBinning.html,https://root.cern,https://root.cern/root/html602/RooUniformBinning.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TTreeFormula*); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Bool_tSync(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeFormulaManager.html:4575,Test,TestBit,4575,root/html532/TTreeFormulaManager.html,https://root.cern,https://root.cern/root/html532/TTreeFormulaManager.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetIsObject(Bool_t isObject); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidWriteRealData(void* pointer, char*& buffer).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRealData.html:4843,Test,TestBit,4843,root/html532/TRealData.html,https://root.cern,https://root.cern/root/html532/TRealData.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEveRecV0&operator=(const TEveRecV0&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveRecV0(); TEveRecV0(const TEveRecV0&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveRecV0.html:4245,Test,TestBit,4245,root/html602/TEveRecV0.html,https://root.cern,https://root.cern/root/html602/TEveRecV0.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimPdfBuilder&operator=(const RooSimPdfBuilder&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooSimPdfBuilder(const RooArgSet& pdfProtoList); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; const RooArgSet&splitLeafList(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimPdfBuilder.html:18286,Test,TestBit,18286,root/html602/RooSimPdfBuilder.html,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," const; voidTObject::MayNotUse(const char* method) const; virtual boolMerge(TCollection* in); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TParameter<bool>&operator=(const TParameter<bool>&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t*) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMergeMode(char mergemode = '+'); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVal(const bool& val); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParameter_bool_.html:4645,Test,TestBit,4645,root/html532/TParameter_bool_.html,https://root.cern,https://root.cern/root/html532/TParameter_bool_.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," const;  Performs the Anderson-Darling 1-Sample Test. ;  ; Double_t KolmogorovSmirnov2SamplesTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; void KolmogorovSmirnov2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; Double_t KolmogorovSmirnovTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void KolmogorovSmirnovTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void operator() (ETestType test, Double_t &pvalue, Double_t &testStat) const;  The class's unary functions performing the gif test according to the ETestType provided. ;  ; Double_t operator() (ETestType test=kAD, const Char_t *option=""p"") const;  Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ;  ; void SetDistribution (EDistribution dist, const std::vector< double > &distParams={});  Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ;  ; void SetUserCDF (const IGenFunction &cdf, Double_t xmin=1, Double_t xmax=0);  Specialization to set the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; template<class Dist > ; void SetUserCDF (Dist &cdf, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; void SetUserDistribution (const IGenFunction &dist, GoFTest::EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution function for 1-sample test using the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ; void SetUserDistribution (Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution function for 1-sample test as a generic functor object. ;  ; void SetUserPDF (const IGenFunction &pdf, Double_t x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:4429,test,tests,4429,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['tests']
Testability," const;  returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ;  ; TVirtualStreamerInfo * GetStreamerInfoAbstractEmulated (Int_t version=0) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; const TObjArray * GetStreamerInfos () const;  ; const std::type_info * GetTypeInfo () const;  ; Bool_t HasConsistentHashMember ();  Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ;  ; Bool_t HasCustomStreamerMember () const;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; Bool_t HasDataMemberInfo () const;  ; Bool_t HasDefaultConstructor (Bool_t testio=kFALSE) const;  Return true if we have access to a constructor usable for I/O. ;  ; Bool_t HasDictionary () const;  Check whether a class has a dictionary or not. ;  ; Bool_t HasInterpreterInfo () const;  ; Bool_t HasInterpreterInfoInMemory () const;  ; Bool_t HasLocalHashMember () const;  Returns true if this class has an definition and/or overload of the member function Hash. ;  ; void IgnoreTObjectStreamer (Bool_t ignore=kTRUE);  When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call TObject::Streamer. ;  ; Bool_t InheritsFrom (const char *cl) const override;  Return kTRUE if this class inherits from a class with name ""classname"". ;  ; Bool_t InheritsFrom (const TClass *cl) const override;  Return kTRUE if this class inherits from class cl. ;  ; void InterpretedShowMembers (void *obj, TMemberInspector &insp, Bool_t isTransient);  Do a ShowMembers() traversal of all members and base classes' members using the reflection information f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:17522,test,testio,17522,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['test'],['testio']
Testability," constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTTUBE::SetAspectRatio(Float_t factor = 1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTUBE::SetNumberOfDivisions(Int_t ndiv); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTUBS.html:6890,Test,TestBit,6890,root/html532/TTUBS.html,https://root.cern,https://root.cern/root/html532/TTUBS.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinuit construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value and the full correlation matrix. RooPlot* contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); Create and draw a TH2 with the error contours in parameters var1 and v2 at up to 6 'sigma' settings; where 'sigma' is calculated as n*n*errorLevel. Bool_t setLogFile(const char* logfile = 0); Change the file name for logging of a RooMinuit of all MINUIT steppings; through the parameter space. If inLogfile is null, the current log file; is closed and logging is stopped. Double_t getPdfParamVal(Int_t index); Access PDF parameter value by ordinal index (needed by MINUIT). Double_t getPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). Bool_t setPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Modify PDF parameter value by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void clearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void backProp(); Transfer MINUIT fit results back into RooFit objects. void applyCovarianceMatrix(TMatrixDSym& V); Apply results of given external",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinuit.html:12505,log,log,12505,root/html526/RooMinuit.html,https://root.cern,https://root.cern/root/html526/RooMinuit.html,10,['log'],"['log', 'logging']"
Testability," constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinuit construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value and the full correlation matrix. RooPlot* contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); Create and draw a TH2 with the error contours in parameters var1 and v2 at up to 6 'sigma' settings; where 'sigma' is calculated as n*n*errorLevel. Bool_t setLogFile(const char* logfile = 0); Change the file name for logging of a RooMinuit of all MINUIT steppings; through the parameter space. If inLogfile is null, the current log file; is closed and logging is stopped. Double_t getPdfParamVal(Int_t index); Access PDF parameter value by ordinal index (needed by MINUIT). Double_t getPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). Bool_t setPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Modify PDF parameter value by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void clearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void backProp(); Transfer MINUIT fit results back into RooFit objects. void updateFloatVec(). void applyCovarianceMatrix(TMatrixDSym& V); Apply re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinuit.html:12987,log,log,12987,root/html534/RooMinuit.html,https://root.cern,https://root.cern/root/html534/RooMinuit.html,12,['log'],"['log', 'logging']"
Testability," constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void AddOptionsXMLTo(void* parent) const; write options to XML file. void ReadOptionsFromXML(void* node). void WriteOptionsReferenceToFile(); write complete options to output stream. void ReadOptionsFromStream(istream& istr); read option back from the weight file. const char* GetName() const; { return GetConfigName(); }. const char* GetConfigName() const; { return fConfigName; }. const char* GetConfigDescription() const; { return fConfigDescription; }. void SetConfigName(const char* n); { fConfigName = TString(n); }. void SetConfigDescription(const char* d); { fConfigDescription = TString(d); }. const TString& GetOptions() const; { return fOptions; }. void SetOptions(const TString& s); { fOptions = s; }. Bool_t LooseOptionCheckingEnabled() const; { return fLooseOptionCheckingEnabled; }. void EnableLooseOptions(Bool_t b = kTRUE); { fLooseOptionCheckingEnabled = b; }. const TString& GetReferenceFile() const; { return fReferenceFile; }. void SetMsgType(TMVA::EMsgType t); set message type. { fLogger->SetMinType(t); }. Log(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Configurable.html:8200,Log,Log,8200,root/html534/TMVA__Configurable.html,https://root.cern,https://root.cern/root/html534/TMVA__Configurable.html,1,['Log'],['Log']
Testability," constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro sou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMacro.html:8497,log,log,8497,root/html534/TMacro.html,https://root.cern,https://root.cern/root/html534/TMacro.html,2,['log'],['log']
Testability," containing these data members: char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; ; // Create a pointer to an Event object; Event *event = new Event();; ; // Create two branches, split one.; t4.Branch(""event_split"", &event,16000,99);; t4.Branch(""event_not_split"", &event,16000,0);; ; // a local variable for the event type; char etype[20];; ; // Fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree4_8C.html:1409,test,test,1409,doc/master/tree4_8C.html,https://root.cern,https://root.cern/doc/master/tree4_8C.html,1,['test'],['test']
Testability," coordinates belong to; 700 Int_t n = (Int_t)(floor((x-fXaxis.GetXmin())/fStepX));; 701 Int_t m = (Int_t)(floor((y-fYaxis.GetXmin())/fStepY));; 702 ; 703 // Make sure the array indices are correct.; 704 if (n>=fCellX) n = fCellX-1;; 705 if (m>=fCellY) m = fCellY-1;; 706 if (n<0) n = 0;; 707 if (m<0) m = 0;; 708 ; 709 if (fIsEmpty[n+fCellX*m]) {; 710 fOverflow[4]+= w;; 711 if (fSumw2.fN) fSumw2.fArray[4] += w*w;; 712 return -5;; 713 }; 714 ; 715 TH2PolyBin *bin;; 716 Int_t bi;; 717 ; 718 TIter next(&fCells[n+fCellX*m]);; 719 TObject *obj;; 720 ; 721 while ((obj=next())) {; 722 bin = (TH2PolyBin*)obj;; 723 // needs to account offset in array for overflow bins; 724 bi = bin->GetBinNumber()-1+kNOverflow;; 725 if (bin->IsInside(x,y)) {; 726 bin->Fill(w);; 727 ; 728 // Statistics; 729 fTsumw = fTsumw + w;; 730 fTsumw2 = fTsumw2 + w*w;; 731 fTsumwx = fTsumwx + w*x;; 732 fTsumwx2 = fTsumwx2 + w*x*x;; 733 fTsumwy = fTsumwy + w*y;; 734 fTsumwy2 = fTsumwy2 + w*y*y;; 735 if (fSumw2.fN) {; 736 assert(bi < fSumw2.fN);; 737 fSumw2.fArray[bi] += w*w;; 738 }; 739 fEntries++;; 740 ; 741 SetBinContentChanged(kTRUE);; 742 ; 743 return bin->GetBinNumber();; 744 }; 745 }; 746 ; 747 fOverflow[4]+= w;; 748 if (fSumw2.fN) fSumw2.fArray[4] += w*w;; 749 return -5;; 750}; 751 ; 752////////////////////////////////////////////////////////////////////////////////; 753/// Increment the bin named ""name"" by w.; 754 ; 755Int_t TH2Poly::Fill(const char* name, Double_t w); 756{; 757 TString sname(name);; 758 ; 759 TIter next(fBins);; 760 TObject *obj;; 761 TH2PolyBin *bin;; 762 ; 763 while ((obj = next())) {; 764 bin = (TH2PolyBin*) obj;; 765 if (!sname.CompareTo(bin->GetPolygon()->GetName())) {; 766 bin->Fill(w);; 767 fEntries++;; 768 SetBinContentChanged(kTRUE);; 769 return bin->GetBinNumber();; 770 }; 771 }; 772 ; 773 return 0;; 774}; 775 ; 776////////////////////////////////////////////////////////////////////////////////; 777/// Fills a 2-D histogram with an array of values and weights.; 778///; 7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:26558,assert,assert,26558,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['assert'],['assert']
Testability," corresponding to the (x,y) point in fGraph2D. ;  ; void FindAllTriangles ();  Attempt to find all the Delaunay triangles of the point set. ;  ; TGraph2D * GetGraph2D () const;  ; Double_t GetMarginBinsContent () const;  ; Int_t * GetMTried () const;  ; Int_t GetNdt () const;  ; Int_t * GetNTried () const;  ; Int_t * GetPTried () const;  ; Double_t * GetXN () const;  ; Double_t GetXNmax () const;  ; Double_t GetXNmin () const;  ; Double_t * GetYN () const;  ; Double_t GetYNmax () const;  ; Double_t GetYNmin () const;  ; Double_t Interpolate (Double_t x, Double_t y);  Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by linearly interpolating the z-values that make up that triangle. ;  ; TClass * IsA () const override;  ; void SetMarginBinsContent (Double_t z=0.);  Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin. ;  ; void SetMaxIter (Int_t n=100000);  Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoning the search. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphDelaunay.html:2790,test,tested,2790,doc/master/classTGraphDelaunay.html,https://root.cern,https://root.cern/doc/master/classTGraphDelaunay.html,1,['test'],['tested']
Testability," create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Fisher_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Fisher_1_dsi] : Number of events in input trees; : Dataset[Category_Fisher_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Fisher_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Fisher_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:6465,test,testing,6465,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability," created QWebEngineView can be found with the command:; 350///; 351/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 352 ; 353std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 354{; 355 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 356 if (qparent) {; 357 where.append("":"");; 358 where.append(std::to_string((uintptr_t) qparent));; 359 }; 360 if (!urlopt.empty()) {; 361 where.append(""?"");; 362 where.append(urlopt);; 363 }; 364 return where;; 365}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:248; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:98; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:148; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:12801,log,log,12801,doc/v632/RWebDisplayArgs_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html,1,['log'],['log']
Testability," created QWebEngineView can be found with the command:; 355///; 356/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 357 ; 358std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:12932,log,log,12932,doc/master/RWebDisplayArgs_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html,1,['log'],['log']
Testability," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIterator.html:1712,log,logical,1712,root/html528/TGeoIterator.html,https://root.cern,https://root.cern/root/html528/TGeoIterator.html,30,['log'],['logical']
Testability," data containers to zero size.; Keep the old data-storage parameters. void AddBox(const Float_t* verts); Create a new box from a set of 8 vertices.; To be used for box-type kBT_FreeBox. void AddBox(Float_t a, Float_t b, Float_t c, Float_t w, Float_t h, Float_t d); Create a new axis-aligned box from at a given position and with; specified dimensions.; To be used for box-type kBT_AABox. void AddBox(Float_t a, Float_t b, Float_t c); Create a new axis-aligned box from at a given position.; To be used for box-type kBT_AABoxFixedDim. void AddCone(const TEveVector& pos, const TEveVector& dir, Float_t r); Create a cone with apex at pos, axis dir and radius r.; To be used for box-type kBT_Cone. void AddEllipticCone(const TEveVector& pos, const TEveVector& dir, Float_t r, Float_t r2, Float_t angle = 0); Create a cone with apex at pos, axis dir and radius r.; To be used for box-type kBT_EllipticCone. void ComputeBBox(); Fill bounding-box information of the base-class TAttBBox (virtual method).; If member 'TEveFrameBox* fFrame' is set, frame's corners are used as bbox. void Test(Int_t nboxes); Fill the structure with a random set of boxes. TEveBoxSet(const TEveBoxSet& ). TEveBoxSet& operator=(const TEveBoxSet& ). virtual ~TEveBoxSet(); {}. Float_t GetDefWidth() const; { return fDefWidth; }. Float_t GetDefHeight() const; { return fDefHeight; }. Float_t GetDefDepth() const; { return fDefDepth; }. Bool_t GetDrawConeCap() const; { return fDrawConeCap; }. void SetDefWidth(Float_t v); { fDefWidth = v ; }. void SetDefHeight(Float_t v); { fDefHeight = v ; }. void SetDefDepth(Float_t v); { fDefDepth = v ; }. void SetDrawConeCap(Bool_t x); { fDrawConeCap=x; StampObjProps(); }. Int_t GetBoxSkip() const; { return fBoxSkip; }. void SetBoxSkip(Int_t bs); { fBoxSkip = bs; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveBoxSet.html:30690,Test,Test,30690,root/html534/TEveBoxSet.html,https://root.cern,https://root.cern/root/html534/TEveBoxSet.html,1,['Test'],['Test']
Testability," data containers to zero size.; Keep the old data-storage parameters. void AddBox(const Float_t* verts); Create a new box from a set of 8 vertices.; To be used for box-type kBT_FreeBox. void AddBox(Float_t a, Float_t b, Float_t c, Float_t w, Float_t h, Float_t d); Create a new axis-aligned box from at a given position and with; specified dimensions.; To be used for box-type kBT_AABox. void AddBox(Float_t a, Float_t b, Float_t c); Create a new axis-aligned box from at a given position.; To be used for box-type kBT_AABoxFixedDim. void AddCone(const TEveVector& pos, const TEveVector& dir, Float_t r); Create a cone with apex at pos, axis dir and radius r.; To be used for box-type kBT_Cone. void AddEllipticCone(const TEveVector& pos, const TEveVector& dir, Float_t r, Float_t r2, Float_t angle = 0); Create a cone with apex at pos, axis dir and radius r.; To be used for box-type kBT_EllipticCone. void ComputeBBox(); Fill bounding-box information of the base-class TAttBBox (virtual method).; If member 'TEveFrameBox* fFrame' is set, frame's corners are used as bbox. void Test(Int_t nboxes); Fill the structure with a random set of boxes. TEveBoxSet(const TEveBoxSet& ). TEveBoxSet& operator=(const TEveBoxSet& ). virtual ~TEveBoxSet(); {}. Float_t GetDefWidth() const; { return fDefWidth; }. Float_t GetDefHeight() const; { return fDefHeight; }. Float_t GetDefDepth() const; { return fDefDepth; }. Bool_t GetDrawConeCap() const; { return fDrawConeCap; }. void SetDefWidth(Float_t v); { fDefWidth = v ; }. void SetDefHeight(Float_t v); { fDefHeight = v ; }. void SetDefDepth(Float_t v); { fDefDepth = v ; }. void SetDrawConeCap(Bool_t x); { fDrawConeCap=x; StampObjProps(); }. Int_t GetBoxSkip() const; { return fBoxSkip; }. void SetBoxSkip(Int_t bs); { fBoxSkip = bs; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveBoxSet.html:31998,Test,Test,31998,root/html604/TEveBoxSet.html,https://root.cern,https://root.cern/root/html604/TEveBoxSet.html,1,['Test'],['Test']
Testability," data containers to zero size.; Keep the old data-storage parameters. void AddBox(const Float_t* verts); Create a new box from a set of 8 vertices.; To be used for box-type kBT_FreeBox. void AddBox(Float_t a, Float_t b, Float_t c, Float_t w, Float_t h, Float_t d); Create a new axis-aligned box from at a given position and with; specified dimensions.; To be used for box-type kBT_AABox. void AddBox(Float_t a, Float_t b, Float_t c); Create a new axis-aligned box from at a given position.; To be used for box-type kBT_AABoxFixedDim. void AddCone(const TEveVector& pos, const TEveVector& dir, Float_t r); Create a cone with apex at pos, axis dir and radius r.; To be used for box-type kBT_Cone. void AddEllipticCone(const TEveVector& pos, const TEveVector& dir, Float_t r, Float_t r2, Float_t angle = 0); Create a cone with apex at pos, axis dir and radius r.; To be used for box-type kBT_EllipticCone. void ComputeBBox(); Fill bounding-box information of the base-class TAttBBox (virtual method).; If member 'TEveFrameBox* fFrame' is set, frame's corners are used as bbox. void Test(Int_t nboxes); Fill the structure with a random set of boxes. TEveBoxSet(const TEveBoxSet& ). TEveBoxSet& operator=(const TEveBoxSet& ). virtual ~TEveBoxSet(); {}. Float_t GetDefWidth() const; { return fDefWidth; }. Float_t GetDefHeight() const; { return fDefHeight; }. Float_t GetDefDepth() const; { return fDefDepth; }. Bool_t GetDrawConeCap() const; { return fDrawConeCap; }. void SetDefWidth(Float_t v); { fDefWidth = v ; }. void SetDefHeight(Float_t v); { fDefHeight = v ; }. void SetDefDepth(Float_t v); { fDefDepth = v ; }. void SetDrawConeCap(Bool_t x); { fDrawConeCap=x; StampObjProps(); }. Int_t GetBoxSkip() const; { return fBoxSkip; }. void SetBoxSkip(Int_t bs); { fBoxSkip = bs; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveBoxSet.html:31998,Test,Test,31998,root/html602/TEveBoxSet.html,https://root.cern,https://root.cern/root/html602/TEveBoxSet.html,1,['Test'],['Test']
Testability," data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 // Return the MVA outputs and fill into histograms; 316 ; 317 if (Use[""CutsGA""]) {; 318 // Cuts is a special case: give the desired signal efficiency; 319 Bool_t passed = reader->EvaluateMVA( ""CutsGA method"", effS );; 320 if (passed) nSelCutsGA++;; 321 }; 322 ; 323 if (Use[""Likelihood"" ]) histLk ->Fill( reader->EvaluateMVA( ""Likelihood method"" ) );; 324 if (Use[""LikelihoodD"" ]) histLkD ->Fill( reader->EvaluateMVA( ""LikelihoodD method"" ) );; 325 if (Use[""LikelihoodPCA""]) histLkPCA ->Fill( reader->EvaluateMVA( ""LikelihoodPCA method"" ) );; 326 if (Use[""LikelihoodKDE""]) histLkKDE ->Fill( reader->EvaluateMVA( """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:12943,test,tests,12943,doc/master/TMVAClassificationApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html,1,['test'],['tests']
Testability," data1.GetPoint(i, value);; 774 xdata[i] = *x; ; 775 ntot1 += value; ; 776 }; 777 for (unsigned int i = 0; i < n2; ++i) {; 778 double value = 0;; 779 const double * x = data2.GetPoint(i, value);; 780 xdata[n1+i] = *x;; 781 ntot2 += value; ; 782 }; 783 double nall = ntot1+ntot2; ; 784 // sort the combined data ; 785 std::vector<unsigned int> index(n1+n2);; 786 TMath::Sort(n1+n2, &xdata[0], &index[0], false ); ; 787 ; 788 // now compute the sums for the tests ; 789 double sum1 = 0; ; 790 double sum2 = 0;; 791 double sumAll = 0; ; 792 double adsum = 0;; 793 unsigned int j = 0; ; 794 ; 795 while( j < n1+n2 ) { ; 796// for (unsigned int j = 0; j < n1+n2; ++j) { ; 797 // skip equal observations; 798 double x = xdata[ index[j] ]; ; 799 unsigned int k = j; ; 800 // loop on the bins with the same center value ; 801 double t = 0;; 802 do { ; 803 unsigned int i = index[k];; 804 double value = 0; ; 805 if (i < n1 ) {; 806 value = data1.Value(i); ; 807 sum1 += value;; 808 }; 809 else { ; 810 // from data2; 811 i -= n1;; 812 assert(i < n2);; 813 value = data2.Value(i); ; 814 sum2 += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:29194,assert,assert,29194,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,1,['assert'],['assert']
Testability," deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Similar to StepReducedWeights(...) but also evaluates the loss. ; May trigger synchronization with the device. ; Definition at line 224 of file DLMinimizers.h. Member Data Documentation. ◆ fBatchSize. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fBatchSize. private . Batch size to use for the training. ; Definition at line 72 of file DLMinimizers.h. ◆ fConvergenceCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceCount. private . Current number of training epochs without. ; considerable decrease in the test error. ; Definition at line 76 of file DLMinimizers.h. ◆ fConvergenceSteps. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceSteps. private . Number of training epochs without considerable. ; decrease in the test error for convergence. ; Definition at line 74 of file DLMinimizers.h. ◆ fLearningRate. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fLearningRate. private . Learning rate \(\alpha\). ; Definition at line 81 of file DLMinimizers.h. ◆ fMinimumError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fMinimumError. private . The minimum loss achieved on the training set during the current training session. ; Definition at line 82 of file DLMinimizers.h. ◆ fStepCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fStepCount. private . Number of steps performed in the current training session. ; Definition at line 73 of file DLMinimizers.h. ◆ fTestError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fTestError. private . Holds the most recently computed test loss. ; Definition at line 80 of file DLMini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:11932,test,test,11932,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['test'],['test']
Testability," default (Option = """") return CLs or CLsb depending if the flag UseCLs is set If Option = ""CLb"" return CLb plot = ""CLs+b"" return CLs+b plot independently of the flag = ""CLs"" return CLs plot independently of the flag ; Make the plot of the result of the scan using the observed data.; By default plot CLs or CLsb depending if the flag UseCLs is set for the results that are passed to this instance.; Parameters. optOptions according to following list:; Empty: Return CLs or CLs+b depending on the value of UseCLs.ƒ; ""CLB"": return CLb plot; ""CLS+B"" / ""CLSPLUSB"": return CLs+b plot independently of the flag; ""CLS"": return CLs plot independently of the flag . Definition at line 80 of file HypoTestInverterPlot.cxx. ◆ MakeTestStatPlot(). SamplingDistPlot * HypoTestInverterPlot::MakeTestStatPlot ; (; int ; index, . int ; type = 0, . int ; nbins = 100 . ). Plot the test statistic distributions. ; Parameters. indexIndex of the result stored in HypoTestInverterResult ; typeType of the test (see below) ; nbinsNumber of bins; type =0 null and alt; type = 1 only null (S+B); type = 2 only alt (B) . Definition at line 395 of file HypoTestInverterPlot.cxx. ◆ Streamer(). void RooStats::HypoTestInverterPlot::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooStats::HypoTestInverterPlot::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 76 of file HypoTestInverterPlot.h. Member Data Documentation. ◆ fResults. HypoTestInverterResult* RooStats::HypoTestInverterPlot::fResults. private . Definition at line 72 of file HypoTestInverterPlot.h. Libraries for RooStats::HypoTestInverterPlot:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/HypoTestInverterPlot.h; roofit/roostats/src/HypoTestInverterPlot.cxx. RooStatsHypoTestInverterPlot. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:54",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html:17385,test,test,17385,doc/master/classRooStats_1_1HypoTestInverterPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html,1,['test'],['test']
Testability," defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the next two methods:; Method 1; TGeoMaterial::FillMaterialEvolution(TObjArray *population, Double_t precision=0.001); TGeoMaterial::FillMaterialEvolutionvirtual void FillMaterialEvolution(TObjArray *population, Double_t precision=0.001)Fills a user array with all the elements deriving from the possible decay of the top element composin...Definition TGeoMaterial.cxx:742; TObjArrayAn array of TObjects.Definition TObjArray.h:31; To use this method, one has to provide an empty TObjArray object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered. The population list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:; Bool_t TGeoElement::IsRadioNuclide() const; Bool_tbool Bool_tDefinition RtypesCore.h:63; TGeoElement::IsRadioNuclidevirtual Bool_t IsRadioNuclide() constDefinition TGeoElement.h:82; All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoBatemanSol::Drawvoid Draw(Option_t *option="""") overrideDraw the solution of Bateman equation versus time.Definition TGeoElement.cxx:1612; TGeoElementRN::RatioTGeoBatemanSol * Ratio() constDefinition TGeoElement.h:188; Method 2; Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); TGeoMaterial::DecayMaterialvirtual TGeoMaterial * Decay",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:10106,test,test,10106,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['test'],['test']
Testability," definition bitmap images. ;  ; Bool_t fIsReading;  ! Set to FALSE when userclass::UseCurrentStyle is called by the style manager ;  ; Int_t fJoinLinePS;  Determines the appearance of joining lines on PostScript, PDF and SVG. ;  ; Width_t fLegendBorderSize;  Legend box border size. ;  ; Color_t fLegendFillColor;  Legend fill color. ;  ; Style_t fLegendFillStyle;  Legend fill style. ;  ; Style_t fLegendFont;  Legend font style. ;  ; Double_t fLegendTextSize;  Legend text size. If 0 the size is computed automatically. ;  ; Float_t fLegoInnerR;  Inner radius for cylindrical legos. ;  ; Float_t fLineScalePS;  Line scale factor when drawing lines on Postscript. ;  ; TString fLineStyle [30];  String describing line style i (for postScript) ;  ; Int_t fNumberContours;  Default number of contours for 2-d plots. ;  ; Int_t fOptDate;  True if date option is selected. ;  ; Int_t fOptFile;  True if option File is selected. ;  ; Int_t fOptFit;  True if option Fit is selected. ;  ; Int_t fOptLogx;  True if log scale in X. ;  ; Int_t fOptLogy;  True if log scale in y. ;  ; Int_t fOptLogz;  True if log scale in z. ;  ; Int_t fOptStat;  True if option Stat is selected. ;  ; Int_t fOptTitle;  True if option Title is selected. ;  ; Bool_t fOrthoCamera;  Use orthographic camera with web display. ;  ; Int_t fPadBorderMode;  Pad border mode. ;  ; Width_t fPadBorderSize;  Pad border size. ;  ; Float_t fPadBottomMargin;  Pad bottom margin. ;  ; Color_t fPadColor;  Pad color. ;  ; Bool_t fPadGridX;  True to get the grid along X. ;  ; Bool_t fPadGridY;  True to get the grid along Y. ;  ; Float_t fPadLeftMargin;  Pad left margin. ;  ; Float_t fPadRightMargin;  Pad right margin. ;  ; Int_t fPadTickX;  True to set special pad ticks along X. ;  ; Int_t fPadTickY;  True to set special pad ticks along Y. ;  ; Float_t fPadTopMargin;  Pad top margin. ;  ; TString fPaintTextFormat;  Printing format for TH2::PaintText. ;  ; Float_t fPaperSizeX;  PostScript paper size along X. ;  ; Float_t fPaperSizeY;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:39396,log,log,39396,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,1,['log'],['log']
Testability," delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); THLimitsFinder&operator=(const THLimitsFinder&); static voidOptimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidOptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THLimitsFinder.html:5180,Test,TestBit,5180,root/html532/THLimitsFinder.html,https://root.cern,https://root.cern/root/html532/THLimitsFinder.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualIndex&operator=(const TVirtualIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualIndex.html:5128,Test,TestBit,5128,root/html532/TVirtualIndex.html,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); voidUpdate(MethodArgInfo_t* info); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodArg.html:5228,Test,TestBit,5228,root/html602/TMethodArg.html,https://root.cern,https://root.cern/root/html602/TMethodArg.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethod&operator=(const TMethod& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tTFunction::Property() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetMenuItem(EMenuItemKind menuItem); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual TMethodCall*SetterMethod(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMethod.html:5796,Test,TestBit,5796,root/html534/TMethod.html,https://root.cern,https://root.cern/root/html534/TMethod.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* name = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShow(const char* name); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStart(const char* name); virtual voidStop(const char* name); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSummary(Float_t& rt, Float_t& cp); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBenchmark.html:4842,Test,TestBit,4842,root/html534/TBenchmark.html,https://root.cern,https://root.cern/root/html534/TBenchmark.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TViewer3DPad.html:5247,Test,TestBit,5247,root/html532/TViewer3DPad.html,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSQLClassInfo&operator=(const TSQLClassInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClassTableName(const char* name); voidSetColumns(TObjArray* columns); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetRawExist(Bool_t on); voidSetRawTableName(const char* name); voidSetTableStatus(TObjArray* columns = 0, Bool_t israwtable = kFALSE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TSQLClassInfo(); TSQLClassInfo(const TSQLClassInfo&); TSQLClassInfo(Long64_t classid, const char* classname, Int_t version); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLClassInfo.html:5098,Test,TestBit,5098,root/html602/TSQLClassInfo.html,https://root.cern,https://root.cern/root/html602/TSQLClassInfo.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::Timer&operator=(const TMVA::Timer&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTStopwatch::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); Double_tTStopwatch::RealTime(); virtual voidTObject::RecursiveRemove(TObject* obj); voidReset(); voidTObject::ResetBit(UInt_t f); voidTStopwatch::ResetCpuTime(Double_t time = 0); voidTStopwatch::ResetRealTime(Double_t time = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); voidTStopwatch::Start(Bool_t reset = kTRUE); voidTStopwatch::Stop(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMVA::TimerTimer(const TMVA::Timer&); TMVA::TimerTimer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); TMVA::TimerTimer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Timer.html:5306,Test,TestBit,5306,root/html532/TMVA__Timer.html,https://root.cern,https://root.cern/root/html532/TMVA__Timer.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TFileStager&operator=(const TFileStager&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual Bool_tStage(const char*, Option_t* = 0); virtual Bool_tStage(TCollection* pathlist, Option_t* opt = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TFileStager(const char* stager); TFileStager(const TFileStager&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileStager.html:5330,Test,TestBit,5330,root/html602/TFileStager.html,https://root.cern,https://root.cern/root/html602/TFileStager.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGondzioSolver&operator=(const TGondzioSolver& source); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset_parameters(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTQpSolverBase::SetArTol(Double_t ar); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTQpSolverBase::SetMuTol(Double_t m); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tSolve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); virtual voidTQpSolverBase::Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTQpSolverBase::SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGondzioSolver.html:6101,Test,TestBit,6101,root/html532/TGondzioSolver.html,https://root.cern,https://root.cern/root/html532/TGondzioSolver.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofMonSenderML&operator=(const TProofMonSenderML&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSendDataSetInfo(TDSet*, TList*, const char*, const char*); virtual Int_tSendFileInfo(TDSet*, TList*, const char*, const char*); virtual Int_tSendSummary(TList*, const char*); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); Int_tTProofMonSender::SetSendOptions(const char*); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMonSenderML.html:5046,Test,TestBit,5046,root/html532/TProofMonSenderML.html,https://root.cern,https://root.cern/root/html532/TProofMonSenderML.html,2,['Test'],"['TestBit', 'TestBits']"
Testability," delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSQLTableInfo&operator=(const TSQLTableInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TSQLTableInfo(); TSQLTableInfo(const TSQLTableInfo&); TSQLTableInfo(const char* tablename, TList* columns, const char* comment = ""SQL table"", const char* engine = 0, const char* create_time = 0, const char* update_time = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLTableInfo.html:4865,Test,TestBit,4865,root/html602/TSQLTableInfo.html,https://root.cern,https://root.cern/root/html602/TSQLTableInfo.html,4,['Test'],"['TestBit', 'TestBits']"
Testability," derivative of the NN w.r.t. each input. That quantity is recognized as one of the measures to determine key quantities in the network.; What is done is to vary one input around its nominal value and to see how the NN changes. This is done for each entry in the sample and produces a distribution.; What you can learn from that is:; is variable a really useful, or is my network insensitive to it ?; is there any risk of big systematic ? Is the network extremely sensitive to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve as input for an ""educated guess"" when optimizing the network. ; Definition at line 311 of file TMLPAnalyzer.cxx. ◆ DrawNetwork(). void TMLPAnalyzer::DrawNetwork ; (; Int_t ; neuron, . const char * ; signal, . const char * ; bg . ). Draws the distribution of the neural network (using ith neuron). ; Two distributions are drawn, for events passing respectively the ""signal"" and ""background"" cuts. Only the test sample is used. ; Definition at line 337 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviation(). TProfile * TMLPAnalyzer::DrawTruthDeviation ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; This method is mainly useful when doing regression analysis with the MLP (i.e. not classification, but continuous truth values). The resulting TProfile histogram is returned. It is not drawn if option ""goff"" is specified. Options are passed to TProfile::Draw ; Definition at line 398 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviationInOut(). TProfile * TMLPAnalyzer::DrawTruthDeviationInOut ; (; Int_t ; innode, . Int_t ; outnode = 0, . Option_t * ; option = """" . ). Creates a profile of the difference of the MLP output outnode minus the true value of outnode vs the input value innode, for all test data events. ; The resulting TProfile histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:15140,test,test,15140,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['test'],['test']
Testability," details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Double_t* positionInit, const Bool_t* fixPosition, const Double_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional. void SetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2). SETTER FUNCTION. This function sets the following fitting parameters of background:; -a0Init - initial value of a0 parameter (backgroud is estimated as a0+a1*x+a2*x*x); -fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); -a1Init - initial value of a1 parameter; -fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); -a2Init - initial value of a2 parameter; -fixA2 - logical value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:36941,log,logical,36941,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,8,['log'],['logical']
Testability," determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:21682,test,test,21682,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,6,['test'],['test']
Testability," determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*>& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDERS.html:24049,test,test,24049,root/html602/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDERS.html,4,['test'],['test']
Testability," dim2 = -1, Bool_t TreatEmptyCells = kFALSE). private:. TMVA::PDEFoamDistr*GetDistr() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationsplit cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDistr*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsfill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypetype of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsnumber of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxpeek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimertimer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracvolume fraction (with respect to total phase space; Double_t*fXmax[fDim] maximum for variable transform; Double_t*fXmin[fD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:10553,log,logger,10553,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['log'],['logger']
Testability," direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;�������������",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:49648,log,logical,49648,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,10,['log'],['logical']
Testability," direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitely by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitely, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:6991,test,test,6991,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,4,['test'],['test']
Testability," directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TApplicationServer.html:15932,log,logon,15932,root/html534/TApplicationServer.html,https://root.cern,https://root.cern/root/html534/TApplicationServer.html,4,['log'],['logon']
Testability," directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2009-12-07 13:50; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:15603,log,logon,15603,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,2,['log'],['logon']
Testability," directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2010-10-06 16:19; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplicationServer.html:15762,log,logon,15762,root/html528/TApplicationServer.html,https://root.cern,https://root.cern/root/html528/TApplicationServer.html,2,['log'],['logon']
Testability," directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() const; { return fUrl.GetHost(); }. TSocket * GetSocket() const; { return fSocket; }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsValid() const; { return fIsValid; }. » Author: G. Ganis 10/5/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TApplicationServer.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TApplicationServer.html:15913,log,logon,15913,root/html530/TApplicationServer.html,https://root.cern,https://root.cern/root/html530/TApplicationServer.html,2,['log'],['logon']
