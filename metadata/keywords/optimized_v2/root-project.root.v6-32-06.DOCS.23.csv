quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"fect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer. Withholding; these potentially stale variable values from the developer diminishes the; amount of available debug information, but increases the reliability of the; remaining information. To illustrate some potential issues, consider the following example:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); br i1 %cond, label %truebr, label %falsebr; truebr:; %tval = add i32 %bar, 1; call @llvm.dbg.value(metadata i32 %tval, metadata !1, metadata !2); %g1 = call i32 @gazonk(); br label %exit; falsebr:; %fval = add i32 %bar, 2; call @llvm.dbg.value(metadata i32 %fval, metadata !1, metadata !2); %g2 = call i32 @gazonk(); br label %exit; exit:; %merge = phi [ %tval, %tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:19439,redund,redundant,19439,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['redund'],['redundant']
Safety,"fety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20180,safe,safety,20180,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"few deserve mention. If the parsed form of the attribute is more complex, or differs from the; semantic form, the ``HasCustomParsing`` bit can be set to ``1`` for the class,; and the parsing code in `Parser::ParseGNUAttributeArgs(); <https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp>`_; can be updated for the special case. Note that this only applies to arguments; with a GNU spelling -- attributes with a __declspec spelling currently ignore; this flag and are handled by ``Parser::ParseMicrosoftDeclSpec``. Note that setting this member to 1 will opt out of common attribute semantic; handling, requiring extra implementation efforts to ensure the attribute; appertains to the appropriate subject, etc. If the attribute should not be propagated from a template declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:138745,avoid,avoid,138745,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"fferMerger. An excerpt of the; [tutorial](https://github.com/root-project/root/blob/master/tutorials/multicore/mt103_fillNtuples.C); is shown below.; ```{.cpp}; // Create the TBufferMerger; TBufferMerger merger(""mp103_fillNtuple.root"");. // Define what each worker will do; auto work_function = [&]() {; auto f = merger.GetFile();; TNtuple ntrand(""ntrand"", ""Random Numbers"", ""r"");; fill(ntrand, nEventsPerWorker);; ntrand.Write();; f->Write();; };; ```. ## Language Bindings. - Add in PyROOT the converter for std::string_view; - Fix ROOT-8811: pickling of ROOT.Long now works; - Fix ROOT-8809: push_back on a vector of pointers; - Fix ROOT-8805: itemsize was not set on buffers returned by PyROOT functions. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - rlibmap has been removed; it was deprecated for three years.; - Added the CMake exported ROOT libraries into the ROOT:: namespace. In this way, projects based on CMake using ROOT can avoid; conflicts in library target names. As an example, this is the way to build a project consisting of one library and one; executable using ROOT.; ```; find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}). include_directories(${CMAKE_SOURCE_DIR} ${ROOT_INCLUDE_DIRS}); add_definitions(${ROOT_CXX_FLAGS}). ROOT_GENERATE_DICTIONARY(G__Event Event.h LINKDEF EventLinkDef.h). add_library(Event SHARED Event.cxx G__Event.cxx); target_link_libraries(Event ROOT::Hist ROOT::Tree). add_executable(Main MainEvent.cxx); target_link_libraries(Main Event); ```; - Added option `builtin_all` to enable all the built in options.; - For rootcling_stage1 (formerly known as rootcling_tmp), the package structure was changed to enable homogenous visibility; settings across object files. See core/README for an overview.; - Several non-public headers are not copied into include/ anymore; they reside in the PACKAGE/res/ subdirectory in the source tree.; - The IMT switch is set to on by default.; - A new",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:17687,avoid,avoid,17687,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoid']
Safety,"fficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1323,avoid,avoid,1323,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['avoid'],['avoid']
Safety,"ffsets to a; live frame pointer to recover the address of the allocation. The offset is; computed during frame layout of the caller of ``llvm.localescape``. Arguments:; """""""""""""""""""". All arguments to '``llvm.localescape``' must be pointers to static allocas or; casts of static allocas. Each function can only call '``llvm.localescape``'; once, and it can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It is zero-indexed. Semantics:; """""""""""""""""""". These intrinsics allow a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:514612,recover,recover,514612,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recover']
Safety,"fied version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-specified ISA naming strings (e.g. ``-march``). We are actively deciding not to support multiple specification revisions; at this time. We acknowledge a likely future need, but actively defer the; decisions making around handling this until we have a concrete example of; real hardware having shipped and an incompatible change to the; specification made afterwards. Base ISAs; =========. The specification defines five base instruction sets: RV32I, RV32E, RV64I,; RV64E, and RV128I.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:1528,avoid,avoid,1528,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['avoid'],['avoid']
Safety,"figure how LLVM should be built on your system,. - ninja: runs the C++ compiler to (re)build specific parts of LLVM,. - python: to run the LLVM tests,. As an example, on Ubuntu:. .. code:: console. $ sudo apt-get install git clang cmake ninja-build python arcanist. Building LLVM; =============. Checkout; --------. The source code is stored `on; Github <https://github.com/llvm/llvm-project>`__ in one large repository; (""the monorepo""). It may take a while to download!. .. code:: console. $ git clone https://github.com/llvm/llvm-project.git. This will create a directory ""llvm-project"" with all of the source; code. (Checking out anonymously is OK - pushing commits uses a different; mechanism, as we'll see later.). Configure your workspace; ------------------------. Before we can build the code, we must configure exactly how to build it; by running CMake. CMake combines information from three sources:. - explicit choices you make (is this a debug build?). - settings detected from your system (where are libraries installed?). - project structure (which files are part of 'clang'?). First, create a directory to build in. Usually, this is; llvm-project/build. .. code:: console. $ mkdir llvm-project/build; $ cd llvm-project/build. Now, run CMake:. .. code:: console. $ cmake -G Ninja ../llvm -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=clang. If all goes well, you'll see a lot of ""performing test"" lines, and; finally:. .. code:: console. Configuring done; Generating done; Build files have been written to: /path/llvm-project/build. And you should see a build.ninja file. Let's break down that last command a little:. - **-G Ninja**: we're going to use ninja to build; please create; build.ninja. - **../llvm**: this is the path to the source of the ""main"" LLVM; project. - The two **-D** flags set CMake variables, which override; CMake/project defaults:. - **CMAKE_BUILD_TYPE=Release**: build in optimized mode, which is; (surprisingly) the fastest option. If you want to run unde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:2529,detect,detected,2529,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['detect'],['detected']
Safety,"files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1381,detect,detecting,1381,geom/gdml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md,1,['detect'],['detecting']
Safety,"finalize state; for the ``MaterializationResponsibility`` if needed. .. code-block:: c++. Error notifyEmitted(MaterializationResponsibility &MR). * ``notifyFailed`` is called if the link fails at any point. It can be; overridden to react to the failure (e.g. to deallocate any already allocated; resources). .. code-block:: c++. Error notifyFailed(MaterializationResponsibility &MR). * ``notifyRemovingResources`` is called when a request is made to remove any; resources associated with the ``ResourceKey`` *K* for the; ``MaterializationResponsibility``. .. code-block:: c++. Error notifyRemovingResources(ResourceKey K). * ``notifyTransferringResources`` is called if/when a request is made to; transfer tracking of any resources associated with ``ResourceKey``; *SrcKey* to *DstKey*. .. code-block:: c++. void notifyTransferringResources(ResourceKey DstKey,; ResourceKey SrcKey). Plugin authors are required to implement the ``notifyFailed``,; ``notifyRemovingResources``, and ``notifyTransferringResources`` methods in; order to safely manage resources in the case of resource removal or transfer,; or link failure. If no resources are managed by the plugin then these methods; can be implemented as no-ops returning ``Error::success()``. Plugin instances are added to an ``ObjectLinkingLayer`` by; calling the ``addPlugin`` method [1]_. E.g. .. code-block:: c++. // Plugin class to print the set of defined symbols in an object when that; // object is linked.; class MyPlugin : public ObjectLinkingLayer::Plugin {; public:. // Add passes to print the set of defined symbols after dead-stripping.; void modifyPassConfig(MaterializationResponsibility &MR,; const Triple &TT,; jitlink::PassConfiguration &Config) override {; Config.PostPrunePasses.push_back([this](jitlink::LinkGraph &G) {; return printAllSymbols(G);; });; }. // Implement mandatory overrides:; Error notifyFailed(MaterializationResponsibility &MR) override {; return Error::success();; }; Error notifyRemovingResources(ResourceKey ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:4459,safe,safely,4459,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['safe'],['safely']
Safety,"fine void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33030,safe,safepoint,33030,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"fined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76618,recover,recover,76618,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recover']
Safety,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108556,redund,redundant,108556,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['redund'],['redundant']
Safety,"for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, update the CMake toolchain version checks as; well as the :doc:`getting started<GettingStarted>` guide. This provides a; softer transition path for developers compiling LLVM, because the; error can be turned into a warning using a CMake flag. This is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new feature",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:34634,avoid,avoid,34634,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['avoid'],['avoid']
Safety,"for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via using the following scripts. Similarly to the local environment, configuration is split in different files; to allow for a system-wide configuration, which has precedence over; user's configuration in the home directory. If a script cannot be found,; it will be silently skipped. - `<output_of_payload>`. - `common.before`. - `remote.before`. - `remote.conf`. - `common.after`. - `remote.after`. For an explanation on how to pass extra data to the workers safely; through the payload, see below. ### Payload: sending local files to the remote nodes. In many cases it is necessary to send some local data to the remote; workers: it is very common, for instance, to distribute a local Grid; authentication proxy on the remote workers to let them authenticate to; access a data storage. The `payload` file must be an executable generating some output that; will be prepended to the remote environment preparation. Differently; than the other environment scripts, it is not executed: instead, it is; first run, then *the output it produces will be executed*. Let's see a practical example to better understand how it works. We need; to send our Grid proxy to the master node. This is our `payload` executable script:. ``` {.bash}; #!/bin/bash; echo ""echo '`cat /tmp/x509up_u$UID | base64 | tr -d '\r\n'`'"" \; ""| base64 -d > /tmp/x509up_u\$UID""; ```. This script will be executed locally, providing another ""script line"" as; output:. ``` {.bash}; ech",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:4986,safe,safely,4986,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['safe'],['safely']
Safety,"fp. v2, v3, v2; mfcr r3, 2; rlwinm r3, r3, 25, 31, 31; cmpwi cr0, r3, 0; bne cr0, LBB1_2 ; entry; LBB1_1: ; entry; mr r6, r5; LBB1_2: ; entry; mr r3, r6; mtspr 256, r2; blr. //===----------------------------------------------------------------------===//. CodeGen/PowerPC/vec_constants.ll has an and operation that should be; codegen'd to andc. The issue is that the 'all ones' build vector is; SelectNodeTo'd a VSPLTISB instruction node before the and/xor is selected; which prevents the vnot pattern from matching. //===----------------------------------------------------------------------===//. An alternative to the store/store/load approach for illegal insert element ; lowering would be:. 1. store element to any ol' slot; 2. lvx the slot; 3. lvsl 0; splat index; vcmpeq to generate a select mask; 4. lvsl slot + x; vperm to rotate result into correct slot; 5. vsel result together. //===----------------------------------------------------------------------===//. Should codegen branches on vec_any/vec_all to avoid mfcr. Two examples:. #include <altivec.h>; int f(vector float a, vector float b); {; int aa = 0;; if (vec_all_ge(a, b)); aa |= 0x1;; if (vec_any_ge(a,b)); aa |= 0x2;; return aa;; }. vector float f(vector float a, vector float b) { ; if (vec_any_eq(a, b)) ; return a; ; else ; return b; ; }. //===----------------------------------------------------------------------===//. We should do a little better with eliminating dead stores.; The stores to the stack are dead since %a and %b are not needed. ; Function Attrs: nounwind; define <16 x i8> @test_vpmsumb() #0 {; entry:; %a = alloca <16 x i8>, align 16; %b = alloca <16 x i8>, align 16; store <16 x i8> <i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15, i8 16>, <16 x i8>* %a, align 16; store <16 x i8> <i8 113, i8 114, i8 115, i8 116, i8 117, i8 118, i8 119, i8 120, i8 121, i8 122, i8 123, i8 124, i8 125, i8 126, i8 127, i8 112>, <16 x i8>* %b, align 16; %0 = load <16 x i8>*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:5542,avoid,avoid,5542,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,2,['avoid'],['avoid']
Safety,"frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:40257,detect,detect,40257,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['detect'],['detect']
Safety,"from RooFit and; then it translates that into a single piece of code (a C++ function), that can; then be differentiated using Clad. It also helps evaluate the model. In RooFit, evaluation is done using the 'evaluate()' function. It also; performs a lot of book-keeping, caching, etc. that is required for RooFit (but; not necessarily for AD). A new `translate()` function is added to RooFit classes that includes a call; to this `evaluate()` function. `translate()` helps implement the Code; Squashing logic. All RooFit classes that should support AD need to use this; function. It creates a string of code, which is then just-in-time compiled; using Cling (C++ interpreter for ROOT). For each of the `translate()`; functions, it is important to call `addResult()` since this is what enables; the squashing to happen. #### Helper Functions. - **RooFit::Detail::CodeSquashContext**: this class maintains the context for squashing of; RooFit models into code. It keeps track of the results of various; expressions to avoid redundant calculations. - **Loop Scopes()**: `beginloop()` and `endloop()` are used to create a scope; for iterating over vector observables (collections of data). This is; especially useful when dealing with data that comes in sets or arrays. - **addToGlobalScope()**: helps add code statements to the global scope; (e.g., to declare variables). - **addToCodeBody()**: adds the input string to the squashed code body. If a; class implements a translate function that wants to emit something to the; squashed code body, it must call this function with the code it wants to; emit. In case of loops, it automatically determines if the code needs to be; stored inside or outside the scope of that loop. - **makeValidVarName()**: takes a string (e.g., a variable name) and converts; it into a valid C++ variable name by replacing any forbidden characters with; underscores. - **buildArg()**: helps convert RooFit objects into arrays or other C++; representations for efficient computa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:31321,avoid,avoid,31321,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"from_indexable(T, PTR [, PTR_TO_TERM])`` casts any; safe pointer PTR to a ``__terminated_by(T)`` pointer. ``PTR_TO_TERM`` is an; optional argument where the programmer can provide the exact location of the; terminator. With this argument, the function can skip reading the entire; array in order to locate the end of the pointer (or the upper bound).; Providing an incorrect ``PTR_TO_TERM`` causes a run-time trap. + ``__unsafe_forge_terminated_by(T, P, E)`` creates ``T __terminated_by(E)``; pointer given any pointer ``P``. Tmust be a pointer type. Portability with toolchains that do not support the extension; -------------------------------------------------------------. The language model is designed so that it doesn't alter the semantics of the; original C program, other than introducing deterministic traps where otherwise; the behavior is undefined and/or unsafe. Clang provides a toolchain header; (``ptrcheck.h``) that macro-defines the annotations as type attributes when; ``-fbounds-safety`` is enabled and defines them to empty when the extension is; disabled. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ================================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:45539,safe,safety,45539,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requires a combination of language design, runtime; support, and often operating system support. It is certainly possible to implement a safe language in LLVM, but LLVM; IR does not itself guarantee safety. The LLVM IR allows unsafe pointer; casts, use after free bugs, buffer over-runs, and a variety of other; problems. Safety needs to be implemented as a layer on top of LLVM and,; conveniently, several groups have investigated this. Ask on the `LLVM; forums <https://discourse.llvm.org>`_ if you are interested in more details. Language-Specific Optimizations; -------------------------------. One thing about LLVM that turns off many people is that it does not; solve all the world's problems in one system. One specific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; information"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:8339,unsafe,unsafe,8339,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['unsafe'],['unsafe']
Safety,"function entry block, 0 otherwise.; }. Tracing PCs; ===========. With ``-fsanitize-coverage=trace-pc`` the compiler will insert; ``__sanitizer_cov_trace_pc()`` on every edge.; With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call.; These callbacks are not implemented in the Sanitizer run-time and should be defined; by the user.; This mechanism is used for fuzzing the Linux kernel; (https://github.com/google/syzkaller). Instrumentation points; ======================; Sanitizer Coverage offers different levels of instrumentation. * ``edge`` (default): edges are instrumented (see below).; * ``bb``: basic blocks are instrumented.; * ``func``: only the entry block of every function will be instrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:7895,redund,redundant,7895,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['redund'],['redundant']
Safety,"function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81880,avoid,avoid,81880,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"fval, %falsebr ]; %g = phi [ %g1, %truebr ], [ %g2, %falsebr ]; call @llvm.dbg.value(metadata i32 %merge, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %plusten = add i32 %merge, 10; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. Containing two source-level variables in ``!1`` and ``!3``. The function could,; perhaps, be optimized into the following code:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; %g = call i32 @gazonk(); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; ret i32 %toret; }. What ``llvm.dbg.value`` intrinsics should be placed to represent the original variable; locations in this code? Unfortunately the second, third and fourth; dbg.values for ``!1`` in the source function have had their operands; (%tval, %fval, %merge) optimized out. Assuming we cannot recover them, we; might consider this placement of dbg.values:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. However, this will cause ``!3`` to have the return value of ``@gazonk()`` at; the same time as ``!1`` has the constant value zero -- a pair of assignments; that never occurred in the unoptimized program. To avoid this, we must terminate; the range that ``!1`` has the constant value assignment by inserting a poison; dbg.value before the dbg.value for ``!3``:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:21412,recover,recover,21412,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['recover'],['recover']
Safety,"g a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4616,detect,detection,4616,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['detect'],['detection']
Safety,"g a linear congruential random; generator. The multipliers used are the same of the BSD `rand()` random; generator. Its sequence is:. $x_{n+1} = (ax_n + c) mod m$ with $a =1103515245$,; $c = 12345$ and $m =2^{31}$. This type of generator uses a state of only a 32 bit integer and it has; a very short period, 2^31^,about 10^9^, which can be exhausted in just; few seconds. The quality of this generator is therefore BAD and it is; strongly recommended to NOT use for any statistical study. ### TRandom1. This random number generator is based on the Ranlux engine, developed by; M. Lüsher and implemented in Fortran by F. James. This engine has; mathematically proven random proprieties and a long period of about; 10^171^. Various luxury levels are provided `(1,2,3,4)` and can be; specified by the user in the constructor. Higher the level, better; random properties are obtained at a price of longer CPU time for; generating a random number. The level 3 is the default, where any; theoretical possible correlation has very small chance of being; detected. This generator uses a state of 24 32-bits words. Its main; disadvantage is that is much slower than the others (see timing table).; For more information on the generator see the following article:. - F. James, ""RANLUX: A Fortran implementation of the high quality; pseudo-random number generator of Lüscher"", Computer Physics; Communication, 79 (1994) 111. ### TRandom2. This generator is based on the maximally equi-distributed combined; Tausworthe generator by L'Ecuyer. It uses only 3 32-bits words for the; state and it has a period of about 10^26^. It is fast and given its; small states, it is recommended for applications, which require a very; small random number size. For more information on the generator see the; following article:. - P. L'Ecuyer, ""Maximally Equi-distributed Combined Tausworthe; Generators"", Mathematics of Computation, 65, 213 (1996), 203-213. ### TRandom3. This is based on the Mersenne and Twister pseudo-rand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:11869,detect,detected,11869,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['detect'],['detected']
Safety,"g from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped through the substitution table to find the most; recent instruction number / operand number of the value it refers to. Use `MachineFunction::substituteDebugValuesForInst` to automatically produce; substitutions between an old and new instruction. It assumes that any operand; that is a def in the old instruction is a def in the new instruction at the; same operand position. This works most of the time, for example in the example; above. If operand numbers do not line up between the old and new instruction, use; `MachineInstr::getDebugInstrNum` to acquire the instruction number for the new; instruction, and `MachineFunction::makeDebugValueSubstitution` to record the; mapping between register definitions in the old and new instructions. If some; values computed by the old instruction are no longer computed by the new; instruction, record no substitution -- `LiveDebugValues` will safely drop the; now unavailable variable value. Should your target clone instructions, much the same as the `TailDuplicator`; optimisation pass, do not attempt to preserve the instruction numbers or; record any substitutions. `MachineFunction::CloneMachineInstr` should drop the; instruction number of any cloned instruction, to avoid duplicate numbers; appearing to `LiveDebugValues`. Dealing with duplicated instructions is a; natural extension to instruction referencing that's currently unimplemented. [LiveDebugValues]: project:SourceLevelDebugging.rst#LiveDebugValues expansion of variable locations; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:8689,safe,safely,8689,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,2,"['avoid', 'safe']","['avoid', 'safely']"
Safety,"g it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:150959,avoid,avoid,150959,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"g report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:1988,avoid,avoid,1988,hist/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html,2,['avoid'],['avoid']
Safety,"g): Determines whether a; reference of type ``T`` bound to an expression of type ``U`` would bind to a; materialized temporary object. If ``T`` is not a reference type the result; is false. Note this trait will also return false when the initialization of; ``T`` from ``U`` is ill-formed.; Deprecated, use ``__reference_constructs_from_temporary``.; * ``__reference_constructs_from_temporary(T, U)`` (C++); Returns true if a reference ``T`` can be constructed from a temporary of type; a non-cv-qualified ``U``.; * ``__underlying_type`` (C++, GNU, Microsoft). In addition, the following expression traits are supported:. * ``__is_lvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is an lvalue expression.; Deprecated, use ``__is_lvalue_reference(decltype((e)))`` instead.; * ``__is_rvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is a prvalue expression.; Deprecated, use ``!__is_reference(decltype((e)))`` instead. There are multiple ways to detect support for a type trait ``__X`` in the; compiler, depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:65322,detect,detect,65322,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['detect'],['detect']
Safety,"g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one may need to execute different code depending on whether; ShadowCallStack is enabled. The macro ``__has_feature",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:7838,avoid,avoids,7838,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoids']
Safety,"g.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the wrong thing. //===---------------------------------------------------------------------===//. It would be really nice to be able to write patterns in .td files for copies,; which would eliminate a bunch of explicit predicates on them (e.g. no side; effects). Once this is in place, it would be even better to have tblgen; synthesize the various copy insertion/inspection methods in TargetInstrInfo. //===---------------------------------------------------------------------===//. Stack coloring improvements:. 1. Do proper LiveStacks analysis on all stack objects including those which are; not spill slots.; 2. Reorder objects to fill in gaps between objects.; e.g. 4, 1, <gap>, 4, 1, 1, 1, <gap>, 4 => 4, 1, 1, 1, 1, 4, 4. //===---------------------------------------------------------------------===//. The scheduler should be able to sort nearby instructions by their address. For; example, in an expanded memset sequence it's not uncommon to see code like this:. movl $0, 4(%rdi); movl $0, 8(%rdi); movl $0, 12(%rdi); movl $0, 0(%rdi). Each of the stores is independent, and the scheduler is currently making an; arbitrary decision about the order. //===---------------------------------------------------------------------===//. Another opportunitiy in this code is that the $0 could be moved to a register:. movl $0, 4(%rdi); movl $0, 8(%rdi); movl $0, 12(%rdi); movl $0, 0(%rdi). This would save substantial code size, especially for longer sequences like; this. It would be easy to have a rule telling isel to avoid matching MOV32mi; if the immediate has more than some fixed number of uses. It's more involved; to teach the register allocator how to do late folding to recover from; excessive register pressure. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:5942,avoid,avoid,5942,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,2,"['avoid', 'recover']","['avoid', 'recover']"
Safety,"g; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37883,detect,detects,37883,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['detect'],['detects']
Safety,"gInfoMetadata.h`` and the implementations of the; helper functions in ``lib/IR/DIBuilder.cpp``. C/C++ source file information; -----------------------------. ``llvm::Instruction`` provides easy access to metadata attached with an; instruction. One can extract line number information encoded in LLVM IR using; ``Instruction::getDebugLoc()`` and ``DILocation::getLine()``. .. code-block:: c++. if (DILocation *Loc = I->getDebugLoc()) { // Here I is an LLVM instruction; unsigned Line = Loc->getLine();; StringRef File = Loc->getFilename();; StringRef Dir = Loc->getDirectory();; bool ImplicitCode = Loc->isImplicitCode();; }. When the flag ImplicitCode is true then it means that the Instruction has been; added by the front-end but doesn't correspond to source code written by the user. For example. .. code-block:: c++. if (MyBoolean) {; MyObject MO;; ...; }. At the end of the scope the MyObject's destructor is called but it isn't written; explicitly. This information is useful to avoid to have counters on brackets when; making code coverage. C/C++ global variable information; ---------------------------------. Given an integer global variable declared as follows:. .. code-block:: c. _Alignas(8) int MyGlobal = 100;. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the global itself.; ;;; @MyGlobal = global i32 100, align 8, !dbg !0. ;;; ;; List of debug info of globals; ;;; !llvm.dbg.cu = !{!1}. ;; Some unrelated metadata.; !llvm.module.flags = !{!6, !7}; !llvm.ident = !{!8}. ;; Define the global variable itself; !0 = distinct !DIGlobalVariable(name: ""MyGlobal"", scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64). ;; Define the compile unit.; !1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,; producer: ""clang version 4.0.0"",; isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,; enums: !3, globals: !4). ;;; ;; Define the file; ;;; !2 = !DIFile(filename: ""/dev/stdin"",; direc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:42453,avoid,avoid,42453,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"gReport. BugType, as the name would suggest, represents a type of bug. The; constructor for BugType takes two parameters: The name of the bug; type, and the name of the category of the bug. These are used (e.g.) in the; summary page generated by the scan-build tool. The BugReport class represents a specific occurrence of a bug. In; the most common case, three parameters are used to form a BugReport:. The type of bug, specified as an instance of the BugType class.; A short descriptive string. This is placed at the location of the bug in; the detailed line-by-line output generated by scan-build.; The context in which the bug occurred. This includes both the location of; the bug in the program and the program's state when the location is reached. These are; both encapsulated in an ExplodedNode. In order to obtain the correct ExplodedNode, a decision must be made; as to whether or not analysis can continue along the current path. This decision; is based on whether the detected bug is one that would prevent the program under; analysis from continuing. For example, leaking of a resource should not stop; analysis, as the program can continue to run after the leak. Dereferencing a; null pointer, on the other hand, should stop analysis, as there is no way for; the program to meaningfully continue after such an error. If analysis can continue, then the most recent ExplodedNode; generated by the checker can be passed to the BugReport constructor; without additional modification. This ExplodedNode will be the one; returned by the most recent call to CheckerContext::addTransition.; If no transition has been performed during the current callback, the checker should call CheckerContext::addTransition(); and use the returned node for bug reporting. If analysis can not continue, then the current state should be transitioned; into a so-called sink node, a node from which no further analysis will be; performed. This is done by calling the ; CheckerContext::generateSink function; this f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:16781,detect,detected,16781,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,['detect'],['detected']
Safety,"generated, and that supports performance measurements.; However, it is possible to stop at some stage before measuring. Choices are:; * ``prepare-snippet``: Only generate the minimal instruction sequence.; * ``prepare-and-assemble-snippet``: Same as ``prepare-snippet``, but also dumps an excerpt of the sequence (hex encoded).; * ``assemble-measured-code``: Same as ``prepare-and-assemble-snippet``. but also creates the full sequence that can be dumped to a file using ``--dump-object-to-disk``.; * ``measure``: Same as ``assemble-measured-code``, but also runs the measurement. .. option:: --x86-lbr-sample-period=<nBranches/sample>. Specify the LBR sampling period - how many branches before we take a sample.; When a positive value is specified for this option and when the mode is `latency`,; we will use LBRs for measuring.; On choosing the ""right"" sampling period, a small value is preferred, but throttling; could occur if the sampling is too frequent. A prime number should be used to; avoid consistently skipping certain blocks. .. option:: --x86-disable-upper-sse-registers. Using the upper xmm registers (xmm8-xmm15) forces a longer instruction encoding; which may put greater pressure on the frontend fetch and decode stages,; potentially reducing the rate that instructions are dispatched to the backend,; particularly on older hardware. Comparing baseline results with this mode; enabled can help determine the effects of the frontend and can be used to; improve latency and throughput estimates. .. option:: --repetition-mode=[duplicate|loop|min]. Specify the repetition mode. `duplicate` will create a large, straight line; basic block with `num-repetitions` instructions (repeating the snippet; `num-repetitions`/`snippet size` times). `loop` will, optionally, duplicate the; snippet until the loop body contains at least `loop-body-size` instructions,; and then wrap the result in a loop which will execute `num-repetitions`; instructions (thus, again, repeating the snippet; `num",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:11751,avoid,avoid,11751,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['avoid'],['avoid']
Safety,"ges locally.; Fix issue setting permission and ownership of the dataset; user directories.Fix; a subtle bug affecting the (possibly rare) case when not all entries; are required and # entries does not correspond to an complete subset of; files (e.g. # entries = 1001000 with files of 100000 entries each). The; effect was uncomplete processing (skipped events, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during worker setup.; Make sure that the TProof instance on the client is invalidated after an idle timeout",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:11907,Avoid,Avoid,11907,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['Avoid'],['Avoid']
Safety,"get specific predefined macros or/and language version; predefined macros (see `feature/extension preprocessor macros defined in; opencl-c-base.h; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Headers/opencl-c-base.h>`__). **Pragmas**. Some extensions alter standard parsing dynamically via pragmas. Clang provides a mechanism to add the standard extension pragma; ``OPENCL EXTENSION`` by setting a dedicated flag in the extension list entry of; ``OpenCLExtensions.def``. Note that there is no default behavior for the; standard extension pragmas as it is not specified (for the standards up to and; including version 3.0) in a sufficient level of detail and, therefore,; there is no default functionality provided by clang. Pragmas without detailed information of their behavior (e.g. an explanation of; changes it triggers in the parsing) should not be added to clang. Moreover, the; pragmas should provide useful functionality to the user. For example, such; functionality should address a practical use case and not be redundant i.e.; cannot be achieved using existing features. Note that some legacy extensions (published prior to OpenCL 3.0) still; provide some non-conformant functionality for pragmas e.g. add diagnostics on; the use of types or functions. This functionality is not guaranteed to remain in; future releases. However, any future changes should not affect backward; compatibility. .. _opencl_addrsp:. Address spaces attribute; ------------------------. Clang has arbitrary address space support using the ``address_space(N)``; attribute, where ``N`` is an integer number in the range specified in the; Clang source code. This addresses spaces can be used along with the OpenCL; address spaces however when such addresses spaces converted to/from OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:11142,redund,redundant,11142,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['redund'],['redundant']
Safety,"gh LLVM's struct types and reason about the; underlying memory offsets. The community realized that pointee types hinder LLVM; development, rather than helping it. Some of the initially proposed high-level; optimizations have evolved into `TBAA; <https://llvm.org/docs/LangRef.html#tbaa-metadata>`_ due to limitations with; representing higher-level language information directly via SSA values. Pointee types provide some value to frontends because the IR verifier uses types; to detect straightforward type confusion bugs. However, frontends also have to; deal with the complexity of inserting bitcasts everywhere that they might be; required. The community consensus is that the costs of pointee types; outweight the benefits, and that they should be removed. Many operations do not actually care about the underlying type. These; operations, typically intrinsics, usually end up taking an arbitrary pointer; type ``i8*`` and sometimes a size. This causes lots of redundant no-op bitcasts; in the IR to and from a pointer with a different pointee type. No-op bitcasts take up memory/disk space and also take up compile time to look; through. However, perhaps the biggest issue is the code complexity required to; deal with bitcasts. When looking up through def-use chains for pointers it's; easy to forget to call `Value::stripPointerCasts()` to find the true underlying; pointer obfuscated by bitcasts. And when looking down through def-use chains; passes need to iterate through bitcasts to handle uses. Removing no-op pointer; bitcasts prevents a category of missed optimizations and makes writing LLVM; passes a little bit easier. Fewer no-op pointer bitcasts also reduces the chances of incorrect bitcasts in; regards to address spaces. People maintaining backends that care a lot about; address spaces have complained that frontends like Clang often incorrectly; bitcast pointers, losing address space information. An analogous transition that happened earlier in LLVM is integer signedness.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:3675,redund,redundant,3675,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['redund'],['redundant']
Safety,"gma(""clang abi_ptr_attr set(bidi_indexable)""). #define __ptrcheck_abi_assume_unsafe_indexable() \; _Pragma(""clang abi_ptr_attr set(unsafe_indexable)""). ABI implications of default bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although simply modifying types of a local variable doesn't normally impact the; ABI, taking the address of such a modified type could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:24165,safe,safety,24165,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"gnal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default. .. admonition:: Rationale. C++ already introduces pervasive exceptions-cleanup code of the sort that ARC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:99364,safe,safer,99364,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safer']
Safety,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12491,detect,detect,12491,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['detect'],['detect']
Safety,"gral pointers which has not been addressed upstream. To work around; this, you need to disable speculation of loads unless the memory type; (non-integral pointer vs anything else) is known to unchanged. That is, it is; not safe to speculate a load if doing causes a non-integral pointer value to; be loaded as any other type or vice versa. In practice, this restriction is; well isolated to isSafeToSpeculate in ValueTracking.cpp. Explicit Representation; ^^^^^^^^^^^^^^^^^^^^^^^. A frontend could directly generate this low level explicit form, but; doing so may inhibit optimization. Instead, it is recommended that; compilers with relocating collectors target the abstract machine model just; described. The heart of the explicit approach is to construct (or rewrite) the IR in a; manner where the possible updates performed by the garbage collector are; explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The reco",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:6794,safe,safepoint,6794,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"gram with the ""safe"" backend and running it. **--run-{int,jit,llc,custom}**. Whenever the test program is compiled, **bugpoint** should generate code for it; using the specified code generator. These options allow you to choose the; interpreter, the JIT compiler, the static native code compiler, or a; custom command (see **--exec-command**) respectively. **--safe-{llc,custom}**. When debugging a code generator, **bugpoint** should use the specified code; generator as the ""safe"" code generator. This is a known-good code generator; used to generate the ""reference output"" if it has not been provided, and to; compile portions of the program that as they are excluded from the testcase.; These options allow you to choose the; static native code compiler, or a custom command, (see **--exec-command**); respectively. The interpreter and the JIT backends cannot currently; be used as the ""safe"" backends. **--exec-command** *command*. This option defines the command to use with the **--run-custom** and; **--safe-custom** options to execute the bitcode testcase. This can; be useful for cross-compilation. **--compile-command** *command*. This option defines the command to use with the **--compile-custom**; option to compile the bitcode testcase. The command should exit with a; failure exit code if the file is ""interesting"" and should exit with a; success exit code (i.e. 0) otherwise (this is the same as if it crashed on; ""interesting"" inputs). This can be useful for; testing compiler output without running any link or execute stages. To; generate a reduced unit test, you may add CHECK directives to the; testcase and pass the name of an executable compile-command script in this form:. .. code-block:: sh. #!/bin/sh; llc ""$@""; not FileCheck [bugpoint input file].ll < bugpoint-test-program.s. This script will ""fail"" as long as FileCheck passes. So the result; will be the minimum bitcode that passes FileCheck. **--safe-path** *path*. This option defines the path to the command to execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:5113,safe,safe-custom,5113,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['safe'],['safe-custom']
Safety,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69508,safe,safe,69508,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"gure iossim; make. To build a native iOS armv7 version do:. ./configure ios; make. Both builds create a libRoot.a that can be used to create ROOT based iOS apps; (iOS does not allow apps to load non-system dynamic libraries at run time).; Some sample Xcode projects using ROOT will soon be made available. Base. Change TTime data member from Long_t to Long64_t. On 32-bit systems the; Long_t is 32-bits and too small to keep the time in milliseconds since the ROOT EPOCH (1-1-1995). Added new operators:. operator long long(); operator unsigned long long(). The existing operators long and unsigned long on 32-bit machines return; an error in case the stored time is larger then 32-bit and truncation; occurs (like was always the case till now, but silently). New method ExitOnException() which allows to set the behaviour of; TApplication in case of an exception (sigsegv, sigbus, sigill, sigfpe).; The default is to trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and the -p and -o option. ACLiC. Allow ACLiC to use a flat directory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:1677,abort,abort,1677,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,2,['abort'],['abort']
Safety,"h can be used at link; time. Link Time Optimization (LTO) is another name for intermodular; optimization when performed during the link stage. This document describes the; interface and design between the LTO optimizer and the linker. Design Philosophy; =================. The LLVM Link Time Optimizer provides complete transparency, while doing; intermodular optimization, in the compiler tool chain. Its main goal is to let; the developer take advantage of intermodular optimizations without making any; significant changes to the developer's makefiles or build system. This is; achieved through tight integration with the linker. In this model, the linker; treats LLVM bitcode files like native object files and allows mixing and; matching among them. The linker uses `libLTO`_, a shared object, to handle LLVM; bitcode files. This tight integration between the linker and LLVM optimizer; helps to do optimizations that are not possible in other models. The linker; input allows the optimizer to avoid relying on conservative escape analysis. .. _libLTO-example:. Example of link time optimization; ---------------------------------. The following example illustrates the advantages of LTO's integrated approach; and clean interface. This example requires a system linker which supports LTO; through the interface described in this document. Here, clang transparently; invokes system linker. * Input source file ``a.c`` is compiled into LLVM bitcode form.; * Input source file ``main.c`` is compiled into native object code. .. code-block:: c++. --- a.h ---; extern int foo1(void);; extern void foo2(void);; extern void foo4(void);. --- a.c ---; #include ""a.h"". static signed int i = 0;. void foo2(void) {; i = -1;; }. static int foo3() {; foo4();; return 10;; }. int foo1(void) {; int data = 0;. if (i < 0); data = foo3();. data = data + 42;; return data;; }. --- main.c ---; #include <stdio.h>; #include ""a.h"". void foo4(void) {; printf(""Hi\n"");; }. int main() {; return foo1();; }. To compile, r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:1271,avoid,avoid,1271,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['avoid'],['avoid']
Safety,"h variable and then looping through all; events, placing the cuts always in the middle between two; of the sorted events, and finding the true possible; maximum separation gain in the training sample by cutting; on this variable.; . BDT, AdaBoost The beta parameter is now an; option (default is 1).; . BDT: The node purity at which a node is; classified as signal (respective background node) for; determining the error fraction in the pruning became a; parameter that can be set via the option NodePurityLimit; (default is 0.5).; . Dataset preparation:. First implementation of a new preprocessing method: transformation of the; variables first into a Gaussian distribution, then performing a decorrelation of; the ""Gaussianised"" variables. The transformation is again done by default such that; (by default) the signal distributions become Gaussian and are decorrelated. Note ; that simultaneous Gaussianisation and decorrelation of signal and background is ; only possible (and done) for methods, such as Likelihood, which test both hypotheses.; . Bug fixes:. Fix in Expected error pruning: Rather than multiplying both sides, the error on ; the node and the sub-tree, with the prune strength, now only the expected error ; of the sub-tree is scaled.; . Fix in FDA parsing of the input formula. There were problems when treating; more than 10 parameters (thanks to Hugh Skottowe for reporting this).; . Calculation of ""Separation"": fixed bin-shift and; normalisation bugs. Thanks to Dag Gillberg (Fraser U) for; spotting these.; . Fixed problem in ""SetSignal(Background)WeightExpression"":; signal (background weight expressions not existing in the; background (signal) tree led to an abort of the tree; reading (""Bad numerical expression""). Thanks to Alfio; Rizzo (Brussels) for pointing this out.; . Fixed problem when specifying train and test tree; explicitly. Some code was forgotten in the background; part, creating incompatibilities. Thanks to Zhiyi Liu; (Fraser U) for reporting this.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html:2366,abort,abort,2366,tmva/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html,2,['abort'],['abort']
Safety,"h) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent background for the histogram title. Misc. In the root executable, auto-detect command line arguments that are local root files even if their name does not end with "".root"". If home directory is not correctly set in pw file or user is not known, use the HOME shell variable to find the desired home directory. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:4139,detect,detect,4139,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,2,['detect'],['detect']
Safety,"handle this:. R1 = X + 4; R2 = X + 7; R3 = X + 15. loop:; R1 = X + 4 @ re-materialized; load [i + R1]; ...; R2 = X + 7 @ re-materialized; load [i + R2]; ...; R3 = X + 15 @ re-materialized; load [i + R3]. Furthermore, with re-association, we can enable sharing:. R1 = X + 4; R2 = X + 7; R3 = X + 15. loop:; T = i + X; load [T + 4]; ...; load [T + 7]; ...; load [T + 15]; //===---------------------------------------------------------------------===//. It's not always a good idea to choose rematerialization over spilling. If all; the load / store instructions would be folded then spilling is cheaper because; it won't require new live intervals / registers. See 2003-05-31-LongShifts for; an example. //===---------------------------------------------------------------------===//. With a copying garbage collector, derived pointers must not be retained across; collector safe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The oca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:2926,safe,safe,2926,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['safe'],['safe']
Safety,"happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; `TGeo` offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. \anchor GP05a; ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In `TGeo`, physical nodes are represented by; the class TGeoPhysicalNode and can be created on demand for; alignment purposes:. ~~~{.cpp}; TGeoPhysicalNode(const char* path); ~~~. The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can; however create ""symbolic links"" to any complex path to make it more; representable for the object it designates:. ~~~{.cpp}; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); ~~~. Such a symbolic link hides the complexity of the path to the align; object and replaces it with a more meaningful name. In addition,; TGeoPNEntry objects are faster to search by name and they may; optionally store an additional user matrix. ~~~{.cpp}; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *uni",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:107051,detect,detector,107051,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"haracterization of the performance, and specific benchmarks are unlikely to; reveal especially interesting properties. ### Future Work: Fine Grained Control and API-Integration. The performance overhead of this technique is likely to be very significant and; something users wish to control or reduce. There are interesting options here; that impact the implementation strategy used. One particularly appealing option is to allow both opt-in and opt-out of this; mitigation at reasonably fine granularity such as on a per-function basis,; including intelligent handling of inlining decisions -- protected code can be; prevented from inlining into unprotected code, and unprotected code will become; protected when inlined into protected code. For systems where only a limited; set of code is reachable by externally controlled inputs, it may be possible to; limit the scope of mitigation through such mechanisms without compromising the; application's overall security. The performance impact may also be focused in a; few key functions that can be hand-mitigated in ways that have lower; performance overhead while the remainder of the application receives automatic; protection. For both limiting the scope of mitigation or manually mitigating hot functions,; there needs to be some support for mixing mitigated and unmitigated code; without completely defeating the mitigation. For the first use case, it would; be particularly desirable that mitigated code remains safe when being called; during misspeculation from unmitigated code. For the second use case, it may be important to connect the automatic; mitigation technique to explicit mitigation APIs such as what is described in; http://wg21.link/p0928 (or any other eventual API) so that there is a clean way; to switch from automatic to manual mitigation without immediately exposing a; hole. However, the design for how to do this is hard to come up with until the; APIs are better established. We will revisit this as those APIs mature.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:50166,safe,safe,50166,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['safe'],['safe']
Safety,"hat have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds anno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2938,safe,safety,2938,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modified to work before C++14.; - Added TCollection::Notify to allow notifying more than one object.; ```{.cpp}; TList formulas;; // Add several TTreeFormula to the list;; chain.SetNotify(&formulas);; ```; - For classes that need the `ClassDef` support",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:1684,avoid,avoiding,1684,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoiding']
Safety,"have only one address space), one function stores a 64-bit; integer, while another one stores a pointer. If the target is the machine; mentioned above, and if functions are identical, except the parameter type (we; could consider it as a part of function type), then we can treat a ``uint64_t``; and a ``void*`` as equal. This is just an example; more possible details are described a bit below. As another example, the reader may imagine two more functions. The first; function performs a multiplication by 2, while the second one performs an; logical left shift by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:4830,detect,detector,4830,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,['detect'],"['detector', 'detectors']"
Safety,"havior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented from optimizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:8994,detect,detects,8994,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['detect'],['detects']
Safety,"he Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68746,detect,detection,68746,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['detect'],['detection']
Safety,"he Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avoided; in C++ anyway:. .. code-block:: python. >>> cppyy.cppdef('std::string str_array[3][2] = {{""aa"", ""bb""}, {""cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_uint; >>> u = c_uint(0); >>> c.uint_ref_assign(u, 42); >>> u.value; 42; >>>. For objects, an object, a pointer to an object, and a smart pointer to an; object are represented th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:4244,avoid,avoided,4244,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['avoid'],['avoided']
Safety,"he TMinuit class. ## RooFit Libraries. - Remove deprecated `RooComplex` superseded by `std::complex`. ## TTree Libraries. - `TTreeReader` now supports `TEntryList`s, `Double32_t` / `Float16_t`.; - `TTreeReader::SetLastEntry()` has been deprecated. Its name is misleading; please use `TTreePlayer::SetEntriesRange()` instead.; - `TTree::Branch()` now complains for wrong leaf list strings, e.g. ""value/F[4]"" (which should really be spelled as ""value[4]/F"").; - Allow reading of older version of TTreePerfStats (ROOT-8520); - In `TTree::OptimizeBaskets()` do not call GetBasket(0) to avoid disc reads; - It is now possible to define the precision of the default histogram created; by `TTree::Draw`. Three new parameters are available in `$ROOTSYS/etcsystem.rootrc`; ```{.cpp}; Hist.Precision.1D: float; Hist.Precision.2D: float; Hist.Precision.3D: float; ```; the default values are `float`. They can be set to `double`.; - Fix ROOT-8742: TTree::SetBranchAddress could not be invoked safely even when dealing with the same tree obtained from the same file opened in different threads.; - TTree::Branch() now complains if a ""name[size]/F"" branch specification is passed wrongly (e.g. as ""name/F[size]""). ### TDataFrame; - Creation of the TDataFrame class. The TDataFrame allows to interact with data; stored in columnar format in a functional and intuitive way in order to perform; data analysis. Parallelism is accessible simply by activating implicit; multi-threading with the ROOT::EnableImplicitMT() function.; In a nutshell, the functionality provided is:; - Create and fill histograms with one single method invocation; - Express filtering of entries with strings, lambdas or functions; - Easy creation of efficiencies of cut-flows; - Possibility to run on ranges of entries; - Creating columns not present in the original dataset; - Chain multiple actions to be executed on the same event loop; - Creation of events on-the-fly (e.g. via Pythia or user-define generator functors), with no need for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:5872,safe,safely,5872,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['safe'],['safely']
Safety,"he bin volume corresponding to the variables *not* in `sumSet`. ### New fully parametrised Crystal Ball shape class. So far, the Crystal Ball distribution has been represented in RooFit only by the `RooCBShape` class, which has a Gaussian core and a single power-law tail on one side.; This release introduces [`RooCrystalBall`](https://root.cern/doc/v624/classRooCrystalBall.html), which implements some common generalizations of the Crystal Ball shape:. - symmetric or asymmetric power-law tails on both sides; - different width parameters for the left and right sides of the Gaussian core. The new `RooCrystalBall` class can substitute the `RooDSCBShape` and `RooSDSCBShape`, which were passed around in the community. ## 2D Graphics Libraries. - Add the method `AddPoint`to `TGraph(x,y)` and `TGraph2D(x,y,z)`, equivalent to `SetPoint(g->GetN(),x,y)`and `SetPoint(g->GetN(),x,y,z)`; - Option `E0` draws error bars and markers are drawn for bins with 0 contents. Now, combined; with options E1 and E2, it avoids error bars clipping. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### Multithreaded support for FastCGI. Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests; received via FastCGI channel. This significantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:24891,avoid,avoids,24891,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['avoid'],['avoids']
Safety,"he call site they're attached to, and can be; used by a suitable runtime to deoptimize the compiled frame at the; specified call site. There can be at most one ``""deopt""`` operand; bundle attached to a call site. Exact details of deoptimization is; out of scope for the language reference, but it usually involves; rewriting a compiled frame into a set of interpreted frames. From the compiler's perspective, deoptimization operand bundles make; the call sites they're attached to at least ``readonly``. They read; through all of their pointer typed operands (even if they're not; otherwise escaped) and the entire visible heap. Deoptimization; operand bundles do not capture their operands except during; deoptimization, in which case control will not be returned to the; compiled frame. The inliner knows how to inline through calls that have deoptimization; operand bundles. Just like inlining through a normal call site; involves composing the normal and exceptional continuations, inlining; through a call site with a deoptimization operand bundle needs to; appropriately compose the ""safe"" deoptimization continuation. The; inliner does this by prepending the parent's deoptimization; continuation to every deoptimization continuation in the inlined body.; E.g. inlining ``@f`` into ``@g`` in the following example. .. code-block:: llvm. define void @f() {; call void @x() ;; no deopt state; call void @y() [ ""deopt""(i32 10) ]; call void @y() [ ""deopt""(i32 10), ""unknown""(ptr null) ]; ret void; }. define void @g() {; call void @f() [ ""deopt""(i32 20) ]; ret void; }. will result in. .. code-block:: llvm. define void @g() {; call void @x() ;; still no deopt state; call void @y() [ ""deopt""(i32 20, i32 10) ]; call void @y() [ ""deopt""(i32 20, i32 10), ""unknown""(ptr null) ]; ret void; }. It is the frontend's responsibility to structure or encode the; deoptimization state in a way that syntactically prepending the; caller's deoptimization state to the callee's deoptimization state is; semantic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:120230,safe,safe,120230,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"he control flow) of a program. **CIE**; Common Information Entry. A kind of CFI used to reduce the size of FDEs.; The compiler creates a CIE which contains the information common across all; the FDEs. Each FDE then points to its CIE. **CSE**; Common Subexpression Elimination. An optimization that removes common; subexpression computation. For example ``(a+b)*(a+b)`` has two; subexpressions that are the same: ``(a+b)``. This optimization would; perform the addition only once and then perform the multiply (but only if; it's computationally correct/safe). D; -. **DAG**; Directed Acyclic Graph. .. _derived pointer:; .. _derived pointers:. **Derived Pointer**; A pointer to the interior of an object, such that a garbage collector is; unable to use the pointer for reachability analysis. While a derived pointer; is live, the corresponding object pointer must be kept in a root, otherwise; the collector might free the referenced object. With copying collectors,; derived pointers pose an additional hazard that they may be invalidated at; any `safe point`_. This term is used in opposition to `object pointer`_. **DSA**; Data Structure Analysis. **DSE**; Dead Store Elimination. E; -. **ento**; This namespace houses the; `Clang Static Analyzer <https://clang.llvm.org/docs/ClangStaticAnalyzer.html>`_.; It is an abbreviation of `entomology <https://en.wikipedia.org/wiki/Entomology>`_. *""Entomology is the scientific study of insects.""*. In the past, this namespace had not only the name `GR` (aka. Graph Reachability); but also `entoSA`. F; -. **FCA**; First Class Aggregate. **FDE**; Frame Description Entry. A kind of CFI used to describe the stack frame of; one function. G; -. **GC**; Garbage Collection. The practice of using reachability analysis instead of; explicit memory management to reclaim unused memory. **GEP**; ``GetElementPtr``. An LLVM IR instruction that is used to get the address; of a subelement of an aggregate data structure. It is documented in detail; `here <https://ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:2797,hazard,hazard,2797,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,2,"['hazard', 'safe']","['hazard', 'safe']"
Safety,"he dataset repository is checked for newly; incoming staging requests. Defaults to **10**. dsmgrd.parallelxfrs *n*; : Number of concurrent transfers. Defaults to **8**. dsmgrd.stagecmd *shell\_command*; : Command to run in order to stage each file. It might be whatever you; want (executable, shell script...). If you add `$URLTOSTAGE` and/or; `$TREENAME` in the *shell\_command*, they'll be substituted; respectively with the destination URL and the default ROOT tree name; in the file (as specified in the dataset staging request from ROOT). An example:. dsmgrd.stagecmd /path/to/afdsmgrd-xrd-stage-verify.sh ""$URLTOSTAGE"" ""$TREENAME"". Return value of the command is ignored: standard output is; considered, as explained here. Defaults to `/bin/false`. dsmgrd.cmdtimeoutsecs *secs*; : Timeout on staging command, expressed in seconds: after this; timeout, the command is considered failed and it is killed (in first; place with `SIGSTOP`, then if it is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:4462,timeout,timeout,4462,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['timeout'],['timeout']
Safety,"he new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited functionality. ## PyROOT. - Introduce the `ROOT.Numba.Declare` decorator which provides a simple way to call Python callables from C++. The Python callables are; just-in-time compiled with [numba](http://numba.pydata.org/), which ensures a runtime performance similar to a C++ implementation.; The feature is targeted to improve the performance of Python based analyses, e.g., allows seamless integration into `RDataFrame` workflows.; See the tutorial [`pyroot004_NumbaDeclare.py`](https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html) for further information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:10805,safe,safe,10805,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['safe'],['safe']
Safety,"he non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12012,unsafe,unsafe,12012,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['unsafe'],['unsafe']
Safety,"he ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6664,safe,safety,6664,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,"['redund', 'safe']","['redundant', 'safety']"
Safety,"he parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parame",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6522,avoid,avoid,6522,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoid']
Safety,"he right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds check expression; =======================. Bounds checks are part of semantics defined in the ``-fbounds-safety`` language; model. Hence, exposing the bounds checks and other semantic actions in the AST; is desirable. A new expression for bounds checks has been added to the AST. The; bounds check expression has a ``BoundsCheckKind`` to indicate the kind of checks; and has the additional sub-expressions that are necessary to perform the check; according to the kind. Paired assignment check; =======================. ``-fbounds-safety`` enforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or ana",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:5091,safe,safety,5091,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"her options you can use are:. .. code-block:: bash. Use Ninja instead of Make: ""-G Ninja""; Build with assertions on: ""-DLLVM_ENABLE_ASSERTIONS=True""; Local (non-sudo) install path: ""-DCMAKE_INSTALL_PREFIX=$HOME/llvm/install""; CPU flags: ""DCMAKE_C_FLAGS=-mcpu=cortex-a15"" (same for CXX_FLAGS). After that, just typing ``make -jN`` or ``ninja`` will build everything.; ``make -jN check-all`` or ``ninja check-all`` will run all compiler tests. For; running the test suite, please refer to :doc:`TestingGuide`. #. If you are building LLVM/Clang on an ARM board with 1G of memory or less,; please use ``gold`` rather then GNU ``ld``. In any case it is probably a good; idea to set up a swap partition, too. .. code-block:: bash. $ sudo ln -sf /usr/bin/ld /usr/bin/ld.gold. #. ARM development boards can be unstable and you may experience that cores; are disappearing, caches being flushed on every big.LITTLE switch, and; other similar issues. To help ease the effect of this, set the Linux; scheduler to ""performance"" on **all** cores using this little script:. .. code-block:: bash. # The code below requires the package 'cpufrequtils' to be installed.; for ((cpu=0; cpu<`grep -c proc /proc/cpuinfo`; cpu++)); do; sudo cpufreq-set -c $cpu -g performance; done. Remember to turn that off after the build, or you may risk burning your; CPU. Most modern kernels don't need that, so only use it if you have; problems. #. Running the build on SD cards is ok, but they are more prone to failures; than good quality USB sticks, and those are more prone to failures than; external hard-drives (those are also a lot faster). So, at least, you; should consider to buy a fast USB stick. On systems with a fast eMMC,; that's a good option too. #. Make sure you have a decent power supply (dozens of dollars worth) that can; provide *at least* 4 amperes, this is especially important if you use USB; devices with your board. Externally powered USB/SATA harddrives are even; better than having a good power supply.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst:2862,risk,risk,2862,interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst,1,['risk'],['risk']
Safety,"her.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and havi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134061,safe,safety,134061,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"herefore casting should be relatively uncommon. For example all; of the arithmetic operations work on almost all data types. > Making the second arg. to 'shl' a ubyte seems good enough to me.; > 255 positions seems adequate for several generations of machines. Okay, that comment is removed. > and is more compact than uint. No, it isn't. Remember that the bytecode encoding saves value slots into; the bytecode instructions themselves, not constant values. This is; another case where we may introduce more cast instructions (but we will; also reduce the number of opcode variants that must be supported by a; virtual machine). Because most shifts are by constant values, I don't; think that we'll have to cast many shifts. :). > I still have some major concerns about including malloc and free in the; > language (either as builtin functions or instructions). Agreed. How about this proposal:. malloc/free are either built in functions or actual opcodes. They provide; all of the type safety that the document would indicate, blah blah; blah. :). Now, because of all of the excellent points that you raised, an; implementation may want to override the default malloc/free behavior of; the program. To do this, they simply implement a ""malloc"" and; ""free"" function. The virtual machine will then be defined to use the user; defined malloc/free function (which return/take void*'s, not type'd; pointers like the builtin function would) if one is available, otherwise; fall back on a system malloc/free. Does this sound like a good compromise? It would give us all of the; typesafety/elegance in the language while still allowing the user to do; all the cool stuff they want to... > 'alloca' on the other hand sounds like a good idea, and the; > implementation seems fairly language-independent so it doesn't have the; > problems with malloc listed above. Okay, once we get the above stuff figured out, I'll put it all in the; spec. > About indirect call:; > Your option #2 sounded good to me. I'm not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:4181,safe,safety,4181,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['safe'],['safety']
Safety,"herwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65009,avoid,avoid,65009,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"hich asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16289,safe,safety-negative,16289,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety-negative']
Safety,"hich pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9893,detect,detect,9893,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,2,['detect'],"['detect', 'detection']"
Safety,"hich provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119569,safe,safe,119569,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"his code path error prone.; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] foo::bar/*store parsing state*/; gSystem->Load(""Foo"");; // More scaffolding.; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; /*restore parsing state*/ baz1 /*store parsing state*/; #include <Foo.h>/*restore parsing state*/;; ```. To recap, unfortunately, ROOT PCH is not extendable; ROOTMAP requires a lot of; maintenance and goes on a very untested codepath, while RDICT has a very limited; scope. The three features require a lot of mechanisms to work together and the; corner cases are very many. The interaction between some of the features often; break design and introduce layering violations. ## From C++ Modules to Dictionaries. C++ Modules have native capabilities to avoid reparsing. It combines all; home-grown solutions to avoid the costly operation at industry quality. Currently, when ROOT is built with `-Druntime_cxxmodules=On` it gives priority to; C++ Module files (real *pcm* files). If such a file is present it reads all; necessary information from it. If no such file is present ROOT falls back to the; standard information flow. ### Observable differences from 'standard' ROOT. As always, ROOT is (mostly) API and ABI compatible. C++ Modules-aware ROOT is no; different. There are several differences which can be noticed:; * \*modulemap files in $ROOTSYS/include -- those files are used by rootcling to; put a set of header files in a single pcm file. For example, all related; headers of *libGeom* are persisted in *Geom.pcm*. There are a few notable; examples, which are specific to the way we build ROOT. In certain cases we; want some header files to be compiled within C context or with RTTI on/off.; That's mostly for bootstrapping ROOT (aka rootcling stage1).; * modulemap.overlay.yaml -- automatically crea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:11313,avoid,avoid,11313,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"his new format is now online; and can be seen from the [ROOT home page](https://root.cern.ch/doc/master/index.html). ## Core Libraries. ### Dictionary generation. Fixed the dictionary generation in the case of class inside a namespace; marked inlined. Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates. Fix [ROOT-7760] : fully allow the usage of the dylib extension on OSx. Fix [ROOT-7723] : allow IOCtors to have as argument a ref to a type called __void__. We added a dictionary for map<string,string> as part of the default STL dictionary. We added support for template parameter packs in class name involved in the I/O. ### Thread safety and thread awareness. We added the function `TMethodCall::GetCallFunc` to allow direct access to the function wrapper. We reduced thread serialization in `TClass::GetCheckSum`, `TClass::GetBaseClassOffset` and `TClass::Property`. `TObjArray::Delete` was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock). We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at destruction time and does not change the current directory. The constructor for `TDirectory::TContext` that takes a single TDirectory pointer as; an argument was changed to set `gDirectory` to zero when being passed a null",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:2354,avoid,avoid,2354,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['avoid'],['avoid']
Safety,"his would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribute__((arm_streaming_compatible)) some_use(svfloat32_t *);. // Use a float argument type, to check the value isn't clobbered by smstart.; // Use a float return type to check the value isn't clobbered by smstop.; float __attribute__((noinline, arm_locally_streaming)) foo(float arg) {; // Create local for SVE vector to check local is created with correct; // size when not yet in streaming mode (ADDSVL).; float array[N];; svfloat32_t vector;. some_use(&vector);; svst1_f32(svptrue_b32(), &array[0], vector);; return array[N - 1] + arg;; }. should use ADDSVL for allocating the stack space and should avoid clobbering; the return/argument values. .. code-block:: none. _Z3foof: // @_Z3foof; // %bb.0: // %entry; stp d15, d14, [sp, #-96]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; stp x29, x30, [sp, #64] // 16-byte Folded Spill; add x29, sp, #64; str x28, [sp, #80] // 8-byte Folded Spill; addsvl sp, sp, #-1; sub sp, sp, #256; str s0, [x29, #28] // 4-byte Folded Spill; smstart sm; sub x0, x29, #64; addsvl x0, x0, #-1; bl _Z10some_usePu13__SVFloat32_t; sub x8, x29, #64; ptrue p0.s; ld1w { z0.s }, p0/z, [x8, #-1, mul vl]; ldr s1, [x29, #28] // 4-byte Folded Reload; st1w { z0.s }, p0, [sp]; ldr s0, [sp, #252]; fadd s0, s0, s1; str s0, [x29, #28] // 4-byte Folded Spill; smstop sm; ldr s0, [x29, #28] // 4-byte Folded Reload; addsvl sp, sp, #1; add sp, sp, #256; ldp x29, x30, [sp, #64] // 16-byte Folded Reload; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:13110,avoid,avoid,13110,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['avoid'],['avoid']
Safety,"hod is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this function returns `kFALSE`. It; combines the methods **`TSelector::ProcessCut()` and; `TSelector`**`::ProcessFill()` in one, avoiding the necessity to; maintain the state in the class to communicate between these two; functions. It reduces the information that needs to be shared; between them and promotes a more granular data access by reading; branches as they are needed. - `TSelector::Terminate() -` it is called at the end of a loop on a; **`TTree`**. This is a convenient place to draw and fit your; histograms. - `TSelector::Version()` `-` this function provides backward; compatibility for old versions and support for the future upgrades. - The **`TSelector`**, unlike the resulting class from `MakeClass`,; separates the processing into a `ProcessCut()` and `ProcessFill()`,; so we can limit reading of branches to the ones we need. - When a selector is used with a **`TChain`** in methods `Process()`,; `ProcessFill()`, `ProcessCut()`, you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:132379,avoid,avoiding,132379,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['avoid'],['avoiding']
Safety,"hoices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on a diverged path from ``B`` to ``J``. .. figure:: convergence-closed-path.png; :name: convergence-closed-path. Consider the closed path `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21272,detect,detects,21272,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detects']
Safety,"hought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update local values in the; current frame. If we don't, we'll be accessing a potential invalid reference; once we eventually return from the call. In this example, we need to relocate the SSA value ``%obj``. Since we can't; actually change the value in the SSA value ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 7, i32 7); ret i8 addrspace(1)* %obj.re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:8213,safe,safepoint,8213,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectre variant #2"" vulnerabilities. When inlining, the attribute is sticky. Inlining a function that carries; this attribute will cause the caller to gain the attribute. This is intended; to provide a maximally conservative model where the code in a function; annotated with this attribute will always (even after inlining) end u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:101048,safe,safety,101048,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:10486,safe,safe,10486,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],"['safe', 'safety']"
Safety,"i32); declare i64 @llvm.loop.decrement.reg.i64(i64, i64). Overview:; """""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics are used to lower the loop; iteration counter and return an updated value that will be used in the next; loop test check. Arguments:; """""""""""""""""""". Both arguments must have identical integer types. The first operand is the; loop iteration counter. The second operand is the maximum number of elements; processed in an iteration. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics do an integer ``SUB`` of its; two operands, which is not allowed to wrap. They return the remaining number of; iterations still to be executed, and can be used together with a ``PHI``,; ``ICMP`` and ``BR`` to control the number of loop iterations executed. Any; optimisations are allowed to treat it is a ``SUB``, and it is supported by; SCEV, so it's the backends responsibility to handle cases where it may be; optimised. These intrinsics are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.loop.decrement.i32(i32); declare i1 @llvm.loop.decrement.i64(i64). Overview:; """""""""""""""""". The HardwareLoops pass allows the loop decrement value to be specified with an; option. It defaults to a loop decrement value of 1, but it can be an unsigned; integer value provided by this option. The '``llvm.loop.decrement.*``'; intrinsics decrement the loop iteration counter with this value, and return a; false predicate if the loop should exit, and true otherwise.; This is emitted if the loop counter is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iterati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:648825,avoid,avoid,648825,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89546,recover,recoveryExpr,89546,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recoveryExpr']
Safety,"ial for RDataFrame helper functions](https://root.cern/doc/master/df020__helpers_8C.html).; - Throw if name of a custom column is not a valid C++ name.; - Allow every RDataFrame variable be cast to a common type `ROOT::RDF::RNode`.; - Speed up just-in-time compilation (and therefore runtime) of Snapshots with a large number of branches.; - Create names for histograms and graphs based on the input columns if no model is provided.; - RCutFlowReport can print cumulative efficiency of cuts.; - Reading and writing of columns holding `vector<bool>` instances and `bool` C arrays.; - Support `rdfentry_` and `rdfslot_` implicit columns (`tdfentry_` and `tdfslot_` kept for backwards compatibility).; - Remove `RDataFrame` from the 32-bit builds.; - Speed up interpreted usage of RDataFrame (i.e. in macros or from ROOT prompt) by removing certain cling runtime safety checks.; - Streamline and better document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/master/classROOT_1_1RDataFrame.html#parallel-execution) for more information. ### TTreeProcessorMT; - Parallelise search of cluster boundaries for input datasets with no friends or TEntryLists. The net effect is a faster initialization time in this common case.; - Handle gracefully the presence of chains the files associated to which are corrupted.; - Reduce number of expensive `TChain::LoadTree` calls by spawning nested TBB tasks to ensure clusters of a given file will be most likely processed by the same thread. ### TTree; - TTrees can be forced to only create new baskets at event cluster boundaries.; This simplifies file layout and I/O at the cost of memory. Recommended for; simple file formats such as ntuples but not more complex data types. To; enable, invoke `tree->SetBit(TTree::kOnlyFlushAtCluste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:9950,safe,safe,9950,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['safe'],['safe']
Safety,"ial stack frame,; not accounting for any dynamic allocation. * ``roots_size()``: The count of roots in the function. To access the stack map, use ``GCFunctionMetadata::roots_begin()`` and; -``end()`` from the :ref:`GCMetadataPrinter <assembly>`:. .. code-block:: c++. for (iterator I = begin(), E = end(); I != E; ++I) {; GCFunctionInfo *FI = *I;; unsigned FrameSize = FI->getFrameSize();; size_t RootCount = FI->roots_size();. for (GCFunctionInfo::roots_iterator RI = FI->roots_begin(),; RE = FI->roots_end();; RI != RE; ++RI) {; int RootNum = RI->Num;; int RootStackOffset = RI->StackOffset;; Constant *RootMetadata = RI->Metadata;; }; }. If the ``llvm.gcroot`` intrinsic is eliminated before code generation by a; custom lowering pass, LLVM will compute an empty stack map. This may be useful; for collector plugins which implement reference counting or a shadow stack. .. _init-roots:. Initializing roots to null; ---------------------------. It is recommended that frontends initialize roots explicitly to avoid; potentially confusing the optimizer. This prevents the GC from visiting; uninitialized pointers, which will almost certainly cause it to crash. As a fallback, LLVM will automatically initialize each root to ``null``; upon entry to the function. Support for this mode in code generation is; largely a legacy detail to keep old collector implementations working. Custom lowering of intrinsics; ------------------------------. For GCs which use barriers or unusual treatment of stack roots, the; implementor is responsibly for providing a custom pass to lower the; intrinsics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:33673,avoid,avoid,33673,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['avoid'],['avoid']
Safety,"ialSquare; | Circle. A Bug to be Aware Of; --------------------. The example just given opens the door to bugs where the ``classof``\s are; not updated to match the ``Kind`` enum when adding (or removing) classes to; (from) the hierarchy. Continuing the example above, suppose we add a ``SomewhatSpecialSquare`` as; a subclass of ``Square``, and update the ``ShapeKind`` enum like so:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_Circle; }. Now, suppose that we forget to update ``Square::classof()``, so it still; looks like:. .. code-block:: c++. static bool classof(const Shape *S) {; // BUG: Returns false when S->getKind() == SK_SomewhatSpecialSquare,; // even though SomewhatSpecialSquare ""is a"" Square.; return S->getKind() >= SK_Square &&; S->getKind() <= SK_OtherSpecialSquare;; }. As the comment indicates, this code contains a bug. A straightforward and; non-clever way to avoid this is to introduce an explicit ``SK_LastSquare``; entry in the enum when adding the first subclass(es). For example, we could; rewrite the example at the beginning of `Concrete Bases and Deeper; Hierarchies`_ as:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; + SK_LastSquare,; SK_Circle; }; ...; // Square::classof(); - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_LastSquare;; + }. Then, adding new subclasses is easy:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_LastSquare,; SK_Circle; }. Notice that ``Square::classof`` does not need to be changed. .. _classof-contract:. The Contract of ``classof``; ---------------------------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:9860,avoid,avoid,9860,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['avoid'],['avoid']
Safety,"iant.load and TBAA's constant flags. Pass Ordering; ^^^^^^^^^^^^^. One of the most common mistakes made by new language frontend projects is to; use the existing -O2 or -O3 pass pipelines as is. These pass pipelines make a; good starting point for an optimizing compiler for any language, but they have; been carefully tuned for C and C++, not your target language. You will almost; certainly need to use a custom pass order to achieve optimal performance. A; couple specific suggestions:. #. For languages with numerous rarely executed guard conditions (e.g. null; checks, type checks, range checks) consider adding an extra execution or; two of LoopUnswitch and LICM to your pass order. The standard pass order,; which is tuned for C and C++ applications, may not be sufficient to remove; all dischargeable checks from loops. #. If your language uses range checks, consider using the IRCE pass. It is not; currently part of the standard pass order. #. A useful sanity check to run is to run your optimized IR back through the; -O2 pipeline again. If you see noticeable improvement in the resulting IR,; you likely need to adjust your pass order. I Still Can't Find What I'm Looking For; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If you didn't find what you were looking for above, consider proposing a piece; of metadata which provides the optimization hint you need. Such extensions are; relatively common and are generally well received by the community. You will; need to ensure that your proposal is sufficiently general so that it benefits; others if you wish to contribute it upstream. You should also consider describing the problem you're facing on `Discourse; <https://discourse.llvm.org>`_ and asking for advice.; It's entirely possible someone has encountered your problem before and can; give good advice. If there are multiple interested parties, that also; increases the chances that a metadata extension would be well received by the; community as a whole. Adding to this document; ===",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:13261,sanity check,sanity check,13261,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['sanity check'],['sanity check']
Safety,"iate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16062,avoid,avoid,16062,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['avoid'],['avoid']
Safety,"ibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this way must be defined with public LTO visibility. Classes that fall into either of these categories can be marked up with the; ``[[clang::lto_visibility_public]]`` attribute. To specifically handle the; COM case, classes with the ``__declspec(uuid())`` attribute receive public; LTO visibility. On Windows platforms, clang-cl's ``/MT`` and ``/MTd``; flags statically link the program against a prebuilt standard library;; these flags imply public LTO visibility for every class declared in the; ``std`` and ``stdext`` namespace",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:3533,avoid,avoid,3533,interpreter/llvm-project/clang/docs/LTOVisibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst,1,['avoid'],['avoid']
Safety,"ible lowerings for the memcpy and memmove operations:; GC leaf lowering and GC parseable lowering. If a call is explicitly marked with; ""gc-leaf-function"" attribute the call is lowered to a GC leaf call to; '``__llvm_memcpy_element_unordered_atomic_*``' or; '``__llvm_memmove_element_unordered_atomic_*``' symbol. Such a call can not; take a safepoint. Otherwise, the call is made GC parseable by wrapping the; call into a statepoint. This makes it possible to take a safepoint during; copy operation. Note that a GC parseable copy operation is not required to; take a safepoint. For example, a short copy operation may be performed without; taking a safepoint. GC parseable calls to '``llvm.memcpy.element.unordered.atomic.*``',; '``llvm.memmove.element.unordered.atomic.*``' intrinsics are lowered to calls; to '``__llvm_memcpy_element_unordered_atomic_safepoint_*``',; '``__llvm_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:30705,safe,safepoints,30705,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"ibute; would prevent this:. .. code-block:: c. my_sub_group_shuffle() __attribute__((convergent));. Using ``convergent`` guarantees correct execution by keeping CFG equivalence; wrt operations marked as ``convergent``. CFG ``G´`` is equivalent to ``G`` wrt; node ``Ni`` : ``iff ∀ Nj (i≠j)`` domination and post-domination relations with; respect to ``Ni`` remain the same in both ``G`` and ``G´``. noduplicate; ^^^^^^^^^^^. ``noduplicate`` is more restrictive with respect to optimizations than; ``convergent`` because a convergent function only preserves CFG equivalence.; This allows some optimizations to happen as long as the control flow remains; unmodified. .. code-block:: c. for (int i=0; i<4; i++); my_sub_group_shuffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:151957,safe,safe,151957,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['safe'],['safe']
Safety,"ic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit, overriding bounds annotation that can; be used to verify the safety of the operation. The compiler issues an error when; a ``__single`` pointer is utilized for pointer arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts programmers to provide sufficient bounds information; to pointers. In the following example, the pointer on parameter p is; single-by-default, and is employed for array access. As a result, the compiler; generates an error suggesting to add ``__counted_by`` to the pointer. .. code-block:: c. void fill_array_with_indices(int *p, unsigned count) {; for (unsigned i = 0; i < count; ++i) {; p[i] = i; // error; }; }. External bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""External"" bounds annotations provide a way to express a relationship between a; pointer variable and another variable (or expression) containing the bounds; information of the pointer. In the followin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:8273,safe,safety,8273,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"icGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42235,avoid,avoid,42235,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"icTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1176,detect,detecting,1176,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['detect'],['detecting']
Safety,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180661,detect,detection,180661,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,3,"['detect', 'recover']","['detection', 'recover', 'recovery']"
Safety,"icates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57287,avoid,avoids,57287,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"ication does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>` call. The runtime must provide a number of new entrypoints which the compiler may; emit, which are described in the remainder of this section. .. admonition:: Rationale. Several of these functions are semantically equivalent to a message send; we; emit calls to C functions instead because:. * the machine code to do so is significantly smaller,; * it is much easier to recognize the C functions in the ARC optimizer, and; * a sufficient sophisticated runtime may be able to avoid the message send in; common cases. Several other of these functions are ""fused"" operations which can be; described entirely in terms of other operations. We use the fused operations; primarily as a code-size optimization, although in some cases there is also a; real potential for avoiding redundant operations in the runtime. .. _arc.runtime.objc_autorelease:. ``id objc_autorelease(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it adds the object; to the innermost autorelease pool exactly as if the object had been sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:106609,avoid,avoid,106609,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoid']
Safety,"ics and the; intrinsic is completely dropped during instruction selection. '``llvm.codeview.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This annotation emits a label at its program point and an associated; ``S_ANNOTATION`` codeview record with some additional string metadata. This is; used to implement MSVC's ``__annotation`` intrinsic. It is marked; ``noduplicate``, so calls to this intrinsic prevent inlining and should be; considered expensive. ::. declare void @llvm.codeview.annotation(metadata). Arguments:; """""""""""""""""""". The argument should be an MDTuple containing any number of MDStrings. '``llvm.trap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.trap() cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.trap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to the target dependent trap instruction. If; the target does not have a trap instruction, this intrinsic will be; lowered to a call of the ``abort()`` function. '``llvm.debugtrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.debugtrap() nounwind. Overview:; """""""""""""""""". The '``llvm.debugtrap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behavi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:928598,abort,abort,928598,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['abort'],['abort']
Safety,"idden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:7257,safe,safety,7257,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89797,recover,recoveryExpr,89797,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recoveryExpr']
Safety,"ides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16104,recover,recovery,16104,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recovery']
Safety,"idi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actually allocated.; // ...; }. By promoting array references to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that ``buf`` has ``count`` number of elements available. This; relationship must hold even after any of these related variables are updated. To; this end, the model requires that assignments to ``buf`` and ``count`` must be; side by side, with no side effects between them. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35210,safe,safety,35210,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"idi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:25133,avoid,avoid,25133,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"iding some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17810,detect,detected,17810,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['detect'],['detected']
Safety,"ier; regardless of where their work is applied to. What is covered; ---------------. The core tier is composed of:; * Core code (``llvm-project``) present in official releases and buildbots:; compiler, debugger, linker, libraries, etc, including infrastructure code; (table-gen, lit, file-check, unit-tests, etc).; * Build infrastructure that creates releases and buildbots (CMake, scripts).; * `Phabricator <https://github.com/llvm/phabricator>`_ and; `buildbot <https://github.com/llvm/llvm-zorg>`_ infrastructure.; * The `test-suite <https://github.com/llvm/llvm-test-suite>`_. Requirements; ------------. Code in this tier must:; * Keep official buildbots green, with warnings on breakages being emailed to; all affected developers. Those must be fixed as soon as possible or patches; must be reverted, as per review policy.; * Bit-rot of a component in the core tier will result in that component being; downgraded to the peripheral tier or being removed. Sub-communities can; avoid this by fixing all raised issues in a timely manner. Peripheral Tier; ===============. The peripheral tier encompass the parts of LLVM that cater to a specific; sub-community and which don't usually affect the core components directly. This includes experimental back-ends, disabled-by-default options and; alternative paths (work-in-progress replacements) in the same repository, as; well as separate efforts to integrate LLVM development with local practices. It is the responsibility of each sub-community to care about their own parts; and the intersection of that with the core tier and other peripheral parts. There are three main groups of code that fit in this category:; * Code that is making its way into LLVM, via the `experimental <https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:3077,avoid,avoid,3077,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['avoid'],['avoid']
Safety,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6022,recover,recovery,6022,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['recover'],"['recover', 'recovery']"
Safety,"if (...) {; c->name = ...; // Overwritten: {c->account_id, c->name}; } else {; c->name = ...; // Overwritten: {c->account_id, c->name}; }; // Overwritten: {c->account_id, c->name}; }; ```. When the data flow algorithm computes a normal state, but not all fields are; proven to be overwritten we can't perform the refactoring. ```c++; void target(bool b, Customer* c) {; // Overwritten: {}; if (b) {; c->account_id = 42; // Overwritten: {c->account_id}; } else {; c->name = ""Konrad""; // Overwritten: {c->name}; }; // Overwritten: {}; }; ```. Similarly, when the data flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; print(c->name); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores and loads, and find stores that were never; read. [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; * finding out if it would be safe to move an object. ## Example: definitive initialization. Definitive initialization proves that variables are known to be initialized when; read. If we find a variable which is read when not initialized then we generate; a warning. ```c++; void Init() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; } else {; x = 20; // x is initialized; }; prin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:19684,redund,redundant,19684,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['redund'],['redundant']
Safety,"ig ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12885,safe,safely,12885,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['safe'],['safely']
Safety,"ike ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed descriptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85130,safe,safe,85130,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ile located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:2505,detect,detects,2505,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['detect'],['detects']
Safety,"ile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:147900,safe,safely,147900,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"iling on 632 and main; * [[#15370](https://github.com/root-project/root/issues/15370)] - Broken link in HS3 printout; * [[#15340](https://github.com/root-project/root/issues/15340)] - Webgraphics: canvas displayed, but many error printed; * [[#15253](https://github.com/root-project/root/issues/15253)] - C++ standard not propagated via CMake anymore; * [[#15197](https://github.com/root-project/root/issues/15197)] - RBDT does not support xgboost inference; * [[#15156](https://github.com/root-project/root/issues/15156)] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; * [[#15139](https://github.com/root-project/root/issues/15139)] - cmake option -Dall=YES breaks the cmake; * [[#15118](https://github.com/root-project/root/issues/15118)] - jsoninterface does not build if provided with RapidYAML; * [[#15108](https://github.com/root-project/root/issues/15108)] - Turn off clang-format for Linkdef files; * [[#15090](https://github.com/root-project/root/issues/15090)] - TClass::GetClassInfo() is not thread safe; * [[#15077](https://github.com/root-project/root/issues/15077)] - Passing different floating point types to `RVec` utility functions; * [[#15048](https://github.com/root-project/root/issues/15048)] - [ntuple] Handling of virtual inheritance broken; * [[#15040](https://github.com/root-project/root/issues/15040)] - [RDataFrame] Inaccurate example of progress bar from documentation; * [[#15028](https://github.com/root-project/root/issues/15028)] - [RDataFrame] Unable to cacheread remote file; * [[#15027](https://github.com/root-project/root/issues/15027)] - spurrious cmake message about AfterImage with -Dminimal=ON; * [[#14981](https://github.com/root-project/root/issues/14981)] - RVecs leak memory with np.asarray in pyROOT; * [[#14964](https://github.com/root-project/root/issues/14964)] - ROOT-HEAD fails with ""cling interactive line includer >>>: fatal error: module file '[snip]/Vc.pcm' not found: module file not found""; * [[#14958](https://github.com/root-proj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:26794,safe,safe,26794,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['safe'],['safe']
Safety,"ime unrolling, the original loop of. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; Stmt(i);. is transformed into (using an unroll factor of 4):. .. code-block:: c. int i = 0;; for (; i + 3 < n; i+=4) { // unrolled loop; Stmt(i);; Stmt(i+1);; Stmt(i+2);; Stmt(i+3);; }; for (; i < n; i+=1) // remainder loop; Stmt(i);. ``llvm.loop.unroll.followup_unrolled`` will set the loop attributes of; the unrolled loop. If not specified, the attributes of the original loop; without the ``llvm.loop.unroll.*`` attributes are copied and; ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll.followup_remainder`` defines the attributes of the; remainder loop. If not specified the remainder loop will have no; attributes. The remainder loop might not be present due to being fully; unrolled in which case this attribute has no effect. Attributes defined in ``llvm.loop.unroll.followup_all`` are added to the; unrolled and remainder loops. To avoid that the partially unrolled loop is unrolled again, it is; recommended to add ``llvm.loop.unroll.disable`` to; ``llvm.loop.unroll.followup_all``. If no follow-up attribute specified; for a generated loop, it is added automatically. Unroll-And-Jam; --------------. Unroll-and-jam uses the following transformation model (here with an; unroll factor if 2). Currently, it does not support a fallback version; when the transformation is unsafe. .. code-block:: c. for (int i = 0; i < n; i+=1) { // original outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // original inner loop; SubLoop(i, j);; Aft(i);; }. .. code-block:: c. int i = 0;; for (; i + 1 < n; i+=2) { // unrolled outer loop; Fore(i);; Fore(i+1);; for (int j = 0; j < m; j+=1) { // unrolled inner loop; SubLoop(i, j);; SubLoop(i+1, j);; }; Aft(i);; Aft(i+1);; }; for (; i < n; i+=1) { // remainder outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // remainder inner loop; SubLoop(i, j);; Aft(i);; }. ``llvm.loop.unroll_and_jam.followup_outer`` will set the loop attributes; o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:8499,avoid,avoid,8499,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"ime), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implementation based on an AVL; tree. Adding or removing elements is done through a Factory object and results; in the creation of a new ImmutableSet object. If an ImmutableSet already exists; with the given contents, then the existing one is returned; equality is compared; with a FoldingSetNodeID. The time and space complexity of add or remove; operations is logarithmic in the size of the original set. There is no method for returning an element of the set, you can only check for; membership. .. _dss_otherset:. Other Set-Like Container Options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The STL provides several other options, such as std::multiset and; std::unordered_set. We never use containers like unordered_set because; they are generally very expensive (each insertion requires a malloc). std::multiset is useful if you're not interested in elimination of duplica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:86523,avoid,avoided,86523,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoided']
Safety,"imization. Instead, it is recommended that; compilers with relocating collectors target the abstract machine model just; described. The heart of the explicit approach is to construct (or rewrite) the IR in a; manner where the possible updates performed by the garbage collector are; explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:7191,safe,safepoint,7191,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71948,safe,safely,71948,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safely']
Safety,"in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but this means the tuple `(num, branch-name)` uniquely; identifies a commit. We can thus use this revision number to ensure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; We could supply a pre-push hook on the client side that would run and check the; history, before allowing the commit being pushed [statuschecks]_.; However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and prevents SVN access to the; repository. What About Commit Emails?; -------------------------. We will need a new bot to send emails for each commit. This proposal leaves the; email format unchanged besides the commit URL. Straw Man Migration Plan; ========================. Step #1 : Before The Move; -------------------------. 1. Update docs to mention the move, so people are aware of what is going on.; 2. Set up a read-only version of the GitHub project, mirroring our current SVN; repository.; 3. Add the required bots to implement the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:5917,avoid,avoid,5917,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['avoid'],['avoid']
Safety,"in_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115901,avoid,avoid,115901,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"indNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119836,safe,safety,119836,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; mor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4078,safe,safe,4078,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['safe'],['safe']
Safety,"inear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float's. To use them, one; must include the header file `Math/Vector3D.h`. The following typedef's,; defined in the header file `Math/Vector3Dfwd.h`, are available for the; different instantiations of the template class; `ROOT::Math::`**`DisplacementVector3D`**:. - `ROOT::Math::`**`XYZVector`** vector based on `x,y,z` coordinates; (Cartesian) in double precision. - `ROOT::Math::`**`XYZVectorF`** vector based on `x,y,z` coordinates; (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DVector`** vector based on `r,theta,phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DVectorF`** vector based on `r,theta,phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiVector`** vector based on `rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:77495,avoid,avoid,77495,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"ined in the model is read; auto reader = RNTupleReader::Open(std::move(model), ntuple);; reader->LoadEntry(0);. // Option 3: through views; // Each view will only trigger reading of the related field, without reading other fields at the same entry number.; auto reader = RNTupleReader::Open(ntuple);; auto viewPt = reader->GetView<float>(""pt"");; // Load the pt from the first entry; auto pt = viewPt(0);; ```. In the above cases, RNTuple creates the objects being read into.; It is also possible to bind already existing objects.; This is shown below for entries and works similarly for views. ```c++; // A bare entry is an entry that has initially no bindings (all top-level fields need to be bound by the caller); auto entry = reader->GetModel().CreateBareEntry();; auto ptToken = entry->GetToken(""pt"");. // Option 1: type safe, shared ownership; std::shared_ptr<float> ptTypedSharedPtr;; entry->BindValue(ptToken, ptTypedSharedPtr);. // Option 2: type unsafe, shared ownership; std::shared_ptr<void> ptVoidSharedPtr;; entry->BindValue(ptToken, ptVoidSharedPtr);. // Option 3: type unsafe, application owns the object; void *ptVoidPtr;; entry->BindRawPtr(ptToken, ptVoidPtr);. // Option 4: switch back from application-provided object to RNTuple-created object; entry->EmplaceNewValue(ptToken);. // For all options: use an explicit entry; reader->LoadEntry(0, *entry);; ```. Walkthrough: Writing Data; -------------------------. ```c++; auto model = RNTupleModel::Create();; // Add a field to the model and return the shared pointer for that field in the model's default entry.; auto ptrPt = model->MakeField<float>(""pt"");. auto file = std::make_unique<TFile>(""data.root"", ""APPEND"");; // The writer creates a page sink and connects the model's fields to it; auto writer = RNTupleWriter::Append(std::move(model), ""ntpl"", *file);; *ptrPt = 1.0;; // Append the model's default entry; writer->Fill();; // Commit the dataset by destructing the writer; writer.reset();; ```. The points on object type-safe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:3967,unsafe,unsafe,3967,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['unsafe'],['unsafe']
Safety,"information to be included. For; example, the AMD OpenCL runtime records kernel argument information. .. _amdgpu-amdhsa-code-object-metadata-v2:. Code Object V2 Metadata; +++++++++++++++++++++++. .. warning::; Code object V2 generation is no longer supported by this version of LLVM. Code object V2 metadata is specified by the ``NT_AMD_HSA_METADATA`` note record; (see :ref:`amdgpu-note-records-v2`). The metadata is specified as a YAML formatted string (see [YAML]_ and; :doc:`YamlIO`). .. TODO::. Is the string null terminated? It probably should not if YAML allows it to; contain null characters, otherwise it should be. The metadata is represented as a single YAML document comprised of the mapping; defined in table :ref:`amdgpu-amdhsa-code-object-metadata-map-v2-table` and; referenced tables. For boolean values, the string values of ``false`` and ``true`` are used for; false and true respectively. Additional information can be added to the mappings. To avoid conflicts, any; non-AMD key names should be prefixed by ""*vendor-name*."". .. table:: AMDHSA Code Object V2 Metadata Map; :name: amdgpu-amdhsa-code-object-metadata-map-v2-table. ========== ============== ========= =======================================; String Key Value Type Required? Description; ========== ============== ========= =======================================; ""Version"" sequence of Required - The first integer is the major; 2 integers version. Currently 1.; - The second integer is the minor; version. Currently 0.; ""Printf"" sequence of Each string is encoded information; strings about a printf function call. The; encoded information is organized as; fields separated by colon (':'):. ``ID:N:S[0]:S[1]:...:S[N-1]:FormatString``. where:. ``ID``; A 32-bit integer as a unique id for; each printf function call. ``N``; A 32-bit integer equal to the number; of arguments of printf function call; minus 1. ``S[i]`` (where i = 0, 1, ... , N-1); 32-bit integers for the size in bytes; of the i-th FormatString argument ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:118964,avoid,avoid,118964,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"ing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:69971,detect,detect,69971,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['detect'],['detect']
Safety,"ing function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit, overriding bounds annotation that can; be used to verify the safety of the operation. The compiler issues an error when; a ``__single`` pointer is utilized for pointer arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:7452,unsafe,unsafety,7452,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,"['safe', 'unsafe']","['safety', 'unsafety']"
Safety,"ing launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each function in them to be compiled the; first time it is called. To do this, the CompileOnDemandLayer creates two small; utilities for each function that it scans: a *stub* and a *compile; callback*. The stub is a pair of a function pointer (which will be pointed at; the function's implementation once the function has been compiled) and an; indirect jump through the pointer. By fixing the address of the indirect jump; for the lifetime of the program we can give the function a permanent ""effective; address"", one that can be safely used for indirection and function pointer; comparison even if the function's implementation is never compiled, or if it is; compiled more than once (due to, for example, recompiling the function at a; higher optimization level) and changes address. The second utility, the compile; callback, represents a re-entry point from the program into the compiler that; will trigger compilation and then execution of a function. By initializing the; function's stub to point at the function's compile callback, we enable lazy; compilation: The first attempted call to the function will follow the function; pointer and trigger the compile callback instead. The compile callback will; compile the function, update the function pointer for the stub, then execute; the function. On all subsequent calls to the function, the function pointer; will point at the already-compiled function, so there is no further overhead; from the compiler. We will look at this process in more detail in the next; chapter of this tutorial, but for now we'll trust the Compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:2528,safe,safely,2528,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['safe'],['safely']
Safety,"ing of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*. ## How to use; C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). Enjoy. To disable C++ Modules in ROOT use `-Druntime_cxxmodules=Off`. ## Citing ROOT's C++ Modules; ```latex; % Peer-Reviewed Publication; %; % 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP); % 8-14 October, 2016, San Francisco, USA; %; @inproceedings{Vassilev_ROOTModules,; author = {Vassilev,V.},; title = {{Optimizing ROOT's Performance Using C++ Modules}},; journal = {Journal of Physics: Conference Series},; year = 2017,; month = {oct},; volume = {898},; number = {7},; pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18961,avoid,avoid,18961,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"ing the content of a workspace, as well as perform basic fitting operations with the models and datasets. ![Demonstration of RooBrowser using json workspace from the roofit tutorials directory](RooBrowser.png). ### Removal of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statistics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a model in the ""standard form"" where the dataset has one row for each; event, and the column corresponds to the value of the observable in the; histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:23249,avoid,avoid,23249,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoid']
Safety,"ing with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20403,safe,safety,20403,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"ing. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:18562,safe,safety-negative,18562,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety-negative']
Safety,"ing. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7393,avoid,avoid,7393,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['avoid'],['avoid']
Safety,"initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103364,safe,safety,103364,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"ink your program with ``-fsanitize=memtag`` flag. This; will only work when targeting AArch64 with MemTag extension. One; possible way to achieve that is to add ``-target; aarch64-linux -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:1875,detect,detected,1875,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['detect'],['detected']
Safety,"inning at a four-aligned SGPR index; are reserved for the tentative scratch V#. These will be used if it is; determined that spilling is needed. - If no use is made of the tentative scratch V#, then it is unreserved,; and the register count is determined ignoring it.; - If use is made of the tentative scratch V#, then its register numbers; are shifted to the first four-aligned SGPR index after the highest one; allocated by the register allocator, and all uses are updated. The; register count includes them in the shifted location.; - In either case, if the processor has the SGPR allocation bug, the; tentative allocation is not shifted or unreserved in order to ensure; the register count is higher to workaround the bug. .. note::. This approach of using a tentative scratch V# and shifting the register; numbers if used avoids having to perform register allocation a second; time if the tentative V# is eliminated. This is more efficient and; avoids the problem that the second register allocation may perform; spilling which will fail as there is no longer a scratch V#. When the kernel prolog code is being emitted it is known whether the scratch V#; described above is actually used. If it is, the prolog code must set it up by; copying the Private Segment Buffer to the scratch V# registers and then adding; the Private Segment Wavefront Offset to the queue base address in the V#. The; result is a V# with a base address pointing to the beginning of the wavefront; scratch backing memory. The Private Segment Buffer is always requested, but the Private Segment; Wavefront Offset is only requested if it is used (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). .. _amdgpu-amdhsa-memory-model:. Memory Model; ~~~~~~~~~~~~. This section describes the mapping of the LLVM memory model onto AMDGPU machine; code (see :ref:`memmodel`). The AMDGPU backend supports the memory synchronization scopes specified in; :ref:`amdgpu-memory-scopes`. The code sequences used to implement the m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:200024,avoid,avoids,200024,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoids']
Safety,"instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36384,unsafe,unsafe,36384,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['unsafe'],['unsafe']
Safety,"ints in a 2D space. Its constructor is:. ``` {.cpp}; TPolyLine(Int_t n,Double_t* x,Double_t* y,Option_t* option); ```. Where `n` is the number of points, and `x` and `y` are arrays of `n`; elements with the coordinates of the points. **`TPolyLine`** can be used; by it self, but is also a base class for other objects, such as curly; arcs. ### Circles and Ellipses. An ellipse can be truncated and rotated. It is defined by its center; `(x1,y1)` and two radii `r1` and `r2`. A minimum and maximum angle may; be specified `(phimin,phimax)`. The ellipse may be rotated with an angle; `theta`. All these angles are in degrees. The attributes of the outline; line are set via **`TAttLine`**, of the fill area - via **`TAttFill`**; class. They are described in ""Graphical Objects Attributes"". ![Different types of ellipses](pictures/030000AE.png). When an ellipse sector is drawn only, the lines between the center and; the end points of the sector are drawn by default. By specifying the; drawn option ""`only`"", these lines can be avoided. Alternatively, the; method `SetNoEdges()` can be called. To remove completely the ellipse; outline, specify zero (0) as a line style. The **`TEllipse`** constructor is:. ``` {.cpp}; TEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2,; Double_t phimin, Double_t phimax, Double_t theta); ```. An ellipse may be created with:. ``` {.cpp}; root[] e = new TEllipse(0.2,0.2,0.8,0.3); root[] e->Draw(); ```. ### Rectangles. The class **`TBox`** defines a rectangle. It is a base class for many; different higher-level graphical primitives. Its bottom left coordinates; `x1`, `y1` and its top right coordinates `x2`, `y2`, defines a box. The; constructor is:. ``` {.cpp}; TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. It may be used as in:. ``` {.cpp}; root[] b = new TBox(0.2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(); ```. ![A rectangle with a border](pictures/020000AF.jpg). A **`TWbox`** is a rectangle (**`TBox`**) with a border",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:34945,avoid,avoided,34945,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['avoid'],['avoided']
Safety,"ion type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; release",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4355,avoid,avoid,4355,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['avoid'],['avoid']
Safety,"ion with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16985,safe,safe,16985,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['safe'],['safe']
Safety,"ion; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the dis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121786,safe,safety,121786,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ional optional tasks:. `|stepmax| < TGeoShape::Big()`. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121576,safe,safe,121576,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"ions will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereference (``*p``), array subscript (``p[i]``), member access (``p->``), and; pointer arithmetic, with some restrictions on bounds-unsafe uses. ``-fbounds-safety`` has a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; T *lower_bound; };``. As the; name indicates, pointers with this annotation are ""bidirectionally indexable"",; meaning that they can be indexed with either a negative or a positive offset; and the pointers can be incremented or decre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:13797,unsafe,unsafe,13797,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"ions:. 1. Every divergent branch inside the cycle satisfies the; :ref:`diverged entry criterion<convergence-diverged-entry>`, and,; 2. There are no :ref:`diverged paths reaching the; cycle<convergence-diverged-outside>` from a divergent branch; outside it. .. note::. A reducible cycle :ref:`trivially satisfies; <convergence-reducible-cycle>` the above conditions. In particular,; if the whole CFG is reducible, then all nodes in the CFG are; m-converged. The uniformity of each output of a static instance; is determined using the criteria; :ref:`described earlier <convergence-uniformity>`. The discovery of; divergent outputs may cause their uses (including branches) to also; become divergent. The analysis propagates this divergence until a; fixed point is reached. The convergence inferred using these criteria is a safe subset of the; maximal converged-with relation for any cycle hierarchy. In; particular, it is sufficient to determine if a static instance is; m-converged for a given cycle hierarchy ``T``, even if that fact is; not detected when examining some other cycle hierarchy ``T'``. This property allows compiler transforms to use the uniformity; analysis without being affected by DFS choices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:20146,detect,detected,20146,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detected']
Safety,"iorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15126,recover,recoverable,15126,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recoverable']
Safety,"irectory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copied. TStreamerInfo::New inserts the address of the creating TStreamerInfo into; the object. This address is inserted in each emulated that does not inherit; from an emulated class and is positioned after all the base classes (which; are compiled classes). A derived class will set this value inside each; of its emulated base class.; TStreamerInfo::Destruct and the new method TStreamerInfo::GetActualClass; use this information to detect the TStreamerInfo actually used to create; the object and hence run the proper emulated destructor. Add a new function GenerateDictionary to TInterpreter which allows for the quick and easy creation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommendation of creating a small 'loader.C' script to create the dictionaries. Implement a ShowMembers function for interpreted classes, by querying the interpreter for the data member; information.; In order to fix possible buffer overflow of parent string buffer in TMemberInspector,; the signature of ShowMember() was changed to no longer require (nor request) the; caller to provide a buffer (of length unknown to the callee.); Improve the uniqueness of globally visible symbols to allow for the mixing of; dictionaries ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:3053,detect,detect,3053,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,2,['detect'],['detect']
Safety,"is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3929,safe,safepoints,3929,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"is done by compile-time restrictions or; run-time checks (see `Maintaining correctness of bounds annotations`_; for more detail). For instance, initializing ``buf`` with ``null`` while; assigning non-zero value to ``count``, as shown in the following example, would; violate the ``__counted_by`` annotation because a null pointer does not point to; any valid memory location. To avoid this, the compiler produces either a; compile-time error or run-time trap. .. code-block:: c. void null_with_count_10(int *__counted_by(count) buf, unsigned count) {; buf = 0;; // This is not allowed as it creates a null pointer with non-zero length; count = 10;; }. However, there are use cases where a pointer is either a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereferen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:12703,avoid,avoid,12703,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"is necessary to insert; bounds checking for ``buf[i]``. .. code-block:: c. void *__sized_by(size) malloc(size_t size);. int *__counted_by(n) get_array_with_0_to_n_1(size_t n) {; int *buf = malloc(sizeof(int) * n);; for (size_t i = 0; i < n; ++i); buf[i] = i;; return buf;; }. Annotations for sentinel-delimited arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A C string is an array of characters. The null terminator — the first null; character ('\0') element in the array — marks the end of the string.; ``-fbounds-safety`` provides ``__null_terminated`` to annotate C strings and the; generalized form ``__terminated_by(T)`` to annotate pointers and arrays with an; end marked by a sentinel value. The model prevents dereferencing a; ``__terminated_by`` pointer beyond its end. Calculating the location of the end; (i.e., the address of the sentinel value), requires reading the entire array in; memory and would have some performance costs. To avoid an unintended performance; hit, the model puts some restrictions on how these pointers can be used.; ``__terminated_by`` pointers cannot be indexed and can only be incremented one; element at a time. To allow these operations, the pointers must be explicitly; converted to ``__indexable`` pointers using the intrinsic function; ``__unsafe_terminated_by_to_indexable(P, T)`` (or; ``__unsafe_null_terminated_to_indexable(P)``) which converts the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer beyond it is; prevented at run time. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:18446,avoid,avoid,18446,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about general control flow and arithmetic, it is; not anywhere near as strong at reasoning about the various intrinsics. If; profitable for code generation purposes, the optimiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:8137,predict,predictable,8137,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['predict'],['predictable']
Safety,"is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled with ShadowCallStack must either target; one of the platforms whose ABI reserves ``SCSReg`` (currently Android, Darwin,; Fuchsia and Windows) or be compiled with a flag to reserve that register (e.g.,; ``-ffixed-x18``). If absolutely necessary, code compiled without reserving the; register may be run on the same thread as code that uses ShadowCallStack by; saving the register value temporarily on the stack (`example in Android`_) but; this should be done with care since it risks leaking the shadow call stack; address. .. _`example in Android`: https://android-review.googlesource.com/c/platform/frameworks/base/+/803717. Because it requires a dedicated register, the ShadowCallStack feature is; incompatible with any other feature that may use ``SCSReg``. However, there is; no inherent reason why ShadowCallStack needs to use a specific register; in; principle, a platform could choose to reserve and use another register for; ShadowCallStack, but this would be incompatible with the ABI standards; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:3613,risk,risks,3613,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['risk'],['risks']
Safety,"is program to create a little endian version of the table. The table; is used in PPCISelLowering.cpp, PPCTargetLowering::LOWERVECTOR_SHUFFLE(). //===----------------------------------------------------------------------===//. Opportunies to use instructions from PPCInstrVSX.td during code gen; - Conversion instructions (Sections 7.6.1.5 and 7.6.1.6 of ISA 2.07); - Scalar comparisons (xscmpodp and xscmpudp); - Min and max (xsmaxdp, xsmindp, xvmaxdp, xvmindp, xvmaxsp, xvminsp). Related to this: we currently do not generate the lxvw4x instruction for either; v4f32 or v4i32, probably because adding a dag pattern to the recognizer requires; a single target type. This should probably be addressed in the PPCISelDAGToDAG logic. //===----------------------------------------------------------------------===//. Currently EXTRACT_VECTOR_ELT and INSERT_VECTOR_ELT are type-legal only; for v2f64 with VSX available. We should create custom lowering; support for the other vector types. Without this support, we generate; sequences with load-hit-store hazards. v4f32 can be supported with VSX by shifting the correct element into; big-endian lane 0, using xscvspdpn to produce a double-precision; representation of the single-precision value in big-endian; double-precision lane 0, and reinterpreting lane 0 as an FPR or; vector-scalar register. v2i64 can be supported with VSX and P8Vector in the same manner as; v2f64, followed by a direct move to a GPR. v4i32 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 1, using a direct move to a GPR, and; sign-extending the 32-bit result to 64 bits. v8i16 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 3, using a direct move to a GPR, and; sign-extending the 16-bit result to 64 bits. v16i8 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 7, using a direct move to a GPR, and; sign-extending the 8-bit result to 64 bits.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:10315,hazard,hazards,10315,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,2,['hazard'],['hazards']
Safety,"is still in active development. This document may become outdated; over time. If you see something that's incorrect, please update it. Use Cases; ---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1368,redund,redundant,1368,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['redund'],['redundant']
Safety,"is to check whether there; is another execution and if not, immediately exit without doing any work; (also see :ref:`loop-terminology-loop-rotate`), loop trip count is not; the best measure of a loop's number of iterations. For instance, the; number of header executions of the code below for a non-positive n; (before loop rotation) is 1, even though the loop body is not executed; at all. .. code-block:: C. for (int i = 0; i < n; ++i); body(i);. A better measure is the **backedge-taken count**, which is the number of; times any of the backedges is taken before the loop. It is one less than; the trip count for executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9454,detect,detection,9454,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['detect'],['detection']
Safety,"is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15788,recover,recover,15788,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['recover'],"['recover', 'recovered']"
Safety,"is written and will be reused),; if the TBuffer size is greater than. - twice the data in the current basket; and - twice the average data in each basket (of this branch); and - twice the requeste basket size (TBranch::GetBasketSize).; the size of the buffer is reduced to the max of; 'the data in the current basket' and 'the average' and the requested; buffer size and aligned to next highest multiple of 512.; In TBranchRef distinguish between the entry we need (now called RequestedEntry) and the; entry we have read (fReadEntry) so that we can avoid re-reading the same entry too many; times when executing TRef::GetObject.; Reduce by 40% the time taken GetEntry for a branch created using a leaflist (exclusive of the decompression time).; Introduce TVirtualPerfStats::FileUnzipEvent to be able to keep track of the cost of unzipping and use this in TTreePerfStats and TBasket ... This give a good picture of where the time in unzip or in unstreaming; Add more clusters to the TTreeCache buffer until fBufferMinSize is hit to avoid severely underfilled buffer when; a low number of branches is selected/used.; When reading backwards, make sure to load a full (new) cluster and several other fixes to TTreeCache.; Reduce the memory used by a TTree in half. Refactor the code reading and writing the TBasket data.; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch.; In TTree::Fill, call FlushBasket before calling OptimizeBaskets so that we have a correct; and accurate value of fTotBytes to use as the requested memory.; In TTree::OptimizeBasket enforces hard minimun for the basket size (no lower than the; estimate size of one entry in the branch and no lower than 8 bytes). TTree::Process. Add support for the flag TSelector::kAbortFile. TTree::Draw. The line width setting was missing in a few places.; Namely support the option 'a' for TGraphs in TTree::Draw (delegate the axis management to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html:1881,avoid,avoid,1881,tree/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html,2,['avoid'],['avoid']
Safety,"is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>` call. The runtime must provide a number of new entrypoints which the compiler may; emit, which are described in the remainder of this section. .. admonition:: Rationale. Several of these functions are semantically equivalent to a message send; we; emit calls to C functions instead because:. * the machine code to do so is significantly smaller,; * it is much easier to recognize the C functions in the ARC optimizer, and; * a sufficient sophisticated runtime may be able to avoid the message send in; common cases. Several other of these functions are ""fused"" operations which can be; described entirely in terms of other operations. We use the fused operations; primarily as a code-size optimization, although in some cases there is also a; real potential for avoiding redundant operations in the runtime. .. _arc.runtime.objc_autorelease:. ``id objc_autorelease(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it adds the object; to the innermost autorelease pool exactly as if the object had been sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autoreleasePoolPush <arc.runtime.objc_autoreleasePoolPush>` on the; current thread, where neither ``pool`` nor any enclosing pool have previously; been popped. Releases all the objects added to the given autorelease pool and any; autorelease pools it encloses, then sets the current autorelease pool to the; pool directly en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:106896,avoid,avoiding,106896,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['avoid', 'redund']","['avoiding', 'redundant']"
Safety,"istics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a model in the ""standard form"" where the dataset has one row for each; event, and the column corresponds to the value of the observable in the; histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:23791,avoid,avoid,23791,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoid']
Safety,"it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2797,recover,recover,2797,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"itcast of an alloca. The second contains a pointer to metadata that should be; associated with the pointer, and **must** be a constant or global value; address. If your target collector uses tags, use a null pointer for metadata. A compiler which performs manual SSA construction **must** ensure that SSA; values representing GC references are stored in to the alloca passed to the; respective ``gcroot`` before every call site and reloaded after every call.; A compiler which uses mem2reg to raise imperative code using ``alloca`` into; SSA form need only add a call to ``@llvm.gcroot`` for those variables which; are pointers into the GC heap. It is also important to mark intermediate values with ``llvm.gcroot``. For; example, consider ``h(f(), g())``. Beware leaking the result of ``f()`` in the; case that ``g()`` triggers a collection. Note, that stack variables must be; initialized and marked with ``llvm.gcroot`` in function's prologue. The ``%metadata`` argument can be used to avoid requiring heap objects to have; 'isa' pointers or tag bits. [Appel89_, Goldberg91_, Tolmach94_] If specified,; its value will be tracked along with the location of the pointer in the stack; frame. Consider the following fragment of Java code:. .. code-block:: java. {; Object X; // A null-initialized reference to an object; ...; }. This block (which may be located in the middle of a function or in a loop nest),; could be compiled to this LLVM code:. .. code-block:: llvm. Entry:; ;; In the entry block for the function, allocate the; ;; stack space for X, which is an LLVM pointer.; %X = alloca %Object*. ;; Tell LLVM that the stack space is a stack root.; ;; Java has type-tags on objects, so we pass null as metadata.; %tmp = bitcast %Object** %X to i8**; call void @llvm.gcroot(i8** %tmp, i8* null); ... ;; ""CodeBlock"" is the block corresponding to the start; ;; of the scope above.; CodeBlock:; ;; Java null-initializes pointers.; store %Object* null, %Object** %X. ... ;; As the pointer goes out o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:11560,avoid,avoid,11560,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['avoid'],['avoid']
Safety,"iterator's destructor. TFile::MakeProject. Extend TFile::MakeProject to support genreflex, cases of user's data model where; the 2 distincts pointers point to a single object and more cases where we are; missing the StreamerInfo and need to guess whether the symbol represent an enum,; a class or a namespace. To use genreflex, call MakeProject with the ""genreflex"" option, for example:. file->MakeProject(libdir,""*"",""NEW+genreflex"");. To make sure the library created by MakeProject does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. MakeProject now implements a move constructor for each classes. For the implementation, we 'use' the 'copy constructor' until the C++ compilers properly support the official move constructor notation. Implementing a move constructor avoid having to delete and reconstruct resource during a std::vector resize and avoid the double delete induced by using the default copy constructor. MakeProject now adds dictionaries for auto_ptr. MakeProject no longer request the dictionary for std::pair instances that already have been loaded. Misc. TFile::Open now does variable expansion so that you can include the protocol in the variable (for example: export H1=""http://root.cern/files/h1""; ...; TFile::Open(""$H1/dstarmb.root"");; Added warning if the file does contain any StreamerInfo objects and was written with a different version of ROOT.; Implemented polymorphism for Emulated object (still not supporting polymorphism of Emulated Object inheriting from compiled class). See the Core/Meta section for details.; Add support for streaming auto_ptr when generating their dictionary via rootcint; Enable the use of the I/O customization rules on data members that are either a variable size array or a fixed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" vers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:8870,avoid,avoid,8870,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,4,['avoid'],['avoid']
Safety,"ith ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:7675,avoid,avoids,7675,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoids']
Safety,"ithm; ROOT::Math::GSLMultiRootFinder::kDNewton with name ""DNewton"": discrete Newton algorithm ; ROOT::Math::GSLMultiRootFinder::kBroyden with name ""Broyden"": Broyden algorithm . Minuit2. Improve Printing of information and Error messages. Use the class ROOT::Minuit2::MnPrint to store a; static print level, which can be set by using the static function MnPrint::SetLevel(int ). Add new information messages in the VariableMetricBuilder (i.e. Migrad), to print some messages; during the minimization.The new printing level is now also controlled by the Minuit2Minimizer class. ; Print now in the messages the parameter names instead of the parameter indices.; fix the update of the number of function calls in Minuit2 after calling Hess after Migrad. The number is now not; reset in MnHesse; Fix a problem, when, after calling Hesse ,the edm was correct to values below the required tolerance.; Now do not flag these cases as failed minimizations but as good ones.; Correct tolerance by 2E-3 instead 2E-4 to ve conistent with what is done in F77 Minuit or TMinuit; Avoid when using the CombinedMinimumBuilder (i.e. the Minimize algorithm) to call two times; ModularFunctionMinimize::Minimum. Since this last function correct the tolerance by the Up value, a; double correction was applied in this case. ; Implement the methods Minuit2Minimizer::GetHessianMatrix(double * mat) and; Minuit2Minimizer::GetCovMatrix(double * mat).; For retrieving the Hessian, a new method has been added, MnUserParameterState::Hessian, which returns; the Hessian by inverting the covariance matrix, since the Hessian is not stored inside the Minuit2 classes.; Fix a bug in MnUserTransformation when using unnamed parameters (bug 82552).; ; Add the possibility when using Minos to pass the tolerance for the Migrad calls. (use a default of 0.1 * Up, which is; the same value used in F77). . Minuit. Implement the methods TMinuitMinimizer::GetHessianMatrix(double * mat) and; TMinuitMinimizer::GetCovMatrix(double * mat). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:5532,Avoid,Avoid,5532,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,1,['Avoid'],['Avoid']
Safety,"ithout any additional terms or conditions.; Notwithstanding the above, nothing herein shall supersede or modify; the terms of any separate license agreement you may have executed; with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade; names, trademarks, service marks, or product names of the Licensor,; except as required for reasonable and customary use in describing the; origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or; agreed to in writing, Licensor provides the Work (and each; Contributor provides its Contributions) on an ""AS IS"" BASIS,; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or; implied, including, without limitation, any warranties or conditions; of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A; PARTICULAR PURPOSE. You are solely responsible for determining the; appropriateness of using or redistributing the Work and assume any; risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory,; whether in tort (including negligence), contract, or otherwise,; unless required by applicable law (such as deliberate and grossly; negligent acts) or agreed to in writing, shall any Contributor be; liable to You for damages, including any direct, indirect, special,; incidental, or consequential damages of any character arising as a; result of this License or out of the use or inability to use the; Work (including but not limited to damages for loss of goodwill,; work stoppage, computer failure or malfunction, or any and all; other commercial damages or losses), even if such Contributor; has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing; the Work or Derivative Works thereof, You may choose to offer,; and charge a fee for, acceptance of support, warranty, in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:8022,risk,risks,8022,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,5,['risk'],['risks']
Safety,"itution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operands); << lex->getType() << rex->getType(); << lex->getSourceRange() << rex->getSourceRange();. This shows that use of the ``Diag`` method: it takes a location (a; :ref:`SourceLocation <SourceLocation>` object) and a diagnostic enum value; (which matches the name from ``Diagnostic*Kinds.td``). If the diagnostic takes; arguments, they are specified with the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:16120,detect,detects,16120,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['detect'],['detects']
Safety,"ity. And when the types are obvious from people's experience; (e.g., in the br instruction), it doesn't seem to help as much. o On reflection, I really like your idea of having the two different switch; types (even though they encode implementation techniques rather than; semantics). It should simplify building the CFG and my guess is it could; enable some significant optimizations, though we should think about which. o In the lookup-indirect form of the switch, is there a reason not to make; the val-type uint? Most HLL switch statements (including Java and C++); require that anyway. And it would also make the val-type uniform ; in the two forms of the switch. I did see the switch-on-bool examples and, while cute, we can just use; the branch instructions in that particular case. o I agree with your comment that we don't need 'neg'. o There's a trade-off with the cast instruction:; + it avoids having to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact than uint. o I still have some major concerns about including malloc and free in the; language (either as builtin functions or instructions). LLVM must be; able to represent code from many different languages. Languages such as; C, C++ Java and Fortran 90 would not be able to use our malloc anyway; because each of them will want to provide a library implementation of it. This gets even worse when code from different languages is linked; into a single executable (which is fairly common in large apps).; Having a single malloc would just not suffice, and instead would simply; complicate the picture further because it adds an extra variant in; addition to the one each language provid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:1585,avoid,avoids,1585,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['avoid'],['avoids']
Safety,"ivate member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:21309,safe,safety,21309,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"ive username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still destroyed at the end of the query, but there was no; memory advantage in TH1::Add wrt TH1::Merge.; Make sure that the performance tree is removed from the output; list when saved to the output file. Solves a segv at quit.; Decouple from registered TChains in already TProof::Close(); allows; to avoid possible crash at exit ('.q') occuring after the recent; revision of the socket cleanup policy.; In XrdProofd, fix a few issues with option 'xpd.multiuser'.; In TXSocket::ProcessUnsolicitedMsg, fix an issue preventig server; messages to be displayed during setup, i.e. when the XrdClientConn; instance is not yet defined.; In XrdProofd, fix the behavior of the 'xpd.allowedusers' and; 'xpd.allowedgroups' directives. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:4248,avoid,avoid,4248,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,['avoid'],['avoid']
Safety,"ix - correct tooltip handling for graphs with lines and markers; 8. Fix - interactive zooming in TH2 when doing histogram update. ## Changes in 4.4.2; 1. Fix - statistic collection for TH2; 2. Fix - correct handling of empty TList in browser/inspector; 3. Fix - support TFolder in browser/inspector (#40). ## Changes in 4.4.1; 1. Fix - colz palette resize when drawing histogram second time; 2. Fix - use embedded in TCanvas color for background color of canvas itself; 3. Fix - rotate too long X axis text labels; 4. Fix - draw histogram bins on frame boundary; 5. Fix - use alternative color for shapes with default black color; 6. Fix - correctly handle pcon/pgon shape with rmin==rmax on top or bottom side. ## Changes in 4.4; 1. Fix faces orientation for all TGeo shapes.; 2. Improve TGeoTorus creation - handle all parameters combinations; 3. Implement TGeoCompositeShape, using ThreeCSG.js; 4. Fix problem with color palette when switch to 3D mode (#28); 5. Use nested CSS classes to avoid conflicts with other libraries (#29); 6. Let move and resize TFrame; 7. Improve TH1/TH2 drawings; - draw all histograms points in the range (no any skipped bins); - minimize SVG code for drawing (up to factor 100); - gives significant speedup in drawings; 8. SVG code improvement for TGraph, TF1, TAxis drawings; 9. Provide new tooltip kind; - created only when needed (minimizing SVG code); - tooltip can be drawn for every object in the frame; - touch devices are supported; 10. Fix - let draw same object on the canvas with different options; 11. Create cached list of known class methods. It can be extended by users.; 12. Use of cached methods improves binary I/O performance by 20%; 13. Support TGaxis; 14. Project now can be obtained via 'bower install jsroot'; 15. Support 'scat' and 'text' draw options for TH2; 16. Support in binary I/O zipped buffer bigger than 16M; 17. Correctly handle in binary I/O pointer on TArray object (like in THnSparseArrayChunk). ## Changes in 4.3; 1. Implement TGe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:56685,avoid,avoid,56685,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['avoid'],['avoid']
Safety,"ix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121916,safe,safety,121916,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4325,unsafe,unsafe,4325,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"ize by a factor 10 (compare to the previous; implementation) for normal plots with math formulae and greek characters.; - Offer 0 as line width option. Useful to make a line invisible. ### TPDF. - When a text size was equal or smaller than 0 the PDF file was corrupted.; - Small fix for fill patterns 1, 2 and 3.; - When printing a coloured 2D histograms (with option COLZ) into a PDF or PostScript; file, the preview on screen using many standard PDF previewer tools showed very; thin white lines between the bins as well as in the color palette.; This made very ugly the final output.; This problem is due to bad implementation of anti-aliasing in these previewers.; A way to bypass this issue was to turn off the anti-aliasing in the previewer; but then the rest of the document does not look nice. This problem is now bypassed; with a fix in both PDF and PostScript output.; - Offer 0 as line width option. Useful to make a line invisible. ### TSVG. - Use float numbers instead of integer to describe graphics paths to avoid; rounding problems.; - Implement missing math symbols.; - Offer 0 as line width option. Useful to make a line invisible. ### TASImage. - In the animated gif it is now possible to specify the delay between the last; image and the fist image in case of infinite loop. (Fernando Hueso González; <f.gonzalez@hzdr.de>). ### TPadPainter; - Offer 0 as line width option. Useful to make a line invisible. ### TPad. - In `TPad::ShowGuidelines` the number of guide lines is limited to 15. Above; that they become useless.; - Print a warning if one of the pad limit is a NaN.; - Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. ### TCanvas. - Make sure that ""/"" and ""."" are not part of the method name when a canvas is; saved as a .C file. ### TLatex. - With the Cocoa backend the PDF and PS output produced miss-aligned exponents; because the `GetTextExtend` method behaved differently in batch mode and ""screen""; mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:22917,avoid,avoid,22917,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['avoid'],['avoid']
Safety,"jective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71856,unsafe,unsafe,71856,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=und",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2410,recover,recover,2410,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"k:: c++. #include ""llvm/CodeGen/AsmPrinter.h""; #include ""llvm/IR/Function.h""; #include ""llvm/IR/DataLayout.h""; #include ""llvm/Target/TargetAsmInfo.h""; #include ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37715,safe,safe,37715,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ke this:. .. code-block:: text. ; Function Attrs: nounwind ssp uwtable; define void @foo() #0 !dbg !4 {; entry:; %X = alloca i32, align 4; %Y = alloca i32, align 4; %Z = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; store i32 21, i32* %X, align 4, !dbg !14; call void @llvm.dbg.declare(metadata i32* %Y, metadata !15, metadata !13), !dbg !16; store i32 22, i32* %Y, align 4, !dbg !16; call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; store i32 23, i32* %Z, align 4, !dbg !19; %0 = load i32, i32* %X, align 4, !dbg !20; store i32 %0, i32* %Z, align 4, !dbg !21; %1 = load i32, i32* %Y, align 4, !dbg !22; store i32 %1, i32* %X, align 4, !dbg !23; ret void, !dbg !24; }. ; Function Attrs: nounwind readnone; declare void @llvm.dbg.declare(metadata, metadata, metadata) #1. attributes #0 = { nounwind ssp uwtable ""less-precise-fpmad""=""false"" ""frame-pointer""=""all"" ""no-infs-fp-math""=""false"" ""no-nans-fp-math""=""false"" ""stack-protector-buffer-size""=""8"" ""unsafe-fp-math""=""false"" ""use-soft-float""=""false"" }; attributes #1 = { nounwind readnone }. !llvm.dbg.cu = !{!0}; !llvm.module.flags = !{!7, !8, !9}; !llvm.ident = !{!10}. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)"", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, subprograms: !3, globals: !2, imports: !2); !1 = !DIFile(filename: ""/dev/stdin"", directory: ""/Users/dexonsmith/data/llvm/debug-info""); !2 = !{}; !3 = !{!4}; !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, retainedNodes: !2); !5 = !DISubroutineType(types: !6); !6 = !{null}; !7 = !{i32 2, !""Dwarf Version"", i32 2}; !8 = !{i32 2, !""Debug Info Version"", i32 3}; !9 = !{i32 1, !""PIC Level"", i32 2}; !10 = !{!""clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)""}; !11 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:13856,unsafe,unsafe-fp-math,13856,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['unsafe'],['unsafe-fp-math']
Safety,"ked just like; `LLVMFuzzerTestOneInput`, and has the same signature. .. code-block:: c++. extern ""C"" int LLVMFuzzerRunDriver(int *argc, char ***argv,; int (*UserCb)(const uint8_t *Data, size_t Size));. Rejecting unwanted inputs; -------------------------. It may be desirable to reject some inputs, i.e. to not add them to the corpus. For example, when fuzzing an API consisting of parsing and other logic,; one may want to allow only those inputs into the corpus that parse successfully. If the fuzz target returns -1 on a given input,; libFuzzer will not add that input top the corpus, regardless of what coverage; it triggers. .. code-block:: c++. extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; if (auto *Obj = ParseMe(Data, Size)) {; Obj->DoSomethingInteresting();; return 0; // Accept. The input may be added to the corpus.; }; return -1; // Reject; The input will not be added to the corpus.; }. Leaks; -----. Binaries built with AddressSanitizer_ or LeakSanitizer_ will try to detect; memory leaks at the process shutdown.; For in-process fuzzing this is inconvenient; since the fuzzer needs to report a leak with a reproducer as soon as the leaky; mutation is found. However, running full leak detection after every mutation; is expensive. By default (``-detect_leaks=1``) libFuzzer will count the number of; ``malloc`` and ``free`` calls when executing every mutation.; If the numbers don't match (which by itself doesn't mean there is a leak); libFuzzer will invoke the more expensive LeakSanitizer_; pass and if the actual leak is found, it will be reported with the reproducer; and the process will exit. If your target has massive leaks and the leak detection is disabled; you will eventually run out of RAM (see the ``-rss_limit_mb`` flag). Developing libFuzzer; ====================. LibFuzzer is built as a part of LLVM project by default on macos and Linux.; Users of other operating systems can explicitly request compilation using; ``-DCOMPILER_RT_BUILD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:26412,detect,detect,26412,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"kers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Saurav Shekhar, GSOC 2017,\; Xavier Valls Pla, UJI, CERN/SFT,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit,\; Stefan Wunsch, CERN/SFT, \; Zhe Zhang, UNL. ## Important Notice. The default compression algorithm used when writing ROOT files has been updated to use LZ4 in particular to improve read (decompression) performance. You can change this default for each file through (for example) the `TFile constructor` or `TFile::SetCompressionAlgorithm`. It should be noted that ROOT files written with LZ4 compression can not be read with older release of ROOT. Support for LZ4 was however back-ported to the patch branches of previous releases and the following tags (and later release in the same patch series) can read ROOT files written with LZ4 compression:. * v5.34/38; * v6.08/06 [not yet released]; * v6.10/08; * v6.12/02. ## Removed interfaces. ## Core Libraries; - Optimize away redundant deserialization of template specializations. This reduces the memory footprint for hsimple by around 30% while improving the runtime performance for various cases by around 15%.; - When ROOT is signaled with a SIGUSR2 (i.e. on Linux and MacOS X) it will now print a backtrace.; - Move RStringView.h to ROOT/RStringView.hxx and always include ROOT/RStringView.hxx instead of RStringView.h for backward compatibility; - In `TClingCallFunc`, support r-value reference parameters. This paves the way for the corresponding support in PyROOT (implemented now in the latest Cppyy).; - Included the new TSequentialExecutor in ROOT, sharing the interfaces of TExecutor.This should improve code economy when providing a fallback for TThreadExecutor/TProcessExecutor. ### Thread safety; - Resolved several race conditions, dead-locks, performance and order of initialization/destruction issues still lingering because of or despite the new read-write lock mechanism. ## Interpreter. - Enabled use of multi-thre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:1755,redund,redundant,1755,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['redund'],['redundant']
Safety,"kground estimate. The signal is always assumed to be Poisson;; background may be Poisson, Gaussian, or user-supplied; efficiency may be; Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum.; Meth. A551:493-503,2005. **`TLimit`** class computes 95% C.L. limits using the Likelihood ratio; semi-Bayesian method ( <CLs> method; see e.g. T. Junk, NIM A434, p.; 435-443, 1999). It takes signal background and data histograms wrapped; in a `TLimitDataSource` as input, and runs a set of Monte Carlo; experiments in order to compute the limits. If needed, inputs are; fluctuated according to systematic. ### Specialized Classes for Fitting. **`TFractionFitter`** fits Monte Carlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:118317,predict,predictions,118317,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['predict'],['predictions']
Safety,"king inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22771,safe,safety,22771,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26485,safe,safe,26485,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"l be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163610,safe,safe,163610,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safe']
Safety,"l""; LABELS ${labels}; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}). if(${t} IN_LIST multithreaded); # Makes sure that this doesn't run in parallel with other multithreaded tutorials, and that cmake doesn't start too; # many other tests. That we use 4 processors is actually a lie, because IMT takes whatever it finds.; # However, even this poor indication of MT behaviour is a good hint for cmake to reduce congestion.; set_tests_properties(tutorial-${tname} PROPERTIES RESOURCE_LOCK multithreaded PROCESSORS ${NProcessors}); endif(); endforeach(). #---Loop over all MPI tutorials and define the corresponding test---------; foreach(t ${mpi_tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). # These tests on ARM64 need much more than 20 minutes - increase the timeout; if(ROOT_ARCHITECTURE MATCHES arm64 OR ROOT_ARCHITECTURE MATCHES ppc64); set(thisTestTimeout 3000) # 50m; else(); set(thisTestTimeout 1200) # 20m; endif(). ROOT_ADD_TEST(tutorial-${tname}; COMMAND ${MPIEXEC_EXECUTABLE} ${MPIEXEC_NUMPROC_FLAG} 4 ${ROOT_root_CMD} -b -l -q ${CMAKE_CURRENT_SOURCE_DIR}/${t}${${tname}-aclic}; PASSRC ${rc} FAILREGEX ""Error in <"" "": error:"" ""segmentation violation"" ""FROM HESSE STATUS=FAILED"" ""warning: Failed to call""; LABELS tutorial; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}); endforeach(). #---Python tutorials-----------------------------------------------------; if(ROOT_pyroot_FOUND). # Copy .rootlogon.py file into the build directory. It disables graphics for the Python tutorials; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/.rootlogon.py ${CMAKE_CURRENT_BINARY_DIR} COPYONLY); # Copy .enableImplicitMTWrapper.py file into the build directory. It can limit the size of the thread pool; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/.enableImpli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:25467,timeout,timeout,25467,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['timeout'],['timeout']
Safety,"l, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has_constexpr_builtin`` is used in libcxx's implementation of; the ``<cmath>`` header file to conditionally make a function constexpr whenever; the constant evaluation of the corresponding builtin (for exa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1675,detect,detect,1675,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['detect'],['detect']
Safety,"language, for example by; lifting a restriction or by adding new syntax, the change will be annotated; with a revision marker, like so:. ARC applies to Objective-C pointer types, block pointer types, and; :when-revised:`[beginning Apple 8.0, LLVM 3.8]` :revision:`BPTRs declared; within` ``extern ""BCPL""`` blocks. For now, it is sensible to version this document by the releases of its sole; implementation (and its host project), clang. ""LLVM X.Y"" refers to an; open-source release of clang from the LLVM project. ""Apple X.Y"" refers to an; Apple-provided release of the Apple LLVM Compiler. Other organizations that; prepare their own, separately-versioned clang releases and wish to maintain; similar information in this document should send requests to cfe-dev. If a change decreases the expressiveness of the language, for example by; imposing a new restriction, this should be taken as an oversight in the; original specification and something to be avoided in all versions. Such; changes are generally to be avoided. .. _arc.general:. General; =======. Automatic Reference Counting implements automatic memory management for; Objective-C objects and blocks, freeing the programmer from the need to; explicitly insert retains and releases. It does not provide a cycle collector;; users must explicitly manage the lifetime of their objects, breaking cycles; manually or with weak or unsafe references. ARC may be explicitly enabled with the compiler flag ``-fobjc-arc``. It may; also be explicitly disabled with the compiler flag ``-fno-objc-arc``. The last; of these two flags appearing on the compile line ""wins"". If ARC is enabled, ``__has_feature(objc_arc)`` will expand to 1 in the; preprocessor. For more information about ``__has_feature``, see the; :ref:`language extensions <langext-__has_feature-__has_extension>` document. .. _arc.objects:. Retainable object pointers; ==========================. This section describes retainable object pointers, their basic operations, and; the restr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:8709,avoid,avoided,8709,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoided']
Safety,"lap with any other pass executions (thus it should be very fast). .. _writing-an-llvm-pass-runOnSCC:. The ``runOnSCC`` method; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnSCC(CallGraphSCC &SCC) = 0;. The ``runOnSCC`` method performs the interesting work of the pass, and should; return ``true`` if the module was modified by the transformation, ``false``; otherwise. The ``doFinalization(CallGraph &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization(CallGraph &CG);. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnSCC; <writing-an-llvm-pass-runOnSCC>` for every SCC in the program being compiled. .. _writing-an-llvm-pass-FunctionPass:. The ``FunctionPass`` class; --------------------------. In contrast to ``ModulePass`` subclasses, `FunctionPass; <https://llvm.org/doxygen/classllvm_1_1Pass.html>`_ subclasses do have a; predictable, local behavior that can be expected by the system. All; ``FunctionPass`` execute on each function in the program independent of all of; the other functions in the program. ``FunctionPass``\ es do not require that; they are executed in a particular order, and ``FunctionPass``\ es do not modify; external functions. To be explicit, ``FunctionPass`` subclasses are not allowed to:. #. Inspect or modify a ``Function`` other than the one currently being processed.; #. Add or remove ``Function``\ s from the current ``Module``.; #. Add or remove global variables from the current ``Module``.; #. Maintain state across invocations of :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` (including global data). Implementing a ``FunctionPass`` is usually straightforward (See the :ref:`Hello; World <writing-an-llvm-pass-basiccode>` pass for example).; ``FunctionPass``\ es may override three virtual methods to do their work. All; of these methods should return ``true`` if they modified the program, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:17256,predict,predictable,17256,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['predict'],['predictable']
Safety,"laration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In parti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22121,unsafe,unsafe,22121,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['unsafe'],['unsafe']
Safety,"lating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6507,safe,safety,6507,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"lation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124140,safe,safe,124140,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3047,safe,safe,3047,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"le header file. Don't do this!. If you really need to do something like this, put a private header file in the; same directory as the source files, and include it locally. This ensures that; your private interface remains private and undisturbed by outsiders. .. note::. It's okay to put extra implementation methods in a public class itself. Just; make them private (or protected) and all is well. Use Namespace Qualifiers to Implement Previously Declared Functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When providing an out of line implementation of a function in a source file, do; not open namespace blocks in the source file. Instead, use namespace qualifiers; to help ensure that your definition matches an existing declaration. Do this:. .. code-block:: c++. // Foo.h; namespace llvm {; int foo(const char *s);; }. // Foo.cpp; #include ""Foo.h""; using namespace llvm;; int llvm::foo(const char *s) {; // ...; }. Doing this helps to avoid bugs where the definition does not match the; declaration from the header. For example, the following C++ code defines a new; overload of ``llvm::foo`` instead of providing a definition for the existing; function declared in the header:. .. code-block:: c++. // Foo.cpp; #include ""Foo.h""; namespace llvm {; int foo(char *s) { // Mismatch between ""const char *"" and ""char *""; }; } // namespace llvm. This error will not be caught until the build is nearly complete, when the; linker fails to find a definition for any uses of the original function. If the; function were instead defined with a namespace qualifier, the error would have; been caught immediately when the definition was compiled. Class method implementations must already name the class and new overloads; cannot be introduced out of line, so this recommendation does not apply to them. .. _early exits:. Use Early Exits and ``continue`` to Simplify Code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When reading code, keep in mind how much state and ho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:34321,avoid,avoid,34321,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"le hierarchy"". Each node ``X`` in a given CFG is reported to be m-converged if and; only if every cycle that contains ``X`` satisfies the following necessary; conditions:. 1. Every divergent branch inside the cycle satisfies the; :ref:`diverged entry criterion<convergence-diverged-entry>`, and,; 2. There are no :ref:`diverged paths reaching the; cycle<convergence-diverged-outside>` from a divergent branch; outside it. .. note::. A reducible cycle :ref:`trivially satisfies; <convergence-reducible-cycle>` the above conditions. In particular,; if the whole CFG is reducible, then all nodes in the CFG are; m-converged. The uniformity of each output of a static instance; is determined using the criteria; :ref:`described earlier <convergence-uniformity>`. The discovery of; divergent outputs may cause their uses (including branches) to also; become divergent. The analysis propagates this divergence until a; fixed point is reached. The convergence inferred using these criteria is a safe subset of the; maximal converged-with relation for any cycle hierarchy. In; particular, it is sufficient to determine if a static instance is; m-converged for a given cycle hierarchy ``T``, even if that fact is; not detected when examining some other cycle hierarchy ``T'``. This property allows compiler transforms to use the uniformity; analysis without being affected by DFS choices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:19925,safe,safe,19925,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['safe'],['safe']
Safety,"le nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, etc) using a cast. The extension provides builtins to force; this conversion, ``__unsafe_forge_bidi_indexable(type, pointer, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicitly be ``FILE; *__unsafe_indexable`` and thus it cannot be directly assigned to ``FILE *fp``; in the bounds-safe source. To allow this operation, ``__unsafe_forge_single``; is used to create a ``__single`` from the return value of ``fopen``. * Simila",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:40752,unsafe,unsafe,40752,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"le pass clean up dead defs for such calls, as it does; for stores. //===---------------------------------------------------------------------===//. Consider implementing optimizeSelect, optimizeCompareInstr, optimizeCondBranch,; optimizeLoadInstr, and/or getMachineCombinerPatterns. //===---------------------------------------------------------------------===//. Find a clean way to fix the problem which leads to the Shrink Wrapping pass; being run after the WebAssembly PEI pass. //===---------------------------------------------------------------------===//. When setting multiple local variables to the same constant, we currently get; code like this:. i32.const $4=, 0; i32.const $3=, 0. It could be done with a smaller encoding like this:. i32.const $push5=, 0; local.tee $push6=, $4=, $pop5; local.copy $3=, $pop6. //===---------------------------------------------------------------------===//. WebAssembly registers are implicitly initialized to zero. Explicit zeroing is; therefore often redundant and could be optimized away. //===---------------------------------------------------------------------===//. Small indices may use smaller encodings than large indices.; WebAssemblyRegColoring and/or WebAssemblyRegRenumbering should sort registers; according to their usage frequency to maximize the usage of smaller encodings. //===---------------------------------------------------------------------===//. Many cases of irreducible control flow could be transformed more optimally; than via the transform in WebAssemblyFixIrreducibleControlFlow.cpp. It may also be worthwhile to do transforms before register coloring,; particularly when duplicating code, to allow register coloring to be aware of; the duplication. //===---------------------------------------------------------------------===//. WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more; aggressively. //===---------------------------------------------------------------------===//. WebAssemblyRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:4315,redund,redundant,4315,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,2,['redund'],['redundant']
Safety,"le path references in ``.rc`` files; concatenated from multiple string literals. * The ``llvm-windres`` option ``--preprocessor`` now resolves its argument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:15906,avoid,avoiding,15906,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['avoid'],['avoiding']
Safety,"le still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:23458,safe,safety,23458,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"le, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:6527,timeout,timeout,6527,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['timeout'],['timeout']
Safety,"leView` objects for the independent reading of individual fields.; The reader can create `RBulk` objects for bulk reading of individual fields. Additionally, the reader provides access to a cached copy of the descriptor.; It can display individual entries (`RNTupleReader::Show()`) and summary information (`RNTupleReader::PrintInfo()`). ### RNTupleView<T>; RNTuple views provide read access to individual fields.; Views are created from an RNTupleReader.; Views are templated; for simple types (e.g., `float`, `int`), views provide read-only access directly to an RNTuple page in memory.; Complex types and void views require additional memory copies to populate an object in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data source for RDataFrame.; It is part of the `ROOTDataFrame` library.; The RNTuple data source supports chains with a constructor that takes a list of input files.; The RNTuple data source also supports multi-threaded dataframes, parallelized on the file and cluster level. The data source exposes inner fields of complex collections.; For instance, if the data model contains a vector of `Event` classes, where each `Event` has `pt` and `eta` floats,; the dataframe can use the event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:14120,safe,safely,14120,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['safe'],['safely']
Safety,"led. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and dynamic analysis tools could use the bounds information to improve; diagnostics for out-of-bounds accesses, even if ``-fbounds-safety`` is not used.; The bounds annotations could be used to improve C interoperability with; bounds-safe languages, providing a better mapping to bounds-safe types in the; safe language interface. The bounds annotations can also serve as documentation; specifying the relationship between declarations. Limitations; ===========. ``-fbounds-safety`` aims to bring the bounds safety guarantee to the C language,; and it does not guarantee other types of memory safety properties. Consequently,; it may not prevent some of the secondary bounds safety violations caused by; other types of safety violations such as type confusion. For instance,; ``-fbounds-safety`` does not perform type-safety checks on conversions between; `__single`` pointers of different pointee types (e.g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:46594,safe,safety,46594,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"lee upon return. The idea is that it saves callers from having to remember this value,; which would often require a callee-saved register. Callees usually; need to keep this value live for most of their body anyway, so it; doesn't add a significant burden on them. We currently implement this in codegen, however this is suboptimal; because it means that it would be quite awkward to implement the; optimization for callers. A better implementation would be to relax the LLVM IR rules for sret; arguments to allow a function with an sret argument to have a non-void; return type, and to have the front-end to set up the sret argument value; as the return value of the function. The front-end could more easily; emit uses of the returned struct value to be in terms of the function's; lowered return value, and it would free non-C frontends from a; complication only required by a C-based ABI. //===---------------------------------------------------------------------===//. We get a redundant zero extension for code like this:. int mask[1000];; int foo(unsigned x) {; if (x < 10); x = x * 45;; else; x = x * 78;; return mask[x];; }. _foo:; LBB1_0:	## entry; 	cmpl	$9, %edi; 	jbe	LBB1_3	## bb; LBB1_1:	## bb1; 	imull	$78, %edi, %eax; LBB1_2:	## bb2; 	movl	%eax, %eax <----; 	movq	_mask@GOTPCREL(%rip), %rcx; 	movl	(%rcx,%rax,4), %eax; 	ret; LBB1_3:	## bb; 	imull	$45, %edi, %eax; 	jmp	LBB1_2	## bb2; ; Before regalloc, we have:. %reg1025 = IMUL32rri8 %reg1024, 45, implicit-def %eflags; JMP mbb<bb2,0x203afb0>; Successors according to CFG: 0x203afb0 (#3). bb1: 0x203af60, LLVM BB @0x1e02310, ID#2:; Predecessors according to CFG: 0x203aec0 (#0); %reg1026 = IMUL32rri8 %reg1024, 78, implicit-def %eflags; Successors according to CFG: 0x203afb0 (#3). bb2: 0x203afb0, LLVM BB @0x1e02340, ID#3:; Predecessors according to CFG: 0x203af10 (#1) 0x203af60 (#2); %reg1027 = PHI %reg1025, mbb<bb,0x203af10>,; %reg1026, mbb<bb1,0x203af60>; %reg1029 = MOVZX64rr32 %reg1027. so we'd have to know that IMUL32rri8 le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt:2843,redund,redundant,2843,interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt,2,['redund'],['redundant']
Safety,"lename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68886,safe,safe,68886,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"lete clusters not matter the; size (even with the size was larger than 2GB!). This patch resolves the issue by limiting the amount of memory used to:. The requested size if more than one cluster fits in the cache.; Twice the requested size if at least one basket per branch fits in the cache.; Four time the requested size in the case where the cache can not even hold one basket per branch. The filling will restart at the next cluster boundary in the case a) and will; restart at the maximum of entry number read in the cache in the case b) and c).; Baskets that are below this boundary and did not fit in the cache will be read; individually.; Repaired the basket flushing frequency when the TTree has already more than one cluster size.; Repaired binning of string histogram generated by TTree::Draw.; Many bug fixes and fix for issues discovery by Coverity, see change log for more details.; In TTree::MakeProxy add proper support for top level stl collection of objects and for stl collection of objects that are 'empty' in the file (and thus we know nothing about its content).; Avoid deficiency in hadd when the resulting TTree is longer than the AutoSave length *and* the TFileMerger needs to handle the input files in more than one pass for example when there is more than 1000 input files or the -n option is passed to hadd.; Fix support for emulated class that derived from an abstract class.; This can happen when reading a file containing an ancient; class layout where the derived class is no longer provided in the; compiled code but the abstract base class is still provided. It also happens when using schema evolution rules on a class derived; from an abstract base class (in which case the system introduce; implicitly an emulated class deriving from the same base classes; as the evolved from class). To fix the issue, we introduce the TClass::GetStreamerInfoAbstractEmulated; which will return a StreamerInfo representing an emulated version of the; class even if it is loaded. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html:4134,Avoid,Avoid,4134,tree/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html,1,['Avoid'],['Avoid']
Safety,"ligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a backend for an; architecture which cannot satisfy these restrictions and cares about; concurrency, please send an email to llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8585,safe,safe,8585,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['safe'],['safe']
Safety,"ling convention is `swifttailcc` or `swiftcc`:. - Only these ABI-impacting attributes attributes are allowed: sret, byval,; swiftself, and swiftasync.; - Prototypes are not required to match. Tail call optimization for calls marked ``tail`` is guaranteed to occur if; the following conditions are met:. - Caller and callee both have the calling convention ``fastcc`` or ``tailcc``.; - The call is in tail position (ret immediately follows call and ret; uses value of call or is void).; - Option ``-tailcallopt`` is enabled,; ``llvm::GuaranteedTailCallOpt`` is ``true``, or the calling convention; is ``tailcc``; - `Platform-specific constraints are; met. <CodeGenerator.html#tailcallopt>`_. #. The optional ``notail`` marker indicates that the optimizers should not add; ``tail`` or ``musttail`` markers to the call. It is used to prevent tail; call optimization from being performed on the call. #. The optional ``fast-math flags`` marker indicates that the call has one or more; :ref:`fast-math flags <fastmath>`, which are optimization hints to enable; otherwise unsafe floating-point optimizations. Fast-math flags are only valid; for calls that return a floating-point scalar or vector type, or an array; (nested to any depth) of floating-point scalar or vector types. #. The optional ""cconv"" marker indicates which :ref:`calling; convention <callingconv>` the call should use. If none is; specified, the call defaults to using C calling conventions. The; calling convention of the call must match the calling convention of; the target function, or else the behavior is undefined.; #. The optional :ref:`Parameter Attributes <paramattrs>` list for return; values. Only '``zeroext``', '``signext``', and '``inreg``' attributes; are valid here.; #. The optional addrspace attribute can be used to indicate the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:475806,unsafe,unsafe,475806,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"lization with designators, you; need to create and edit the configuration struct explicitely:; ```C++; RooStats::HistFactory::HistoToWorkspaceFactoryFast::Configuration hfCfg;; hfCfg.binnedFitOptimization = false;; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, hfCfg);; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermore, in `RooAbsRealLValue`, the assigment operator was overloaded by a; function that only assigns the value of another `RooAbsReal`. With all these inconsistencies, it was deemed safer to disable copy assignment; of RooAbsArgs from now on. ### RooBrowser: a graphical user interface for workspace exploration, visualization, and analysis. This experimental new feature utilises the technology from ROOT's familiar `TBrowser` in order to create an interface for graphically exploring and visualizing the content of a workspace, as well as perform basic fitting operations with the models and datasets. ![Demonstration of RooBrowser using json workspace from the roofit tutorials directory](RooBrowser.png). ### Removal of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:21919,safe,safer,21919,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['safe'],['safer']
Safety,"lized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant powe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19317,redund,redundant,19317,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['redund'],['redundant']
Safety,"ll arguments specified after **--args** to the test program whenever it runs.; Note that if any of the *program args* start with a ""``-``"", you should use:. .. code-block:: bash. bugpoint [bugpoint args] --args -- [program args]. The ""``--``"" right after the **--args** option tells **bugpoint** to consider; any options starting with ""``-``"" to be part of the **--args** option, not as; options to **bugpoint** itself. **--tool-args** *tool args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any options starting with ""``-``"" to be part of the **--tool-args**; option, not as options to **bugpoint** itself. (See **--args**, above.). **--safe-tool-args** *tool args*. Pass all arguments specified after **--safe-tool-args** to the ""safe"" execution; tool. **--gcc-tool-args** *gcc tool args*. Pass all arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:2207,safe,safe-tool-args,2207,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,2,['safe'],"['safe', 'safe-tool-args']"
Safety,"ll be costly for downstream maintainers. See `Big bang`_ for potential; mitigations. Laissez faire; -------------. The coding standard could allow both ``CamelCase`` and ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **Mitigation**: `git-hyper-blame; <https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/git-hyper-blame.html>`_; can ignore or ""look through"" a given set of commits.; A ``.git-blame-ignore-revs`` file identifying the variable renaming commits; could be added to the LLVM git repository root directory.; It is being `investigated; <https://public-inbox.org/git/20190324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:8803,avoid,avoiding,8803,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['avoid'],['avoiding']
Safety,"ll designate non-overlapping; nodes as ONLY and the others MANY as in GEANT3, where this concept was; introduced:. 1. The part of a MANY node B extruding its container A will never be; ""seen"" during navigation, as if B was in fact the result of the; intersection of A and B. 2. If we have two nodes A (ONLY) and B (MANY) inside the same container,; all points in the overlapping region of A and B will be designated as; belonging to A. 3. If A an B in the above case were both MANY, points in the overlapping; part will be designated to the one defined first. Both nodes must have; the same medium. 4. The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is; much slower. Any overlapping part can be defined based on composite; shapes - might be in some cases a better way out. #### Replicating Volumes. What can we do if our chamber contains two identical wires instead of; one? What if then we would need 1000 chambers in our detector? Should we; create 2000 wires and 1000 chamber volumes? No, we will just need to; replicate the ones that we have already created. ``` {.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ```. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:79098,detect,detector,79098,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"llowing relocations of objects; without visible effects. This high level abstract machine model is used for most of the optimizer. As; a result, transform passes do not need to be extended to look through explicit; relocation sequence. Before starting code generation, we switch; representations to an explicit form. The exact location chosen for lowering; is an implementation detail. Note that most of the value of the abstract machine model comes for collectors; which need to model potentially relocatable objects. For a compiler which; supports only a non-relocating collector, you may wish to consider starting; with the fully explicit form. Warning: There is one currently known semantic hole in the definition of; non-integral pointers which has not been addressed upstream. To work around; this, you need to disable speculation of loads unless the memory type; (non-integral pointer vs anything else) is known to unchanged. That is, it is; not safe to speculate a load if doing causes a non-integral pointer value to; be loaded as any other type or vice versa. In practice, this restriction is; well isolated to isSafeToSpeculate in ValueTracking.cpp. Explicit Representation; ^^^^^^^^^^^^^^^^^^^^^^^. A frontend could directly generate this low level explicit form, but; doing so may inhibit optimization. Instead, it is recommended that; compilers with relocating collectors target the abstract machine model just; described. The heart of the explicit approach is to construct (or rewrite) the IR in a; manner where the possible updates performed by the garbage collector are; explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:5948,safe,safe,5948,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safe']
Safety,"lls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, Fre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5105,detect,detected,5105,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['detect'],['detected']
Safety,"llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These operations are required to be atomic in the sense that if you use; unordered loads and unordered stores, a load cannot see a value which was; never stored. A normal load or store instruction is usually sufficient, but; note that an unordered load or store cannot be split into multiple; instructions (or an instruction which doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8882,safe,safe,8882,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['safe'],['safe']
Safety,"llvm-diff - LLVM structural 'diff'; ==================================. .. program:: llvm-diff. SYNOPSIS; --------. **llvm-diff** [*options*] *module 1* *module 2* [*global name ...*]. DESCRIPTION; -----------. **llvm-diff** compares the structure of two LLVM modules, primarily; focusing on differences in function definitions. Insignificant; differences, such as changes in the ordering of globals or in the; names of local values, are ignored. An input module will be interpreted as an assembly file if its name; ends in '.ll'; otherwise it will be read in as a bitcode file. If a list of global names is given, just the values with those names; are compared; otherwise, all global values are compared, and; diagnostics are produced for globals which only appear in one module; or the other. **llvm-diff** compares two functions by comparing their basic blocks,; beginning with the entry blocks. If the terminators seem to match,; then the corresponding successors are compared; otherwise they are; ignored. This algorithm is very sensitive to changes in control flow,; which tend to stop any downstream changes from being detected. **llvm-diff** is intended as a debugging tool for writers of LLVM; passes and frontends. It does not have a stable output format. EXIT STATUS; -----------. If **llvm-diff** finds no differences between the modules, it will exit; with 0 and produce no output. Otherwise it will exit with a non-zero; value. BUGS; ----. Many important differences, like changes in linkage or function; attributes, are not diagnosed. Changes in memory behavior (for example, coalescing loads) can cause; massive detected differences in blocks.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-diff.rst:1126,detect,detected,1126,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-diff.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-diff.rst,2,['detect'],['detected']
Safety,"llvm-ifs - shared object stubbing tool; ======================================. .. program:: llvm-ifs. SYNOPSIS; --------. :program:`llvm-ifs` [*options*] *inputs*. DESCRIPTION; -----------. :program:`llvm-ifs` is a tool that jointly produces human readable text-based; stubs (.ifs files) for shared objects and linkable shared object stubs; (.so files) from either ELF shared objects or text-based stubs. The text-based; stubs is useful for monitoring ABI changes of the shared object. The linkable; shared object stubs can be used to avoid unnecessary relinks when the ABI of; shared libraries does not change. IFS FORMATS; -----------. Here is an example of the text representation (IFS) of a shared object produced; by the :program:`llvm-ifs`:. ::. --- !ifs-v1; IFSVersion: 3.0; SoName: libtest.so /* Optional */; Target: x86_64-unknown-linux-gnu /* Optional, format 1, same format as llvm target triple */; Target: { Arch: x86_64, Endianness: little, Bitwidth: 64 } /* Optional, format 2 */; NeededLibs:; - libc.so.6; Symbols:; - { Name: sym0, Type: Notype }; - { Name: sym1, Type: Object, Size: 0 }; - { Name: sym2, Type: Func, Weak: false }; - { Name: sym3, Type: TLS }; - { Name: sym4, Type: Unknown, Warning: foo }; ... * ``IFSVersion``: Version of the IFS file for reader compatibility. * ``SoName`` (optional): Name of the shared object file that is being stubbed. * ``Target`` (optional): The architecture, endianness and bitwise information of; this shared object. It can be either in explicit format or in implicit LLVM; triple format. It can be optional and can be overridden from command line; options. * ``NeededLibs``: The list of the external shared objects that this library depends on. * ``Symbols``: A collection of all data needed to link objects for each symbol, sorted by name in ascending order. + ``Name``: Symbol name. + ``Type``: Whether the symbol is an object, function, no-type, thread local storage, or unknown. Symbol types not explicitly supported are mapped as unkn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst:536,avoid,avoid,536,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,1,['avoid'],['avoid']
Safety,"llvm-mca - LLVM Machine Code Analyzer; =====================================. .. program:: llvm-mca. SYNOPSIS; --------. :program:`llvm-mca` [*options*] [input]. DESCRIPTION; -----------. :program:`llvm-mca` is a performance analysis tool that uses information; available in LLVM (e.g. scheduling models) to statically measure the performance; of machine code in a specific CPU. Performance is measured in terms of throughput as well as processor resource; consumption. The tool currently works for processors with a backend for which; there is a scheduling model available in LLVM. The main goal of this tool is not just to predict the performance of the code; when run on the target, but also help with diagnosing potential performance; issues. Given an assembly code sequence, :program:`llvm-mca` estimates the Instructions; Per Cycle (IPC), as well as hardware resource pressure. The analysis and; reporting style were inspired by the IACA tool from Intel. For example, you can compile code with clang, output assembly, and pipe it; directly into :program:`llvm-mca` for analysis:. .. code-block:: bash. $ clang foo.c -O2 --target=x86_64 -S -o - | llvm-mca -mcpu=btver2. Or for Intel syntax:. .. code-block:: bash. $ clang foo.c -O2 --target=x86_64 -masm=intel -S -o - | llvm-mca -mcpu=btver2. (:program:`llvm-mca` detects Intel syntax by the presence of an `.intel_syntax`; directive at the beginning of the input. By default its output syntax matches; that of its input.). Scheduling models are not just used to compute instruction latencies and; throughput, but also to understand what processor resources are available; and how to simulate them. By design, the quality of the analysis conducted by :program:`llvm-mca` is; inevitably affected by the quality of the scheduling models in LLVM. If you see that the performance report is not accurate for a processor,; please `file a bug <https://github.com/llvm/llvm-project/issues>`_; against the appropriate backend. OPTIONS; -------. If ``input",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:625,predict,predict,625,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['predict'],['predict']
Safety,"llvm-reduce - LLVM automatic testcase reducer.; ==============================================. .. program:: llvm-reduce. SYNOPSIS; --------. :program:`llvm-reduce` [*options*] [*input...*]. DESCRIPTION; -----------. The :program:`llvm-reduce` tool project that can be used for reducing the size of LLVM test cases.; It works by removing redundant or unnecessary code from LLVM test cases while still preserving ; their ability to detect bugs. If ``input`` is ""``-``"", :program:`llvm-reduce` reads from standard; input. Otherwise, it will read from the specified ``filenames``. LLVM-Reduce is a useful tool for reducing the size and ; complexity of LLVM test cases, making it easier to identify and debug issues in ; the LLVM compiler infrastructure. GENERIC OPTIONS; ---------------. .. option:: --help. Display available options (--help-hidden for more). .. option:: --abort-on-invalid-reduction. Abort if any reduction results in invalid IR. .. option::--delta-passes=<string> . Delta passes to run, separated by commas. By default, run all delta passes. .. option:: --in-place . WARNING: This option will replace your input file with the reduced version!. .. option:: --ir-passes=<string> . A textual description of the pass pipeline, same as what's passed to `opt -passes`. .. option:: -j <uint> . Maximum number of threads to use to process chunks. Set to 1 to disable parallelism. .. option:: --max-pass-iterations=<int>. Maximum number of times to run the full set of delta passes (default=5). .. option:: --mtriple=<string> . Set the target triple. .. option:: --preserve-debug-environment. Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps). .. option:: --print-delta-passes . Print list of delta passes, passable to --delta-passes as a comma separated liste. .. option:: --skip-delta-passes=<string> . Delta passes to not run, separated by commas. By default, run all delta passes. .. option:: --starting-granularity-level=<uint>. Number of time",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst:338,redund,redundant,338,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,3,"['abort', 'detect', 'redund']","['abort-on-invalid-reduction', 'detect', 'redundant']"
Safety,"lly be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; modifying code in ways it deems safe according to these constraints, will not; violate their requirements. For example, if the user puts logging statements; in ``retain``, they should not be surprised if those statements are executed; more or less often depending on optimization settings. These constraints are; not exhaustive of the optimization opportunities: values held in local; variables are subject to additional restrictions, described later in this; document. It is undefined behavior if a computation history featuring a send of; ``retain`` followed by a send of ``release`` to the same object, with no; intervening ``release`` on that object, is not equivalent under the high-level; semantics to a computation history in which these sends are removed. Note that; this implies that these methods may not raise exceptions. It is undefined behavior if a computation history features any use whatsoever; of an object following the completion of a send of ``rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:13653,safe,safe,13653,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safe']
Safety,"lly is a; recursive acronym, ""**G**\WP-ASan **W**\ill **P**\rovide **A**\llocation; **SAN**\ity"". GWP-ASan is based on the classic; `Electric Fence Malloc Debugger <https://linux.die.net/man/3/efence>`_, with a; key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-parity where reasonable, and to; support compiler-rt as the reference implementation. Allocator Support; -----------------. GWP-ASan is not a replacement for a traditional allocator. Instead, it works by; inserting stubs into a supporting allo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:1268,detect,detected,1268,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detected']
Safety,"load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3655,safe,safely,3655,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safely']
Safety,"loop (15 mins) after client disconnectionsAvoid potential deadlocks when trying to remove a node from a clusterCorrect matching of incoming connection with previously dropped connectionCorrect export of cluster identificationCorrectly propagate information about files that could not be stagedPrevent endsess deadlock when parallel streams stall due to large WAN RTTFix infinite wait for primary login that will never; happen if you are a manager without a meta-managerPrevent annoying (but not deadly) infinite loop should a; server go offline that is subject to a locate request display.Client sideBetter handling of errno, especially for parallel streamsAllow the client to cycle through all the remaining valid security protocols in the list of protocols returned by the serverMake the readahead strategy more conservativeFix a rare race condition happening when destroying instances with outstanding open requestsEnforce cache coherency in the case of reads+writes in the same fileCorrectly guess the filesize of a file opened for writing in sync modeMake server host name check more flexible for GSI authenticationFix some relevant issues with cache handling on the client, including a rare but fatal bug in; determining the cache holes list and the end of a cache lookupMore complete detection of async read errorsGeneralFix problem in handling the return code; of X509_REQ_verify; in XrdCryptosslX509Req.ccAvoid SEGV when doing an lsd admin command with; authenticated xrootd clientsClose race conditions that allowed a supervisor/manager; to subscribe without declaring a data port. Initialize nostage state in; XrdCmsState to prevent erroneous state declaration during; initialization.Fix a problem with the subject name of proxies of level; > 1; this was creating a failure when a Globus application was; trying to use the proxy certificateFix a problem with cache refreshing in XrdSutCache; affecting automatic reloading of password filesFor now, turn off IPV6 processing as it seems to cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:2618,detect,detection,2618,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,2,['detect'],['detection']
Safety,"lor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->SetStyle(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; A new parameter Canvas.Style in etc/system.rootrc allows; to define the default style. If it is not specified, the Modern; style is used. To use the old default style one can set it to Classic or add. gROOT->SetStyle(""Classic"");; ; to your scripts. We seek feedback on improving the Modern style.; Please leave comments in the forum.; ; The following table shows the two plots hpx->Draw() and hpxpy->Draw(""colz""); in the ""Classic"" and ""Modern"" styles.; . Classic Style; Modern Style. An other example:; ; Classic style:. Modern style:. ACLiC. ACLiC now passes the macro __ACLIC__ to both the rootcint and compiler phases. TWinNTSystem. Fix 64-bit compatibility issues (__asm keyword is not allowed).; Try (as much as possible) to avoid the disturbing ""There is no disk in the drive. Please insert a disk into drive \Device\..."" popup message box when calling AccessPathName() on removable disk drives with no media installed. This should fix the problem reported on the forum.; Prevent short timers (e.g. 10ms) to keep looping in the DispatchOneEvent() infinite loop.; Better stdout/stderr redirection (it was impossible to restore stdout using freopen on Windows 7, leaving the console as a zombie...); Make sure the stdout/stderr redirection works also in the case there is no console (i.e. in stand-alone applications).; Make sure the file descriptors are valid before using them.; The shortcuts are now working on Windows. Building with CMake. ROOT can now be build using the CMake build system (version 2.8). ; The initial supported platforms are Linux(gcc), Windows (vc9), MacOSX(gcc). The installed libraries and executables should be compatible to the standard build of ROOT.  CMake generates native makefiles and workspaces (i.e. Xc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:3336,avoid,avoid,3336,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,2,['avoid'],['avoid']
Safety,"lose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:78716,detect,detect,78716,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['detect'],['detect']
Safety,"low and instruction referencing debug info, corresponding to the earlier; LLVM IR:. ```text; %2:gr32 = ADD32rr %0, %1, implicit-def $eflags, debug-instr-number 1; DBG_INSTR_REF 1, 0, !123, !456, debug-location !789; ```. While the function remains in SSA form, virtual register `%2` is sufficient to; identify the value computed by the instruction -- however the function; eventually leaves SSA form, and register optimisations will obscure which; register the desired value is in. Instead, a more consistent way of identifying; the instruction's value is to refer to the `MachineOperand` where the value is; defined: independently of which register is defined by that `MachineOperand`. In; the code above, the `DBG_INSTR_REF` instruction refers to instruction number; one, operand zero, while the `ADD32rr` has a `debug-instr-number` attribute; attached indicating that it is instruction number one. De-coupling variable locations from registers avoids difficulties involving; register allocation and optimisation, but requires additional instrumentation; when the instructions are optimised instead. Optimisations that replace; instructions with optimised versions that compute the same value must either; preserve the instruction number, or record a substitution from the old; instruction / operand number pair to the new instruction / operand pair -- see; `MachineFunction::substituteDebugValuesForInst`. If debug info maintenance is; not performed, or an instruction is eliminated as dead code, the variable; location is safely dropped and marked ""optimised out"". The exception is; instructions that are mutated rather than replaced, which always need debug info; maintenance. # Register allocator considerations. When the register allocator runs, debugging instructions do not directly refer; to any virtual registers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:2453,avoid,avoids,2453,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['avoid'],['avoids']
Safety,"lowup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] = B[0];. into:. .. code-block:: c. if (rtc) {; auto b = B[0];; for (int i = 0; i < n; i+=1) // versioned loop; A[i] = b;; } else {; for (int i = 0; i < n; i+=1) // unversioned loop; A[i] = B[0];; }. The runtime condition (``rtc``) checks that the array ``A`` and the; element `B[0]` do not alias. Currently, this transformation does not support followup-attributes. Loop Interchange; ----------------. Currently, the ``LoopInterchange`` pass does not use any metadata. Ambiguous Transformation Order; ==============================. If there multiple transformations defined, the order in which they are; executed depends on the order in LLVM's pass pipeline, which is subject; to change. The def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12620,avoid,avoids,12620,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoids']
Safety,"lowup_unrolled`` will set the loop attributes of; the unrolled loop. If not specified, the attributes of the original loop; without the ``llvm.loop.unroll.*`` attributes are copied and; ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll.followup_remainder`` defines the attributes of the; remainder loop. If not specified the remainder loop will have no; attributes. The remainder loop might not be present due to being fully; unrolled in which case this attribute has no effect. Attributes defined in ``llvm.loop.unroll.followup_all`` are added to the; unrolled and remainder loops. To avoid that the partially unrolled loop is unrolled again, it is; recommended to add ``llvm.loop.unroll.disable`` to; ``llvm.loop.unroll.followup_all``. If no follow-up attribute specified; for a generated loop, it is added automatically. Unroll-And-Jam; --------------. Unroll-and-jam uses the following transformation model (here with an; unroll factor if 2). Currently, it does not support a fallback version; when the transformation is unsafe. .. code-block:: c. for (int i = 0; i < n; i+=1) { // original outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // original inner loop; SubLoop(i, j);; Aft(i);; }. .. code-block:: c. int i = 0;; for (; i + 1 < n; i+=2) { // unrolled outer loop; Fore(i);; Fore(i+1);; for (int j = 0; j < m; j+=1) { // unrolled inner loop; SubLoop(i, j);; SubLoop(i+1, j);; }; Aft(i);; Aft(i+1);; }; for (; i < n; i+=1) { // remainder outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // remainder inner loop; SubLoop(i, j);; Aft(i);; }. ``llvm.loop.unroll_and_jam.followup_outer`` will set the loop attributes; of the unrolled outer loop. If not specified, the attributes of the; original outer loop without the ``llvm.loop.unroll.*`` attributes are; copied and ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll_and_jam.followup_inner`` will set the loop attributes; of the unrolled inner loop. If not specified, the attributes of the; original inner loop are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:8938,unsafe,unsafe,8938,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['unsafe'],['unsafe']
Safety,"lso optimize constants by emitting them directly in the stack map,; either in the ``Offset`` of a ``Constant`` location or in the constant; pool, referred to by ``ConstantIndex`` locations. At each callsite, a ""liveout"" register list is also recorded. These; are the registers that are live across the stackmap and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15291,safe,safely,15291,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['safe'],['safely']
Safety,"lt behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:194906,detect,detected,194906,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"lt of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954547,detect,detection,954547,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detection']
Safety,"ltin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its first argument ``expr`` is expected to take the; value of its second argument ``val``. It always returns ``expr``. Query for this feature with ``__has_builtin(__builtin_expect)``. ``__builtin_expect_with_probability``; -------------------------------------. ``__builtin_expect_with_probability`` is similar to ``__builtin_expect`` but it; takes a probability as third argument. **Syntax**:. .. code-block:: c++. long __builtin_expect_with_probability(long expr, long val, double p). **Example of use**:. .. code-block:: c++. if (__builtin_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115141,predict,prediction,115141,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['predict'],['prediction']
Safety,"lting semantics provides a new notion of ""cycle iteration"" even for; irreducible cycles. But this allows a natural loop to have a heart in a; node other than its header, which has interesting consequences on the; meaning of a loop iteration in terms of convergence. For now, we disallow; this situation since its practical application is very rare. .. _llvm.experimental.convergence.anchor:. ``llvm.experimental.convergence.anchor``; ----------------------------------------. .. code-block:: llvm. token @llvm.experimental.convergence.anchor() convergent readnone. This intrinsic produces an initial convergence token that is independent from; any ""outer scope"". The set of threads executing converged dynamic instances of; this intrinsic is implementation-defined. It is an error to pass a ``convergencectrl`` operand bundle at a; call to this intrinsic. .. note::. The expectation is that all threads within a group that ""happen to be active; at the same time"" will execute converged dynamic instances, so that programs; can detect the maximal set of threads that can communicate efficiently within; some local region of the program. .. _convergence_uncontrolled:. Uncontrolled Convergent Operations; ==================================. Convergent operations with an explicit ``convergencectrl`` operand bundle are; called *controlled convergent operations*. All other convergent operations are; said to be *uncontrolled*. An uncontrolled convergent operation is said to have *implicit convergence; control* determined by the ``convergent`` attribute alone. The semantics of the; ``convergent`` attribute as implemented in LLVM differs from the documented; semantics. The implementation tries to follow common intuition about convergent; operations, which remains under-specified. As such, it is not possible to fully; translate implicit convergence control into explicit convergence control tokens,; and these two modes cannot be mixed in the same function. If a function contains a controlled conv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:27012,detect,detect,27012,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['detect'],['detect']
Safety,"lude full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related information. In the following somewhat; nonsensical example you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error. Because clang prints a; point, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about.; Range information is very useful for; cases involving precedence issues and many other cases. $ gcc-4.9 -fsyntax-only t.c; t.c: In function 'int f(int, int)':; t.c:7:39: error: invali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:1668,detect,detected,1668,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,2,['detect'],['detected']
Safety,"lue ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 7, i32 7); ret i8 addrspace(1)* %obj.relocated; }. Ideally, this sequence would have been represented as a M argument, N; return value function (where M is the number of values being; relocated + the original call arguments and N is the original return; value + each relocated value), but LLVM does not easily support such a; representation. Instead, the statepoint intrinsic marks the actual site of the; safepoint or statepoint. The statepoint returns a token value (which; exists only at compile time). To get back the original return value; of the call, we use the ``gc.result`` intrinsic. To get the relocation; of each pointer in turn, we use the ``gc.relocate`` intrinsic with the; appropriate index. Note that both the ``gc.relocate`` and ``gc.result`` are; tied to the statepoint. The combination forms a ""statepoint relocation; sequence"" and represents the entirety of a parseable call or 'statepoint'. When lowered, this example would generate the following x86 assembly:. .. code-block:: gas. 	 .globl	test1; 	 .align	16, 0x90; 	 pushq	%rax; 	 callq	foo; .Ltmp1:; 	 movq	(%rsp), %rax # This load is redundant (oops!); 	 popq	%rdx; 	 retq. Each of the potentially relocated values has been spilled to the; stack, and a record of that location has been recorded to the; :ref:`Stack Map section <stackmap-section>`. If the garbage collector; needs to update any of these pointe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:9577,safe,safepoint,9577,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"lue of an address to indicate the object it is associated; with. If the garbage collector wishes to move any object, the; compiler must provide a mapping, for each pointer, to an indication of; its allocation. To simplify the interaction between a collector and the compiled code,; most garbage collectors are organized in terms of three abstractions:; load barriers, store barriers, and safepoints. #. A load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3138,safe,safepoint,3138,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"lumns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1668,predict,prediction,1668,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['predict'],['prediction']
Safety,"ly be compiled with the -std=c++11 and -std=gnu++11; // options, because rvalue references are only standardized in C++11.; #endif. #if __has_extension(cxx_rvalue_references); // This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98; // and -std=gnu++98 options, because rvalue references are supported as a; // language extension in C++98.; #endif. .. _langext-has-feature-back-compat:. For backward compatibility, ``__has_feature`` can also be used to test; for support for non-standardized features, i.e. features not prefixed ``c_``,; ``cxx_`` or ``objc_``. Another use of ``__has_feature`` is to check for compiler features not related; to the language standard, such as e.g. :doc:`AddressSanitizer; <AddressSanitizer>`. If the ``-pedantic-errors`` option is given, ``__has_extension`` is equivalent; to ``__has_feature``. The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evalu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:4746,avoid,avoid,4746,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"ly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing work on developing such; a verifier. Please ask on llvm-dev if you're interested in; experimenting with the current version. .. _statepoint-utilities:. Utility Passes for Safepoint Insertion; ======================================. .. _RewriteStatepointsForGC:. RewriteStatepointsForGC; ^^^^^^^^^^^^^^^^^^^^^^^^. The pass RewriteStatepointsForGC transforms a function's IR to lower from the; abstract machine model described above to the explicit statepoint model of; relocations. To do this, it replaces all calls or invokes of functions which; might contain a safepoint poll with a ``gc.statepoint`` and associated full; relocation sequence, including all required ``gc.relocates``. This pass only applies to GCStrategy instances where the ``UseRS4GC`` flag; is set. The two builtin GC strategies with this set are the; ""statepoint-example"" and ""coreclr"" strategies. As an example, given this code:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void @foo(); ret i8 addrspace(1)* %obj; }. The pass would produce this IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 12, i32 12); ret i8 addr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:25602,safe,safepoint,25602,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"m of CPU time. More detailed information on the new mathematical functions can be found in this presentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms like TMath::LocMin, TMath::LocMax or TMath::Permute the original implementation is faster than STL and has been maintained.; ; Add a generic iterator interface, similar to the STL algorithm interface, to the following TMath functions:; MinElement, MaxElement, LocMin, LocMax, Mean, GeomMean, RMS,; BinarySearch. The iterator interface for sort is called; TMath::SortItr to avoid a compilation ambiguity. For example,; for finding the mean of a std::vector<double> v, one simply needs to call TMath::Mean(v.begin(), v.end() ) .; ; Various changes have been applied to the mathematical functions to remove duplications in the implementation with the special and statistical functions defined in ROOT::Math. The functions which have been changed and thus they can return a sightly different result than before are:; ; TMath::Erf and TMath::Erfc call ROOT::Math::erf and ROOT::math::erfc which are implemented using the Cephes algorithms, which is accurate at the required double precision level.; TMath::Gamma(z) is implemented with ROOT::Math::tgamma, which again uses Cephes.; The incomplete gamma function, TMath::Gamma(a,x) it is implemented using ROOT::Math::inc_gamma based on a corresponding Cephes function.; TMath::Prob (the upper chi2 probability) is implemented also using ROOT::Math::chisquared_cdf_c which uses ROOT::Math::inc_gamma_c based on a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:2373,avoid,avoid,2373,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['avoid'],['avoid']
Safety,"m.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310731,avoid,avoid,310731,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"mand erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanvas * canvas = new TCanvas(""glC"",""C"",800,800);; TH3D *h = new TH3D(""h3"",""h3"",150,0,20,150,-5,5,150,-5,5);; ntuple->Draw(""px:py+1:pz+4.7>>h3"","""",""Q"");; }. TGraph. TGraph::SavePrimitive() uses a greater precision to output the; X and Y vectors. The following macro generated a wrong output (tmp.C). void testGraphPrec() {; double offset=55.0;; TCanvas* myC = new TCanvas(""myC"",""myC"",600,400);; TGraph* gr=new TGraph();; for (int i=0; i < 1000; i++) {; double",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:2359,avoid,avoid,2359,hist/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html,2,['avoid'],['avoid']
Safety,"mdgpu_synid_integer_number>` or; :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Examples:. .. parsed-literal::. mul:2; mul:x // x must be equal to 2 or 4. .. _amdgpu_synid_vop3_operand_modifiers:. VOP3 Operand Modifiers; ----------------------. Operand modifiers are not used separately. They are applied to source operands. .. _amdgpu_synid_abs:. abs; ~~~. Computes the absolute value of its operand. Must be applied before :ref:`neg<amdgpu_synid_neg>`; (if any). Valid for floating-point operands only. ======================================== ====================================================; Syntax Description; ======================================== ====================================================; abs(<operand>) Get the absolute value of a floating-point operand.; \|<operand>| The same as above (an SP3 syntax).; ======================================== ====================================================. Note: avoid using SP3 syntax with operands specified as expressions because the trailing '|'; may be misinterpreted. Such operands should be enclosed into additional parentheses, as shown; in examples below. Examples:. .. parsed-literal::. abs(v36); \|v36|; abs(x|y) // ok; \|(x|y)| // additional parentheses are required. .. _amdgpu_synid_neg:. neg; ~~~. Computes the negative value of its operand. Must be applied after :ref:`abs<amdgpu_synid_abs>`; (if any). Valid for floating-point operands only. ================== ====================================================; Syntax Description; ================== ====================================================; neg(<operand>) Get the negative value of a floating-point operand.; An optional :ref:`abs<amdgpu_synid_abs>` modifier; may be applied to the operand before negation.; -<operand> The same as above (an SP3 syntax).; ================== ====================================================. Note: SP3 syntax is supported with limitations because of a potential ambiguity.; Currently, it is allo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:55969,avoid,avoid,55969,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['avoid'],['avoid']
Safety,"me optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectre variant #2"" vulnerabilities. When inlining, the attribute is sticky. Inlining a function that carries; this attribute will cause the caller to gain the att",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100881,safe,safety,100881,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"mechanisms and interfaces provided by LLVM to; support accurate garbage collection. Goals and non-goals; -------------------. LLVM's intermediate representation provides :ref:`garbage collection intrinsics; <gc_intrinsics>` that offer support for a broad class of collector models. For; instance, the intrinsics permit:. * semi-space collectors. * mark-sweep collectors. * generational collectors. * incremental collectors. * concurrent collectors. * cooperative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize increm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:5932,safe,safepoint,5932,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safepoint']
Safety,"mehow. Yes yes yes! :) I think it would be *VERY* useful to include this kind; of information (which EPIC architectures *implicitly* encode. The trend; that we are seeing supports this greatly:. 1. Commodity processors are getting massive SIMD support:; * Intel/Amd MMX/MMX2; * AMD's 3Dnow!; * Intel's SSE/SSE2; * Sun's VIS; 2. SMP is becoming much more common, especially in the server space.; 3. Multiple processors on a die are right around the corner. If nothing else, not designing this in would severely limit our future; expansion of the project... > Also, this will require some reading on at least two other; > projects:; > -- Multiscalar architecture from Wisconsin; > -- Simultaneous multithreading architecture from Washington; >; > o Or forget all this and stick to a traditional instruction set?. Heh... :) Well, from a pure research point of view, it is almost more; attactive to go with the most extreme/different ISA possible. On one axis; you get safety and conservatism, and on the other you get degree of; influence that the results have. Of course the problem with pure research; is that often times there is no concrete product of the research... :). > BTW, on an unrelated note, after the meeting yesterday, I did remember; > that you had suggested doing instruction scheduling on SSA form instead; > of a dependence DAG earlier in the semester. When we talked about; > it yesterday, I didn't remember where the idea had come from but I; > remembered later. Just giving credit where its due... :) Thanks. . > Perhaps you can save the above as a file under RCS so you and I can; > continue to expand on this. I think it makes sense to do so when we get our ideas more formalized and; bounce it back and forth a couple of times... then I'll do a more formal; writeup of our goals and ideas. Obviously our first implementation will; not want to do all of the stuff that I pointed out above... be we will; want to design the project so that we do not artificially limit ourselves; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:8349,safe,safety,8349,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['safe'],['safety']
Safety,"ment (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spilled to stack.; The `RET` instruction is replaced with a load of the jump table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:26177,abort,abort,26177,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['abort'],['abort']
Safety,"ments, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Consumed parameters; ^^^^^^^^^^^^^^^^^^^. A function or method parameter of retainable object pointer type may be marked; as :arc-term:`consumed`, signifying that the callee expects to take ownership; of a +1 retain count. This is done by adding the ``ns_consumed`` attribute to; the parameter declaration, like so:. .. code-block:: objc. void foo(__attribute((ns_consumed)) id x);; - (void) foo: (id) __attribute((ns_consumed)) x;. This attribute is part of the type of the function or method, not the type of; the parameter. It controls only how the argument is passed and received. When passing such an argument, ARC retains the argument prior to making the; call. When receiving such an argument, ARC releases",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:16308,avoid,avoid,16308,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoid']
Safety,"meter correlations, and worst of all cannot be expected to converge; accurately to the minimum in a finite time. Its estimate of the; *expected distance to the minimum* $\mbox{EDM}$ is largely fantasy,; so it would not even know if it did converge. ## Floating point precision ##. M figures out at execution time the machine precision [api:epsmac], and; assumes that $\mbox{FCN}$ provides about the same precision. That; means not just the length of the numbers used and returned by; $\mbox{FCN}$, but the actual mathematical accuracy of the; calculations. Section [install:epsmac] describes what to do if this is; not the case. ## Parameter limits ##. Putting limits (absolute bounds) on the allowed values for a given; parameter, causes M to make a non-linear transformation of its own; internal parameter values to obtain the (external) parameter values; passed to $\mbox{FCN}$. To understand the adverse effect of limits,; see [intro:limits]. Basically, the use of limits should be avoided unless needed to keep the; parameter inside a desired range. If parameter limits are needed, in spite of the effects described in; Chapter One, then the user should be aware of the following techniques; to alleviate problems caused by limits. ### Getting the Right Minimum with Limits ###. If $\mbox{MIGRAD}$ converges normally to a point where no parameter; is near one of its limits, then the existence of limits has probably not; prevented M from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimizer has become ""blocked"" at a limit. This may normally happen only; if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{ \pi}{ 2}$ that M prints a warning to this effect; when it prints the parameter values. The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer; $\partia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:63595,avoid,avoided,63595,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoided']
Safety,"milar to how; MCJIT is commonly used). However ORC also provides built-in support for lazy; compilation via lazy-reexports (see :ref:`Laziness`). **Support for Custom Compilers and Program Representations**; Clients can supply custom compilers for each symbol that they define in their; JIT session. ORC will run the user-supplied compiler when the a definition of; a symbol is needed. ORC is actually fully language agnostic: LLVM IR is not; treated specially, and is supported via the same wrapper mechanism (the; ``MaterializationUnit`` class) that is used for custom compilers. **Concurrent JIT'd code** and **Concurrent Compilation**; JIT'd code may be executed in multiple threads, may spawn new threads, and may; re-enter the ORC (e.g. to request lazy compilation) concurrently from multiple; threads. Compilers launched my ORC can run concurrently (provided the client; sets up an appropriate dispatcher). Built-in dependency tracking ensures that; ORC does not release pointers to JIT'd code or data until all dependencies; have also been JIT'd and they are safe to call or use. **Removable Code**; Resources for JIT'd program representations. **Orthogonality** and **Composability**; Each of the features above can be used independently. It is possible to put; ORC components together to make a non-lazy, in-process, single threaded JIT; or a lazy, out-of-process, concurrent JIT, or anything in between. LLJIT and LLLazyJIT; ===================. ORC provides two basic JIT classes off-the-shelf. These are useful both as; examples of how to assemble ORC components to make a JIT, and as replacements; for earlier LLVM JIT APIs (e.g. MCJIT). The LLJIT class uses an IRCompileLayer and RTDyldObjectLinkingLayer to support; compilation of LLVM IR and linking of relocatable object files. All operations; are performed eagerly on symbol lookup (i.e. a symbol's definition is compiled; as soon as you attempt to look up its address). LLJIT is a suitable replacement; for MCJIT in most cases (no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:3208,safe,safe,3208,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['safe'],['safe']
Safety,"mine what proportion of rules were; successfully imported. The easiest way to use this is to copy the; ``-gen-globalisel`` tablegen command from ``ninja -v`` and modify it. Similarly, the ``--warn-on-skipped-patterns`` option can be used to obtain the; reasons that rules weren't imported. This can be used to focus on the most; important rejection reasons. PatLeaf Predicates; ^^^^^^^^^^^^^^^^^^. PatLeafs cannot be imported because their C++ is implemented in terms of; ``SDNode`` objects. PatLeafs that handle immediate predicates should be; replaced by ``ImmLeaf``, ``IntImmLeaf``, or ``FPImmLeaf`` as appropriate. There's no standard answer for other PatLeafs. Some standard predicates have; been baked into TableGen but this should not generally be done. Custom SDNodes; ^^^^^^^^^^^^^^. Custom SDNodes should be mapped to Target Pseudos using ``GINodeEquiv``. This; will cause the instruction selector to import them but you will also need to; ensure the target pseudo is introduced to the MIR before the instruction; selector. Any preceding pass is suitable but the legalizer will be a; particularly common choice. ComplexPatterns; ^^^^^^^^^^^^^^^. ComplexPatterns cannot be imported because their C++ is implemented in terms of; ``SDNode`` objects. GlobalISel versions should be defined with; ``GIComplexOperandMatcher`` and mapped to ComplexPattern with; ``GIComplexPatternEquiv``. The following predicates are useful for porting ComplexPattern:. * isBaseWithConstantOffset() - Check for base+offset structures; * isOperandImmEqual() - Check for a particular constant; * isObviouslySafeToFold() - Check for reasons an instruction can't be sunk and folded into another. There are some important points for the C++ implementation:. * Don't modify MIR in the predicate; * Renderer lambdas should capture by value to avoid use-after-free. They will be used after the predicate returns.; * Only create instructions in a renderer lambda. GlobalISel won't clean up things you create but don't use. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst:3479,avoid,avoid,3479,interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,1,['avoid'],['avoid']
Safety,"mis-behaving passes, you; can debug incorrect code generation by either LLC or the JIT, using; ``bugpoint``. The process ``bugpoint`` follows in this case is to try to; narrow the code down to a function that is miscompiled by one or the other; method, but since for correctness, the entire program must be run,; ``bugpoint`` will compile the code it deems to not be affected with the C; Backend, and then link in the shared object it generates. To debug the JIT:. .. code-block:: bash. bugpoint -run-jit -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to lli] \; --args -- [program arguments]. Similarly, to debug the LLC, one would run:. .. code-block:: bash. bugpoint -run-llc -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to llc] \; --args -- [program arguments]. **Special note:** if you are debugging MultiSource or SPEC tests that; already exist in the ``llvm/test`` hierarchy, there is an easier way to; debug the JIT, LLC, and CBE, using the pre-written Makefile targets, which; will pass the program options specified in the Makefiles:. .. code-block:: bash. cd llvm/test/../../program; make bugpoint-jit. At the end of a successful ``bugpoint`` run, you will be presented; with two bitcode files: a *safe* file which can be compiled with the C; backend and the *test* file which either LLC or the JIT; mis-codegenerates, and thus causes the error. To reproduce the error that ``bugpoint`` found, it is sufficient to do; the following:. #. Regenerate the shared object from the safe bitcode file:. .. code-block:: bash. llc -march=c safe.bc -o safe.c; gcc -shared safe.c -o safe.so. #. If debugging LLC, compile test bitcode native and link with the shared; object:. .. code-block:: bash. llc test.bc -o test.s; gcc test.s safe.so -o test.llc; ./test.llc [program options]. #. If debugging the JIT, load the shared object and supply the test; bitcode:. .. code-block:: bash. lli -load=safe.so test.bc [program options]; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:10618,safe,safe,10618,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,8,['safe'],['safe']
Safety,"mmend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13698,avoid,avoid,13698,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['avoid'],['avoid']
Safety,"modify it. For example, if you distribute copies of such a program, whether; gratis or for a fee, you must give the recipients all the rights that; you have. You must make sure that they, too, receive or can get the; source code. And you must show them these terms so they know their; rights. We protect your rights with two steps: (1) copyright the software, and; (2) offer you this license which gives you legal permission to copy,; distribute and/or modify the software. Also, for each author's protection and ours, we want to make certain; that everyone understands that there is no warranty for this free; software. If the software is modified by someone else and passed on, we; want its recipients to know that what they have is not the original, so; that any problems introduced by others will not reflect on the original; authors' reputations. Finally, any free program is threatened constantly by software; patents. We wish to avoid the danger that redistributors of a free; program will individually obtain patent licenses, in effect making the; program proprietary. To prevent this, we have made it clear that any; patent must be licensed for everyone's free use or not licensed at all. The precise terms and conditions for copying, distribution and; modification follow. GNU GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License applies to any program or other work which contains; a notice placed by the copyright holder saying it may be distributed; under the terms of this General Public License. The ""Program"", below,; refers to any such program or work, and a ""work based on the Program""; means either the Program or any derivative work under copyright law:; that is to say, a work containing the Program or a portion of it,; either verbatim or with modifications and/or translated into another; language. (Hereinafter, translation is included without limitation in; the term ""modification"".) Each licensee is addressed as ""you"". Ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:2472,avoid,avoid,2472,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,4,['avoid'],['avoid']
Safety,"module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16988,avoid,avoid,16988,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['avoid'],['avoid']
Safety,"monitoring information from the master; at each GetNextPacket (at each call of TPerfStat::PacketEvent) to allow; extrnal real-time progress monitoring.; Save the status of a 'proofserv' session into a new file; in the 'activesessions' area. The full path of the new file is;          ; <admin_path>/.xproofd.<port>/activesessions/<user>.<group>.<pid>.status. The status indicates whether the session is idle, running or queued.; The status is updated every 'checkfq' secs (see xpd.proofservmgr;; default 30 s). The status is dumped by the reader thread of TXProofServ; and therefore its r/w access is protected. Enable the use of the tree cache also for local files,; adapting the default settings for the cache to the recent changes; In the XrdProofd plug-in. Improve synchronization between parent and child during; fork; Optimize loops over directory entries; Improve error and notification messages. Improved handling of Ctrl-C; this follows from a fix in; TMonitor and an improved handling of non-finished query state in the; workers (results are not send to master if the query was aborted) . Fixes. TFileMerger. Fix a problem preventing correct transmission of all; non-mergeable objects (fixes bug #52886); Remove the argument isdir from the function; MergeRecursive; Do not remove the first file in the list when returning; from MergeRecursive (fixes bug #54591); Fix a major leak when merging files with collections; written using kSingleKey option.  The merger was reading each; key in memory and deleted the object at the end, but the container is; not owner by default, so all objects inside leaked. PROOF-Lite. Fix a couple of memory leaks showing up when running; repeated queries; Fix a problem in TProofServ::CopyFromCache affecting; the case where the sandbox dir has a '.' and the macro name has no '.',; e.g. compiled selectors in PROOF-Lite. TProofOutputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:6463,abort,aborted,6463,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,['abort'],['aborted']
Safety,"more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192422,safe,safe,192422,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"move_element_unordered_atomic_*``' symbol. Such a call can not; take a safepoint. Otherwise, the call is made GC parseable by wrapping the; call into a statepoint. This makes it possible to take a safepoint during; copy operation. Note that a GC parseable copy operation is not required to; take a safepoint. For example, a short copy operation may be performed without; taking a safepoint. GC parseable calls to '``llvm.memcpy.element.unordered.atomic.*``',; '``llvm.memmove.element.unordered.atomic.*``' intrinsics are lowered to calls; to '``__llvm_memcpy_element_unordered_atomic_safepoint_*``',; '``__llvm_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:30910,safe,safepoint,30910,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"mprises of the following classes. :LoopVectorizationPlanner:; A LoopVectorizationPlanner is designed to handle the vectorization of a loop; or a loop nest. It can construct, optimize and discard one or more VPlans,; each VPlan modelling a distinct way to vectorize the loop or the loop nest.; Once the best VPlan is determined, including the best VF and UF, this VPlan; drives the generation of output IR. :VPlan:; A model of a vectorized candidate for a given input IR loop or loop nest. This; candidate is represented using a Hierarchical CFG. VPlan supports estimating; the cost and driving the generation of the output IR code it represents. :Hierarchical CFG:; A control-flow graph whose nodes are basic-blocks or Hierarchical CFG's. The; Hierarchical CFG data structure is similar to the Tile Tree [5]_, where; cross-Tile edges are lifted to connect Tiles instead of the original; basic-blocks as in Sharir [6]_, promoting the Tile encapsulation. The terms; Region and Block are used rather than Tile [5]_ to avoid confusion with loop; tiling. :VPBlockBase:; The building block of the Hierarchical CFG. A pure-virtual base-class of; VPBasicBlock and VPRegionBlock, see below. VPBlockBase models the hierarchical; control-flow relations with other VPBlocks. Note that in contrast to the IR; BasicBlock, a VPBlockBase models its control-flow successors and predecessors; directly, rather than through a Terminator branch or through predecessor; branches that ""use"" the VPBlockBase. :VPBasicBlock:; VPBasicBlock is a subclass of VPBlockBase, and serves as the leaves of the; Hierarchical CFG. It represents a sequence of output IR instructions that will; appear consecutively in an output IR basic-block. The instructions of this; basic-block originate from one or more VPBasicBlocks. VPBasicBlock holds a; sequence of zero or more VPRecipes that model the cost and generation of the; output IR instructions. :VPRegionBlock:; VPRegionBlock is a subclass of VPBlockBase. It models a collection of; V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst:5026,avoid,avoid,5026,interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,1,['avoid'],['avoid']
Safety,"mproving performance especially for TTree::Map() by about 35%. This has been achieved with a better caching strategy for request strings (especially avoiding to recalculate the auth base64 encoding), and with a drastic optimization in reading the response headers.; Fixes in the counting of the bytes read. TWebSystem. New implementation of TSystem allowing to use TSystem::AccessPathName() and GetPathInfo() to check if a web file exists and to get its size. Directory browsing is not available yet. NETX; ; TXNetFile. Several fixes and optimisations, mainly in the use of the cache; Fix an offset issue affecting the use of the cache with files in archives. TXNetSystem. A few optimizations in the use of retry mechanism, path locality checks, file online checks. XROOTD. Import a new version of XROOTD (20091202-0509); ; Fixes in bulk prepare and sync readv operations; Add support for 'make install' / 'make uninstall' and; other improvements in configure.classic; Several improvements / fixes:; ; reduced memory and CPU consumption;; extreme cp optimizations;; windows porting; new cache policies on the client side; new listing features implemented recently in the 'cns' module.; optimizations in cmsd and cnsd (performance improvements); support for openssl 1.0.0 (required by Fedora 12). Support for if/else if/else/fi constructs; Several portability fixes; ; Support 32-bit builds with icc on 64-bit platforms; Improved detection of libreadline and lib(n)curses. Increase the flexibility for configuring with an external xrootd; ; Add standard switches to disentangle lib and inc dirs;       --with-xrootd-incdir=<path_to dir_containing_XrdVersion.hh>;       --with-xrootd-libdir=<path_to_dir_containing_xrootd_plugins_and_libs>; ; When; passing a global xrootd dir with --with-xrootd, check both; src/XrdVersion.hh and include/xrootd/XrdVersion.hh so that both build; and install distributions are supported. Fix a problem with the xrootd build when running make via 'sudo' (issue #47644). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html:1497,detect,detection,1497,net/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html,2,['detect'],['detection']
Safety,"must be followed by a ``DBG_VALUE`` use of that def. If; an instruction does not define a register, but can be followed by a debug inst,; MIRDebugify inserts a ``DBG_VALUE`` that references a constant. Insertion of; ``DBG_VALUE``'s can be disabled by setting ``-debugify-level=locations``. To run MIRDebugify once, simply insert ``mir-debugify`` into your ``llc``; invocation, like:. .. code-block:: bash. # Before some other pass.; $ llc -run-pass=mir-debugify,other-pass ... # After some other pass.; $ llc -run-pass=other-pass,mir-debugify ... To run MIRDebugify before each pass in a pipeline, use; ``-debugify-and-strip-all-safe``. This can be combined with ``-start-before``; and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-and-strip-all-safe -O1 <other llc args>. If you want to check it after each pass in a pipeline, use; ``-debugify-check-and-strip-all-safe``. This can also be combined with; ``-start-before`` and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>. To check all debug info from a test, use ``mir-check-debugify``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-check-debugify. To strip out all debug info from a test, use ``mir-strip-debug``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-strip-debug. It can be useful to combine ``mir-debugify``, ``mir-check-debugify`` and/or; ``mir-strip-debug`` to identify backend transformations which break in; the presence of debug info. For example, to run the AArch64 backend tests; with all normal passes ""sandwiched"" in between MIRDebugify and; MIRStripDebugify mutation passes, run:. .. code-block:: bash. $ llvm-lit test/CodeGen/AArch64 -Dllc=""llc -debugify-and-strip-all-safe"". Using LostDebugLocObserver; --------------------------. TODO; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:18518,safe,safe,18518,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,3,['safe'],['safe']
Safety,"n %0, i32 12, i32 12); ret i8 addrspace(1)* %obj.relocated; }. In the above examples, the addrspace(1) marker on the pointers is the mechanism; that the ``statepoint-example`` GC strategy uses to distinguish references from; non references. This is controlled via GCStrategy::isGCManagedPointer. The; ``statepoint-example`` and ``coreclr`` strategies (the only two default; strategies that support statepoints) both use addrspace(1) to determine which; pointers are references, however custom strategies don't have to follow this; convention. This pass can be used an utility function by a language frontend that doesn't; want to manually reason about liveness, base pointers, or relocation when; constructing IR. As currently implemented, RewriteStatepointsForGC must be; run after SSA construction (i.e. mem2ref). RewriteStatepointsForGC will ensure that appropriate base pointers are listed; for every relocation created. It will do so by duplicating code as needed to; propagate the base pointer associated with each pointer being relocated to; the appropriate safepoints. The implementation assumes that the following; IR constructs produce base pointers: loads from the heap, addresses of global; variables, function arguments, function return values. Constant pointers (such; as null) are also assumed to be base pointers. In practice, this constraint; can be relaxed to producing interior derived pointers provided the target; collector can find the associated allocation from an arbitrary interior; derived pointer. By default RewriteStatepointsForGC passes in ``0xABCDEF00`` as the statepoint; ID and ``0`` as the number of patchable bytes to the newly constructed; ``gc.statepoint``. These values can be configured on a per-callsite; basis using the attributes ``""statepoint-id""`` and; ``""statepoint-num-patch-bytes""``. If a call site is marked with a; ``""statepoint-id""`` function attribute and its value is a positive; integer (represented as a string), then that value is used as the ID",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:27606,safe,safepoints,27606,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"n __libc_start_main ??:0; ==9442== ABORTING. If that does not work for you (e.g. your process is sandboxed), you can use a; separate script to symbolize the result offline (online symbolization can be; force disabled by setting ``ASAN_OPTIONS=symbolize=0``):. .. code-block:: console. % ASAN_OPTIONS=symbolize=0 ./a.out 2> log; % projects/compiler-rt/lib/asan/scripts/asan_symbolize.py / < log | c++filt; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:5366,detect,detect,5366,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detect']
Safety,"n area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8503,predict,prediction,8503,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['prediction']
Safety,"n badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly sc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62937,recover,recovers,62937,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['recover'],['recovers']
Safety,"n be; additional cycles between any two loops where one is contained in the other.; However, an LLVM :ref:`cycle<cycle-terminology>` covers both, loops and; irreducible control flow. * The `FixIrreducible <https://llvm.org/doxygen/FixIrreducible_8h.html>`_; pass can transform irreducible control flow into loops by inserting; new loop headers. It is not included in any default optimization pass; pipeline, but is required for some back-end targets. * Exiting edges are not the only way to break out of a loop. Other; possibilities are unreachable terminators, [[noreturn]] functions,; exceptions, signals, and your computer's power button. * A basic block ""inside"" the loop that does not have a path back to the; loop (i.e. to a latch or header) is not considered part of the loop.; This is illustrated by the following code. .. code-block:: C. for (unsigned i = 0; i <= n; ++i) {; if (c1) {; // When reaching this block, we will have exited the loop.; do_something();; break;; }; if (c2) {; // abort(), never returns, so we have exited the loop.; abort();; }; if (c3) {; // The unreachable allows the compiler to assume that this will not rejoin the loop.; do_something();; __builtin_unreachable();; }; if (c4) {; // This statically infinite loop is not nested because control-flow will not continue with the for-loop.; while(true) {; do_something();; }; }; }. * There is no requirement for the control flow to eventually leave the; loop, i.e. a loop can be infinite. A **statically infinite loop** is a; loop that has no exiting edges. A **dynamically infinite loop** has; exiting edges, but it is possible to be never taken. This may happen; only under some circumstances, such as when n == UINT_MAX in the code; below. .. code-block:: C. for (unsigned i = 0; i <= n; ++i); body(i);. It is possible for the optimizer to turn a dynamically infinite loop; into a statically infinite loop, for instance when it can prove that the; exiting condition is always false. Because the exiting edge is never",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:6345,abort,abort,6345,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['abort'],['abort']
Safety,"n exception. A program may be compiled with the option ``-fobjc-arc-exceptions`` in order to; enable these, or with the option ``-fno-objc-arc-exceptions`` to explicitly; disable them, with the last such argument ""winning"". .. admonition:: Rationale. The standard Cocoa convention is that exceptions signal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default. .. admonition:: Rationale. C++ already introduces pervasive exceptions-cleanup code of the sort that ARC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:99047,safe,safety,99047,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safety']
Safety,"n hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visibility. All; other classes receive hidden LTO visibility. Classes with internal linkage; (e.g. classes declared in unnamed namespaces) also receive hidden LTO; visibility. During the LTO link, all classes with public LTO visibility but not marked with; ``[[clang::lto_visibility_public]]`` (see below) will be refined to hidden LTO; visibility when the ``--lto-whole-program-visibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:2814,unsafe,unsafe,2814,interpreter/llvm-project/clang/docs/LTOVisibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst,1,['unsafe'],['unsafe']
Safety,"n needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer << arr;; }; ```; which would only really stream the array at the first iteration because it will be detected has having the same address and thus assumed to be the same object. We can now do:; ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer.WriteObject(&arr, kFALSE);; }; ```; where the last argument of WriteObject tells the buffer do *not* remember this object's address and to always stream it. This feature is also available via WriteObjectAny. - Added a new mechanism for providing clean forward-compatibility breaks in a ``TTree`` (i.e., a newer version of ROOT writes a ``TTree`` an older version cannot read). When future versions of ROOT utilize an IO feature that this version does not support, ROOT will provide a clear error message instead of crashing or returning garbage data. In future ROOT6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:6997,detect,detected,6997,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['detect'],['detected']
Safety,"n object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3545,abort,aborts,3545,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['abort'],['aborts']
Safety,"n obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18124,avoid,avoid,18124,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['avoid'],['avoid']
Safety,"n of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This is a performance consideration: ``lib/Support`` functions are; at the bottom of many call chains and as such can be frequently called. We; need them to be as efficient as possible. However, no routines in the system; library should actually throw exceptions. Code Organization; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:8889,avoid,avoids,8889,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['avoid'],['avoids']
Safety,"n operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The innermost loop may contain complex; nesting of IFs, ELSEs and even GOTOs. .. code-block:: c++. int foo(int *A, int *B, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); if (A[i] > B[i]); sum += A[i] + 5;; return sum;; }. Pointer Induction Variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. This example uses the ""accumulate"" function of the standard c++ library. This; loop uses C++ iterators, which are pointers, and not integer indices.; The Loop Vectorizer detects pointer induction variables and can vectorize; this loop. This feature is important because many C++ programs use iterators. .. code-block:: c++. int baz(int *A, int n) {; return std::accumulate(A, A + n, 0);; }. Reverse Iterators; ^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize loops that count backwards. .. code-block:: c++. void foo(int *A, int n) {; for (int i = n; i > 0; --i); A[i] +=1;; }. Scatter / Gather; ^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize code that becomes a sequence of scalar instructions; that scatter/gathers memory. .. code-block:: c++. void foo(int * A, int * B, int n) {; for (intptr_t i = 0; i < n; ++i); A[i] += B[i * 4];; }. In many situations the cost model will inform LLVM that this is not beneficial; and LLVM will only vectorize such code if forced with ""-mllvm -force-vector-width=#"". Vectorization of Mixed Types; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize programs with mixed types. The Vectorizer; cost model can estimate the cost of the t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:7431,detect,detects,7431,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['detect'],['detects']
Safety,"n option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile stores. '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.scope.begin(); declare void @llvm.seh.scope.end(). Overview:; """""""""""""""""". The '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' intrinsics mark; the boundary of a CPP object lifetime for Windows SEH Asynchrous Exception; Handling (MSVC option -EHa). Semantics:; """""""""""""""""""". LLVM's ordinary exception-handling representation associates EH cleanups and; handlers only with ``invoke``s, which normally correspond only to call sites. To; support arbitrary faulting instructions, it must be possible to recover the current; EH scope for any instruction. Turning every operation in LLVM that could fault; into an ``invoke`` of a new, potentially-throwing intrinsic would require adding a; large number of intrinsics, impede optimization of those operations, and make; compilation slower by introducing many extra basic blocks. These intrinsics can; be used instead to mark the region protected by a cleanup, such as for a local; C++ object with a non-trivial destructor. ``llvm.seh.scope.begin`` is used to mark; the start of the region; it is always called with ``invoke``, with the unwind block; being the desired unwind destination for any potentially-throwing instructions; within the region. `llvm.seh.scope.end` is used to mark when the scope ends; and the EH cleanup is no longer required (e.g. because the destructor is being; called). .. _int_read_register:; .. _int_read_volatile_register:; .. _int_write_register:. '``llvm.read_register``', '``llvm.read_volatile_register``', and '``l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:516648,recover,recover,516648,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recover']
Safety,"n provide the exact location of the; terminator. With this argument, the function can skip reading the entire; array in order to locate the end of the pointer (or the upper bound).; Providing an incorrect ``PTR_TO_TERM`` causes a run-time trap. + ``__unsafe_forge_terminated_by(T, P, E)`` creates ``T __terminated_by(E)``; pointer given any pointer ``P``. Tmust be a pointer type. Portability with toolchains that do not support the extension; -------------------------------------------------------------. The language model is designed so that it doesn't alter the semantics of the; original C program, other than introducing deterministic traps where otherwise; the behavior is undefined and/or unsafe. Clang provides a toolchain header; (``ptrcheck.h``) that macro-defines the annotations as type attributes when; ``-fbounds-safety`` is enabled and defines them to empty when the extension is; disabled. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:45653,safe,safety,45653,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"n the bounds of the allocation; they're associated with. As a result, the base object can be found at; runtime provided the bounds of allocations are known to the runtime system. ""Exterior derived pointers"" are outside the bounds of the associated object;; they may even fall within *another* allocations address range. As a result,; there is no way for a garbage collector to determine which allocation they; are associated with at runtime and compiler support is needed. The ``gc.relocate`` intrinsic supports an explicit operand for describing the; allocation associated with a derived pointer. This operand is frequently; referred to as the base operand, but does not strictly speaking have to be; a base pointer, but it does need to lie within the bounds of the associated; allocation. Some collectors may require that the operand be an actual base; pointer rather than merely an internal derived pointer. Note that during; lowering both the base and derived pointer operands are required to be live; over the associated call safepoint even if the base is otherwise unused; afterwards. If we extend our previous example to include a pointless derived pointer,; we get:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %gep = getelementptr i8, i8 addrspace(1)* %obj, i64 20000; %token = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj, i8 addrspace(1)* %gep); %obj.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 7); %gep.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 8); %p = getelementptr i8, i8 addrspace(1)* %gep, i64 -20000; ret i8 addrspace(1)* %p; }. Note that in this example %p and %obj.relocate are the same address and we; could replace one with the other, potentially removing the derived pointer; from the l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:15216,safe,safepoint,15216,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"n x86 processors may speculate into called functions and out of functions; to their return address. As a consequence, we need a way to check loads that; occur after a misspeculated predicate but where the load and the misspeculated; predicate are in different functions. In essence, we need some interprocedural; generalization of the predicate state tracking. A primary challenge to passing; the predicate state between functions is that we would like to not require a; change to the ABI or calling convention in order to make this mitigation more; deployable, and further would like code mitigated in this way to be easily; mixed with code not mitigated in this way and without completely losing the; value of the mitigation. ##### Embed the predicate state into the high bit(s) of the stack pointer. We can use the same technique that allows hardening pointers to pass the; predicate state into and out of functions. The stack pointer is trivially; passed between functions and we can test for it having the high bits set to; detect when it has been marked due to misspeculation. The callsite instruction; sequence looks like (assuming a misspeculated state value of `-1`):; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; ```. This first puts the predicate state into the high bits of `%rsp` before calling; the function and then reads it back out of high bits of `%rsp` afterward. When; correctly executing (speculatively or not), these are all no-ops. When; misspeculating, the stack pointer will end up negative. We arrange for it to; remain a canonical address, but otherwise leave the low bits alone to allow; stack adjustments to proceed normally without disrupting this. Within the; called function, we can extract this predicate state and then reset it on; return:; ```; other_function:; # prolog; callq other_function; mov",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:38837,detect,detect,38837,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['detect'],['detect']
Safety,"n, CERN/SFT,\; Philippe Canal, FNAL,\; Cristina Cristescu, CERN/SFT,\; Olivier Couet, CERN/SFT,\; Kyle Cranmer, NYU, RooStats,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/Alice,\; Lukasz Janyst, CERN/IT,\; Christopher Jones, Fermilab, CMS,\; Wim Lavrijsen, LBNL, PyRoot,\; Sergey Linev, GSI, http,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Timur Pocheptsov, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Liza Sakellari, CERN/SFT,\; Manuel Tobias Schiller,\; David Smith, CERN/IT,\; Matevz Tadel, UCSD/CMS, Eve, \; Vassil Vassilev, CERN/SFT \; Wouter Verkerke, NIKHEF/Atlas, RooFit, \; Yue Shi Lai, MIT,\; Maciej Zimnoch. ## Core Libraries. ### General. #### Platform support. ROOT now works on linuxarm64 / AArch64 / ARMv8 64-bit - thanks, David Abdurachmanov!. ROOT supports GCC 5.0 (using the GCC4 ABI) and XCode 6.3, Mac OSX 10.10.3. #### Thread-Safety. A lot of effort went into improving the thread-safety of Core and Meta classes / functions. A special thanks to Chris Jones from CMS!. #### std::string_view. Introduce a preview of C++17's std::string_view. To take advantage of this new; class use:; ```{.cpp}; #include ""RStringView.h""; ```; The documentation of this can be found at `http://en.cppreference.com/w/cpp/experimental/basic_string_view`; The implementation provided is extracted from libcxx. Whenever the current; compiler and standard library provide an implmentation, it is used. The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. This type is used throughout the ROOT code to avoid copying strings when a; sub-string is needed and to extent interfaces that uses to take a const char*; to take a std::string_view as thus be able to be directly directly passed a; TString, a std::string or a std::string_view. Usage example:. ``` {.cpp}; // With SetName(std::strin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:1354,safe,safety,1354,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['safe'],['safety']
Safety,"n-linear least square.; . MathCore. Fixed a bug in setting the VEGAS integration mode in the GSLMCIntegrator class.; . Fumili. Add implementation of Minimizer interface using TFumili.; ; Minuit. In TMinuitMinimizer: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:3622,safe,safe,3622,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,2,['safe'],['safe']
Safety,n. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50419,safe,safely-derived,50419,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['safe'],['safely-derived']
Safety,"n; /tmp/foo/test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --basenames; main; test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --relativenames; main; foo/test.cpp:15:0. Example 7 - Addresses as symbol names:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf main; main; /tmp/test.cpp:14:0; $ llvm-symbolizer --obj=test.elf ""CODE foz""; foz; /tmp/test.h:1:0. OPTIONS; -------. .. option:: --adjust-vma <offset>. Add the specified offset to object file addresses when performing lookups.; This can be used to perform lookups as if the object were relocated by the; offset. .. option:: --basenames, -s. Print just the file's name without any directories, instead of the; absolute path. .. option:: --build-id. Look up the object using the given build ID, specified as a hexadecimal; string. Mutually exclusive with :option:`--obj`. .. option:: --color [=<always|auto|never>]. Specify whether to use color in :option:`--filter-markup` mode. Defaults to; ``auto``, which detects whether standard output supports color. Specifying; ``--color`` alone is equivalent to ``--color=always``. .. option:: --debug-file-directory <path>. Provide a path to a directory with a `.build-id` subdirectory to search for; debug information for stripped binaries. Multiple instances of this argument; are searched in the order given. .. option:: --debuginfod, --no-debuginfod. Whether or not to try debuginfod lookups for debug binaries. Unless specified,; debuginfod is only enabled if libcurl was compiled in (``LLVM_ENABLE_CURL``); and at least one server URL was provided by the environment variable; ``DEBUGINFOD_URLS``. .. _llvm-symbolizer-opt-C:. .. option:: --demangle, -C. Print demangled function names, if the names are mangled (e.g. the mangled; name `_Z3bazv` becomes `baz()`, whilst the non-mangled name `foz` is printed; as is). Defaults to true. .. option:: --dwp <path>. Use the specified DWP file at ``<path>`` for any CUs that have split DWARF; debug data. .. option:: --fallbac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:5374,detect,detects,5374,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['detect'],['detects']
Safety,"n; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,; `derived pointers`_ must not be retained across safe points and `object; pointers`_ must be reloaded from stack roots. **SDISel**; Selection DAG Instruction Selection. **SCC**; Strongly Connected Component. **SCCP**; Sparse Conditional Constant Propagation. **SLP**; Superword-Level Parallelism, same as :ref:`Basic-Block Vectorization; <lexicon-bb-vectorization>`. **Splat**; Splat refers to a vector of identical scalar elements. The term is based on the PowerPC Altivec instructions that provided; this functionality in hardware. For example, ""vsplth"" and the corresponding; software intrinsic ""vec_splat()"". Examples of other hardware names for this; action include ""duplicate"" (ARM) and ""broadcast"" (x86). **SRoA**; Scalar Replacement of Aggregates. **SSA**; Static Single Assignment. **Stack Map**; In garbage collection, metadata emitted by the code generator which; identifies `roots`_ within the stack frame of an executing function. T; -. **TBAA**; Type-Based Alias Analysis. W; -. **WPD**; Whole Program Devirtualization. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:7873,safe,safe,7873,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['safe'],['safe']
Safety,"nabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing from NSLocalizedString macros.; These can be enabled by passing the following command to scan-build:.   -enable-checker alpha.osx.cocoa.NonLocalizedStringChecker,alpha.osx.cocoa.EmptyLocalizationContextChecker. New checks for _Nonnull type qualifiers. These can be enabled with:.   -enable-checker nullability.NullPassedToNonnull,nullability.NullReturnedFromNonnull; New checks for misuse of Objective-C generics. These can be enabled with -enable-checker alpha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1602,detect,detect,1602,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,2,['detect'],['detect']
Safety,"nality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to both a) confirm that all of LLVM builds with your host; compiler, and b) want to do a multi-stage clang build on your target, you; may be better off with two separate bots. Splitting increases resource; consumption, but makes it easy for each bot to keep up with commit flow.; Additionally, splitting bots may assist in triage by narrowing attention to; relevant parts of the failing configuration. In general, we recommend Release build types with Assertions enabled. This; generally provides a good balance between build times and bug detection for; most buildbots. There may be room for including some debug info (e.g. with; `-gmlt`), but in general the balance between debug info quality and build; times is a delicate one. Use Ninja & LLD; Ninja really does help build times over Make, particularly for highly; parallel builds. LLD helps to reduce both link times and memory usage; during linking significantly. With a build machine with sufficient; parallelism, link times tend to dominate critical path of the build, and are; thus worth optimizing. Use CCache and NOT incremental builds; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:10527,detect,detection,10527,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['detect'],['detection']
Safety,"name syntax that includes pathnames with multiple dots, such as ""myBranch.mySubBranch.myLeaf"". This is available both for jitted expressions and for lists of column names.; - The CSV data source (TCsvDS) can now be constructed with a chunk size parameter, and as a result the CSV file will be read progressively, in chunks of the specified size. This can be used to prevent the whole CSV file from being read into memory at once, thus reducing the memory footprint of this data source.; - Add the `ROOT::Experimental::TAdoptAllocator<T>`, an allocator which allows to adopt existing memory. If memory is adopted, upon allocation a copy is performed in the new, potentially more extended, memory region.; - Add `ROOT::Experimental::VecOps::TVec<T>` a class which represents a contiguous array, inspired by Numpy arrays. `TVec` offer a convenient interface, almost identical to the one of `std::vector`. It can own or adopt its memory. As well as a set of tools which make analysis of collections easier, avoiding to loop over the individual elements of the collections. Basic arithmetic operations such as +,-,*,/,% between TVecs and scalars and TVecs are supported. Most popular math functions which act on TVecs are provided. Helpers to calculate basic quantities such as sum, mean, variance or standard deviation of TVecs are provided.; A powerful and concise syntax for expressing cuts is available:; ```; // mu_pts_tvec and mu_etas_tvec are two equally sized TVecs holding kinematic properties of muons; // a filter on muons pseudorapidities is applied considering a range in pseudo rapidity.; filtered_mu_pts_tvec = mu_pts_tvec[abs(mu_etas_tvec) < 2)];; ```; - The `TArrayBranch` class has been removed and replaced by the more powerful `TVec`.; - Columns on disk stored as C arrays should be read as `TVec`s, `std::vector` columns can be read as `TVec`s if requested. Jitted transformations and actions consider `std::vector` columns as well as C array columns `TVec`s.; - In jitted transformati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:8719,avoid,avoiding,8719,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoiding']
Safety,"natural semantics of value propagation, where; all basic operations on the type come down to copies and destroys,; and everything else is just an optimization on top of those. The most glaring weakness of programming with non-trivial types in C; is that there are no language mechanisms (akin to C++'s placement; ``new`` and explicit destructor calls) for explicitly creating and; destroying objects. Clang should consider adding builtins for this; purpose, as well as for common optimizations like destructive; relocation. Application of the formal C rules to nontrivial ownership qualifiers; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Nontrivially ownership-qualified types are considered non-trivial; to copy, destroy, and default-initialize. A dynamic object of nontrivially ownership-qualified type contingently; exists at a location if the memory is filled with a zero pattern, e.g.; by ``calloc`` or ``bzero``. Such an object can be safely accessed in; all of the cases above, but its memory can also be safely repurposed.; Assigning a null pointer into an l-value of ``__weak`` or; ``__strong``-qualified type accesses the dynamic object there (and thus; may have undefined behavior if no such object exists), but afterwards; the object's memory is guaranteed to be filled with a zero pattern; and thus may be either further accessed or repurposed as needed.; The upshot is that programs may safely initialize dynamically-allocated; memory for nontrivially ownership-qualified types by ensuring it is zero-initialized, and they may safely deinitialize memory before; freeing it by storing ``nil`` into any ``__strong`` or ``__weak``; references previously created in that memory. C/C++ compatibility for structs and unions with non-trivial members; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Structs and unions with non-trivial members are compatible in; different language modes (e.g. between Objective-C and Objective-C++,; or between AR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:60111,safe,safely,60111,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['safe'],['safely']
Safety,"ncatenated with the next one. In this way you can build up; long pipelines of commands without making huge line lengths. The lines; ending in ``\`` are concatenated until a RUN line that doesn't end in; ``\`` is found. This concatenated set of RUN lines then constitutes one; execution. :program:`lit` will substitute variables and arrange for the pipeline; to be executed. If any process in the pipeline fails, the entire line (and; test case) fails too. Below is an example of legal RUN lines in a ``.ll`` file:. .. code-block:: llvm. ; RUN: llvm-as < %s | llvm-dis > %t1; ; RUN: llvm-dis < %s.bc-13 > %t2; ; RUN: diff %t1 %t2. As with a Unix shell, the RUN lines permit pipelines and I/O; redirection to be used. There are some quoting rules that you must pay attention to when writing; your RUN lines. In general nothing needs to be quoted. :program:`lit` won't; strip off any quote characters so they will get passed to the invoked program.; To avoid this use curly braces to tell :program:`lit` that it should treat; everything enclosed as one value. In general, you should strive to keep your RUN lines as simple as possible,; using them only to run tools that generate textual output you can then examine.; The recommended way to examine output to figure out if the test passes is using; the :doc:`FileCheck tool <CommandGuide/FileCheck>`. *[The usage of grep in RUN; lines is deprecated - please do not send or commit patches that use it.]*. Put related tests into a single file rather than having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:10440,avoid,avoid,10440,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoid']
Safety,"nce itself from the; costly full header inclusion. Unfortunately, several of them are home-grown and; in a few cases inaccurate (eg line #5) causing a noticeable technical debt. Here we will briefly describe the three common layers of optimizations: ROOT PCH,; ROOTMAP and RDICT. The ROOT precompiled header (PCH) reduces the CPU and memory cost for ROOT's; most used libraries. The precompiled header technology is well-understood since; decades [[4]]. It is an efficient on-disk representation of the state of the; compiler after parsing a set of headers. It can be loaded before starting the; next instance to avoid doing redundant work. At build time, rootcling (ROOT's; dictionary generator) creates such PCH file which is attached at ROOT startup; time. Its major drawback is the fact that if third-party users want to include; their libraries, they have to recompile it every time there is a change. RDICT files store some useful information (in particular about class offsets) in; ROOT files to avoid the potentially expensive call to the interpreter if the; information is not the PCH. For example, ROOT's libGeom and other third-party; code. This is done to circumvent the costly call to `ShowMembers` which will; require parsing. ROOTMAP files reduce parsing for code which is not in the PCH. Consider; `foo::bar` and `S` are defined in `libFoo`'s `Foo.h`:; ```cpp; // Foo.h; namespace foo { struct bar{}; }; struct S{};; ```. ```bash; # libFoo.rootmap; { decls }; namespace foo { }; struct S;; ; [ libFoo.so ]; # List of selected classes; class bar; struct S; ```. ```cpp; // G__Foo.cxx (aka libFoo dictionary); namespace {; void TriggerDictionaryInitialization_libFoo_Impl() {; static const char* headers[] = {""Foo.h""}; // More scaffolding; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; }; ```. The code snippet bellow d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:6591,avoid,avoid,6591,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"nce); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84675,recover,recovery,84675,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"nch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. Mixing References and Raw Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Support for languages which allow unmanaged pointers to garbage collected; objects (i.e. pass a pointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides the connection between; the reference value and the raw pointer. The problem is that having ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33511,safe,safepoints,33511,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"nd header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular backg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9636,detect,detecting,9636,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['detect'],['detecting']
Safety,"nd nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1197,safe,safe,1197,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['safe'],['safe']
Safety,"nd notation for column name `R_rdf_sizeof_var`.; - Helpers have been added to export data from `RDataFrame` to RooFit datasets. See the ""RooFit Libraries"" section below for more details, or see [the tutorial](https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html). ### Notable changes in behavior. - Using `Alias`, it is now possible to register homonymous aliases (alternative column names) in different branches of the computation graph, in line with the behavior of `Define` (until now, aliases were required to be unique in the whole computaton graph).; - The `Histo*D` methods now support the combination of scalar values and vector-like weight values. For each entry, the histogram is filled once for each weight, always with the same scalar value.; - The `Histo*D` methods do not work on columns of type `std::string` anymore. They used to fill the histogram with the integer value corresponding to each of the characters in the string. Please use `Fill` with a custom class to recover the old behavior if that was what was desired. ### Other improvements. - The scaling to a large amount of threads of computation graphs with many simple `Filter`s or `Define`s has been greatly improved, see also [this talk](https://indico.cern.ch/event/1036730/#1-a-performance-study-of-the-r) for more details; - The output format of `Display` has been significantly improved.; - The `Fill` method now correctly supports user-defined classes with arbitrary `Fill` signatures (see [#9428](https://github.com/root-project/root/issues/9428)). ### Experimental Distributed RDataFrame. The distributed RDataFrame module has been improved. Now it supports sending RDataFrame tasks to a [Dask](https://dask.org/) scheduler. Through Dask, RDataFrame can be also scaled to a cluster of machines managed through a batch system like HTCondor or Slurm. Here is an example:. ```python; import ROOT; from dask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Pyt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:9693,recover,recover,9693,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['recover'],['recover']
Safety,"nd the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current minimum version of Python required is documented in the :doc:`GettingStarted`; section. Python code in the LLVM repository should only use language features; available in this version of Python. The Python code within the LLVM repository should adhere to the formatting guidelines; outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_. For consistency and to limit churn, code should be automatically formatted with; the `black <https://github.com/psf/black>`_ utility, which is PEP 8 compliant.; Use its default rules. For example, avoid specifying ``--line-length`` even; though it does not default to 80. The default rules can change between major; versions of black. In order to avoid unnecessary churn in the formatting rules,; we currently use black version 23.x in LLVM. When contributing a patch unrelated to formatting, you should format only the; Python code that the patch modifies. For this purpose, use the `darker; <https://pypi.org/project/darker/>`_ utility, which runs default black rules; over only the modified Python code. Doing so should ensure the patch will pass; the Python format checks in LLVM's pre-commit CI, which also uses darker. When; contributing a patch specifically for reformatting Python files, use black,; which currently only supports formatting entire files. Here are some quick examples, but see the black and darker documentation for; details:. .. code-block:: bash. $ pip install black=='23.*' darker # install black 23.x and darker; $ darker test.py # format uncommitted changes; $ darker -r HEAD^ test.py # also format changes from last commit; $ black test.py # format entire file. Instead of individual file names, you can specify directories to; darker, and it will find ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:5346,avoid,avoid,5346,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"nd their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101505,safe,safety,101505,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"nd write all memory. As a result,; memory operations can not be reordered past a statepoint. It is; illegal to mark a statepoint as being either 'readonly' or 'readnone'. Note that legal IR can not perform any memory operation on a 'gc; pointer' argument of the statepoint in a location statically reachable; from the statepoint. Instead, the explicitly relocated value (from a; ``gc.relocate``) must be used. '``llvm.experimental.gc.result``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare type; @llvm.experimental.gc.result(token %statepoint_token). Overview:; """""""""""""""""". ``gc.result`` extracts the result of the original call instruction; which was replaced by the ``gc.statepoint``. The ``gc.result``; intrinsic is actually a family of three intrinsics due to an; implementation limitation. Other than the type of the return value,; the semantics are the same. Operands:; """""""""""""""""". The first and only argument is the ``gc.statepoint`` which starts; the safepoint sequence of which this ``gc.result`` is a part.; Despite the typing of this as a generic token, *only* the value defined; by a ``gc.statepoint`` is legal here. Semantics:; """""""""""""""""""". The ``gc.result`` represents the return value of the call target of; the ``statepoint``. The type of the ``gc.result`` must exactly match; the type of the target. If the call target returns void, there will; be no ``gc.result``. A ``gc.result`` is modeled as a 'readnone' pure function. It has no; side effects since it is just a projection of the return value of the; previous call represented by the ``gc.statepoint``. '``llvm.experimental.gc.relocate``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <pointer type>; @llvm.experimental.gc.relocate(token %statepoint_token,; i32 %base_offset,; i32 %pointer_offset). Overview:; """""""""""""""""". A ``gc.relocate`` returns the potentially relocated value of a pointer; at the safepoint. Operands:; """""""""""""""""". The first argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:504275,safe,safepoint,504275,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safepoint']
Safety,"nd/or ``nsw`` keywords are present, the; result value of the ``add`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = add i32 4, %var ; yields i32:result = 4 + %var. .. _i_fadd:. '``fadd``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fadd [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fadd``' instruction returns the sum of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fadd``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point sum of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fadd float 4.0, %var ; yields float:result = 4.0 + %var. .. _i_sub:. '``sub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sub <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nsw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``sub``' instruction returns the difference of its two operands. Note that the '``sub``' instruction is used to represent the '``neg``'; instruction present in most other intermediate representations. Arguments:; """""""""""""""""""". The two arguments to the '``sub``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer difference of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:379211,unsafe,unsafe,379211,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"ndeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81508,safe,safe,81508,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ndif. .. _arc.misc.self:. ``self``; --------. The ``self`` parameter variable of an non-init Objective-C method is considered; :ref:`externally-retained <arc.misc.externally_retained>` by the implementation.; It is undefined behavior, or at least dangerous, to cause an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ------------------------------------. If a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:95327,risk,risk,95327,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['risk'],['risk']
Safety,"ndler --unbundle --inputs=libFatArchive.a -type=a \; -targets=openmp-amdgcn-amdhsa-gfx906:sramecc+:xnack+, \; openmp-amdgcn-amdhsa-gfx908:sramecc-:xnack+ \; -outputs=devicelib-gfx906.a,deviceLib-gfx908.a. .. _additional-options-archive-unbundling:. Additional Options while Archive Unbundling; -------------------------------------------. **-allow-missing-bundles**; Create an empty archive file if no compatible device binary is found. **-check-input-archive**; Check if input heterogeneous device archive follows rules for composition; as defined in :ref:`code-object-composition` before creating device-specific; archive(s). **-debug-only=CodeObjectCompatibility**; Verbose printing of matched/unmatched comparisons between bundle entry id of; a device binary from HDA and bundle entry ID of a given target processor; (see :ref:`compatibility-bundle-entry-id`). Compression and Decompression; =============================. ``clang-offload-bundler`` provides features to compress and decompress the full; bundle, leveraging inherent redundancies within the bundle entries. Use the; `-compress` command-line option to enable this compression capability. The compressed offload bundle begins with a header followed by the compressed binary data:. - **Magic Number (4 bytes)**:; This is a unique identifier to distinguish compressed offload bundles. The value is the string 'CCOB' (Compressed Clang Offload Bundle). - **Version Number (16-bit unsigned int)**:; This denotes the version of the compressed offload bundle format. The current version is `1`. - **Compression Method (16-bit unsigned int)**:; This field indicates the compression method used. The value corresponds to either `zlib` or `zstd`, represented as a 16-bit unsigned integer cast from the LLVM compression enumeration. - **Uncompressed Binary Size (32-bit unsigned int)**:; This is the size (in bytes) of the binary data before it was compressed. - **Hash (64-bit unsigned int)**:; This is a 64-bit truncated MD5 hash of the uncomp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:18941,redund,redundancies,18941,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['redund'],['redundancies']
Safety,"ne ZLIB_VERSION \""[^\""]*\""$""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""([0-9]+).*$"" ""\\1"" ZLIB_VERSION_MAJOR ""${ZLIB_H}""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""[0-9]+\\.([0-9]+).*$"" ""\\1"" ZLIB_VERSION_MINOR ""${ZLIB_H}""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""[0-9]+\\.[0-9]+\\.([0-9]+).*$"" ""\\1"" ZLIB_VERSION_PATCH ""${ZLIB_H}""); set(ZLIB_VERSION_STRING ""${ZLIB_VERSION_MAJOR}.${ZLIB_VERSION_MINOR}.${ZLIB_VERSION_PATCH}""). set(ZLIB_VERSION_TWEAK """"); if(""${ZLIB_H}"" MATCHES ""ZLIB_VERSION \""[0-9]+\\.[0-9]+\\.[0-9]+\\.([0-9]+)""); set(ZLIB_VERSION_TWEAK ""${CMAKE_MATCH_1}""); string(APPEND ZLIB_VERSION_STRING "".${ZLIB_VERSION_TWEAK}""); endif(). set(ZLIB_VERSION ${ZLIB_VERSION_STRING} CACHE INTERNAL """"); set(ZLIB_VERSION_STRING ${ZLIB_VERSION_STRING} CACHE INTERNAL """"). set(ZLIB_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR} CACHE INTERNAL """"); set(ZLIB_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR} CACHE INTERNAL """"). if((CMAKE_SYSTEM_PROCESSOR MATCHES ""amd64|x86_64|AMD64|X86_64|aarch64"") AND (CMAKE_SYSTEM_NAME MATCHES ""Linux"")); # Calling helper to avoid using old unsupported binutils (e.g. with SL6); # macro is returning extra ${ROOT_DEFINITIONS} used after in ZLIB-CF; root_check_assembler(); # Calling helper to avoid using old unsupported binutils (e.g. with Centos7; # and native gcc compiler 4.8.5); # Macros are returning bools SSE_SUPPORT & AVX2_SUPPORT; root_check_sse41(); root_check_avx2(); if(SSE_SUPPORT OR AVX2_SUPPORT); set(ZLIB_CF TRUE CACHE INTERNAL """"); endif(); endif(). if(ZLIB_CF); add_library(ZLIB STATIC ${ZLIB_PUBLIC_HEADERS} ${ZLIBCF_PRIVATE_HEADERS} ${ZLIBCF_SOURCES}); else(); add_library(ZLIB STATIC ${ZLIB_PUBLIC_HEADERS} ${ZLIB_PRIVATE_HEADERS} ${ZLIB_SOURCES}); endif(). set_target_properties(ZLIB PROPERTIES C_VISIBILITY_PRESET hidden POSITION_INDEPENDENT_CODE ON); target_include_directories(ZLIB INTERFACE $<BUILD_INTERFACE:${ZLIB_INCLUDE_DIR}>). if((CMAKE_SYSTEM_PROCESSOR MATCHES ""amd64|x86_64|AMD64|X86_64"") AND (CMAKE_SYSTEM_NAME MATCHES ""Linux"")); target_compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/CMakeLists.txt:2067,avoid,avoid,2067,builtins/zlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/CMakeLists.txt,1,['avoid'],['avoid']
Safety,"ned by the method is the object which shape; boundary will be crossed first. The distance to the next crossing can be; retrieved after the call:. ~~~{.cpp}; Double_t TGeoManager::GetStep(); ~~~. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning ""step approved"". The default value for `stepmax` is; TGeoShape::Big with the meaning that boundaries are looked for; without limitation. \image html geometry017.png ""Finding the distance to the next crossed boundary"" width=600px. According the values of the input parameters the method will perform; additional optional tasks:. `|stepmax| < TGeoShape::Big()`. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial poin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:120638,safe,safe,120638,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"ned int count = 0;; for (unsigned int i = 0; i < 4 * 8; i++); count += (input >> i) & i;; return count;; }. This should be recognized as CLZ: https://github.com/llvm/llvm-project/issues/64167. unsigned clz_a(unsigned a) {; int i;; for (i=0;i<32;i++); if (a & (1<<(31-i))); return i;; return 32;; }. This sort of thing should be added to the loop idiom pass. //===---------------------------------------------------------------------===//. These should turn into single 16-bit (unaligned?) loads on little/big endian; processors. unsigned short read_16_le(const unsigned char *adr) {; return adr[0] | (adr[1] << 8);; }; unsigned short read_16_be(const unsigned char *adr) {; return (adr[0] << 8) | adr[1];; }. //===---------------------------------------------------------------------===//. -instcombine should handle this transform:; icmp pred (sdiv X / C1 ), C2; when X, C1, and C2 are unsigned. Similarly for udiv and signed operands. . Currently InstCombine avoids this transform but will do it when the signs of; the operands and the sign of the divide match. See the FIXME in ; InstructionCombining.cpp in the visitSetCondInst method after the switch case ; for Instruction::UDiv (around line 4447) for more details. The SingleSource/Benchmarks/Shootout-C++/hash and hash2 tests have examples of; this construct. . //===---------------------------------------------------------------------===//. [LOOP OPTIMIZATION]. SingleSource/Benchmarks/Misc/dt.c shows several interesting optimization; opportunities in its double_array_divs_variable function: it needs loop; interchange, memory promotion (which LICM already does), vectorization and; variable trip count loop unrolling (since it has a constant trip count). ICC; apparently produces this very nice code with -ffast-math:. ..B1.70: # Preds ..B1.70 ..B1.69; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; addl $8, %edx #; cmpl $131072, %edx #108.2; jb ..B1.70 # Prob 99% #108.2. It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:7804,avoid,avoids,7804,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['avoid'],['avoids']
Safety,"newly introduced tuple-initialization; ```python; myHisto = myTdf.Histo1D(('histName', 'histTitle', 64, 0, 128), 'myColumn'); ```; - Add support for friend trees and chains. Just add the friends before passing the tree/chain to TDataFrame's constructor and refer to friend branches as usual. #### Fixes; - Fixed race condition: concurrent deletion of TTreeReader/TTreeReaderValue; - Fixed reading of c-style arrays from jitted transformations and actions; - Fixed writing of c-style arrays with `Snapshot`; - Improved checks for column name validity (throw if column does not exist and if `Define`d column overrides an already existing column). #### Other changes; - Improved documentation; - TDF now avoids performing virtual calls for parts of the analysis that are not jitted; - Removed ""custom column"" nodes from the internal functional graph therewith optimising its traversal; - Improvements in Cling drastically enhanced scaling and performance of TDF jitted code; - Test coverage has been increased with the introduction of google tests; - Interface change: users must now use TDF::TArrayBranch rather than std::array\_view to specify that the column being read is a c-style array TTree branch; - Interface change: `Min` and `Max` now return results as the same type specified as template parameter, or double if no template parameter was specified. ## Histogram Libraries; - Histogram-based fits are implicitly parallelized.; - Added new options to the histogram fitting interfaces to support explicit parallelization of the fit as well.; - `TF1` gradient evaluation supports vectorization.; - Refactor of `TF1` constructors, default initialization of its data members and fixed ambiguous TF1::operator().; - Extend `TFormula` parsing capabilities.; - The parsing of arguments for defining parametric function is improved. For example a Gaussian function in y can be defined as `gaus( y , [A], [Mean], [Sigma])`.; - One can define the function variables or parameters using another function o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:15117,avoid,avoids,15117,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['avoid'],['avoids']
Safety,"nfo format, which is usable with Microsoft debuggers such; as Visual Studio and WinDBG. LLVM's debug information format is mostly derived; from and inspired by DWARF, but it is feasible to translate into other target; debug info formats such as STABS. It would also be reasonable to use debug information to feed profiling tools; for analysis of generated code, or, tools for reconstructing the original; source from generated code. .. _intro_debugopt:. Debug information and optimizations; -----------------------------------. An extremely high priority of LLVM debugging information is to make it interact; well with optimizations and analysis. In particular, the LLVM debug; information provides the following guarantees:. * LLVM debug information **always provides information to accurately read; the source-level state of the program**, regardless of which LLVM; optimizations have been run. :doc:`HowToUpdateDebugInfo` specifies how debug; info should be updated in various kinds of code transformations to avoid; breaking this guarantee, and how to preserve as much useful debug info as; possible. Note that some optimizations may impact the ability to modify the; current state of the program with a debugger, such as setting program; variables, or calling functions that have been deleted. * As desired, LLVM optimizations can be upgraded to be aware of debugging; information, allowing them to update the debugging information as they; perform aggressive optimizations. This means that, with effort, the LLVM; optimizers could optimize debug code just as well as non-debug code. * LLVM debug information does not prevent optimizations from; happening (for example inlining, basic block reordering/merging/cleanup,; tail duplication, etc). * LLVM debug information is automatically optimized along with the rest of; the program, using existing facilities. For example, duplicate; information is automatically merged by the linker, and unused information; is automatically removed. Basically,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:4156,avoid,avoid,4156,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"nforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Insid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6027,safe,safety,6027,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],['safety']
Safety,"ng an issues for a bug, add enough description to reproduce the issue - at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md). Authors; -------. CivetWeb has been forked from the last MIT version of Mongoose in 2013.; Since then, CivetWeb has seen many improvements from various authors; (Copyright (c) 2013-2021 the CivetWeb developers, MIT license). A list of authors can be found in [CREDITS.md](https://github.com/civetweb/civetweb/blob/master/CREDITS.md). CivetWeb is based on the Mongoose project. The original author of Mongoose was; Sergey Lyubka (Copyright (c) 2004-2013 Sergey Lyubka, MIT license).; However, on August 16, 2013, the [license of Mongoose has been changed](https://groups.google.com/forum/#!topic/mongoose-users/aafbOnHonkI); after writing and distributing the original code this project is based on.; The license change and CivetWeb used to be mentioned on the Mongoose; [Wikipedia](https://en.wikipedia.org/wiki/Mongoose_(web_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:9728,safe,safely,9728,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['safe'],['safely']
Safety,"ng any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-swee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1178,unsafe,unsafe,1178,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"ng around `RVec` objects. `RVecN<T, N>`; It aggregates `RVecImpl` and `SmallVectorStorage` (see below) through public inheritance.; `N` is the small buffer size. `RVec<T>`; Inherits from `RVecN` and fixes the small buffer size `N` to a reasonable default.; We expect most users to use this type and only very rarely switch to `RVecN` to tweak the small buffer size. ### Helper types. - `SmallVectorAlignmentAndSize`: used to figure out the offset of the first small-buffer element in; `SmallVectorTemplateCommon::getFirstEl`; - `SmallVectorStorage`: properly aligned ""small buffer"" storage. It's a separate type so that it can be specialized to; be properly aligned also for the case of small buffer size = 0; - `RVecInlineStorageSize`: calculates the size of the small buffer in `RVec`. ## Memory adoption. We need RVec to be able to act as a view over an existing buffer rather than use its own; to save copies and allocations when reading ROOT data into `RVec`s, e.g. in `RDataFrame`. The feature is exposed via a dedicated constructor: `RVec(pointer, size)`.; `RVec` then switches to its own storage as soon as a resize is requested.; `fCapacity == -1` indicates that we are in ""memory adoption mode"". ## Exception safety guarantees. As per [its docs](https://llvm.org/doxygen/classllvm_1_1SmallVector.html), LLVM's; `SmallVector` implementation ""does not attempt to be exception-safe"".; In its current implementation, `RVec` does not attempt to fix that.; This should not be a problem for `RVec`'s usecases (an exception thrown during; construction of an `RVec` typically means there is a bug to fix in the analysis code),; and we expect to be able to revisit the implementation and fix broken behavior if it; ever turns out to be problematic. Relevant discussion on GitHub:. - https://github.com/root-project/root/pull/7502#issuecomment-818864506; - https://github.com/root-project/root/pull/7502#issuecomment-818905333; - https://github.com/root-project/root/pull/7502#issuecomment-821054757. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md:4498,safe,safety,4498,math/vecops/ARCHITECTURE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md,2,['safe'],"['safe', 'safety']"
Safety,"ng bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2317,safe,safety,2317,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"ng constant-term precalculation optimization in roofit likelihoods as these are now; also stored in vectors rather than trees. The faster access speed of vectors make that the constant; term optimization inside likelihoods results in a larger speed increase. This is particulatly noticeable in pdfs with; many constant expressions from pdfs that were moderately fast to begin with (e.g. RooHistPdf).; The second advantages allows new types of algorithmic likelihood optimization in RooFit detailed below. New algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2207,avoid,avoid,2207,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['avoid'],['avoid']
Safety,"ng for filled area for the Cocoa backend. Default is `no`.; - The ""BOX"" option, to draw 3D histograms, has been reimplemented by Evgueni Tcherniaev; The following picture show the old and new version. ![New box option for 3D histograms](NewBoxOption.png). - Implement options ""BOX1"", ""BOX2"" and ""BOX3"" for TH3 equivalent of ""LEGO1"", ""LEGO2"" and ""LEGO3""for TH2.; - When a 2d histogram was drawn with option `LEGO1` and white colored, the dark side; of the lego was red instead of gray.; - New option ""0"" to draw TH2Poly. When used with any `COL` options, the empty; bins are not drawn.; - Fix a long pending problem with Z axis drawing when a lego or a surface was drawn; upside-down.; - Add a protection in TLatex when a string has a syntax error. It was reported; [here](https://sft.its.cern.ch/jira/browse/ROOT-7424).; - Implement the automatic placement of the Y axis title. If the title offset is; set to 0:; ~~~ {.cpp}; h->GetYaxis()->SetTitleOffset(0.);; ~~~; the axis title is automatically placed to avoid overlaps with the axis labels.; - Implement the automatic placement of the `TLegend`. A new constructor not; specifying the legend position is available. Only width and height are defined.; - `ChangeLabel` is now available for log axis as well as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8537).; - The `TGraph` copy constructor also copy the underlying `TH1F` if it exists (it; holds the axis titles).; - `TGraph` axis range was computed differently depending on the order of SetLog[x|y]""; This issue was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8751); - Add the new markers suggested [here](https://root-forum.cern.ch/t/adding-custom-markers/24506).; Improve the marker style for the OpenGl backend (some where wrong or missing). ![New markers](NewMarkers.png). - Remove a large memory leak in TFITSHDU's GetArrayRow, GetArrayColumn and GetTabRealVectorColumn member functions.; - When `TGraph`s belonging to a `TMultiGraph` were changed (for instance w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:13058,avoid,avoid,13058,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoid']
Safety,"ng frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a large register set before and after the; call in the caller. If the arguments are passed in callee-saved registers,; then they will be preserved by the callee across the call. This doesn't; apply for values returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11 and return registers, if any. R11 can be used as a scratch register.; The treatment of floating-point registers (XMMs/YMMs) matches the OS's C; calling convention: on most platforms, they are not preserved and need to; be saved by the caller, but on Windows, xmm6-xmm15 are preserved. - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. The idea behind this convention is to support calls to runtime functions; that have a hot path and a cold path. The hot path is usually a small piece; of code that doesn't use many registers. The cold path might need to call out to; another function and therefore only needs to preserve the caller-saved",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:16539,recover,recovering,16539,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recovering']
Safety,"ng the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be don",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:63748,safe,safety,63748,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ng to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` flag instructs Clang to stop after this step. * **Assembler**: This converts target-specific assembly code into; target-specific machine code object files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files into a single image; (either a shared object or an executable). Clang provides all of these pieces other than the linker. When multiple; steps are performed by the same tool, it is common for the steps to be; fused together to avoid creating intermediate files. When given an output of one of the above steps as an input, earlier steps; are skipped (for instance, a ``.s`` file input will be assembled and linked). The Clang driver can be invoked with the ``-###`` flag (this argument will need; to be escaped under most shells) to see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:2696,avoid,avoid,2696,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['avoid'],['avoid']
Safety,"ng type of pass is the ""`ImmutablePass; <https://llvm.org/doxygen/classllvm_1_1ImmutablePass.html>`_"" class. This pass; type is used for passes that do not have to be run, do not change state, and; never need to be updated. This is not a normal type of transformation or; analysis, but can provide information about the current compiler configuration. Although this pass class is very infrequently used, it is important for; providing information about the current target machine being compiled for, and; other static information that can affect the various transformations. ``ImmutablePass``\ es never invalidate other transformations, are never; invalidated, and are never ""run"". .. _writing-an-llvm-pass-ModulePass:. The ``ModulePass`` class; ------------------------. The `ModulePass <https://llvm.org/doxygen/classllvm_1_1ModulePass.html>`_ class; is the most general of all superclasses that you can use. Deriving from; ``ModulePass`` indicates that your pass uses the entire program as a unit,; referring to function bodies in no predictable order, or adding and removing; functions. Because nothing is known about the behavior of ``ModulePass``; subclasses, no optimization can be done for their execution. A module pass can use function level passes (e.g. dominators) using the; ``getAnalysis`` interface ``getAnalysis<DominatorTree>(llvm::Function *)`` to; provide the function to retrieve analysis result for, if the function pass does; not require any module or immutable passes. Note that this can only be done; for functions for which the analysis ran, e.g. in the case of dominators you; should only ask for the ``DominatorTree`` for function definitions, not; declarations. To write a correct ``ModulePass`` subclass, derive from ``ModulePass`` and; override the ``runOnModule`` method with the following signature:. The ``runOnModule`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnModule(Module &M) = 0;. The ``runOnModule`` method performs the interest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:12975,predict,predictable,12975,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['predict'],['predictable']
Safety,"ng++ -O2 -fprofile-instr-generate -fprofile-list=fun.list code.cc -o code. The option can be specified multiple times to pass multiple files. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fcoverage-mapping -fprofile-list=fun.list -fprofile-list=code.list code.cc -o code. Supported sections are ``[clang]``, ``[llvm]``, and ``[csllvm]`` representing; clang PGO, IRPGO, and CSIRPGO, respectively. Supported prefixes are ``function``; and ``source``. Supported categories are ``allow``, ``skip``, and ``forbid``.; ``skip`` adds the ``skipprofile`` attribute while ``forbid`` adds the; ``noprofile`` attribute to the appropriate function. Use; ``default:<allow|skip|forbid>`` to specify the default category. .. code-block:: console. $ cat fun.list; # The following cases are for clang instrumentation.; [clang]. # We might not want to profile functions that are inlined in many places.; function:inlinedLots=skip. # We want to forbid profiling where it might be dangerous.; source:lib/unsafe/*.cc=forbid. # Otherwise we allow profiling.; default:allow. Older Prefixes; """"""""""""""""""""""""""""; An older format is also supported, but it is only able to add the; ``noprofile`` attribute.; To filter individual functions or entire source files use ``fun:<name>`` or; ``src:<file>`` respectively. To exclude a function or a source file, use; ``!fun:<name>`` or ``!src:<file>`` respectively. The format also supports; wildcard expansion. The compiler generated functions are assumed to be located; in the main source file. It is also possible to restrict the filter to a; particular instrumentation type by using a named section. .. code-block:: none. # all functions whose name starts with foo will be instrumented.; fun:foo*. # except for foo1 which will be excluded from instrumentation.; !fun:foo1. # every function in path/to/foo.cc will be instrumented.; src:path/to/foo.cc. # bar will be instrumented only when using backend instrumentation.; # Recognized section names are clang, llvm and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:117525,unsafe,unsafe,117525,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe']
Safety,"ng.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4198,safe,safety,4198,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['safe'],['safety']
Safety,"ng/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23611,avoid,avoid,23611,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,2,"['avoid', 'unsafe']","['avoid', 'unsafe']"
Safety,"ngRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21990,avoid,avoids,21990,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"ngRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23855,abort,abort,23855,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"nity in `RooNumber::infinity()`, which was `1e30` before. Now, it is defined as `std::numeric_limits<double>::infinity()`, to be consistent with the C++ standard library and other code. This change also affects the `RooNumber::isInfinite()` function. ### Remove `add(row, weight, weightError)` from RooAbsData interface. It was not good to have this signature in RooAbsData, because the; implementations in the two derived classes RooDataHist and RooDataSet were; inconsistent. The RooDataSet indeed took the weight error as the third argument, but; the RooDataHist version instead took the sum of weights squared, which; is equivalent to the squared weight error. Therefore, the virtual `RooAbsData::add(row, weight, weightError)` function was removed. ### Removal of `RooMomentMorphND` class. The `RooMomentMorphND` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an impleme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14055,avoid,avoided,14055,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['avoid'],['avoided']
Safety,"nk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android ver",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4596,predict,predictable,4596,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['predict'],['predictable']
Safety,"nkContext`` object to perform a (potentially high-latency); asynchronous operation: allocating memory, resolving external symbols, and; finally transferring linked memory to the executing process. #. Phase 1. This phase is called immediately by the ``link`` function as soon as the; initial configuration (including the pass pipeline setup) is complete. #. Run pre-prune passes. These passes are called on the graph before it is pruned. At this stage; ``LinkGraph`` nodes still have their original vmaddrs. A mark-live pass; (supplied by the ``JITLinkContext``) will be run at the end of this; sequence to mark the initial set of live symbols. Notable use cases: marking nodes live, accessing/copying graph data that; will be pruned (e.g. metadata that's important for the JIT, but not needed; for the link process). #. Prune (dead-strip) the ``LinkGraph``. Removes all symbols and blocks not reachable from the initial set of live; symbols. This allows JITLink to remove unreachable symbols / content, including; overridden weak and redundant ODR definitions. #. Run post-prune passes. These passes are run on the graph after dead-stripping, but before memory; is allocated or nodes assigned their final target vmaddrs. Passes run at this stage benefit from pruning, as dead functions and data; have been stripped from the graph. However new content can still be added; to the graph, as target and working memory have not been allocated yet. Notable use cases: Building Global Offset Table (GOT), Procedure Linkage; Table (PLT), and Thread Local Variable (TLV) entries. #. Asynchronously allocate memory. Calls the ``JITLinkContext``'s ``JITLinkMemoryManager`` to allocate both; working and target memory for the graph. As part of this process the; ``JITLinkMemoryManager`` will update the addresses of all nodes; defined in the graph to their assigned target address. Note: This step only updates the addresses of nodes defined in this graph.; External symbols will still have null addresses. #. Pha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:18676,redund,redundant,18676,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['redund'],['redundant']
Safety,"nknown identifier, the; implementation searches in the database if this is a known entity. Line #1 does not require a definition and the forward declaration consumed at; startup is sufficient. Parsing of `Foo.h` is not required. This comes at a cost; of having some non-trivial patches in clang to merge default function arguments; and default template arguments. The design of the ROOTMAP infrastructure; requires the default arguments to be attached to more than one declaration which; is not allowed by standard C++. The behavior of line #1 is equivalent to:; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] S *s;; ```. Line #2 does not require a definition, however, the second identifier lookup; fails. The implementation knows that `foo::bar` is in *libFoo*. It `dlopen`s; libFoo which in turn, during its static initialization, inserts annotated forward; declaration as shown in `G__Foo.cxx`. In turn, this resolves `foo::bar` and; parsing of `Foo.h` is again avoided at relatively small overhead. However, this; is very hard to measure because the dictionary of each library can have different; amount of content. In the case where the library is big and the annotated; forward declarations are many, and we want to include a relatively small header; file it may not pay off. Moreover, the loading of the annotated forward; declarations can happen at any time during parsing. This is nick-named; ""recursive parsing"" and is a code path that exists only in ROOT, never exercised; by clang itself and is thus not well tested. The behavior of line #2 is; equivalent to:; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] foo::bar/*store parsing state*/; gSystem->Load(""Foo"");; // More scaffolding.; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; /*restore parsing state*/ *baz1;; ```. Line #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:9060,avoid,avoided,9060,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoided']
Safety,"nly``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-na",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59250,unsafe,unsafe,59250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe']
Safety,"nning pass (2) SROA on function (g); BISECT: running pass (3) Early CSE on function (g); BISECT: running pass (4) Infer set function attributes on module (test.ll); BISECT: running pass (5) Interprocedural Sparse Conditional Constant Propagation on module (test.ll); BISECT: running pass (6) Global Variable Optimizer on module (test.ll); BISECT: running pass (7) Promote Memory to Register on function (g); BISECT: running pass (8) Dead Argument Elimination on module (test.ll); BISECT: running pass (9) Combine redundant instructions on function (g); BISECT: running pass (10) Simplify the CFG on function (g); BISECT: running pass (11) Remove unused exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exception handling info on SCC (f); BISECT: running pass (15) Function Integration/Inlining on SCC (f); BISECT: running pass (16) Deduce function attributes on SCC (f); BISECT: NOT running pass (17) Remove unused exception handling info on SCC (g); BISECT: NOT running pass (18) Function Integration/Inlining on SCC (g); BISECT: NOT running pass (19) Deduce function attributes on SCC (g); BISECT: NOT running pass (20) SROA on function (g); BISECT: NOT running pass (21) Early CSE on function (g); BISECT: NOT running pass (22) Speculatively execute instructions if target has divergent branches on function (g); ... etc. ... Pass Skipping Implementation; ============================. The -opt-bisect-limit implementation depends on individual passes opting in to; the opt-bisect process. The OptBisect object that manages the process is; entirely passive and has no knowledge of how any pass is implemented. When a; pass is run if the pass may be skipped, it should call the OptBisect object to; see if it should be skipped. The OptBisect object is intended to be accessed through LLVMCo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:5782,redund,redundant,5782,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['redund'],['redundant']
Safety,"nnotation to parameter ``ptr``, indicating that the pointer; has ``N`` valid elements:. .. code-block:: c. void foo(int *__counted_by(N) ptr, size_t N);. Using this bounds information, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This doc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1597,safe,safety,1597,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"nnotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the default annotation for; ABI-visible pointers to be either ``__single``, ``__bidi_indexable``,; ``__indexable``, or ``__unsafe_indexable``. For instance,; ``__ptrcheck_abi_assume_unsafe_indexable()`` will make all ABI-visible pointers; be ``__unsafe_indexable``. Non-ABI visible pointers — the outermost pointer; types of local variables — are ``__bidi_indexable`` by default, so that these; pointers have the bounds information necessary to perform bounds checks without; the need for a manual annotation. All ``const char`` pointers or any typedefs; equivalent to ``const char`` pointers are ``__null_terminated`` by default. This; means that ``char8_t`` is ``unsigned char`` so ``const char8_t *`` won't be; ``__null_terminated`` by default. Similarly, ``const wchar_t *`` won't be; ``__null_terminated`` by default unless the platform defines it as ``typedef; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:21323,safe,safe,21323,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safe']
Safety,"non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36072,safe,safe,36072,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safe']
Safety,"nown to be the backing storage for a variable is considered to represent an; assignment to that variable. This gives us a safe fall-back in cases where `llvm.dbg.assign` intrinsics have; been deleted, the `DIAssignID` attachment on the store has been dropped, or the; optimiser has made a once-indirect store (not tracked with Assignment Tracking); direct. ### Middle-end: Considerations for pass-writers. #### Non-debug instruction updates. **Cloning** an instruction: nothing new to do. Cloning automatically clones a; `DIAssignID` attachment. Multiple instructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any instruction indicates that the memory location isn’t valid. **Merging** stores: In many cases no change is required as `DIAssignID`; attachments are automatically merged if `combineMetadata` is called. One way or; another, the `DIAssignID` attachments must be merged such that new store; becomes linked to all the `llvm.dbg.assign` intrinsics that the merged stores; were linked to. This can be achieved simply by calling a helper function; `Instruction::mergeDIAssignID`. **Inlining** stores: As stores are inlined we generate `llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** store",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:6295,safe,safe,6295,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['safe'],['safe']
Safety,"nsafe_indexable`` because it doesn't; have any invariant to maintain. * ``__single`` casts to ``__bidi_indexable`` if the pointee type has a known; size. After the conversion, the resulting ``__bidi_indexable`` has the size of; a single object of the pointee type of ``__single``. ``__single`` cannot cast; to ``__bidi_indexable`` if the pointee type is incomplete or sizeless. For; example, ``void *__single`` cannot convert to ``void *__bidi_indexable``; because void is an incomplete type and thus the compiler cannot correctly; determine the upper bound of a single void pointer. * Similarly, ``__single`` can cast to ``__indexable`` if the pointee type has a; known size. The resulting ``__indexable`` has the size of a single object of; the pointee type. * ``__single`` casts to ``__counted_by(E)`` only if ``E`` is 0 or 1. * ``__single`` can cast to ``__single`` including when they have different; pointee types as long as it is allowed in the underlying C standard.; ``-fbounds-safety`` doesn't guarantee type safety. * ``__bidi_indexable`` and ``__indexable`` can cast to ``__single``. The; compiler may insert run-time checks to ensure the pointer has at least a; single element or is a null pointer. * ``__bidi_indexable`` casts to ``__indexable`` if the pointer does not have an; underflow. The compiler may insert run-time checks to ensure the pointer is; not below the lower bound. * ``__indexable`` casts to ``__bidi_indexable``. The resulting; ``__bidi_indexable`` gets the lower bound same as the pointer value. * A type conversion may involve both a bitcast and a bounds annotation cast. For; example, casting from ``int *__bidi_indexable`` to ``char *__single`` involve; a bitcast (``int *`` to ``char *``) and a bounds annotation cast; (``__bidi_indexable`` to ``__single``). In this case, the compiler performs; the bitcast and then converts the bounds annotation. This means, ``int; *__bidi_indexable`` will be converted to ``char *__bidi_indexable`` and then; to ``char *__sin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:43036,safe,safety,43036,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['safe'],['safety']
Safety,"nstance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the; deserialization and serialization. The (de-)serialization is a mapping from the C++ type to the more simple **column** type system. A column contains; an arbitrary number of fixed-sized elements of a well-defined se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1278,safe,safety,1278,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['safe'],['safety']
Safety,"nstant. For example, the user could use the tool to remove `example_flag` from this; code:. ```c++; DEFINE_FLAG(std::string, example_flag, """", ""A sample flag."");. void Example() {; bool x = GetFlag(FLAGS_example_flag).empty();; f();; if (x) {; g();; } else {; h();; }; }; ```. The tool would simplify the code to:. ```c++; void Example() {; f();; g();; }; ```. We can solve this problem with a classic constant propagation lattice combined; with symbolic evaluation. ## Example: finding inefficient usages of associative containers. Real-world code often accidentally performs repeated lookups in associative; containers:. ```c++; map<int, Employee> xs;; xs[42]->name = ""..."";; xs[42]->title = ""..."";; ```. To find the above inefficiency we can use the available expressions analysis to; understand that `m[42]` is evaluated twice. ```c++; map<int, Employee> xs;; Employee &e = xs[42];; e->name = ""..."";; e->title = ""..."";; ```. We can also track the `m.contains()` check in the flow condition to find; redundant checks, like in the example below. ```c++; std::map<int, Employee> xs;; if (!xs.contains(42)) {; xs.insert({42, someEmployee});; }; ```. ## Example: refactoring types that implicitly convert to each other. Refactoring one strong type to another is difficult, but the compiler can help:; once you refactor one reference to the type, the compiler will flag other places; where this information flows with type mismatch errors. Unfortunately this; strategy does not work when you are refactoring types that implicitly convert to; each other, for example, replacing `int32_t` with `int64_t`. Imagine that we want to change user IDs from 32 to 64-bit integers. In other; words, we need to find all integers tainted with user IDs. We can use data flow; analysis to implement taint analysis. ```c++; void UseUser(int32_t user_id) {; int32_t id = user_id;; // Variable `id` is tainted with a user ID.; ...; }; ```. Taint analysis is very well suited to this problem because the program rarely; br",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:29293,redund,redundant,29293,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['redund'],['redundant']
Safety,"nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fmul float 4.0, %var ; yields float:result = 4.0 * %var. .. _i_udiv:. '``udiv``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = udiv <ty> <op1>, <op2> ; yields ty:result; <result> = udiv exact <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``udiv``' instruction returns the quotient of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``udiv``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the unsigned integer quotient of the two operands. Note that unsigned integer division and signed integer division are; distinct operations; for signed integer division, use '``sdiv``'. Division by zero is undefined behavior. For vectors, if any element; of the divisor is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:384275,unsafe,unsafe,384275,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"nt TGLCameraOverlay that allows to; display: a) coordinate axes for orthographic mode; b) intersection of; center of screen with a given plane. Add suport for fading in/out of the viewer contents. Many improvements in text and axis rendering for orthographic; view markup. In TGLSceneBase add data-member Bool_t; fSelectable allowing one to preventing any of its elements to be; selected. Useful when given scene is used as background to help guid; the eye. Eve. Added support for internal window management. Windows can be; arranged in horizontal/vertical stacks, tabs and main windows.; The containers and individaul windows can be moved to arbitrary; window-slot. See classes TEveWindow and TEveWindowManager. See tutorial tutorials/eve/test_windows.C. TEveQuadSet -- Add flag 'Bool_t fAntiFlick'. If on (now the; default) it causes each quad to be also rendered as a pixel, thus; preventing it from disappearing when zoomed away. This is needed for visualization of small quads, e.g. silicon; detectors digits. TEveCalo classes -- Add support for automatic rebinning; of 3D views (only supported for 2D views before). In 2D mode support; automatic determination of the cell color based on the most energetic; contribution from available calo slices. Add support for enumerative registration of calorimeter towers. Before; one had to provide THStack as input. See TEveCaloDataVec; class. TEveTrackList -- Generalized API for finding of momentum; limits. TEveTrackPropagator now supports propagation of charged; particles in arbitrary / external magnetic field. Propagation can be; done with the helix-stepper or with the Runge-Kutta method. New abstract interface to magnetic field TEveMagField to get; field vector at given position. Implement two interfaces:; TEveMagFieldConst for constant magnetic field and; TEveMagFieldDuo (two constant magnetic fields, chosen by; cylindrical radius). See examples in tutorials/eve/track.C. TEvePointSetArray -- Added underflow and overflow bins. Many improv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html:1213,detect,detectors,1213,graf3d/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html,2,['detect'],['detectors']
Safety,"nt along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belong either to; the current node or to one of its daughters. The full prototype of the; method is:. ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; ~~~. In the prototype above, besides the current point and direction that are; supposed already initialized, the only input parameter is `step`. This; represents the maximum step allowed by the tracking algorithm or the; `physical step`. The modeller will search for a boundary crossing only; up to a distance equal to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ~~~{.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig ` (default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:77219,safe,safety,77219,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"nt checks everywhere) and it can dramatically reduce the amount of; LLVM IR that is generated in some cases (particular for languages with a; macro preprocessor or that use a lot of constants). On the other hand, the ``IRBuilder`` is limited by the fact that it does; all of its analysis inline with the code as it is built. If you take a; slightly more complex example:. ::. ready> def test(x) (1+2+x)*(x+(1+2));; ready> Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 3.000000e+00, %x; %addtmp1 = fadd double %x, 3.000000e+00; %multmp = fmul double %addtmp, %addtmp1; ret double %multmp; }. In this case, the LHS and RHS of the multiplication are the same value.; We'd really like to see this generate ""``tmp = x+3; result = tmp*tmp;``""; instead of computing ""``x+3``"" twice. Unfortunately, no amount of local analysis will be able to detect and; correct this. This requires two transformations: reassociation of; expressions (to make the add's lexically identical) and Common; Subexpression Elimination (CSE) to delete the redundant add instruction.; Fortunately, LLVM provides a broad range of optimizations that you can; use, in the form of ""passes"". LLVM Optimization Passes; ========================. LLVM provides many optimization passes, which do many different sorts of; things and have different tradeoffs. Unlike other systems, LLVM doesn't; hold to the mistaken notion that one set of optimizations is right for; all languages and for all situations. LLVM allows a compiler implementor; to make complete decisions about what optimizations to use, in which; order, and in what situation. As a concrete example, LLVM supports both ""whole module"" passes, which; look across as large of body of code as they can (often a whole file,; but if run at link time, this can be a substantial portion of the whole; program). It also supports and includes ""per-function"" passes which just; operate on a single function at a time, without looking at other; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:3154,redund,redundant,3154,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['redund'],['redundant']
Safety,"nt in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds annotation defines an invariant for the pointer type, and the model; ensures that this invariant remains true. In the example below, pointer ``p``; annotated with ``__counted_by(count)`` must always point to a memory buffer; containing at least ``count`` elements of the pointee type. Changing the value; of ``count``, like in the example below, may violate this invariant and permit; out-of-bounds access to the pointer. To avoid this, the compiler employs; compile-time restrictions and emits run-time checks as necessary to ensure the; new count value doesn't exceed the actual length of the buffer. Section; `Maintaining correctness of bounds annotations`_ provides more details about; this programming model. .. code-block:: c. int g;. void foo(int *__counted_by(count) p, size_t count) {; count++; // may violate the invariant of __counted_by; count--; // may violate the invariant of __counted_by if count was 0.; count = g; // may violate the invariant of __counted_by; // depending on the value of `g`.; }. The requirement to annotate all pointers with explicit bounds information could; present a significant adoption burden. To tackle this issue, the model; incorporates the concept of a ""wide pointer"" (a.k.a. fat pointer) – a larger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentially reduce the adoption burden, as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:4409,avoid,avoid,4409,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"ntact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13911,detect,detect,13911,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['detect'],['detect']
Safety,"nter otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10633,unsafe,unsafe,10633,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['unsafe'],['unsafe']
Safety,"nter, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicitly be ``FILE; *__unsafe_indexable`` and thus it cannot be directly assigned to ``FILE *fp``; in the bounds-safe source. To allow this operation, ``__unsafe_forge_single``; is used to create a ``__single`` from the return value of ``fopen``. * Similar to ``__unsafe_indexable``, any non-pointer type (including ``int``,; ``intptr_t``, ``uintptr_t``, etc.) cannot be converted to any safe pointer; type because these don't have bounds information. ``__unsafe_forge_single`` or; ``__unsafe_forge_bidi_indexable`` must be used to force the conversion. * Any safe pointer types can cast to ``__unsafe_indexable`` because it doesn't; have any invariant to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:41106,safe,safety,41106,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"ntics). It should simplify building the CFG and my guess is it; > could enable some significant optimizations, though we should think; > about which. Great. I added a note to the switch section commenting on how the VM; should just use the instruction type as a hint, and that the; implementation may choose altermate representations (such as predicated; branches). > In the lookup-indirect form of the switch, is there a reason not to; > make the val-type uint?. No. This was something I was debating for a while, and didn't really feel; strongly about either way. It is common to switch on other types in HLL's; (for example signed int's are particularly common), but in this case, all; that will be added is an additional 'cast' instruction. I removed that; from the spec. > I agree with your comment that we don't need 'neg'. Removed. > There's a trade-off with the cast instruction:; > + it avoids having to define all the upcasts and downcasts that are; > valid for the operands of each instruction (you probably have; > thought of other benefits also); > - it could make the bytecode significantly larger because there could; > be a lot of cast operations. + You NEED casts to represent things like:; void foo(float);; ...; int x;; ...; foo(x);; in a language like C. Even in a Java like language, you need upcasts; and some way to implement dynamic downcasts.; + Not all forms of instructions take every type (for example you can't; shift by a floating point number of bits), thus SOME programs will need; implicit casts. To be efficient and to avoid your '-' point above, we just have to be; careful to specify that the instructions shall operate on all common; types, therefore casting should be relatively uncommon. For example all; of the arithmetic operations work on almost all data types. > Making the second arg. to 'shl' a ubyte seems good enough to me.; > 255 positions seems adequate for several generations of machines. Okay, that comment is removed. > and is more compact than uin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:2411,avoid,avoids,2411,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['avoid'],['avoids']
Safety,"ntrinsic defining a variable; location. This *could* be converted to an SSA form by mem2reg, in the same way; that it uses use-def chains to identify control flow merges and insert phi; nodes for IR Values. However, because debug variable locations are defined for; every machine instruction, in effect every IR instruction uses every variable; location, which would lead to a large number of debugging intrinsics being; generated. Examining the example above, variable ``!30`` is assigned ``%input`` on both; conditional paths through the function, while ``!23`` is assigned differing; constant values on either path. Where control flow merges in ``%bb1`` we would; want ``!30`` to keep its location (``%input``), but ``!23`` to become undefined; as we cannot determine at runtime what value it should have in %bb1 without; inserting a PHI node. mem2reg does not insert the PHI node to avoid changing; codegen when debugging is enabled, and does not insert the other dbg.values; to avoid adding very large numbers of intrinsics. Instead, LiveDebugValues determines variable locations when control; flow merges. A dataflow analysis is used to propagate locations between blocks:; when control flow merges, if a variable has the same location in all; predecessors then that location is propagated into the successor. If the; predecessor locations disagree, the location becomes undefined. Once LiveDebugValues has run, every block should have all valid variable; locations described by DBG_VALUE instructions within the block. Very little; effort is then required by supporting classes (such as; DbgEntityHistoryCalculator) to build a map of each instruction to every; valid variable location, without the need to consider control flow. From; the example above, it is otherwise difficult to determine that the location; of variable ``!30`` should flow ""up"" into block ``%bb1``, but that the location; of variable ``!23`` should not flow ""down"" into the ``%exit`` block. .. _ccxx_frontend:. C/C++ front-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:39325,avoid,avoid,39325,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"ntrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.cttz`` on any; integer bit width, or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.cttz``' intrinsic counts the trailing (least significant); zeros in a variable, or within each element of a vector. If ``src == 0``; then the result is the size in bits of the type of ``src`` if; ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.cttz(2) = 1``. .. _int_overflow:. .. _int_fshl:. '``llvm.fshl.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.fshl`` on any; integer bit width or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.fshl.i8 (i8 %a, i8 %b, i8 %c); declare i64 @llvm.fshl.i64(i64 %a, i64 %b, i64 %c); declare <2 x i32> @llvm.fshl.v2i32(<2 x i32> %a, <2 x i32> %b, <2 x i32> %c). Overview:; """""""""""""""""". The '``llvm.fshl``' family of intrinsic functions performs a funnel shift left:; the first two v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:595964,avoid,avoiding,595964,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoiding']
Safety,"ntrol specific attributes of the target, such as whether SIMD; operations are enabled or not. The default set of attributes is set by the; current CPU. For a list of available attributes, use:. .. code-block:: none. llvm-as < /dev/null | llc -march=xyz -mattr=help. .. option:: --frame-pointer. Specify effect of frame pointer elimination optimization (all,non-leaf,none). .. option:: --disable-excess-fp-precision. Disable optimizations that may produce excess precision for floating point.; Note that this option can dramatically slow down code on some systems; (e.g. X86). .. option:: --enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: --enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: --enable-no-signed-zeros-fp-math. Enable FP math optimizations that assume the sign of 0 is insignificant. .. option:: --enable-no-trapping-fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which conta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:3817,unsafe,unsafe-fp-math,3817,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['unsafe'],['unsafe-fp-math']
Safety,"ntrol this merging:; ; NoIndex : all the TTreeIndex object are dropped.; DropIndexOnError : if any of the underlying TTree object do no have a TTreeIndex,; they are all dropped.; AsIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree object do no have a TTreeIndex,; all TTreeIndex are 'ignored' and the mising piece are rebuilt. Previously the index were kept only if the first files had an index and if there was any missing index,; the resulting index had gaps (the default was similar to AsIsIndexOnError). The new default is BuildIndexOnError ; i.e.; we now attempt by default to build the missing indices. In TBranch CopyAddress (and hence indirectly in the fast cloning); avoid having to read the first entry just to get the address set; and do the address setting directly. In TTree::CopyAddress when copying the addresses of a branch created by a leaflist; and where the memory buffer was allocated automatically (as opposed to set by the user); avoid deleting the memory allocated by the tree each time CopyAddress is called.; (This effectively prevented cloning more than once a TTree with a branch created by a leaflist.). Warning: The TTreeCache is no longer enabled by default in a TChain to align the behavior with a TTree. You need to call; TTree::SetCacheSize to enable the TTreeCache.; Correct and clarify the relationship between AutoFlush and AutoSave:; ; Both the AutoFlush and AutoSave interval can be specified in; terms of bytes (a negative value for fAutoFlush or fAutoSave); or in terms of the number of entries (positive values).; An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave interval is used for both.; If the AutoFlush interval is less than the AutoSave interval,; the AutoSave interval is adjusted to the largest integer; multiple of the AutoFlush interval that is less than or equal; to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:2648,avoid,avoid,2648,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,2,['avoid'],['avoid']
Safety,"nu.org/onlinedocs/gcc/C-Extensions.html>`_ for more information on; these extensions. .. _langext-feature_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1505,abort,abort,1505,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['abort'],['abort']
Safety,"nup.; Usually used in the first line, so it is visible without opening the; actual commit email. O; -; .. _object pointer:; .. _object pointers:. **Object Pointer**; A pointer to an object such that the garbage collector is able to trace; references contained within the object. This term is used in opposition to; `derived pointer`_. P; -. **PGO**; Profile-Guided Optimization. **PR**; Problem report. A bug filed on `the LLVM Bug Tracking System; <https://bugs.llvm.org/enter_bug.cgi>`_. **PRE**; Partial Redundancy Elimination. R; -. **RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:6837,redund,redundancy,6837,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['redund'],['redundancy']
Safety,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17340,predict,predict,17340,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['predict'],['predict']
Safety,"nvisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`; 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; rootgeom.C example looks clipped with a tube. \image html geometry014.png ""Ray-tracing example with box-clipping"". \anchor GP05; ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; `TGeo` offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. \anchor GP05a; ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In `TGeo`, physical nodes are represented by; the class TGeoPhysic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:106237,detect,detector,106237,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"o ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25736,avoid,avoided,25736,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['avoid', 'risk']","['avoided', 'risking']"
Safety,"o all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigation algorithms. The problem is that in order to reproduce the; honeycomb structure out of rows of cells, we have to overlap row; containers. Whoops - we have not obeyed rule No. 2 in positioning.; The way out is to position our rows with a special prototype:. ``` {.cpp}; ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; ```. This will instruct the modeller that the daughter ROW inside CAL; overlaps with something else. The modeller will check this at closure; time and build a list of possibly overlapping candidates. This option is; equivalent with the option MANY in GEANT3. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:76433,avoid,avoid,76433,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['avoid'],['avoid']
Safety,"o all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigation algorithms. The problem is that in order to reproduce the; honeycomb structure out of rows of cells, we have to overlap row; containers. Whoops - we have not obeyed rule No. 2 in positioning.; The way out is to position our rows with a special prototype:. ~~~{.cpp}; ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; ~~~. This will instruct the modeller that the daughter ROW inside CAL; overlaps with something else. The modeller will check this at closure; time and build a list of possibly overlapping candidates. This option is; equivalent with the option MANY in GEANT3. The m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:36872,avoid,avoid,36872,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"o be modularized. As part of our ongoing efforts to move; CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The; tool detects (based on the include paths of the compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] import Foo.*;; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. The implementation avoids recursive actions and relies on a well-defined (by; the C++ standard) behavior. Currently, this comes with a constant performance; overhead which we go in details bellow. ROOT uses the global module index (GMI) to avoid the performance overhead. ROOT; only preloads the set of C++ modules which are not present in the GMI. The; example becomes equivalent to:. ```cpp; // ROOT prompt; root [] import Foo.*; // Preload Foo if it is not in the GMI.; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. Line #4 forces cling to send ROOT a callback that TCanvas in unknown but; the GMI resolves it to module Gpad, loads it and returns the control to cling. ### Performance; This section compares ROOT PCH technology with C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:16445,avoid,avoids,16445,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoids']
Safety,"o be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__)). #define ACQUIRED_AFTER(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__)). #define REQUIRES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__)). #define REQUIRES_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__)). #define ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquire_capability(__VA_ARGS__)). #define ACQUIRE_SHARED(...)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:25240,safe,safely,25240,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safely']
Safety,"o be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10401,avoid,avoid,10401,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['avoid'],['avoid']
Safety,"o detect when you're compiling CUDA code specifically with clang. This is tricky, because NVCC may invoke clang as part of its own compilation; process! For example, NVCC uses the host compiler's preprocessor when; compiling for device code, and that host compiler may in fact be clang. When clang is actually compiling CUDA code -- rather than being used as a; subtool of NVCC's -- it defines the ``__CUDA__`` macro. ``__CUDA_ARCH__`` is; defined only in device mode (but will be defined if NVCC is using clang as a; preprocessor). So you can use the following incantations to detect clang CUDA; compilation, in host and device modes:. .. code-block:: c++. #if defined(__clang__) && defined(__CUDA__) && !defined(__CUDA_ARCH__); // clang compiling CUDA code, host mode.; #endif. #if defined(__clang__) && defined(__CUDA__) && defined(__CUDA_ARCH__); // clang compiling CUDA code, device mode.; #endif. Both clang and nvcc define ``__CUDACC__`` during CUDA compilation. You can; detect NVCC specifically by looking for ``__NVCC__``. Dialect Differences Between clang and nvcc; ==========================================. There is no formal CUDA spec, and clang and nvcc speak slightly different; dialects of the language. Below, we describe some of the differences. This section is painful; hopefully you can skip this section and live your life; blissfully unaware. Compilation Models; ------------------. Most of the differences between clang and nvcc stem from the different; compilation models used by clang and nvcc. nvcc uses *split compilation*,; which works roughly as follows:. * Run a preprocessor over the input ``.cu`` file to split it into two source; files: ``H``, containing source code for the host, and ``D``, containing; source code for the device. * For each GPU architecture ``arch`` that we're compiling for, do:. * Compile ``D`` using nvcc proper. The result of this is a ``ptx`` file for; ``P_arch``. * Optionally, invoke ``ptxas``, the PTX assembler, to generate a file,; ``S_a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:8636,detect,detect,8636,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['detect'],['detect']
Safety,"o fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the way results are transferred and merged:. Output objects are added to the same TMessage until a; HWM is reached (default 1MB; controlled by 'ProofServ.MsgSizeHWM');; this limits the number of transfers in the case of large numbers of; small objects.; Reasonably small histograms (GetSize() <; MsgSizeHWM) are merged in one-go at the end instead of one-by-one to; exploit, for example, the better performance of TH1::Merge on the full; list of histos.; Add possibility to compress the messages; this is; controlled by ProofServ.CompressMessage; <compression_level>; The default is still 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:7528,timeout,timeout,7528,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['timeout'],['timeout']
Safety,"o linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98536,redund,redundant,98536,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['redund'],['redundant']
Safety,"o specify an architecture that is not included in the; universal binary or to use an architecture that does not match a; non-universal binary. .. option:: -format=<FORMAT>. Use the specified output format. The supported formats are: ""text"" (JSON),; ""lcov"". .. option:: -summary-only. Export only summary information for each file in the coverage data. This mode; will not export coverage information for smaller units such as individual; functions or regions. The result will contain the same information as produced; by the :program:`llvm-cov report` command, but presented in JSON or lcov; format rather than text. .. option:: -ignore-filename-regex=<PATTERN>. Skip source code files with file paths that match the given regular expression. .. option:: -skip-expansions. Skip exporting macro expansion coverage data. .. option:: -skip-functions. Skip exporting per-function coverage data. .. option:: -num-threads=N, -j=N. Use N threads to export coverage data. When N=0, llvm-cov auto-detects an; appropriate number of threads to use. This is the default. .. option:: -compilation-dir=<dir>. Directory used as a base for relative coverage mapping paths. Only applicable; when binaries have been compiled with one of `-fcoverage-prefix-map`; `-fcoverage-compilation-dir`, or `-ffile-compilation-dir`. .. option:: -debuginfod. Attempt to look up coverage mapping from objects using debuginfod. This is; attempted by default for binary IDs present in the profile but not provided on; the command line, so long as debuginfod is compiled in and configured via; DEBUGINFOD_URLS. .. option:: -debug-file-directory=<dir>. Provides a directory to search for objects corresponding to binary IDs in the; profile. .. option:: -check-binary-ids. Fail if an object file cannot be found for a binary ID present in the profile,; neither on the command line nor via binary ID lookup. CONVERT-FOR-TESTING COMMAND; ---------------------------. .. warning::; This command is for the LLVM developers who are working on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:18297,detect,detects,18297,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['detect'],['detects']
Safety,"o subsequent if statements are; identical. int test(int c) {; if (c > 5); c += 1;; if (c > 5) // warn; c -= 1;; return c;; }. different.LogicalOpUselessArg; (C); The second operand of a && operator has no impact on; expression result. void test(unsigned a) {; if (a<7 && a<10) {}; // warn; }. different.SameResLogicalExpr; (C); An expression is always evaluated to true/false. void test() {; int i = 0;; if (i != 0) {}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of other type. Parenthesis may bee required around an; assignment. int f();. void test(int x, int y) {; bool b;; if((b = x != y)) {} // ok; if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:23212,Avoid,Avoiding,23212,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['Avoid'],['Avoiding']
Safety,"o traditional data structures; of computer science such as arrays, lists, and trees. Collections can be thought of as polymorphic containers that can contain; different types of elements. For this release of the ROOT system, elements; to be placed in collections must be instances of classes.; These may be classes defined by you or provided by ROOT. Collection elements; must be instances of classes descending from ; TObject. The dependence of collections on TObject may disappear; in the future when all C++ compilers used with the ROOT system fully; support templates. In the mean time, knowing the; role TObject plays in collections can be helpful. In general you don't need to worry about TObject. Many ROOT; classes have TObject as an ancestor. In fact, collections themselves; are descendants of TObject. This makes it possible for collections to; contain other collections (subcollections) in a tree structure. Such trees; are used in the ROOT system to implement components of the graphics system; (graphics pads containing pads), geometries (detectors in detectors), etc. The basic protocol TObject defines for collection elements is shown below:. IsEqual(); Compare(); IsSortable(); Hash(). How to use and override these member functions is shown in the; example program. Types of Collections. The ROOT system implements the following type of collections:; arrays, lists, sorted lists, B-trees, hashtables and maps.; The figure below shows the inheritance hierarchy for the primary; collection classes. Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they; were added. The following sequence collections are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. Both a TObjArray as well as a TOrdCollection can be sorted; using their Sort() member function (assuming the stored items are; sortable). Sorted Collections. Sorted collections are ordered by an int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html:1499,detect,detectors,1499,core/cont/doc/Understanding_Collections.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html,4,['detect'],['detectors']
Safety,"o trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and the -p and -o option. ACLiC. Allow ACLiC to use a flat directory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copied. TStreamerInfo::New inserts the address of the creating TStreamerInfo into; the object. This address is inserted in each emulated that does not inherit; from an emulated class and is positioned after all the base classes (which; are compiled classes). A derived class will set this value inside each; of its emulated base class.; TStreamerInfo::Destruct and the new method TStreamerInfo::GetActualClass; use this information to detect the TStreamerInfo actually used to create; the object and hence run the proper emulated destructor. Add a new function GenerateDictionary to TInterpreter which allows for the quick and easy creation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:2459,avoid,avoids,2459,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,4,['avoid'],"['avoid', 'avoids']"
Safety,"o use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7623,safe,safe,7623,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['safe'],['safe']
Safety,"o-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59945,unsafe,unsafe-math-optimizations,59945,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe-math-optimizations']
Safety,"o; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates to M that it should economize function; calls; it is intended for cases where there are many variable parameters; and/or the function takes a long time to calculate and/or the user is; not interested in very precise values for parameter errors. On the other; hand, value 2 (high) indicates that M is allowed to waste function calls; in order to be sure that all va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:11074,safe,safe,11074,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,"['risk', 'safe']","['risk', 'safe']"
Safety,"oads do not alias; (`-noalias=true`) store operations. Under this assumption, younger loads are; always allowed to pass older stores. Essentially, the LSUnit does not attempt; to run any alias analysis to predict when loads and stores do not alias with; each other. Note that, in the case of write-combining memory, rule 3 could be relaxed to; allow reordering of non-aliasing store operations. That being said, at the; moment, there is no way to further relax the memory model (``-noalias`` is the; only option). Essentially, there is no option to specify a different memory; type (e.g., write-back, write-combining, write-through; etc.) and consequently; to weaken, or strengthen, the memory model. Other limitations are:. * The LSUnit does not know when store-to-load forwarding may occur.; * The LSUnit does not know anything about cache hierarchy and memory types.; * The LSUnit does not know how to identify serializing operations and memory; fences. The LSUnit does not attempt to predict if a load or store hits or misses the L1; cache. It only knows if an instruction ""MayLoad"" and/or ""MayStore."" For; loads, the scheduling model provides an ""optimistic"" load-to-use latency (which; usually matches the load-to-use latency for when there is a hit in the L1D). :program:`llvm-mca` does not (on its own) know about serializing operations or; memory-barrier like instructions. The LSUnit used to conservatively use an; instruction's ""MayLoad"", ""MayStore"", and unmodeled side effects flags to; determine whether an instruction should be treated as a memory-barrier. This was; inaccurate in general and was changed so that now each instruction has an; IsAStoreBarrier and IsALoadBarrier flag. These flags are mca specific and; default to false for every instruction. If any instruction should have either of; these flags set, it should be done within the target's InstrPostProcess class.; For an example, look at the `X86InstrPostProcess::postProcessInstruction` method; within `llvm/lib/Target/X",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:41186,predict,predict,41186,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['predict'],['predict']
Safety,"object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by invoking; **`TThread`**`::CancelPoint()`. Then, if a thread is canceled, the; cancellation is deferred up to the call of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:11648,safe,safely,11648,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safely']
Safety,"ock:: c++. if (__builtin_expect_with_probability(x > 0, 1, 0.8)) {; // This block is likely to be taken with probability 80%.; }. ``switch`` statement; ^^^^^^^^^^^^^^^^^^^^. This is basically the same as ``switch`` statement in ``__builtin_expect``.; The probability that ``exp`` is equal to the expect value is given in; the third argument ``probability``, while the probability of other value is; the average of remaining probability(``1.0 - probability``). For example:. .. code-block:: c++. switch (__builtin_expect_with_probability(x, 5, 0.7)) {; default: break; // Take this case with probability 10%; case 0: break; // Take this case with probability 10%; case 3: break; // Take this case with probability 10%; case 5: break; // This case is likely to be taken with probability 70%; }. CFG Modifications; =================. Branch Weight Metatada is not proof against CFG changes. If terminator operands'; are changed some action should be taken. In other case some misoptimizations may; occur due to incorrect branch prediction information. Function Entry Counts; =====================. To allow comparing different functions during inter-procedural analysis and; optimization, ``MD_prof`` nodes can also be assigned to a function definition.; The first operand is a string indicating the name of the associated counter. Currently, one counter is supported: ""function_entry_count"". The second operand; is a 64-bit counter that indicates the number of times that this function was; invoked (in the case of instrumentation-based profiles). In the case of; sampling-based profiles, this operand is an approximation of how many times; the function was invoked. For example, in the code below, the instrumentation for function foo(); indicates that it was called 2,590 times at runtime. .. code-block:: llvm. define i32 @foo() !prof !1 {; ret i32 0; }; !1 = !{!""function_entry_count"", i64 2590}. If ""function_entry_count"" has more than 2 operands, the later operands are; the GUID of the functions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst:5584,predict,prediction,5584,interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,1,['predict'],['prediction']
Safety,"ocumentation](https://github.com/civetweb/civetweb/blob/master/docs/); and have a look at the [examples](https://github.com/civetweb/civetweb/blob/master/examples/). Recent questions and discussions usually use [GitHub issues](https://github.com/civetweb/civetweb/issues).; Some old information may be found on the [mailing list](https://groups.google.com/d/forum/civetweb), ; but this information may be outdated. Feel free to create a GitHub issue for bugs, feature requests, questions, suggestions or if you want to share tips and tricks.; When creating an issues for a bug, add enough description to reproduce the issue - at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md). Authors; -------. CivetWeb has been forked from the last MIT version of Mongoose in 2013.; Since then, CivetWeb has seen many improvements from various authors; (Copyright (c) 2013-2021 the CivetWeb developers, MIT license). A list of authors can be found in [CREDITS.md](",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:9201,risk,risk,9201,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['risk'],['risk']
Safety,"od Anchor for Classes in Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If a class is defined in a header file and has a vtable (either it has virtual; methods or it derives from classes with virtual methods), it must always have at; least one out-of-line virtual method in the class. Without this, the compiler; will copy the vtable and RTTI into every ``.o`` file that ``#include``\s the; header, bloating ``.o`` file sizes and increasing link times. Don't use default labels in fully covered switches over enumerations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``-Wswitch`` warns if a switch, without a default label, over an enumeration; does not cover every enumeration value. If you write a default label on a fully; covered switch over an enumeration then the ``-Wswitch`` warning won't fire; when new elements are added to that enumeration. To help avoid adding these; kinds of defaults, Clang has the warning ``-Wcovered-switch-default`` which is; off by default but turned on when building LLVM with a version of Clang that; supports the warning. A knock-on effect of this stylistic requirement is that when building LLVM with; GCC you may get warnings related to ""control may reach end of non-void function""; if you return from each case of a covered switch-over-enum because GCC assumes; that the enum expression may take any representable value, not just those of; individual enumerators. To suppress this warning, use ``llvm_unreachable`` after; the switch. Use range-based ``for`` loops wherever possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The introduction of range-based ``for`` loops in C++11 means that explicit; manipulation of iterators is rarely necessary. We use range-based ``for``; loops wherever possible for all newly added code. For example:. .. code-block:: c++. BasicBlock *BB = ...; for (Instruction &I : *BB); ... use I ... Usage of ``std::for_each()``/``llvm::for_each()`` functions is discouraged,; unles",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:51451,avoid,avoid,51451,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"ode-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23745,abort,abort,23745,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"ode-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp sl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192532,safe,safe,192532,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"oduces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Methods. \image html geometry009.png ""Safety computation checking"" width=500px. In order to check a given point, `CheckPoint(x,y,z)` method of; TGeoManager draws the daughters of the volume containing the po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:95089,detect,detected,95089,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detected']
Safety,"of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4901,detect,detection,4901,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['detect'],['detection']
Safety,"of conduct applies to all spaces managed by the LLVM project or The; LLVM Foundation. This includes IRC channels, mailing lists, bug trackers, LLVM; events such as the developer meetings and socials, and any other forums created; by the project that the community uses for communication. It applies to all of; your communication and conduct in these spaces, including emails, chats, things; you say, slides, videos, posters, signs, or even t-shirts you display in these; spaces. . In rare cases, violations of this code outside of these spaces may affect a ; person’s ability to participate within these spaces. Important examples ; include `sexual and gender-based violence`_, `hate crimes`_, and `hate speech`_. ; We do not conduct proactive research, but we have an obligation to respond ; to any reported concerns. We are not interested in evaluating severity, ; responding punitively, or holding people accountable. Both the relevance ; and our response is instead focused on how a person’s continued participation ; impacts the community’s safety, wellbeing, and inclusivity. We specifically ; prioritize remaining a welcoming community to victims as well as groups ; subjected to systemic marginalization or underrepresentation. In addition, violations of this code outside these spaces may, in rare; cases, affect a person's ability to participate within them, when the conduct; amounts to an egregious violation of this code. If you believe someone is violating the code of conduct, we ask that you report; it by emailing conduct@llvm.org. For more details please see the ; :doc:`Reporting Guide <ReportingGuide>`. .. _be friendly and patient:. * **Be friendly and patient.**. .. _be welcoming:. * **Be welcoming.** We strive to be a community that welcomes and supports; people of all backgrounds and identities. This includes, but is not limited; to members of any race, ethnicity, culture, national origin, colour,; immigration status, social and economic class, educational level, sex, se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:1900,safe,safety,1900,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['safe'],['safety']
Safety,"of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only if thread is not; running. Often during the canceling, some clean up actions must be; taken. To define clean up functions use:. ``` {.cpp}; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; ```. Note: `CleanUpPush` and `CleanUpPop` should be used as corresponding; pairs like brackets; unlike `pthreads` cleanup stack (which is *not*; implemented here), **`TThread`** does not force this usage. #### Finishing thread. When a thread returns from a user function the thread is finished. It; also can be finished by `TThread::Exit()`. Then, in case of; `thread`-detached mode, the thread vanishes completely. By default, on; finishing **`TThread`** executes the most recent cleanup ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:12571,safe,safe,12571,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"oint/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:79525,safe,safe,79525,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"older, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19922,avoid,avoid,19922,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['avoid'],['avoid']
Safety,"olume or it will exit inside its container:. ~~~{.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ~~~. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the comput",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:79307,safe,safety,79307,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"olymorphism of Emulated Object inheriting from compiled class). See the Core/Meta section for details.; Add support for streaming auto_ptr when generating their dictionary via rootcint; Enable the use of the I/O customization rules on data members that are either a variable size array or a fixed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""Int_t *fArray; Int_t fN;"" \; target = ""fArray"" \; code = ""{ fArray = new Char_t[onfile.fN]; Char_t* gtc=fArray; Int_t* gti=onfile.fArray; \; for(Int_t i=0; i<onfile.fN; i++) *(gtc+i) = *(gti+i)+10; }""; #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""float fValues[3]"" \; target = ""fValues"" \; code = ""{ for(Int_t i=0; i<3; i++) fValues[i] = 1+onfile.fValues[i]; }"". Allow the seamless schema evolution from map<a,b> to vector<pair<a,b> >.; Avoid dropping information when reading a long written on a 64 bits platforms; and being read into a long long on a 32 bits platform (previously the higher; bits were lost due to passing through a 32 bits temporary long).; Migrate the functionality of TStreamerInfo::TagFile to a new interface TBuffer::TagStreamerInfo; so that TMessage can customize the behavior. TMessage now relies on this new interface; instead of TBuffer::IncrementLevel.; New option to hadd, -O requesting the (re)optimization of the basket size (by avoid the fast merge technique). The equivalent in TFileMerger is to call; merger->SetFastMethod(kFALSE); To make sure that the class emulation layer of ROOT does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. The handling of memory by the collection proxy has been improved in the case of a; collection of pointers which can now become owner of its content. The default, for backward compatibility reasons and to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:10434,Avoid,Avoid,10434,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['Avoid'],['Avoid']
Safety,"ompoundColorSelectionBits enum. TEveElement: propagate transparency to projected replicas. As this; is implemented in the base-class, it works for all projectable classes. TEveVector, TEveVector4 and TEveVector2 are now typedefs to float; specialization of corresponding templates. Double versions use 'D' as; postfix, 'F' postfix is another alias for float versions, e.g.:; typedef TEveVectorT<Float_t> TEveVector;; typedef TEveVectorT<Float_t> TEveVectorF;; typedef TEveVectorT<Double_t> TEveVectorD;. All projectable classes now take into account their transformation; matrix. The projected versions are still stored in global; coordinates.; TEveShape -- a new abstract base-class for 2D/3D shapes that; require fill / outline color, line-width and various flags; controlling the area / outline drawing.; TEveGeoShape and projected classes: subclass from TEveShape. Add; support for TGeoCompositeShapes. In 2D projected class; (TEvePolygonSetProjected) improve detection of duplicate polygons; and add support for detection of minimal-outline (triggered via; Bool_t TEveShape::fMiniOutline).; TEveBox: New class to draw a simple cuboid with minimal memory; usage. It is projectable.; TEveBoxSet: for box-type kBT_FreeBox assure proper face; orientation at registration time and calculate normals when; rendering. TEveJetCone is now projectable.; Several performance improvements when dealing with large; collections of EVE objects. Profiled with simulated heavy-ion; data. In particular, for destruction of self-contained sub-hierarchies of objects; one can use TEveElement::Annihilate() and; TEveElement::AnnihilateElements(). See class docs for constraints. Minor changes. Add support for projecting a new child (all children) of an; element after the element and its old children have already been; projected. This is provided by the following virtual functions in; TEveElement:; void ProjectChild(TEveElement* el, Bool_t sameDepth=kTRUE);; void ProjectAllChildren(Bool_t same_depth=kTRUE);. Se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:5285,detect,detection,5285,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,4,['detect'],['detection']
Safety,"on file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF mas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:2887,avoid,avoid,2887,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['avoid'],['avoid']
Safety,"on may describe the same; physical location. e.g. A stack slot may appear as a deopt location,; a gc base pointer, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing wo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:24001,safe,safepoint,24001,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,2,['safe'],['safepoint']
Safety,"on methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84475,detect,detect,84475,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['detect'],['detect']
Safety,"on unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6429,detect,detection,6429,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"on, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8564,avoid,avoided,8564,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['avoid'],['avoided']
Safety,"on; **SAN**\ity"". GWP-ASan is based on the classic; `Electric Fence Malloc Debugger <https://linux.die.net/man/3/efence>`_, with a; key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-parity where reasonable, and to; support compiler-rt as the reference implementation. Allocator Support; -----------------. GWP-ASan is not a replacement for a traditional allocator. Instead, it works by; inserting stubs into a supporting allocator to redirect allocations to GWP-ASan; when they're chosen to be sampled. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:1315,detect,detection,1315,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"onditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:17794,safe,safety,17794,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"one (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75396,detect,detector,75396,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detector']
Safety,"oned above); whenever feasible.; - Include comments about what is tested/expected in a particular test. If there; are relevant issues in the bug tracker, add references to those bug reports; (for example, ""See PR999 for more details"").; - Avoid undefined behavior and poison/undef values unless necessary. For; example, do not use patterns like ``br i1 undef``, which are likely to break; as a result of future optimizations.; - Minimize tests by removing unnecessary instructions, metadata, attributes,; etc. Tools like ``llvm-reduce`` can help automate this.; - Outside PhaseOrdering tests, only run a minimal set of passes. For example,; prefer ``opt -S -passes=instcombine`` over ``opt -S -O3``.; - Avoid unnamed instructions/blocks (such as ``%0`` or ``1:``), because they may; require renumbering on future test modifications. These can be removed by; running the test through ``opt -S -passes=instnamer``.; - Try to give values (including variables, blocks and functions) meaningful; names, and avoid retaining complex names generated by the optimization; pipeline (such as ``%foo.0.0.0.0.0.0``). Extra files; -----------. If your test requires extra files besides the file containing the ``RUN:`` lines; and the extra files are small, consider specifying them in the same file and; using ``split-file`` to extract them. For example,. .. code-block:: llvm. ; RUN: split-file %s %t; ; RUN: llvm-link -S %t/a.ll %t/b.ll | FileCheck %s. ; CHECK: ... ;--- a.ll; ...; ;--- b.ll; ... The parts are separated by the regex ``^(.|//)--- <part>``. If you want to test relative line numbers like ``[[#@LINE+1]]``, specify; ``--leading-lines`` to add leading empty lines to preserve line numbers. If the extra files are large, the idiomatic place to put them is in a subdirectory ``Inputs``.; You can then refer to the extra files as ``%S/Inputs/foo.bar``. For example, consider ``test/Linker/ident.ll``. The directory structure is; as follows::. test/; Linker/; ident.ll; Inputs/; ident.a.ll; ident.b.ll.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:14527,avoid,avoid,14527,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoid']
Safety,"ones for; :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. The; differences in approach are covered in the `Garbage Collection with LLVM; <GarbageCollection.html>`_ documentation. The intrinsics themselves are; described in :doc:`Statepoints`. .. _int_gcroot:. '``llvm.gcroot``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.gcroot(ptr %ptrloc, ptr %metadata). Overview:; """""""""""""""""". The '``llvm.gcroot``' intrinsic declares the existence of a GC root to; the code generator, and allows some metadata to be associated with it. Arguments:; """""""""""""""""""". The first argument specifies the address of a stack object that contains; the root pointer. The second pointer (which must be either a constant or; a global value address) contains the meta-data to be associated with the; root. Semantics:; """""""""""""""""""". At runtime, a call to this intrinsic stores a null pointer into the; ""ptrloc"" location. At compile-time, the code generator generates; information to allow the runtime to find the pointer at GC safe points.; The '``llvm.gcroot``' intrinsic may only be used in a function which; :ref:`specifies a GC algorithm <gc>`. .. _int_gcread:. '``llvm.gcread``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.gcread(ptr %ObjPtr, ptr %Ptr). Overview:; """""""""""""""""". The '``llvm.gcread``' intrinsic identifies reads of references from heap; locations, allowing garbage collector implementations that require read; barriers. Arguments:; """""""""""""""""""". The second argument is the address to read from, which should be an; address allocated from the garbage collector. The first object is a; pointer to the start of the referenced object, if needed by the language; runtime (otherwise null). Semantics:; """""""""""""""""""". The '``llvm.gcread``' intrinsic has the same semantics as a load; instruction, but may be replaced with substantially more complex code by; the garbage collector runtime, as needed. The '``llvm.gcread``'; intrinsic may o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:497515,safe,safe,497515,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:50846,safe,safe,50846,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ~~~ {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ~~~. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ~~~ {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ~~~. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ~~~ {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:4562,safe,safe,4562,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,"ons cannot overlap. Also, overlapping regions; cannot have the same name. There is no support for marking regions from high-level source code, like C or; C++. As a workaround, inline assembly directives may be used:. .. code-block:: c++. int foo(int a, int b) {; __asm volatile(""# LLVM-MCA-BEGIN foo"":::""memory"");; a += 42;; __asm volatile(""# LLVM-MCA-END"":::""memory"");; a *= b;; return a;; }. However, this interferes with optimizations like loop vectorization and may have; an impact on the code generated. This is because the ``__asm`` statements are; seen as real code having important side effects, which limits how the code; around them can be transformed. If users want to make use of inline assembly; to emit markers, then the recommendation is to always verify that the output; assembly is equivalent to the assembly generated in the absence of markers.; The `Clang options to emit optimization reports <https://clang.llvm.org/docs/UsersManual.html#options-to-emit-optimization-reports>`_; can also help in detecting missed optimizations. INSTRUMENT REGIONS; ------------------. An InstrumentRegion describes a region of assembly code guarded by; special LLVM-MCA comment directives. .. code-block:: none. # LLVM-MCA-<INSTRUMENT_TYPE> <data>; ... ## asm. where `INSTRUMENT_TYPE` is a type defined by the target and expects; to use `data`. A comment starting with substring `LLVM-MCA-<INSTRUMENT_TYPE>`; brings data into scope for llvm-mca to use in its analysis for; all following instructions. If a comment with the same `INSTRUMENT_TYPE` is found later in the; instruction list, then the original InstrumentRegion will be; automatically ended, and a new InstrumentRegion will begin. If there are comments containing the different `INSTRUMENT_TYPE`,; then both data sets remain available. In contrast with an AnalysisRegion,; an InstrumentRegion does not need a comment to end the region. Comments that are prefixed with `LLVM-MCA-` but do not correspond to; a valid `INSTRUMENT_TYPE` for t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:10715,detect,detecting,10715,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['detect'],['detecting']
Safety,"ons flow better. Prefer Preincrement; ^^^^^^^^^^^^^^^^^^^. Hard fast rule: Preincrement (``++X``) may be no slower than postincrement; (``X++``) and could very well be a lot faster than it. Use preincrementation; whenever possible. The semantics of postincrement include making a copy of the value being; incremented, returning it, and then preincrementing the ""work value"". For; primitive types, this isn't a big deal. But for iterators, it can be a huge; issue (for example, some iterators contains stack and set objects in them...; copying an iterator could invoke the copy ctor's of these as well). In general,; get in the habit of always using preincrement, and you won't have a problem. Namespace Indentation; ^^^^^^^^^^^^^^^^^^^^^. In general, we strive to reduce indentation wherever possible. This is useful; because we want code to `fit into 80 columns`_ without excessive wrapping, but; also because it makes it easier to understand the code. To facilitate this and; avoid some insanely deep nesting on occasion, don't indent namespaces. If it; helps readability, feel free to add a comment indicating what namespace is; being closed by a ``}``. For example:. .. code-block:: c++. namespace llvm {; namespace knowledge {. /// This class represents things that Smith can have an intimate; /// understanding of and contains the data associated with it.; class Grokable {; ...; public:; explicit Grokable() { ... }; virtual ~Grokable() = 0;. ... };. } // namespace knowledge; } // namespace llvm. Feel free to skip the closing comment when the namespace being closed is; obvious for any reason. For example, the outer-most namespace in a header file; is rarely a source of confusion. But namespaces both anonymous and named in; source files that are being closed half way through the file probably could use; clarification. .. _static:. Anonymous Namespaces; ^^^^^^^^^^^^^^^^^^^^. After talking about namespaces in general, you may be wondering about anonymous; namespaces in particular. Anony",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:58721,avoid,avoid,58721,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"ons happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2884,avoid,avoid,2884,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,2,['avoid'],['avoid']
Safety,"onversions in template argument deduction; Unknown. 2201; C++17; Cv-qualification of array types; Unknown. 2202; drafting; When does default argument instantiation occur?; Not resolved. 2203; drafting; Defaulted copy/move constructors and UDCs; Not resolved. 2204; NAD; Naming delegated constructors; Unknown. 2205; C++17; Restrictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed names",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:150932,Redund,Redundant,150932,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Redund'],['Redundant']
Safety,"on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75297,detect,detector,75297,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detector']
Safety,"oop attributes the epilogue will have. The; epilogue is not vectorized and is executed when either the vectorized; loop is not known to preserve semantics (because e.g., it processes two; arrays that are found to alias by a runtime check) or for the last; iterations that do not fill a complete set of vector lanes. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.vectorize.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes in the metadata will be added to both the vectorized and; epilogue loop.; See :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll``'; ^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling; optimization hints such as the unroll factor. ``llvm.loop.unroll``; metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. The ``llvm.loop.unroll`` metadata are only; optimization hints and the unrolling will only be performed if the; optimizer believes it is safe to do so. '``llvm.loop.unroll.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll factor to the loop unroller. The; first operand is the string ``llvm.loop.unroll.count`` and the second; operand is a positive integer specifying the unroll factor. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unrolled. '``llvm.loop.unroll.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unrolling. The metadata has a single operand; which is the string ``llvm.loop.unroll.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.disable""}. '``llvm.loop.unroll.runtime.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables runtime loop unrolling. The metadata has a single; operand which is the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:301078,safe,safe,301078,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"oop over all tutorials and define the corresponding test---------; foreach(t ${tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). set(labels tutorial); if(${t} IN_LIST long_running); list(APPEND labels longtest); endif(); if(${t} IN_LIST multithreaded); list(APPEND labels multithreaded); # If this is not a TMVA tutorial, we want to limit the size of the thread; # pool in case the tutorial invokes ROOT::EnableImplicitMT(), which by; # default creates a thread pool of the size of the total number of cores.; if(${t} IN_LIST multithreaded_all_cores); set(createThreadPool ""-e \""ROOT::EnableImplicitMT(${NProcessors})\""""); endif(); else(); unset(createThreadPool); endif(). if(${t} IN_LIST need_network); list(APPEND labels needs_network); endif(). # These tests on ARM64 need much more than 20 minutes - increase the timeout; if(ROOT_ARCHITECTURE MATCHES arm64 OR ROOT_ARCHITECTURE MATCHES ppc64); set(thisTestTimeout 3000) # 50m; else(); set(thisTestTimeout 1200) # 20m; endif(). ROOT_ADD_TEST(tutorial-${tname}; COMMAND ${ROOT_root_CMD} -b -l -q ${createThreadPool} ${CMAKE_CURRENT_SOURCE_DIR}/${t}${${tname}-aclic}; PASSRC ${rc} FAILREGEX ""Error in <"" "": error:"" ""segmentation violation"" ""FROM HESSE STATUS=FAILED"" ""warning: Failed to call""; LABELS ${labels}; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}). if(${t} IN_LIST multithreaded); # Makes sure that this doesn't run in parallel with other multithreaded tutorials, and that cmake doesn't start too; # many other tests. That we use 4 processors is actually a lie, because IMT takes whatever it finds.; # However, even this poor indication of MT behaviour is a good hint for cmake to reduce congestion.; set_tests_properties(tutorial-${tname} PROPERTIES RESOURCE_LOCK multithreaded PROCESSORS ${NProcessors}); endif(); endforeach(). #---Loop over al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:24089,timeout,timeout,24089,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['timeout'],['timeout']
Safety,"operand registers are available and resource requirements are; met. Multiple instructions can be issued in one cycle according to the value of; the ``IssueWidth`` parameter in LLVM's scheduling model. Once issued, an instruction is moved to ``IssuedInst`` set until it is ready to; retire. :program:`llvm-mca` ensures that writes are committed in-order. However,; an instruction is allowed to commit writes and retire out-of-order if; ``RetireOOO`` property is true for at least one of its writes. Custom Behaviour; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Due to certain instructions not being expressed perfectly within their; scheduling model, :program:`llvm-mca` isn't always able to simulate them; perfectly. Modifying the scheduling model isn't always a viable; option though (maybe because the instruction is modeled incorrectly on; purpose or the instruction's behaviour is quite complex). The; CustomBehaviour class can be used in these cases to enforce proper; instruction modeling (often by customizing data dependencies and detecting; hazards that :program:`llvm-mca` has no way of knowing about). :program:`llvm-mca` comes with one generic and multiple target specific; CustomBehaviour classes. The generic class will be used if the ``-disable-cb``; flag is used or if a target specific CustomBehaviour class doesn't exist for; that target. (The generic class does nothing.) Currently, the CustomBehaviour; class is only a part of the in-order pipeline, but there are plans to add it; to the out-of-order pipeline in the future. CustomBehaviour's main method is `checkCustomHazard()` which uses the; current instruction and a list of all instructions still executing within; the pipeline to determine if the current instruction should be dispatched.; As output, the method returns an integer representing the number of cycles; that the current instruction must stall for (this can be an underestimate; if you don't know the exact number and a value of 0 represents no stall). If you'd like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:44393,detect,detecting,44393,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,2,"['detect', 'hazard']","['detecting', 'hazards']"
Safety,"operation; has been evaluated, the stack is therefore as it is left by the evaluation; of the operations of E. Since E is evaluated on the same stack as the call; operation, E can use, and/or remove entries already on the stack, and can; add new entries to the stack. *Values on the stack at the time of the call may be used as parameters by; the called expression and values left on the stack by the called expression; may be used as return values by prior agreement between the calling and; called expressions.*. * If D has a ``DW_AT_location`` attribute that is encoded as a ``loclist`` or; ``loclistsptr``, then the specified location list expression E is; evaluated. The evaluation of E uses the current context, except the result; kind is a location description, the compilation unit is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:76181,avoid,avoids,76181,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoids']
Safety,"opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76236,detect,detected,76236,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40074,redund,redundant,40074,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['redund'],['redundant']
Safety,"or gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the non-supported setters (i.e. SetPt on a PxPyPzEVector) methods, which are generated only for the CINT dictionary. These methods flag a compiled-error when running in C++ mode. SMatrix. Change implementation of the SMatrix::Invert and SMatrix::Inverse methods. Now the optimized method based on the Cramer rule is used only for matrix up to sizes 2x2. The standard methods based on LU (for ordinary square matrix) or Bunch-Kaufman factorization (for square matrix) are used. The factorization method, although slower for small size matrices, they suffer much less from numerical precision problems.; New methods SMatrix::Invert and SMatrix::InverseFast are added for using the Cramer rule for up to matrix of sizes 5x5. This method",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:4541,avoid,avoid,4541,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,2,['avoid'],['avoid']
Safety,"or, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2612,detect,detect,2612,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,2,['detect'],['detect']
Safety,"or: Instruction Selector, Instruction; Scheduling, and Register Allocation. ``llvm/lib/MC/``. The libraries represent and process code at machine code level. Handles; assembly and object-file emission. ``llvm/lib/ExecutionEngine/``. Libraries for directly executing bitcode at runtime in interpreted and; JIT-compiled scenarios. ``llvm/lib/Support/``. Source code that corresponding to the header files in ``llvm/include/ADT/``; and ``llvm/include/Support/``. ``llvm/bindings``; ----------------------. Contains bindings for the LLVM compiler infrastructure to allow; programs written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38026,sanity check,sanity checks,38026,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['sanity check'],['sanity checks']
Safety,"or; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning must not change the meaning of the code.; However, a hint may clarify the meaning as intentional, for example by adding; parentheses when the precedence of operators isn't obvious. If a fix-it can't obey these rules, put the fix-it on a note. Fix-its on notes; are not applied automatically. All fix-it hints are described by the ``FixItHint`` class, instances of which; should be attached to the diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:19671,recover,recover,19671,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recover']
Safety,"or<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81772,unsafe,unsafe,81772,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['unsafe'],['unsafe']
Safety,"oreg, !5, !6. In this circumstance LLVM would leave the MIR as shown above. Were we to move; the DBG_VALUE of virtual register %7 upwards with the SUB32rr, we would re-order; assignments and introduce a new state of the program. Whereas with the solution; above, the debugger will see one fewer combination of variable values, because; ``!3`` and ``!5`` will change value at the same time. This is preferred over; misrepresenting the original program. In comparison, if one sunk the MOV32rm, LLVM would produce the following:. .. code-block:: text. DBG_VALUE $noreg, $noreg, !1, !2; %4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags; DBG_VALUE %4, $noreg, !3, !4; %7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags; DBG_VALUE %7, $noreg, !5, !6; %1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1); DBG_VALUE %1, $noreg, !1, !2. Here, to avoid presenting a state in which the first assignment to ``!1``; disappears, the DBG_VALUE at the top of the block assigns the variable the; undefined location, until its value is available at the end of the block where; an additional DBG_VALUE is added. Were any other DBG_VALUE for ``!1`` to occur; in the instructions that the MOV32rm was sunk past, the DBG_VALUE for ``%1``; would be dropped and the debugger would never observe it in the variable. This; accurately reflects that the value is not available during the corresponding; portion of the original program. Variable locations during Register Allocation; ---------------------------------------------. To avoid debug instructions interfering with the register allocator, the; LiveDebugVariables pass extracts variable locations from a MIR function and; deletes the corresponding DBG_VALUE instructions. Some localized copy; propagation is performed within blocks. After register allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:34985,avoid,avoid,34985,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"orithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and ren",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9373,safe,safe,9373,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['safe'],['safe']
Safety,"ormance Suite; ----------------------; https://github.com/LLNL/RAJAPerf. CORAL-2 Benchmarks; ------------------; https://asc.llnl.gov/coral-2-benchmarks/. Many of its programs have already been integrated in; MultiSource/Benchmarks/DOE-ProxyApps-C and; MultiSource/Benchmarks/DOE-ProxyApps-C++. * Nekbone; * QMCPack; * LAMMPS; * Kripke; * Quicksilver; * PENNANT; * Big Data Analytic Suite; * Deep Learning Suite; * Stream; * Stride; * ML/DL micro-benchmark; * Pynamic; * ACME; * VPIC; * Laghos; * Parallel Integer Sort; * Havoq. NWChem; ------; http://www.nwchem-sw.org/index.php/Benchmarks. TVM; ----; https://github.com/dmlc/tvm/tree/main/apps/benchmark. HydroBench; ----------; https://github.com/HydroBench/Hydro. ParRes; ------; https://github.com/ParRes/Kernels/tree/default/Cxx11. Applications/Libraries; ======================. GnuPG; -----; https://gnupg.org/. Blitz++; -------; https://sourceforge.net/projects/blitz/. FFmpeg; ------; https://ffmpeg.org/. FreePOOMA; ---------; http://www.nongnu.org/freepooma/. FTensors; --------; http://www.wlandry.net/Projects/FTensor. rawspeed; --------; https://github.com/darktable-org/rawspeed. Its test dataset is 756 MB in size, which is too large to be included; into the test-suite repository. C++ Performance Benchmarks; --------------------------; https://gitlab.com/chriscox/CppPerformanceBenchmarks. Generic Algorithms; ==================. Image processing; ----------------. Resampling; ``````````. * Bilinear; * Bicubic; * Lanczos. Dither; ``````. * Threshold; * Random; * Halftone; * Bayer; * Floyd-Steinberg; * Jarvis; * Stucki; * Burkes; * Sierra; * Atkinson; * Gradient-based. Feature detection; `````````````````. * Harris; * Histogram of Oriented Gradients. Color conversion; ````````````````. * RGB to grayscale; * HSL to RGB. Graph; -----. Search Algorithms; `````````````````. * Breadth-First-Search; * Depth-First-Search; * Dijkstra's algorithm; * A-Star. Spanning Tree; `````````````. * Kruskal's algorithm; * Prim's algorithm; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:6057,detect,detection,6057,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['detect'],['detection']
Safety,"ormance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2356,safe,safe,2356,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"orpus.; ./a.out. You should get an error pretty quickly::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-; #4167	NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-; ==31511== ERROR: libFuzzer: deadly signal; ...; artifact_prefix='./'; Test unit written to ./crash-b13e8756b13a00cf168300179061fb4b91fefbed. More examples; -------------. Examples of real-life fuzz targets and the bugs they find can be found; at http://tutorial.libfuzzer.info. Among other things you can learn how; to detect Heartbleed_ in one second. Advanced features; =================; .. contents::; :local:; :depth: 1. Dictionaries; ------------; LibFuzzer supports user-supplied dictionaries with input language keywords; or other interesting byte sequences (e.g. multi-byte magic values).; Use ``-dict=DICTIONARY_FILE``. For some input languages using a dictionary; may significantly improve the search speed.; The dictionary syntax is similar to that used by AFL_ for its ``-x`` option::. # Lines starting with '#' and empty lines are ignored. # Adds ""blah"" (w/o quotes) to the dictionary.; kw1=""blah""; # Use \\ for backslash and \"" for quotes.; kw2=""\""ac\\dc\""""; # Use \xAB for hex values; kw3=""\xF7\xF8""; # the name of the keyword followed by '=' may be omitted:; ""foo\x0Abar"". Tracing CMP instructions; ------------------------. With an additional compiler flag ``-fsanitize-coverage=trace-cmp``; (on by default as part of ``-fsanitize=fuzzer``, see SanitizerCoverageTraceDataFlow_); libFuzzer will int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:19191,detect,detect,19191,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"ort for the option 'noaddr' which ; prevents the printing of the address of the object. This; is useful in particular in roottest. Use this in hadd; and TFileMerger. TROOT. New routine CloseFiles used automatically shortly before termination to ; insure closing of files and sockets before the unload of any library.; New collection 'ClosedObjects' holding pointers to TFile or TSocket that; have been closed but not deleted it. In the case of TSocket, they are added only; if they are closed by the CloseFiles.; Add a Close member function to TProofMgr since it is added to the list of socket.; Migrate the closing of files from various to a single place (T*System::Exit).; Fill in the implementation of TROOT::FindObjectAnyFile.; Mark TROOT as TObject::kInvalidObject as soon as its destructor starts,; in order to be able to veto some action later on (like autoloading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:1364,Avoid,Avoid,1364,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['Avoid'],['Avoid']
Safety,"orted on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can use the following suppression mechanism; to unblock yourself and continue on with the testing. This suppression; mechanism should only be used for suppressing issues in external code; it; does not work on code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6668,detect,detection,6668,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"osed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the entire program is compiled; with ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the star",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:6254,avoid,avoid,6254,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoid']
Safety,"oss-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7448,safe,safer,7448,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['safe'],['safer']
Safety,"ostic text; N2563; Yes. What we think we reserve; N2572; Partial. Remove mixed wide string literal concatenation; N2594; Clang 9. Update to IEC 60559:2020; N2600; Unknown. Compatibility of Pointers to Arrays with Qualifiers; N2607. Partial; Much of the proposal is implemented, but Clang lacks pedantic diagnostics; in C17 and earlier regarding use of incompatible pointer types as an; extension. Further, Clang does not properly compute the correct result; type for the ?: operator when the result type should be a; qualified array type.; . Unclear type relationship between a format specifier and its argument; N2562; Clang 16. String functions for freestanding implementations; N2524; No. Digit separators; N2626; Clang 13. Missing +(x) in table; N2641; Yes. Add support for preprocessing directives elifdef and elifndef; N2645; Clang 13. [[maybe_unused]] for labels; N2662; Clang 16. Zeros compare equal; N2670; Yes. Negative values; N2671; Yes. 5.2.4.2.2	cleanup; N2672; Yes. Towards Integer Safety; N2683; Clang 18. Adding Fundamental Type for N-bit Integers. ; N2763; Clang 15. ; N2775; Clang 15. ; N2969; Clang 15. ; N3035; Clang 15. #warning directive; N2686; Yes. Sterile characters; N2686; Yes. Numerically equal; N2716; Yes. char16_t & char32_t string literals shall be UTF-16 & UTF-32; N2728; Yes. IEC 60559 binding; N2749; Unknown. __has_include for C; N2799; Yes. Annex F overflow and underflow; N2747; Yes. Remove UB from Incomplete Types in Function Parameters; N2770; Yes. Variably-modified types; N2778; Yes. Types do not have types; N2781; Yes. 5.2.4.2.2	cleanup (N2672 update); N2806; Yes. Allow 16-bit ptrdiff_t; N2808; Yes. Proposal to update CFP freestanding requirements; N2823; Unknown. Types and sizes; N2838; Yes. Clarifying integer terms; N2837; Yes. Clarification for max exponent macros; N2843; Unknown. Clarification about expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:9988,Safe,Safety,9988,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['Safe'],['Safety']
Safety,"osure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1893,avoid,avoid,1893,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['avoid'],['avoid']
Safety,"ot cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the non-supported setters (i.e. SetPt on a PxPyPzEVector) methods, which are generated only for the CINT dictionary. These methods flag a compiled-error when running in C++ mode. SMatrix. Change implementation of the SMatrix::Invert and SMatrix::Inverse methods. Now the optimized method based on the Cramer rule is used only for matrix up to sizes 2x2. The standard methods based on LU (for ordinary square matrix) or Bunch-Kaufman factorization (for square matrix) are used. The factorization method, although slower for small size matrices, they suffer much less from numerical precision problems.; New methods SMatrix::Invert and SMatrix::InverseFast are added for using the Cramer rule for up to matrix of sizes 5x5. This method has exactly the same implementation as the Invert and Inverse of the previous ROOT version.; ; Physics. TLorentzVector:Change in the implementation of the function SetPtEtaPhi and SetPtEt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:4670,Avoid,Avoid,4670,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['Avoid'],['Avoid']
Safety,"otFinder; and BrentMinimizer1D) by fixing a bug in the Brent method (see rev. 32544); and adding possibility to pass the tolerance and max number of; iterations; Change also the interface classes,; ROOT::Math::RootFinder and; ROOT::Math::IMinimizer1D to have methods consistent with; the other numerical algorithm classes (e.g. return bool and not; int from RootFinder::Solve and add a; RootFinder::Status() function. In addition, use the same default; tolerance for all the root finder algorithms.; ; The class ROOT::Math::Data::Range returns in the method; GetRange the values -inf and +inf when no range; is set; ; Use in TRandom::SetSeed(int seed) a value of; seed=0 as default argument. This is the same now in all the; derived classes.; Add new methods in ROOT::Fit::FitResult to have a more; consistent and expressive API:FitResult::Parameter(index),; FitResult::ParError(index) and; FitResult::ParName(index).; The method FitResult::ParError should be used instead of; FitResult::Error in the derived TFitResult; class to avoid a conflict with TObject::Error; (see bug 67671).; ; Fix a bug in Tmath::AreEqualRel to take into account; the case when the two arguments may be null.; Improve implementation of the F distribution for large N and; M. Use now the same implementation in ROOT::Math and TMath; Fix the returned value of the incomplete gamma functions for; a=0 or a is a negative integer number. Mathmore. Fix a bug in ROOT::Math::Random::Multinomial. ; Fix some bugs in GSLInterpolator; New mathematical special functions in the ROOT::Math namespace; implemented using GSL:; ; Airy functions:; ; double airy_Ai(double x);; double airy_Bi(double x);; double airy_Ai_deriv(double x);; double airy_Bi_deriv(double x);; double airy_zero_Ai(unsigned int s);; double airy_zero_Bi(unsigned int s);; double airy_zero_Ai_deriv(unsigned int s);; double airy_zero_Bi_deriv(unsigned int s);; ; Wigner coefficient functions:; ; double wigner_3j(int ja, int jb, int jc, int ma, int mb, int mc);; dou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:7231,avoid,avoid,7231,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,2,['avoid'],['avoid']
Safety,"oth its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the hea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1379,redund,redundant,1379,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['redund'],['redundant']
Safety,"ouble`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; ======================================. Clang allows C++-style ``[[]]`` attributes to be written on using-declarations.; For instance:. .. code-block:: c++. [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:36205,unsafe,unsafe,36205,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"ountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83688,safe,safe,83688,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"out needing to distinguish them from non-generic virtual registers. For simplicity, most generic instructions only accept virtual registers (both; generic and non-generic). There are some exceptions to this but in general:. * instead of immediates, they use a generic virtual register defined by an; instruction that materializes the immediate value (see; :ref:`irtranslator-constants`). Typically this is a G_CONSTANT or a; G_FCONSTANT. One example of an exception to this rule is G_SEXT_INREG where; having an immediate is mandatory.; * instead of physical register, they use a generic virtual register that is; either defined by a ``COPY`` from the physical register or used by a ``COPY``; that defines the physical register. .. admonition:: Historical Note. We started with an alternative representation, where MRI tracks a size for; each generic virtual register, and instructions have lists of types.; That had two flaws: the type and size are redundant, and there was no generic; way of getting a given operand's type (as there was no 1:1 mapping between; instruction types and operands).; We considered putting the type in some variant of MCInstrDesc instead:; See `PR26576 <https://llvm.org/PR26576>`_: [GlobalISel] Generic MachineInstrs; need a type but this increases the memory footprint of the related objects. .. _gmir-regbank:. Register Bank; -------------. A Register Bank is a set of register classes defined by the target. This; definition is rather loose so let's talk about what they can achieve. Suppose we have a processor that has two register files, A and B. These are; equal in every way and support the same instructions for the same cost. They're; just physically stored apart and each instruction can only access registers from; A or B but never a mix of the two. If we want to perform an operation on data; that's in split between the two register files, we must first copy all the data; into a single register file. Given a processor like this, we would benefit from clus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:2965,redund,redundant,2965,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['redund'],['redundant']
Safety,"out the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85723,recover,recovery,85723,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"overwrites the pointee on all paths; before returning. * Prove that the function reads the pointee only after overwriting it. * Prove that the function does not persist the pointer in a data structure; that is live after the function returns. There are also requirements that all usage sites of the candidate function must; satisfy, for example, that function arguments do not alias, that users are not; taking the address of the function, and so on. Let's consider verifying usage; site conditions to be a separate static analysis problem. ### Lattice design. To analyze the function body we can use a lattice which consists of normal; states and failure states. A normal state describes program points where we are; sure that no behaviors that block the refactoring have occurred. Normal states; keep track of all parameter's member fields that are known to be overwritten on; every path from function entry to the corresponding program point. Failure; states accumulate observed violations (unsafe reads and pointer escapes) that; block the refactoring. In the partial order of the lattice failure states compare greater than normal; states, which guarantees that they ""win"" when joined with normal states. Order; between failure states is determined by inclusion relation on the set of; accumulated violations (lattice's `⩽` is `⊆` on the set of violations). Order; between normal states is determined by reversed inclusion relation on the set of; overwritten parameter's member fields (lattice's `⩽` is `⊇` on the set of; overwritten fields). ![Lattice for data flow analysis that identifies output parameters](DataFlowAnalysisIntroImages/OutputParameterIdentificationLattice.svg). To determine whether a statement reads or writes a field we can implement; symbolic evaluation of `DeclRefExpr`s, `LValueToRValue` casts, pointer; dereference operator and `MemberExpr`s. ### Using data flow results to identify output parameters. Let's take a look at how we use data flow analysis to identify an ou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:17321,unsafe,unsafe,17321,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['unsafe'],['unsafe']
Safety,"overy AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87406,recover,recovery,87406,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"owing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:182046,Redund,Redundant,182046,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Redund'],['Redundant']
Safety,"own *guarded* slot, which may consist of one or more accessible; pages. Each guarded slot is surrounded by two *guard* pages, which are mapped as; inaccessible. The collection of all guarded slots makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4309,detect,detection,4309,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"p) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6337,redund,redundant,6337,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,2,['redund'],['redundant']
Safety,"p. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1634,detect,detected,1634,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['detect'],['detected']
Safety,"p10 = getelementptr inbounds %struct.anon* %tmp3, i64 %idxprom7, i32 0; %tmp11 = load double* %tmp10, align 8, !tbaa !4; %cmp12 = fcmp ogt double %tmp5, %tmp11; br i1 %cmp12, label %if.then, label %for.inc. if.then: ; preds = %for.body; %i.017 = trunc i64 %indvar to i32; br label %for.inc. for.inc: ; preds = %for.body, %if.then; %i.01719 = phi i32 [ %i.01718, %for.body ], [ %i.017, %if.then ]; %indvar.next = add i64 %indvar, 1; %exitcond = icmp eq i64 %indvar.next, %tmp22; br i1 %exitcond, label %for.cond.for.end_crit_edge, label %for.body. It is good that we hoisted the reloads of numf2's, and Y out of the loop and; sunk the store to winner out. However, this is awful on several levels: the conditional truncate in the loop; (-indvars at fault? why can't we completely promote the IV to i64?). Beyond that, we have a partially redundant load in the loop: if ""winner"" (aka ; %i.01718) isn't updated, we reload Y[winner].y the next time through the loop.; Similarly, the addressing that feeds it (including the sext) is redundant. In; the end we get this generated assembly:. LBB0_2: ## %for.body; ## =>This Inner Loop Header: Depth=1; 	movsd	(%rdi), %xmm0; 	movslq	%edx, %r8; 	shlq	$4, %r8; 	ucomisd	(%rcx,%r8), %xmm0; 	jbe	LBB0_4; 	movl	%esi, %edx; LBB0_4: ## %for.inc; 	addq	$16, %rdi; 	incq	%rsi; 	cmpq	%rsi, %rax; 	jne	LBB0_2. All things considered this isn't too bad, but we shouldn't need the movslq or; the shlq instruction, or the load folded into ucomisd every time through the; loop. On an x86-specific topic, if the loop can't be restructure, the movl should be a; cmov. //===---------------------------------------------------------------------===//. [STORE SINKING]. GCC PR37810 is an interesting case where we should sink load/store reload; into the if block and outside the loop, so we don't reload/store it on the; non-call path. for () {; *P += 1;; if (); call();; else; ...; ->; tmp = *P; for () {; tmp += 1;; if () {; *P = tmp;; call();; tmp = *P;; } else ...; }; *P = tmp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:31375,redund,redundant,31375,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['redund'],['redundant']
Safety,p_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/li,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23971,safe,safestack,23971,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['safe'],['safestack']
Safety,"part.; Despite the typing of this as a generic token, *only* the value defined; by a ``gc.statepoint`` is legal here. Semantics:; """""""""""""""""""". The ``gc.result`` represents the return value of the call target of; the ``statepoint``. The type of the ``gc.result`` must exactly match; the type of the target. If the call target returns void, there will; be no ``gc.result``. A ``gc.result`` is modeled as a 'readnone' pure function. It has no; side effects since it is just a projection of the return value of the; previous call represented by the ``gc.statepoint``. '``llvm.experimental.gc.relocate``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <pointer type>; @llvm.experimental.gc.relocate(token %statepoint_token,; i32 %base_offset,; i32 %pointer_offset). Overview:; """""""""""""""""". A ``gc.relocate`` returns the potentially relocated value of a pointer; at the safepoint. Operands:; """""""""""""""""". The first argument is the ``gc.statepoint`` which starts the; safepoint sequence of which this ``gc.relocation`` is a part.; Despite the typing of this as a generic token, *only* the value defined; by a ``gc.statepoint`` is legal here. The second and third arguments are both indices into operands of the; corresponding statepoint's :ref:`gc-live <ob_gc_live>` operand bundle. The second argument is an index which specifies the allocation for the pointer; being relocated. The associated value must be within the object with which the; pointer being relocated is associated. The optimizer is free to change *which*; interior derived pointer is reported, provided that it does not replace an; actual base pointer with another interior derived pointer. Collectors are; allowed to rely on the base pointer operand remaining an actual base pointer if; so constructed. The third argument is an index which specify the (potentially) derived pointer; being relocated. It is legal for this index to be the same as the second; argument if-and-only-if a base pointer is being",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:505324,safe,safepoint,505324,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safepoint']
Safety,"pd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:2089,avoid,avoids,2089,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['avoid'],['avoids']
Safety,"pdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad' was interrupted; the interrupt was de facto; ineffective, so that collection stayed always until the timeout expired; (default: 5 minutes). Should solve some of the cases were slow response; was experienced.; Fix a problem with log path transmission when the node dies early or; not even starts. The log path was empty and wrong was filled in when; retrieving the log buffers, disorienting debugging.; F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:6291,avoid,avoid,6291,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['avoid'],['avoid']
Safety,"pe (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3830,safe,safepoints,3830,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"pe=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==============; AMDGPU Support; ==============. Clang supports OpenCL, HIP and OpenMP on AMD GPU targets. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__AMDGPU__``; - Indicates that the code is being compiled for an AMD GPU.; * - ``__AMDGCN__``; - Defined if the GPU target is AMDGCN.; * - ``__R600__``; - Defined if the GPU target is R600.; * - ``__<ArchName>__``; - Defined with the name of the architecture (e.g., ``__gfx906__`` for the gfx906 architecture).; * - ``__<GFXN>__``; - Defines the GFX family (e.g., for gfx906, this macro would be ``__GFX9__``).; * - ``__amdgcn_processor__``; - Defined with the processor name as a string (e.g., ``""gfx906""``).; * - ``__amdgcn_target_id__``; - Defined with the target ID as a string.; * - ``__amdgcn_feature_<feature-name>__``; - Defined for each supported target feature. The value is 1 if the feature is enabled and 0 if it is disabled. Allowed feature names are sramecc and xnack.; * - ``__AMDGCN_CUMODE__``; - Defined as 1 if the CU mode is enabled and 0 if the WGP mode is enabled.; * - ``__AMDGCN_UNSAFE_FP_ATOMICS__``; - Defined if unsafe floating-point atomics are allowed.; * - ``__AMDGCN_WAVEFRONT_SIZE__``; - Defines the wavefront size. Allowed values are 32 and 64.; * - ``__AMDGCN_WAVEFRONT_SIZE``; - Alias to ``__AMDGCN_WAVEFRONT_SIZE__``. To be deprecated.; * - ``__HAS_FMAF__``; - Defined if FMAF instruction is available (deprecated).; * - ``__HAS_LDEXPF__``; - Defined if LDEXPF instruction is available (deprecated).; * - ``__HAS_FP64__``; - Defined if FP64 instruction is available (deprecated). Please note that the specific architecture and feature names will vary depending on the GPU. Also, some macros are deprecated and may be removed in future releases.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AMDGPUSupport.rst:1381,unsafe,unsafe,1381,interpreter/llvm-project/clang/docs/AMDGPUSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AMDGPUSupport.rst,1,['unsafe'],['unsafe']
Safety,"perator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77165,safe,safety,77165,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safety']
Safety,"performance; hit, the model puts some restrictions on how these pointers can be used.; ``__terminated_by`` pointers cannot be indexed and can only be incremented one; element at a time. To allow these operations, the pointers must be explicitly; converted to ``__indexable`` pointers using the intrinsic function; ``__unsafe_terminated_by_to_indexable(P, T)`` (or; ``__unsafe_null_terminated_to_indexable(P)``) which converts the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer beyond it is; prevented at run time. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:19454,unsafe,unsafe,19454,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"placing the data into the folder structure and; calling `TTree::Fill`. ### Tree and TRef Objects. ``` {.cpp}; MyTree->BranchRef();; ```. This call requests the construction of an optional branch supporting; table of references (**`TRefTable`**). This branch (**`TBranchRef`**); will keep all the information needed to find the branches containing; referenced objects at each `Tree::Fill`, the branch numbers containing; the referenced objects are saved in the table of references. When the; Tree header is saved (via `TTree::Write` for example), the branch is; saved, keeping the information with the pointers to the branches having; referenced objects. Enabling this optional table, allow; `TTree::Draw` to automatically load the branches needed to; dereference a **`TRef`** (or **`TRefArray`**) object. ### Autosave. `Autosave` gives the option to save all branch buffers every `n` byte.; We recommend using `Autosave` for large acquisitions. If the acquisition; fails to complete, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script using a circular buffer is shown below:. ``` {.cpp}; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:13551,recover,recover,13551,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['recover'],['recover']
Safety,"ple:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstitution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:15570,avoid,avoid,15570,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"pointers against scalar values.; Unsafe usage of dispatch_once_t predicates stored in Objective-C instance variables and other heap-allocated memory.; Issues resulting from self-assignment in C++.; Incorrect usage of MPI APIs in C and C++. This check can be enabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing from NSLocalizedString macros.; These can be enabled by passing the following command to scan-build:.   -enable-checker alpha.osx.cocoa.NonLocalizedStringChecker,alpha.osx.cocoa.EmptyLocalizationContext",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1362,detect,detect,1362,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,2,['detect'],['detect']
Safety,"pose. It; must be run before register allocation takes place. After its execution, the; resulting code may no longer be in SSA form. This happens, for instance, in; situations where an instruction such as ``%a = ADD %b %c`` is converted to two; instructions such as:. ::. %a = MOVE %b; %a = ADD %a %c. Notice that, internally, the second instruction is represented as ``ADD; %a[def/use] %c``. I.e., the register operand ``%a`` is both used and defined by; the instruction. The SSA deconstruction phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. An important transformation that happens during register allocation is called; the *SSA Deconstruction Phase*. The SSA form simplifies many analyses that are; performed on the control flow graph of programs. However, traditional; instruction sets do not implement PHI instructions. Thus, in order to generate; executable code, compilers must replace PHI instructions with other instructions; that preserve their semantics. There are many ways in which PHI instructions can safely be removed from the; target code. The most traditional PHI deconstruction algorithm replaces PHI; instructions with copy instructions. That is the strategy adopted by LLVM. The; SSA deconstruction algorithm is implemented in; ``lib/CodeGen/PHIElimination.cpp``. In order to invoke this pass, the identifier; ``PHIEliminationID`` must be marked as required in the code of the register; allocator. Instruction folding; ^^^^^^^^^^^^^^^^^^^. *Instruction folding* is an optimization performed during register allocation; that removes unnecessary copy instructions. For instance, a sequence of; instructions such as:. ::. %EBX = LOAD %mem_address; %EAX = COPY %EBX. can be safely substituted by the single instruction:. ::. %EAX = LOAD %mem_address. Instructions can be folded with the; ``TargetRegisterInfo::foldMemoryOperand(...)`` method. Care must be taken when; folding instructions; a folded instruction can be quite different from the; original instruction. See ``LiveIntervals::addInte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:68169,safe,safely,68169,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['safe'],['safely']
Safety,"ppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15210,recover,recover,15210,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,2,['recover'],"['recover', 'recoverable']"
Safety,"presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4007,avoid,avoiding,4007,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['avoid'],['avoiding']
Safety,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180149,detect,detection,180149,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detection']
Safety,"preted as describing a sequence of pointers and their corresponding; base pointers. If the Location is of size N x sizeof(pointer), then; there will be N records of one pointer each contained within the Location.; Both Locations in a pair can be assumed to be of the same size. Note that the Locations used in each section may describe the same; physical location. e.g. A stack slot may appear as a deopt location,; a gc base pointer, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly establ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:23803,safe,safepoint,23803,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-7766).; * Change `TGraph::ComputeRange`: in case of log scale the minimum along X and; Y axis are now set to the lowest positive values of the graph. Previously a % of the; maximum was used which may hide some points like in the following example; ``` {.cpp}; {; TGraph * gr = new TGraph(10);; for (int i = 0;i<10;i++) gr->SetPoint(i,i,TMath::Exp(-10.0*i));; for (int i = 5;i<10;i++) gr->SetPoint(i,i,0.);; gr->Draw(""apl"");; gr->SetMarkerStyle(20);; gPad->SetLogy(true);; }; ```; The problem was reported [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20484). ### TGraph2D. Add a new implementation for Delauney interpolation using the triangle code from Jonathan Shewchuk, see [[ http://www.cs.cmu.edu/~quake/triangle.html ]]. ; A new class for Delauney triangulator and interpolation has been added in the MathCore library ( `ROOT::Math::Delauney2D` ). ### Fitting. * Improve thread safety of TH1::Fit by making static member of TVirtualFitter and TMinuitMinimizer thread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:12824,safe,safety,12824,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['safe'],['safety']
Safety,"produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; compares. GCC produces multiple branches, which is much nicer:. compare:; subl $12, %esp; movl 20(%esp), %edx; movl 16(%esp), %eax; decl %edx; jle .L7; .L5:; addl $12, %esp; ret; .p2align 4,,7; .L7:; jl .L4; cmpl $0, %eax; .p2align 4,,8; ja .L5; .L4:; .p2align 4,,9; call abort. //===---------------------------------------------------------------------===//. Tail call optimization improvements: Tail call optimization currently; pushes all arguments on the top of the stack (their normal place for; non-tail call optimized calls) that source from the callers arguments; or that source from a virtual register (also possibly sourcing from; callers arguments).; This is done to prevent overwriting of parameters (see example; below) that might be used later. example: . int callee(int32, int64); ; int caller(int32 arg1, int32 arg2) { ; int64 local = arg2 * 2; ; return callee(arg2, (int64)local); ; }. [arg1] [!arg2 no longer valid since we moved local onto it]; [arg2] -> [(int64); [RETADDR] local ]. Moving arg1 onto the stack slot of callee function would overwrite; arg2 of the caller. Possible optimizations:. - Analyse the actual parameters of the callee to see which would; overwrite a caller parameter which is used by the callee and only; push them onto th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:17900,abort,abort,17900,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,2,['abort'],['abort']
Safety,"program location is used to select the call; frame information entry, and further execution of the thread occurs.*. *A DWARF expression can be used to compute a location description for an object.; A subsequent DWARF expression evaluation can be given the object location; description as the object context or initial stack context to compute a; component of the object. The final result is undefined if the object location; description becomes invalid between the two expression evaluations.*. A change of a thread's program location may not make a location description; invalid, yet may still render it as no longer meaningful. Accessing such a; location description, or using it as the object context or initial stack context; of an expression evaluation, may produce an undefined result. *For example, a location description may specify a register that no longer holds; the intended program object after a program location change. One way to avoid; such problems is to recompute location descriptions associated with threads when; their program locations change.*. .. _amdgpu-dwarf-operation-expressions:. A.2.5.4 DWARF Operation Expressions; +++++++++++++++++++++++++++++++++++. An operation expression is comprised of a stream of operations, each consisting; of an opcode followed by zero or more operands. The number of operands is; implied by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:63860,avoid,avoid,63860,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoid']
Safety,"ption:`--select-types`). :program:`llvm-debuginfo-analyzer` can also compare a set of logical; views (:option:`--compare`), to find differences and identify possible; debug information syntax issues (:option:`--warning`) in any object file. OPTIONS; -------; :program:`llvm-debuginfo-analyzer` options are separated into several; categories, each tailored to a different purpose:. * :ref:`general_` - Standard LLVM options to display help, version, etc.; * :ref:`attributes_` - Describe how to include different details when; printing an element.; * :ref:`print_` - Specify which elements will be included when printing; the view.; * :ref:`output_` - Describe the supported formats when printing the view.; * :ref:`report_` - Describe the format layouts for view printing.; * :ref:`select_` - Allows to use specific criteria or conditions to; select which elements to print.; * :ref:`compare_` - Compare logical views and print missing and/or; added elements.; * :ref:`warning_` - Print the warnings detected during the creation; of the view.; * :ref:`internal_` - Internal analysis of the logical view. .. _general_:. GENERAL; ~~~~~~~; This section describes the standard help options, used to display the; usage, version, response files, etc. .. option:: -h, --help. Show help and usage for this command. (--help-hidden for more). .. option:: --help-list. Show help and usage for this command without grouping the options; into categories (--help-list-hidden for more). .. option:: --help-hidden. Display all available options. .. option:: --print-all-options. Print all option values after command line parsing. .. option:: --print-options. Print non-default options after command line parsing. .. option:: --version. Display the version of the tool. .. option:: @<FILE>. Read command-line options from `<FILE>`. If no input file is specified, :program:`llvm-debuginfo-analyzer`; defaults to read `a.out` and return an error when no input file is found. If `-` is used as the input file, :program:`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:3178,detect,detected,3178,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['detect'],['detected']
Safety,"ptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwise, conditionally thread safe. The read and write APIs provide templated, compile-time type-safe APIs,; APIs where the type at hand is passed as string and which are runtime type-safe,; and type-unsafe APIs using void pointers. On I/O errors and invalid input, RNTuple classes throw an `RException`. Walkthrough: Reading Data; -------------------------. ```c++; auto file = std::make_unique<TFile>(""data.root"");; auto ntuple = std::unique_ptr<RNTuple>(file->Get<RNTuple>(""ntpl""));. // Option 1: entire row; // The reader creates a page source; the page source creates a model from the on-disk information; auto reader = RNTupleReader::Open(ntuple);; // Populate the objects that are used in the model's default entry; reader->LoadEntry(0);; std::shared_ptr<float> pt = reader->GetDefaultEntry().GetPtr<float>(""pt"");. // Option 2: imposed model; auto model = RNTupleModel::Create();; auto pt = model->MakeField<float>(""pt"");; // The reader checks the passed model for compatibility; only the subset of fields defined in the model is read; auto reader = RNTupleReader::Open(std::move(model), ntuple);; reader->LoadEntry(0);. // Opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:2093,safe,safe,2093,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"put is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ~~~{.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ~~~. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; by a previous TGeoManager::FindNextBoundary() cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:80347,safe,safety,80347,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"putation functions for PDFs that enable significantly faster fittings._; #### Note: This library is still at an experimental stage. Tests are being conducted continuously to ensure correctness of the results, but the interfaces and the instructions on how to use might change. ### Purpose; While fitting, a significant amount of time and processing power is spent on computing the probability function for every event and PDF involved in the fitting model. To speed up this process, roofit can use the computation functions provided in this library. The functions provided here process whole data arrays (batches) instead of a single event at a time, as in the legacy evaluate() function in roofit. In addition, the code is written in a manner that allows for compiler optimizations, notably auto-vectorization. This library is compiled multiple times for different [vector instruction set architectures](https://en.wikipedia.org/wiki/SIMD) and the optimal code is executed during runtime, as a result of an automatic hardware detection mechanism that this library contains. **As a result, fits can benefit by a speedup of 3x-16x.**. As of ROOT v6.26, RooBatchComputes also provides multithread and [CUDA](https://en.wikipedia.org/wiki/CUDA) instances of the computation functions, resulting in even greater improvements for fitting times. ### How to use; This library is an internal component of RooFit, so users are not supposed to actively interact with it. Instead, they can benefit from significantly faster times for fitting by calling `fitTo()` and providing a `BatchMode(""cpu"")` or a `BatchMode(""cuda"")` option.; ``` {.cpp}; // fit using the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cpu""));. // fit using the CUDA library along with the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cuda""));; ```; **Note: In case the system does not support vector instructions, the `RooBatchCompute::Cpu` optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:1275,detect,detection,1275,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['detect'],['detection']
Safety,"qual to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53110,unsafe,unsafe,53110,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe']
Safety,"que_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:5795,recover,recoverable-errors,5795,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['recover'],['recoverable-errors']
Safety,"quences to the above ones. However, these are still very marginally; slower, as there are fewer ports able to dispatch shift instructions in most; modern x86 processors than there are for `or` instructions. Fast, single register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; shrxq %rax, %rsi, %rsi # Shift away bits if misspeculating.; movl (%rsi), %edi; ```. This will collapse the register to zero or one, and everything but the offset; in the addressing mode to be less than or equal to 9. This means the full; address can only be guaranteed to be less than `(1 << 31) + 9`. The OS may wish; to protect an extra page of the low address space to account for this. ##### Optimizations. A very large portion of the cost for this approach comes from checking loads in; this way, so it is important to work to optimize this. However, beyond making; the instruction sequences to *apply* the checks efficient (for example by; avoiding `pushfq` and `popfq` sequences), the only significant optimization is; to check fewer loads without introducing a vulnerability. We apply several; techniques to accomplish that. ###### Don't check loads from compile-time constant stack offsets. We implement this optimization on x86 by skipping the checking of loads which; use a fixed frame pointer offset. The result of this optimization is that patterns like reloading a spilled; register or accessing a global field don't get checked. This is a very; significant performance win. ###### Don't check dependent loads. A core part of why this mitigation strategy works is that it establishes a; data-flow check on the loaded address. However, this means that if the address; itself was already loaded using a checked load, there is no need to check a; dependent load provided it is within the same basic block as the checked load,; and therefore has no additional predicates guarding it. Consider code like the; following:; ```; ... .LBB0_4: # %danger; movq (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:34739,avoid,avoiding,34739,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['avoid'],['avoiding']
Safety,"r (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <select> with TGListBox/TGCombobox and emit InputSelected(const char *name, const char *val) when changing selection. TGHtmlBrowser. Added the possibility to save current html page in a local file. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:1832,avoid,avoid,1832,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,2,['avoid'],['avoid']
Safety,"r is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131821,detect,detected,131821,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detected']
Safety,"r new loop(s). This allows additional attributes; including followup-transformations to be specified. Specifying multiple; transformations in the same metadata node is possible for compatibility; reasons, but their execution order is undefined. For instance, when; ``llvm.loop.vectorize.enable`` and ``llvm.loop.unroll.enable`` are; specified at the same time, unrolling may occur either before or after; vectorization. As an example, the following instructs a loop to be vectorized and only; then unrolled. .. code-block:: llvm. !0 = distinct !{!0, !1, !2, !3}; !1 = !{!""llvm.loop.vectorize.enable"", i1 true}; !2 = !{!""llvm.loop.disable_nonforced""}; !3 = !{!""llvm.loop.vectorize.followup_vectorized"", !{""llvm.loop.unroll.enable""}}. If, and only if, no followup is specified, the pass may add attributes itself.; For instance, the vectorizer adds a ``llvm.loop.isvectorized`` attribute and; all attributes from the original loop excluding its loop vectorizer; attributes. To avoid this, an empty followup attribute can be used, e.g. .. code-block:: llvm. !3 = !{!""llvm.loop.vectorize.followup_vectorized""}. The followup attributes of a transformation that cannot be applied will; never be added to a loop and are therefore effectively ignored. This means; that any followup-transformation in such attributes requires that its; prior transformations are applied before the followup-transformation.; The user should receive a warning about the first transformation in the; transformation chain that could not be applied if it a forced; transformation. All following transformations are skipped. Pass-Specific Transformation Metadata; =====================================. Transformation options are specific to each transformation. In the; following, we present the model for each LLVM loop optimization pass and; the metadata to influence them. Loop Vectorization and Interleaving; -----------------------------------. Loop vectorization and interleaving is interpreted as a single; transformation. It",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:4666,avoid,avoid,4666,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"r shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These operations are required to be atomic in the sense that if you use; unordered loads and unordered stores, a load cannot see a value which was; never stored. A normal load or store instruction is usually sufficient, but; note that an unordered load or store cannot be split into multiple; instructions (or an instruction which does multiple memory operations, like; ``LDRD`` on ARM without LPAE, or not naturally-aligned ``LDRD`` on LPAE ARM). Monotonic; ---------. Monotonic is the weakest level of atomicity that can be used in synchronization; primitives, although it does not provide any general synchronization. It; essentially guarantees that if you take all the operations affecting a specific; address, a consistent ordering exists. Relevant standard; This corresponds to the C++/C ``memory_order_relaxed``; see those; standards for the exact definition. Notes for frontends; If",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:9422,safe,safe,9422,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['safe'],['safe']
Safety,"r that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereference (``*p``), array subscript (``p[i]``), member access (``p->``), and; pointer arithmetic, with some restrictions on bounds-unsafe uses. ``-fbounds-safety`` has a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; T *lower_bound; };``. As the; name indicates, pointers with this annotation are ""bidirectionally indexable"",; meaning that they can be indexed with either a negative or a positive offset; and the pointers can be incremented or decremented using pointer arithmetic. A; ``__bidi_indexable`` pointer is allowed to hold an out-of-bounds pointer; value. While creating an OOB pointer is undefined behavior in C,; ``-fbounds-safety`` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:13821,safe,safety,13821,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"r to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::generateNonFatalErrorNode for emitting bug reports.; Most importantly, never emit report against CheckerContext::getPredecessor.; Prefer checkPreCall and checkPostCall to; checkPreStmt<CallExpr> and checkPostStmt<CallExpr>.; Use CallDescription to detect hardcoded API calls in the program.; Simplify C.getState()->getSVal(E, C.getLocationContext()) to C.getSVal(E). Common sources of crashes:. CallEvent::getOriginExpr is nullable - for example, it returns null for an; automatic destructor of a variable. The same applies to some values generated while the; call was modeled, eg. SymbolConjured::getStmt is nullable.; CallEvent::getDecl is nullable - for example, it returns null for a; call of symbolic function pointer.; addTransition, generateSink, generateNonFatalErrorNode,; generateErrorNode are nullable because you can transition to a node that you have already visited.; Methods of CallExpr/FunctionDecl/Ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:24060,safe,safe,24060,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,['safe'],['safe']
Safety,"r) - tmp_ptr < tmp_count) trap();; sbuf->buf = tmp_ptr;; sbuf->count = tmp_count;; }. Whether the compiler can optimize such run-time checks depends on how the upper; bound of the pointer is derived. If the source pointer has ``__sized_by``,; ``__counted_by``, or a variant of such, the compiler assumes that the upper; bound calculation doesn't overflow, e.g., ``ptr + size`` (where the type of; ``ptr`` is ``void *__sized_by(size)``), because when the ``__sized_by`` pointer; is initialized, ``-fbounds-safety`` inserts run-time checks to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer annotation.; Type conversions that change bounds attributes may be allowed if it does not; violate the invariant of the destination or that can be verified at run time.; Here are some of the important cast rules. Two pointers that hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:38492,safe,safety,38492,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"r) or 'random' (the 'broken' sort order prior to this release). IMPORTANT enhancement in TTree::Fill:; Slides from a recent seminar describing the main features of ROOT IO and Trees and the recent; improvements described below are available at; http://root.cern/files/brun_lcgapp09.pptx ; or; http://root.cern/files/brun_lcgapp09.pdf .; The baskets are flushed and the Tree header saved at regular intervals (See AutoFlush and OptimizeBaskets); When the amount of data written so far (fTotBytes) is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region.; When the first call to flush the baskets happens, we also take this opportunity to optimize the baskets buffers.; We also check if the number of bytes written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes.; Note that the user can also decide to call FlushBaskets and AutoSave in her event loop on the base of the number of events written instead of the number of bytes written.; New function TTree::OptimizeBaskets. void TTree::OptimizeBaskets(Int_t maxMemory, Float_t minComp, Option_t *option). This function may be called after having filled some entries in a Tree; using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed.; This function may also be called on an existing Tree to figure out the best values; given the information in the Tree header. TFile ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html:4051,recover,recoverable,4051,tree/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html,2,['recover'],['recoverable']
Safety,"r, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing work on developing such; a verifier. Please ask on llvm-dev if you're interested in; experimenting with the current",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:24176,safe,safepoint,24176,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"r.GetFile();; TNtuple ntrand(""ntrand"", ""Random Numbers"", ""r"");; fill(ntrand, nEventsPerWorker);; ntrand.Write();; f->Write();; };; ```. ## Language Bindings. - Add in PyROOT the converter for std::string_view; - Fix ROOT-8811: pickling of ROOT.Long now works; - Fix ROOT-8809: push_back on a vector of pointers; - Fix ROOT-8805: itemsize was not set on buffers returned by PyROOT functions. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - rlibmap has been removed; it was deprecated for three years.; - Added the CMake exported ROOT libraries into the ROOT:: namespace. In this way, projects based on CMake using ROOT can avoid; conflicts in library target names. As an example, this is the way to build a project consisting of one library and one; executable using ROOT.; ```; find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}). include_directories(${CMAKE_SOURCE_DIR} ${ROOT_INCLUDE_DIRS}); add_definitions(${ROOT_CXX_FLAGS}). ROOT_GENERATE_DICTIONARY(G__Event Event.h LINKDEF EventLinkDef.h). add_library(Event SHARED Event.cxx G__Event.cxx); target_link_libraries(Event ROOT::Hist ROOT::Tree). add_executable(Main MainEvent.cxx); target_link_libraries(Main Event); ```; - Added option `builtin_all` to enable all the built in options.; - For rootcling_stage1 (formerly known as rootcling_tmp), the package structure was changed to enable homogenous visibility; settings across object files. See core/README for an overview.; - Several non-public headers are not copied into include/ anymore; they reside in the PACKAGE/res/ subdirectory in the source tree.; - The IMT switch is set to on by default.; - A new library is now created, libImt. It contains all classes which depend on TBB. Those classes were previously part of libThread. As a consequence rootcling/genreflex do not depend anymore from TBB even in presence of imt builds.; - Refactoring of several math tests to avoid exact comparisons of floating point numbers; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:18948,avoid,avoid,18948,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoid']
Safety,"r: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:3817,avoid,avoid,3817,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,2,['avoid'],['avoid']
Safety,"r=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77627,recover,recover,77627,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recover']
Safety,"r` option. The timing data is stored in the `test_exec_root` in a file named; `.lit_test_times.txt`. If this file does not exist, then `lit` checks the; `test_source_root` for the file to optionally accelerate clean builds. .. option:: --shuffle. Run the tests in a random order, not failing/slowest first. Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:6554,timeout,timeout,6554,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['timeout'],['timeout']
Safety,"racts a constant `KahanSum` term after each likelihood evaluation), this can add up to significant numerical divergence. An improved algorithm was implemented, based on an algorithm for combining Kahan sums and carry terms (Tian et al. 2012). (PR #11940); - The auto-conversion to type `T` and implicit type `T` constructor in `KahanSum` made it hard to debug `KahanSum`, because it is easy to overlook implicit conversions in code, especially in lines where the type of the return value is `auto`. These auto-conversions were removed. Where necessary, they should be replaced with an explicit construction or explicit conversion to double via `Sum()`. (PR #11941); - Binary addition and subtraction operators were added, as well as a unary negation operator. (PR #11940); - Comparison operators `operator==` and `operator!=` were added. ### Foam. The usage of `TRef` in the `TFoamCell` class has ben replaced with array indices. This avoids, when generating a large number of toys requiring a re-initialization of `TFoam` an increase in the memory usage caused by `TRef`. ### RVec. - a number of new helper functions have been added to [RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): [Range](https://root.cern/doc/master/group__vecops.html#ga59cc6e477803f2bfd7dae29e56048cc1), [Product](https://root.cern/doc/master/group__vecops.html#ga25e4c2cf5c82fe56dd6bbc86b2386b69) and Enumerate; - the [Take](https://root.cern/doc/master/group__vecops.html#gac719439afb1ec9d32a28acdc7aee5948) helper function now allows passing a default value that will be used to fill the output array in case it's longer than the input. ## RooFit Libraries. ### Consistent definition of the default minimizer type for all of RooFit/RooStats. In previous releases, the default minimizer type that RooFit used was hardcoded to be the original `Minuit`, while RooStats used the default minimizer specified by `ROOT::Math::MinimizerOptions::DefaultMinimizerType()`. Now it is possible to centrally define ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:17989,avoid,avoids,17989,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoids']
Safety,"ragma clang arc_cf_code_audited begin; ...; #pragma clang arc_cf_code_audited end. All C functions declared within the extent of this pragma are treated as if; annotated with the ``cf_audited_transfer`` attribute unless they otherwise have; the ``cf_unknown_transfer`` attribute. The pragma is accepted in all language; modes. A program is ill-formed if it attempts to change files, whether by; including a file or ending the current file, within the extent of this pragma. It is possible to test for all the features in this section with; ``__has_feature(arc_cf_code_audited)``. .. admonition:: Rationale. A significant inconvenience in ARC programming is the necessity of; interacting with APIs based around C retainable pointers. These features are; designed to make it relatively easy for API authors to quickly review and; annotate their interfaces, in turn improving the fidelity of tools such as; the static analyzer and ARC. The single-file restriction on the pragma is; designed to eliminate the risk of accidentally annotating some other header's; interfaces. .. _arc.runtime:. Runtime support; ===============. This section describes the interaction between the ARC runtime and the code; generated by the ARC compiler. This is not part of the ARC language; specification; instead, it is effectively a language-specific ABI supplement,; akin to the ""Itanium"" generic ABI for C++. Ownership qualification does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:105136,risk,risk,105136,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['risk'],['risk']
Safety,"ral options when creating http server. They could be add as additional URL parameters to the constructor arguments like:. ```cpp; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; ```. Following URL parameters are supported:. | Name | Description |; | :-------------------- | :---------------- |; | thrds=N | number of threads used by the civetweb (default is 10) |; | top=name | configure top name, visible in the web browser |; | auth_file=filename | authentication file name, created with htdigets utility |; | auth_domain=domain | authentication domain |; | loopback | bind specified port to loopback 127.0.0.1 address |; | debug | enable debug mode, server returns html page with request info |; | websocket_timeout=tm | set web sockets timeout in seconds (default 300) |; | websocket_disable | disable web sockets handling (default enabled) |; | cors=domain | define value for CORS header ""Access-Control-Allow-Origin"" in server response |; | log=filename | configure civetweb log file |; | max_age=value | configures ""Cache-Control: max_age=value"" http header for all file-related requests, default 3600 |; | nocache | try to fully disable cache control for file requests |; | winsymlinks=no | do not resolve symbolic links on file system (Windows only), default true |; | dirlisting=no | enable/disable directory listing for browsing filesystem (default no) |. If necessary, one could bind http server to specific IP address like:. ```cpp; new THttpServer(""http:192.168.1.17:8080""); ```. One also can provide extra arguments for THttpServer itself:. | Name | Description |; | :------------- | :---------------- |; | readonly, ro | use server in read-only mode (default) |; | readwrite, rw | use server in read-write mode |; | global | let scan global directories for canvases and files (default) |; | noglobal | disable scan of global directories |; | basic_sniffer | use basic `TRootSniffer` without support of hist, gpad, graph, tree classes |. Example:. ```cpp; new THttpServer(""h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:2075,timeout,timeout,2075,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['timeout'],['timeout']
Safety,"rality) is that it is heavily; laden with target specific assumptions. As one simple example, the; preprocessor often destructively removes target-independence from the; code when it processes the input text:. .. code-block:: c. #ifdef __i386__; int X = 1;; #else; int X = 42;; #endif. While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requires a combination of language design, runtime; support, and often operating system support. It is certainly possible to implement a safe language in LLVM, but LLVM; IR does not itself guarantee safety. The LLVM IR allows unsafe pointer; casts, use after free bugs, buffer over-runs, and a variety of other; problems. Safety needs to be implemented as a layer on top of LLVM and,; conveniently, several groups have investigated this. Ask on the `LLVM; forums <https://discourse.llvm.org>`_ if you are interested in more details. Language-Specific Optimizations; -------------------------------. One thing about LLVM that turns off many people is that it does not; solve all the world's problems in one system. One specific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:7924,safe,safe,7924,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['safe'],['safe']
Safety,"ram`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345276,unsafe,unsafe,345276,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"raries in expressions. They now have a natural way of ending up nested; within each other and within function calls in order to build up aggregates; (such as option structs) from local variables. The historically common formatting of braced initialization of aggregate; variables does not mix cleanly with deep nesting, general expression contexts,; function arguments, and lambdas. We suggest new code use a simple rule for; formatting braced initialization lists: act as-if the braces were parentheses; in a function call. The formatting rules exactly match those already well; understood for formatting nested function calls. Examples:. .. code-block:: c++. foo({a, b, c}, {1, 2, 3});. llvm::Constant *Mask[] = {; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if`` condition is often a typo:. .. code-block:: c++. if (V = getValue()) {; ...; }. Several compilers will print a warning for the code above. It can be suppressed; by adding parentheses:. .. code-block:: c++. if ((V = getValue())) {; ...; }. Write Portable Code; ^^^^^^^^^^^^^^^^^^^. In almost all cases, it is possible to write completely portable code. When; you need to rely on non-portable code, put it behind a well-defined and; well-documented interface. Do not use RTTI or Exceptions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In an effort to reduce cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:21269,predict,predictable,21269,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['predict'],['predictable']
Safety,"ration, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the impleme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8000,safe,safe,8000,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,2,['safe'],['safe']
Safety,"rbage collectors must be able to identify; any references to objects contained within executing code, and,; depending on the collector, potentially update them. The collector; does not need this information at all points in code - that would make; the problem much harder - but only at well-defined points in the; execution known as 'safepoints' For most collectors, it is sufficient; to track at least one copy of each unique pointer value. However, for; a collector which wishes to relocate objects directly reachable from; running code, a higher standard is required. One additional challenge is that the compiler may compute intermediate; results (""derived pointers"") which point outside of the allocation or; even into the middle of another allocation. The eventual use of this; intermediate value must yield an address within the bounds of the; allocation, but such ""exterior derived pointers"" may be visible to the; collector. Given this, a garbage collector can not safely rely on the; runtime value of an address to indicate the object it is associated; with. If the garbage collector wishes to move any object, the; compiler must provide a mapping, for each pointer, to an indication of; its allocation. To simplify the interaction between a collector and the compiled code,; most garbage collectors are organized in terms of three abstractions:; load barriers, store barriers, and safepoints. #. A load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:2144,safe,safely,2144,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safely']
Safety,"rce-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7250,detect,detected,7250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"rdered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81431,unsafe,unsafe,81431,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['unsafe'],['unsafe']
Safety,"rdering operator<=>(const HasSpaceship&) const = default;; };. bool isLess(const HasSpaceship& a, const HasSpaceship& b) {; return a < b;; }. 1 match found. return a < b;; ^~~~~. No match found. Node Matchers. Node matchers are at the core of matcher expressions - they specify the type; of node that is expected. Every match expression starts with a node matcher,; which can then be further refined with a narrowing or traversal matcher. All; traversal matchers take node matchers as their arguments.; For convenience, all node matchers take an arbitrary number of arguments; and implicitly act as allOf matchers.; Node matchers are the only matchers that support the bind(""id"") call to; bind the matched node to the given string, to be later retrieved from the; match callback.; It is important to remember that the arguments to node matchers are; predicates on the same node, just with additional information about the type.; This is often useful to make matcher expression more readable by inlining bind; calls into redundant node matchers inside another node matcher:. // This binds the CXXRecordDecl to ""id"", as the decl() matcher will stay on; // the same node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:8436,redund,redundant,8436,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['redund'],['redundant']
Safety,"rds; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side chan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5114,avoid,avoids,5114,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoids']
Safety,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1724,recover,recovery,1724,interpreter/cling/www/old/contact.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html,6,['recover'],['recovery']
Safety,"re information. :program:`lit` parses options from the environment variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one per line and are treated as if they were in the same place as the; original file referencing argument on the command line. A response file can; reference other response files. Users interested in the :program:`lit` architecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:2541,detect,detected,2541,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['detect'],['detected']
Safety,"re the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the top level in a file, in which case they cover all subsequent function; bodies until they're turned off. Note that it is undefined behavior to enter; code that is *not* covered by one of these pragmas from code that *is* covered; by one of these pragmas unless the floating point environment has been restored; to its default state. See the C standard for more information about these pragmas. The command line option ``-frounding-math`` behaves as if the translation unit; began with ``#pragma STDC FENV_ROUND FE_DYNAMIC``. The command line option; ``-ffp-model=strict`` behaves as if the translation unit began with ``#pragma STDC FENV_ACCESS ON``. Code that just wants to use a specific rounding mode for specific floating point; operations can avoid most of the hazards of the dynamic floating point environment; by using ``#pragma STDC FENV_ROUND`` with a value other than ``FE_DYNAMIC``. .. _crtfastmath.o:. A note about ``crtfastmath.o``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ``-ffast-math`` and ``-funsafe-math-optimizations`` cause ``crtfastmath.o`` to be; automatically linked, which adds a static constructor that sets the FTZ/DAZ; bits in MXCSR, affecting not only the current compilation unit but all static; and shared libraries included in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:71432,avoid,avoid,71432,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,"['avoid', 'hazard']","['avoid', 'hazards']"
Safety,"re variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; linear problem into a nasty non-linear one, which is the reason why; limits should be avoided if not necessary. In addition, the; transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced; in the numerical calculation of the $\mbox{FCN}$ value. The effects; of non-linearity and numerical roundoff both become more important as; the external value gets closer to one of the limits (expressed as the; distance to nearest limit divided by distance between limits). The user; must therefore be aware of the fact that, for example, if they put limits; of $(0,10^{10})$ on a parameter, then the values $0.0$ and $1.0$ will be; indistinguishable to the accuracy of most machines. For this purpose single sided limits on parameters are provided by M ,; with their transformation being:. Lower bound $a$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:8846,avoid,avoided,8846,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoided']
Safety,"re). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned as its determinant shows. We construct a vector `b` by; summing the matrix rows. Therefore, the components of the solution; vector `x` should be exactly 1. Our rule of thumb to the 2.1012; condition number predicts that the solution accuracy should be around. `15 - 12 = 3`. digits. Indeed, the largest deviation is 0.00055 in component 6. ``` {.cpp}; TMatrixDSym H = THilbertMatrixDSym(10);; TVectorD rowsum(10);; for (Int_t irow = 0; irow < 10; irow++); for (Int_t icol = 0; icol < 10; icol++); rowsum(irow) += H(irow,icol);; TDecompLU lu(H);; Bool_t ok;; TVectorD x = lu.Solve(rowsum,ok);; Double_t d1,d2;; lu.Det(d1,d2);; cout << ""cond:"" << lu.Condition() << endl;; cout << ""det :"" << d1*TMath:Power(2.,d2) << endl;; cout << ""tol :"" << lu.GetTol() << endl;; x.Print();; cond:3.9569e+12; det :2.16439e-53; tol :2.22045e-16; Vector 10 is as follows; | 1 |; ------------------; 0 |1; 1 |1; 2 |0.999997; 3 |1.00003; 4 |0.999878; 5 |1.00033; 6 |0.999452; 7 |1.00053; 8 |0.999723; 9 |1.00006; ```. ### LU. Decompose an `nxn` matrix $A$. ``` {.cpp}; PA = LU; ```. *P* permutation matrix stored in the index array `fIndex`: `j=fIndex[i]`; indicates that row j and row` i `should be swapped. Sign of the; permutation, $-1^n$, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:42582,predict,predicts,42582,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['predict'],['predicts']
Safety,"re; can be multiple inner remainder loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307723,unsafe,unsafe,307723,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"re; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21338,safe,safety,21338,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['safe'],['safety']
Safety,"read from the place by the caller after this call; exits. .. code-block:: llvm. @glb = global ptr null; @glb2 = global ptr null; @glb3 = global ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145344,safe,safely,145344,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"read lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, no extension is required if the receiver is loaded directly; from a ``__strong`` object with :ref:`precise lifetime semantics; <arc.optimization.precise>`. .. admonition:: Rationale. Implicit autoreleases carry the risk of significantly inflating memory use,; so it's important to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal, as for local variables; this requires a very explicit annotation, which allows ARC to trust the user; with good cheer. .. _arc.misc.c-retainable:. C retainable pointer types; --------------------------. A type is a :arc-term:`C retainable pointer type` if it is a pointer to; (possibly qualified) ``void`` or a pointer to a (possibly qualifier) ``struct``; or ``class`` type. .. admonition:: Rationale. ARC does not manage pointers of CoreFoundation type (or any of the related; families of retainable C pointers which interoperate with Objective-C for; retain/release operation). In fact, ARC does not even know how to; distinguish these types from arbitrary C pointer types. The intent of this; concept is to filter out some obviously non-object types while leaving a hook; for later tightening if a means of exhaustively marking CF types is made; available. .. _arc.mis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:101606,risk,risk,101606,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['avoid', 'risk']","['avoiding', 'risk']"
Safety,"red -Wl,-G""). # Also set the correct flags for building shared libraries.; string(APPEND CMAKE_SHARED_LINKER_FLAGS "" -shared""); endif(). # Build with _XOPEN_SOURCE on z/OS.; if (CMAKE_SYSTEM_NAME MATCHES ""OS390""); add_compile_definitions(_XOPEN_SOURCE=600); add_compile_definitions(_OPEN_SYS) # Needed for process information.; add_compile_definitions(_OPEN_SYS_FILE_EXT) # Needed for EBCDIC I/O.; add_compile_definitions(_EXT) # Needed for file data.; add_compile_definitions(_UNIX03_THREADS) # Multithreading support.; endif(). # Build with _FILE_OFFSET_BITS=64 on Solaris to match g++ >= 9.; if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""SunOS""); add_compile_definitions(_FILE_OFFSET_BITS=64); endif(). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories( ${LLVM_INCLUDE_DIR} ${LLVM_MAIN_INCLUDE_DIR}). # when crosscompiling import the executable targets from a file; if(LLVM_USE_HOST_TOOLS); include(CrossCompile); llvm_create_cross_target(LLVM NATIVE """" Release); endif(LLVM_USE_HOST_TOOLS); if(LLVM_TARGET_IS_CROSSCOMPILE_HOST); # Dummy use to avoid CMake Warning: Manually-specified variables were not used; # (this is a variable that CrossCompile sets on recursive invocations); endif(). if( ${CMAKE_SYSTEM_NAME} MATCHES SunOS ); # special hack for Solaris to handle crazy system sys/regset.h; include_directories(""${LLVM_MAIN_INCLUDE_DIR}/llvm/Support/Solaris""); endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS ). # Make sure we don't get -rdynamic in every binary. For those that need it,; # use export_executable_symbols(target).; set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS """"). include(AddLLVM); include(TableGen). include(LLVMDistributionSupport). if( MINGW AND NOT ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang"" ); # People report that -O3 is unreliable on MinGW. The traditional; # build also uses -O2 for that reason:; llvm_replace_compiler_option(CMAKE_CXX_FLAGS_RELEASE ""-O3"" ""-O2""); endif(). if(LLVM_INCLUDE_TESTS); umbrella_lit_testsuite_begin(check-all); endif(). # Put this before tblgen. El",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:47862,avoid,avoid,47862,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['avoid'],['avoid']
Safety,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196379,Redund,Redundant,196379,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Redund'],['Redundant']
Safety,"rent bounds annotations on their nested pointer; types are incompatible and cannot implicitly cast to each other. For example,; ``T *__single *__single`` cannot be converted to ``T *__bidi_indexable; *__single``. Such a conversion between incompatible nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, etc) using a cast. The extension provides builtins to force; this conversion, ``__unsafe_forge_bidi_indexable(type, pointer, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:40452,unsafe,unsafe,40452,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"reported; return ret;; }. Additionally to the argument and return value conditions, this checker also adds; state of the value ``errno`` if applicable to the analysis. Many system; functions set the ``errno`` value only if an error occurs (together with a; specific return value of the function), otherwise it becomes undefined. This; checker changes the analysis state to contain such information. This data is; used by other checkers, for example :ref:`unix-Errno`. **Limitations**. The checker can not always provide notes about the values of the arguments.; Without this information it is hard to confirm if the constraint is indeed; violated. The argument values are shown if they are known constants or the value; is determined by previous (not too complicated) assumptions. The checker can produce false positives in cases such as if the program has; invariants not known to the analyzer engine or the bug report path contains; calls to unknown functions. In these cases the analyzer fails to detect the real; range of the argument. **Parameters**. The checker models functions (and emits diagnostics) from the C standard by; default. The ``ModelPOSIX`` option enables modeling (and emit diagnostics) of; additional functions that are defined in the POSIX standard. This option is; disabled by default. .. _osx-checkers:. osx; ^^^; macOS checkers. .. _osx-API:. osx.API (C); """"""""""""""""""""""; Check for proper uses of various Apple APIs. .. code-block:: objc. void test() {; dispatch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. .. _osx-NumberObjectConversion:. osx.NumberObjectConversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for erroneous conversions of objects representing numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:34479,detect,detect,34479,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['detect'],['detect']
Safety,"resent, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A register that has this rule has no recoverable value in the previous frame.; The previous value of this register is the undefined location description (see; :ref:`amdgpu-dwarf-undefined-location-description-operations`). *By convention, the register is not preserved by a callee.*. *same value*; This register has not been modified from the previous caller frame. If the current frame is the top frame, then the previous value of this; register is the location description L that specifies one register location; description SL. SL specifies the register location storage that corresponds to; the register with a bit offset of 0 for the current thread. If the current frame is not the top frame, then the previous value of this; register is the location description obtained using the call frame information; for the callee frame and callee program location invoked by the current caller; frame for the same register. *By convention, the register is preserved by the callee, but the callee has; not modified it.*. *offset(N)*; N i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:190610,recover,recoverable,190610,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['recover'],['recoverable']
Safety,"ression:. * v5.34/38; * v6.08/06 [not yet released]; * v6.10/08; * v6.12/02. ## Removed interfaces. ## Core Libraries; - Optimize away redundant deserialization of template specializations. This reduces the memory footprint for hsimple by around 30% while improving the runtime performance for various cases by around 15%.; - When ROOT is signaled with a SIGUSR2 (i.e. on Linux and MacOS X) it will now print a backtrace.; - Move RStringView.h to ROOT/RStringView.hxx and always include ROOT/RStringView.hxx instead of RStringView.h for backward compatibility; - In `TClingCallFunc`, support r-value reference parameters. This paves the way for the corresponding support in PyROOT (implemented now in the latest Cppyy).; - Included the new TSequentialExecutor in ROOT, sharing the interfaces of TExecutor.This should improve code economy when providing a fallback for TThreadExecutor/TProcessExecutor. ### Thread safety; - Resolved several race conditions, dead-locks, performance and order of initialization/destruction issues still lingering because of or despite the new read-write lock mechanism. ## Interpreter. - Enabled use of multi-threaded code from the interpreter.; - Previouslyl multi-threaded code could be run from the interpreter as long as the call starting the threada was the same code that initialized the ROOT global lock, any other uses, including attempting to run the same code a second time in the same session would lead to a dead lock (if any other thread attempted to take on the ROOT lock).; - The interpreter now suspend the ROOT lock (which is taken to protect the interpreter global state) during user code execution. ## I/O Libraries; - LZ4 (with compression level 4) is now the default compression algorithm for new ROOT files (LZ4 is lossless data compression algorithm that is focused on compression and decompression speed, while in ROOT case providing benefit in faster decompression at the price of a bit worse compression ratio comparing to ZLIB); - If two or mo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:2533,safe,safety,2533,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['safe'],['safety']
Safety,"returns_twice``; This attribute indicates that this function can return twice. The C; ``setjmp`` is an example of such a function. The compiler disables; some optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100734,safe,safety,100734,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"riable correlations, classifier output.; * New classifier visualization for BDT, ANN and DNN.; * Interactive training for all methods. ## 2D Graphics Libraries. * In `TColor::SetPalette`, make sure the high quality palettes are defined; only once taking care of transparency. Also `CreateGradientColorTable` has been; simplified.; * New fast constructor for `TColor` avoiding to call `gROOT->GetColor()`. The; normal constructor generated a big slow down when creating a Palette with; `CreateGradientColorTable`.; * In `CreateGradientColorTable` we do not need anymore to compute the highest; color index.; * In `TGraphPainter`, when graphs are painted with lines, they are split into; chunks of length `fgMaxPointsPerLine`. This allows to paint line with an ""infinite""; number of points. In some case this ""chunks painting"" technic may create artefacts; at the chunk's boundaries. For instance when zooming deeply in a PDF file. To avoid; this effect it might be necessary to increase the chunks' size using the new function:; `TGraphPainter::SetMaxPointsPerLine(20000)`.; * When using line styles different from 1 (continuous line), the behavior of TArrow; was suboptimal. The problem was that the line style is also applied to the arrow; head, which is usually not what one wants.; The arrow tip is now drawn using a continuous line.; * It is now possible to select an histogram on a canvas by clicking on the vertical; lines of the bins boundaries.; This problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-6649).; * When using time format in axis, `TGaxis::PaintAxis()` may in some cases call; `strftime()` with invalid parameter causing a crash.; This problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-7689).; * Having ""X11.UseXft: yes"" activated in .rootrc file and running; [this](https://sft.its.cern.ch/jira/browse/ROOT-7985) little program,; resulted in a crash.; * Ease the setting of the appearance of joining lines for PostScript and PDF; output. `TPo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:14566,avoid,avoid,14566,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['avoid'],['avoid']
Safety,"ries of the ``xray_instr_map``, and; overwrite the instrumentation points at runtime. Using XRay; ==========. You can use XRay in a couple of ways:. - Instrumenting your C/C++/Objective-C/Objective-C++ application.; - Generating LLVM IR with the correct function attributes. The rest of this section covers these main ways and later on how to customize; what XRay does in an XRay-instrumented binary. Instrumenting your C/C++/Objective-C Application; ------------------------------------------------. The easiest way of getting XRay instrumentation for your application is by; enabling the ``-fxray-instrument`` flag in your clang invocation. For example:. ::. clang -fxray-instrument ... By default, functions that have at least 200 instructions (or contain a loop) will; get XRay instrumentation points. You can tweak that number through the; ``-fxray-instruction-threshold=`` flag:. ::. clang -fxray-instrument -fxray-instruction-threshold=1 ... The loop detection can be disabled with ``-fxray-ignore-loops`` to use only the; instruction threshold. You can also specifically instrument functions in your; binary to either always or never be instrumented using source-level attributes.; You can do it using the GCC-style attributes or C++11-style attributes. .. code-block:: c++. [[clang::xray_always_instrument]] void always_instrumented();. [[clang::xray_never_instrument]] void never_instrumented();. void alt_always_instrumented() __attribute__((xray_always_instrument));. void alt_never_instrumented() __attribute__((xray_never_instrument));. When linking a binary, you can either manually link in the `XRay Runtime; Library`_ or use ``clang`` to link it in automatically with the; ``-fxray-instrument`` flag. Alternatively, you can statically link-in the XRay; runtime library from compiler-rt -- those archive files will take the name of; `libclang_rt.xray-{arch}` where `{arch}` is the mnemonic supported by clang; (x86_64, arm7, etc.). LLVM Function Attribute; -----------------------. If",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:2160,detect,detection,2160,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['detect'],['detection']
Safety,"ries, so dsymutil knows where to look; for dSYM files with debug information about symbols present in those; libraries. .. option:: --fat64. Use a 64-bit header when emitting universal binaries. .. option:: --flat, -f. Produce a flat dSYM file. A ``.dwarf`` extension will be appended to the; executable name unless the output file is specified using the ``-o`` option. .. option:: --gen-reproducer. Generate a reproducer consisting of the input object files. Alias for; --reproducer=GenerateOnExit. .. option:: --help, -h. Print this help output. .. option:: --keep-function-for-static. Make a static variable keep the enclosing function even if it would have been; omitted otherwise. .. option:: --minimize, -z. When used when creating a dSYM file, this option will suppress the emission of; the .debug_inlines, .debug_pubnames, and .debug_pubtypes sections since; dsymutil currently has better equivalents: .apple_names and .apple_types. When; used in conjunction with ``--update`` option, this option will cause redundant; accelerator tables to be removed. .. option:: --no-odr. Do not use ODR (One Definition Rule) for uniquing C++ types. .. option:: --no-output. Do the link in memory, but do not emit the result file. .. option:: --no-swiftmodule-timestamp. Don't check the timestamp for swiftmodule files. .. option:: --num-threads <threads>, -j <threads>. Specifies the maximum number (``n``) of simultaneous threads to use when; linking multiple architectures. .. option:: --object-prefix-map <prefix=remapped>. Remap object file paths (but no source paths) before processing. Use; this for Clang objects where the module cache location was remapped using; ``-fdebug-prefix-map``; to help dsymutil find the Clang module cache. .. option:: --oso-prepend-path <path>. Specifies a ``path`` to prepend to all debug symbol object file paths. .. option:: --out <filename>, -o <filename>. Specifies an alternate ``path`` to place the dSYM bundle. The default dSYM; bundle path is created by append",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst:2873,redund,redundant,2873,interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,1,['redund'],['redundant']
Safety,"ring formats.; #if __has_include(""myinclude.h"") && __has_include(<stdint.h>); # include ""myinclude.h""; #endif. To test for this feature, use ``#if defined(__has_include)``:. .. code-block:: c++. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include); #if __has_include(""myinclude.h""); # include ""myinclude.h""; #endif; #endif. .. _langext-__has_include_next:. ``__has_include_next``; ----------------------. This function-like macro takes a single file name string argument that is the; name of an include file. It is like ``__has_include`` except that it looks for; the second instance of the given file found in the include paths. It evaluates; to 1 if the second instance of the file can be found using the include paths,; or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include_next(""myinclude.h"") && __has_include_next(<stdint.h>); # include_next ""myinclude.h""; #endif. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include_next); #if __has_include_next(""myinclude.h""); # include_next ""myinclude.h""; #endif; #endif. Note that ``__has_include_next``, like the GNU extension ``#include_next``; directive, is intended for use in headers only, and will issue a warning if; used in the top-level compilation file. A warning will also be issued if an; absolute path is used in the file argument. ``__has_warning``; -----------------. This function-like macro takes a string literal that represents a command line; option for a warning and returns true if that is a valid warning option. .. code-block:: c++. #if __has_warning(""-Wformat""); ...; #endif. .. _languageextensions-builtin-macros:. Builtin Macros; ==============. ``__BASE_FILE__``; Defined to a string that contains the name of the main input file passed to; Clang. ``__FILE_NAME__``; Clang-specific extension that functions similar to ``__FILE__`` but only; renders the last path component (the filename) i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:11446,avoid,avoid,11446,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"ring>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION``. These are attributes on a function or method that tries to acquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the firs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13764,safe,safety,13764,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"rinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. // And for each live root...; for (GCFunctionInfo::live_iterator LI = MD.live_begin(PI),; LE = MD.live_end(PI);; LI != LE; ++LI) {; // Emit live root's offset within the stack frame.; OS.AddComment(""stack index (offset / wordsize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37926,safe,safe,37926,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ript update. Commit ``UM8``; updates a submodule of local project ``myproj``. The tool ``zip-downstream-fork.py`` at; https://github.com/greened/llvm-git-migration/tree/zip can be used to; convert the umbrella history into a monorepo-based history with; commits in the order implied by submodule updates::. U1 - U2 - U3 <- upstream/main; \ \ \; \ -----\--------------- local/zip--.; \ \ \ |; - Lllvm1 - Llld1 - UM3 - Lclang1 - Lclang2 - Lllvm2 - Llld2 - Lmyproj1 <-'. The ``U*`` commits represent upstream commits to the monorepo main; branch. Each submodule update in the local ``UM*`` commits brought in; a subproject tree at some local commit. The trees in the ``L*1``; commits represent merges from upstream. These result in edges from; the ``U*`` commits to their corresponding rewritten ``L*1`` commits.; The ``L*2`` commits did not do any merges from upstream. Note that the merge from ``U2`` to ``Lclang1`` appears redundant, but; if, say, ``U3`` changed some files in upstream clang, the ``Lclang1``; commit appearing after the ``Llld1`` commit would actually represent a; clang tree *earlier* in the upstream clang history. We want the; ``local/zip`` branch to accurately represent the state of our umbrella; history and so the edge ``U2 -> Lclang1`` is a visual reminder of what; clang's tree actually looks like in ``Lclang1``. Even so, the edge ``U3 -> Llld1`` could be problematic for future; merges from upstream. git will think that we've already merged from; ``U3``, and we have, except for the state of the clang tree. One; possible mitigation strategy is to manually diff clang between ``U2``; and ``U3`` and apply those updates to ``local/zip``. Another,; possibly simpler strategy is to freeze local work on downstream; branches and merge all submodules from the latest upstream before; running ``zip-downstream-fork.py``. If downstream merged each project; from upstream in lockstep without any intervening local commits, then; things should be fine without any special action. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:25705,redund,redundant,25705,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['redund'],['redundant']
Safety,"rison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21592,redund,redundant,21592,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['redund'],['redundant']
Safety,"rker process has its; ``stdout``/``stderr`` redirected to ``fuzz-<JOB>.log``.; ``-workers``; Number of simultaneous worker processes to run the fuzzing jobs to completion; in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is used.; ``-dict``; Provide a dictionary of input keywords; see Dictionaries_.; ``-use_counters``; Use `coverage counters`_ to generate approximate counts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from target code (e.g. messages on assert failure). - 0 (default): close neither ``stdout`` nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list of flags run the fuzzer binary with ``-help=1``. Output; ======. During operation the fuzzer prints information to ``stderr``, for example::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:13748,timeout,timeout,13748,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeout']
Safety,"rmine the current search direction, since this is; the optimal strategy for quadratic functions and ""physical"" functions; should be quadratic in the neighbourhood of the minimum at least. The; search directions determined by $\mbox{MIGRAD}$ are guaranteed to be; downhill only if the covariance matrix is positive–definite, so in case; this is not true, it makes a positive–definite approximation by adding; an appropriate constant along the diagonal as determined by the; eigenvalues of the matrix. Theoretically, the covariance matrix for a; ""physical"" function must be positive–definite at the minimum, although; it may not be so for all points far away from the minimum, even for a; well–determined physical problem. Therefore, if $\mbox{MIGRAD}$; reports that it has found a non-positive–definite covariance matrix,; this may be a sign of one or more of the following:. - **A non–physical region.** On its way to the minimum,; $\mbox{MIGRAD}$ may have traversed a region which has unphysical; behaviour, which is of course not a serious problem as long as it; recovers and leaves such a region. - **An underdetermined problem.** If the matrix is not; positive–definite even at the minimum, this may mean that the; solution is not well–defined, for example that there are more; unknowns than there are data points, or that the parametrization of; the fit contains a linear dependence. If this is the case, then M; (or any other program) cannot solve your problem uniquely, and the; error matrix will necessarily be largely meaningless, so the user; must remove the under-determinedness by reformulating the; parametrization. M cannot do this itself, but it can provide some; hints (contours, global correlation coefficients, eigenvalues) which; can help the clever user to find out what is wrong. - **Numerical inaccuracies.** It is possible that the apparent lack of; positive–definiteness is in fact only due to excessive roundoff; errors in numerical calculations, either in $\mbox{FCN}$ or in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:72195,recover,recovers,72195,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['recover'],['recovers']
Safety,"rom http://gcc.gnu.org/ml/gcc-patches/2004-09/msg01148.html,; but without the unnecessary and.); movl %ecx, %eax; shrl $5, %eax; movl %eax, %edx; xorl $1, %edx; sall %cl, %eax; sall %cl. %edx. 64-bit shifts (in general) expand to really bad code. Instead of using; cmovs, we should expand to a conditional branch like GCC produces. //===---------------------------------------------------------------------===//. Some isel ideas:. 1. Dynamic programming based approach when compile time is not an; issue.; 2. Code duplication (addressing mode) during isel.; 3. Other ideas from ""Register-Sensitive Selection, Duplication, and; Sequencing of Instructions"".; 4. Scheduling for reduced register pressure. E.g. ""Minimum Register; Instruction Sequence Problem: Revisiting Optimal Code Generation for DAGs""; and other related papers.; http://citeseer.ist.psu.edu/govindarajan01minimum.html. //===---------------------------------------------------------------------===//. Should we promote i16 to i32 to avoid partial register update stalls?. //===---------------------------------------------------------------------===//. Leave any_extend as pseudo instruction and hint to register; allocator. Delay codegen until post register allocation.; Note. any_extend is now turned into an INSERT_SUBREG. We still need to teach; the coalescer how to deal with it though. //===---------------------------------------------------------------------===//. It appears icc use push for parameter passing. Need to investigate. //===---------------------------------------------------------------------===//. The instruction selector sometimes misses folding a load into a compare. The; pattern is written as (cmp reg, (load p)). Because the compare isn't; commutative, it is not matched with the load on both sides. The dag combiner; should be made smart enough to canonicalize the load into the RHS of a compare; when it can invert the result of the compare for free. //===------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:2039,avoid,avoid,2039,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,2,['avoid'],['avoid']
Safety,"roven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2704,safe,safety,2704,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"rpreter, this gives the name ""`UserFun`"" to the; thread. This name can be used to retrieve the thread later. However,; when called from compiled code, this method does not give any name to; the thread. So give a name to the thread in compiled use:. ``` {.cpp}; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; ```. You can pass arguments to the thread function using the; `UserArgs`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6415,safe,safe,6415,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"rror Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85339,recover,recovery,85339,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"rrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15718,recover,recovery,15718,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recovery']
Safety,"rs (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:133786,safe,safety,133786,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"rs anywhere else in a declarator, it applies to; the type there. .. admonition:: Rationale. Ownership qualifiers are like ``const`` and ``volatile`` in the sense; that they may sensibly apply at multiple distinct positions within a; declarator. However, unlike those qualifiers, there are many; situations where they are not meaningful, and so we make an effort; to ""move"" the qualifier to a place where it will be meaningful. The; general goal is to allow the programmer to write, say, ``__strong``; before the entire declaration and have it apply in the leftmost; sensible place. .. _arc.ownership.spelling.property:. Property declarations; ^^^^^^^^^^^^^^^^^^^^^. A property of retainable object pointer type may have ownership. If the; property's type is ownership-qualified, then the property has that ownership.; If the property has one of the following modifiers, then the property has the; corresponding ownership. A property is ill-formed if it has conflicting; sources of ownership, or if it has redundant ownership modifiers, or if it has; ``__autoreleasing`` ownership. * ``assign`` implies ``__unsafe_unretained`` ownership.; * ``copy`` implies ``__strong`` ownership, as well as the usual behavior of; copy semantics on the setter.; * ``retain`` implies ``__strong`` ownership.; * ``strong`` implies ``__strong`` ownership.; * ``unsafe_unretained`` implies ``__unsafe_unretained`` ownership.; * ``weak`` implies ``__weak`` ownership. With the exception of ``weak``, these modifiers are available in non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:34591,redund,redundant,34591,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['redund'],['redundant']
Safety,"rs compilation of the symbol(s) searched for; (if they have not been compiled already), and (2) it provides the; synchronization mechanism for concurrent compilation. The pseudo-code for the; lookup process is:. .. code-block:: none. construct a query object from a query set and query handler; lock the session; lodge query against requested symbols, collect required materializers (if any); unlock the session; dispatch materializers (if any). In this context a materializer is something that provides a working definition; of a symbol upon request. Usually materializers are just wrappers for compilers,; but they may also wrap a jit-linker directly (if the program representation; backing the definitions is an object file), or may even be a class that writes; bits directly into memory (for example, if the definitions are; stubs). Materialization is the blanket term for any actions (compiling, linking,; splatting bits, registering with runtimes, etc.) that are required to generate a; symbol definition that is safe to call or access. As each materializer completes its work it notifies the JITDylib, which in turn; notifies any query objects that are waiting on the newly materialized; definitions. Each query object maintains a count of the number of symbols that; it is still waiting on, and once this count reaches zero the query object calls; the query handler with a *SymbolMap* (a map of symbol names to addresses); describing the result. If any symbol fails to materialize the query immediately; calls the query handler with an error. The collected materialization units are sent to the ExecutionSession to be; dispatched, and the dispatch behavior can be set by the client. By default each; materializer is run on the calling thread. Clients are free to create new; threads to run materializers, or to send the work to a work queue for a thread; pool (this is what LLJIT/LLLazyJIT do). Top Level APIs; ==============. Many of ORC's top-level APIs are visible in the example above:. -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:10359,safe,safe,10359,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['safe'],['safe']
Safety,"rs must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2059,predict,predict,2059,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['predict'],['predict']
Safety,"rt; i < end; ++i); A[i] *= B[i] + K;; }. Runtime Checks of Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. In the example below, if the pointers A and B point to consecutive addresses,; then it is illegal to vectorize the code because some elements of A will be; written before they are read from array B. Some programmers use the 'restrict' keyword to notify the compiler that the; pointers are disjointed, but in our example, the Loop Vectorizer has no way of; knowing that the pointers A and B are unique. The Loop Vectorizer handles this; loop by placing code that checks, at runtime, if the arrays A and B point to; disjointed memory locations. If arrays A and B overlap, then the scalar version; of the loop is executed. .. code-block:: c++. void bar(float *A, float* B, float K, int n) {; for (int i = 0; i < n; ++i); A[i] *= B[i] + K;; }. Reductions; ^^^^^^^^^^. In this example the ``sum`` variable is used by consecutive iterations of; the loop. Normally, this would prevent vectorization, but the vectorizer can; detect that 'sum' is a reduction variable. The variable 'sum' becomes a vector; of integers, and at the end of the loop the elements of the array are added; together to create the correct result. We support a number of different; reduction operations, such as addition, multiplication, XOR, AND and OR. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i] + 5;; return sum;; }. We support floating point reduction operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:5986,detect,detect,5986,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['detect'],['detect']
Safety,"rtual void Print(Option_t *wildcard, Option_t *option) const;; with; virtual void Print(Option_t *option="""") const;; virtual void Print(Option_t *option, Int_t recurse) const;; virtual void Print(Option_t *option, const char* wildcard,; Int_t recurse=1) const;; virtual void Print(Option_t *option, TPRegexp& regexp,; Int_t recurse=1) const;. Introduce three new protected methods used to print out collection details.; These are called from the Print() methods and make overriding of what; is printed for a collection / entries easier.; virtual void PrintCollectionHeader(Option_t* option) const;; virtual const char* GetCollectionEntryName(TObject* entry) const;; virtual void PrintCollectionEntry(TObject* entry, Option_t* option,; Int_t recurse) const;. Improve performance of reading TExMap object (50 times faster) using an updated,; slightly larger (16%) on file format for the TExMap object. ACLiC; Fix problem finding rootcint in the --prefix configuration.; Change the naming convention for the temporary files created by ACLiC, instead of randomly named ACLiC now uses:scriptname_scriptextension_ACLiC_function.extension; When ACLiC need to revert to the temp directory for storing the library, it now create the directory; structure under a directory named after the userid. Allow white space in the name of the directory where a script to be compiled by ACLiC resides.; Add optional 5th argument to CompileMacro to allow set the file bit; mode of the directory created.; Avoid looking for Microsoft's link.exe when we already have it (and hence avoid complaining about cygpath when cygwin is not even installed. Meta. Insure that the TClass list of methods is refreshed when new functions are added to the dictionary. TStyle. In TStyle::Reset, the Frame; Fill Color default value did not match the TFrame; Fill Color default value. TSystem. DirName now properly handle; repeated '/'; this allow mkdir(""a/b//c"",true); to succeed.; Extended the support for UNIX sockets on a generic path. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html:1734,avoid,avoid,1734,core/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html,3,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"rtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:19800,abort,abort,19800,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['abort'],['abort']
Safety,"ructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:2635,risk,risk,2635,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,2,['risk'],['risk']
Safety,"rum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already on; - Decompress `TTreeCache` in parallel if IMT is on (upgrade of the `TTreeCacheUnzip` class).; - In `TTreeProcessorMT` delete friend chains after the main chain to avoid double deletes.; - If IMT is enabled, the multithreaded execution of the fit respects the number of threads IMT has been initialized with. ## Language Bindings. ### Notebook integration; - In the ROOT kernel, avoid import of unnecessary components.; - In the ROOT kernel, optimise regexes involved in tab-completion which could take up to minutes to be executed. ## JavaScript ROOT; ; Upgrade JSROOT to v5.4.1. Following new features implemented:. * New supported classes:; - TDiamond; - TArc; - TCurlyLine; - TCurlyArc; - TCrown; * New draw options:; - ""RX"" and ""RY"" for TGraph to reverse axis; - ""noopt"" for TGraph to disable drawing optimization; - ""CPN"" for TCanvas to create color palette from N last colors; - ""line"" for TGraph2D; * New features:; - support LZ4 compression; - tooltips and zooming in TGraphPolar drawings; - TPavesText with multiple underlying paves; - implement all fill styles; - draw borders for TWbox; - draw all objects from TList/TObjArray as they appear in list of primitives; - let enable/disable highlight of extra objects in geometry viewer; - draw axis labels on both sides when pad.fTick[x/y] > 1; - make drawing of TCanvas with many primitives smoother; - add fOptTitl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:15295,avoid,avoid,15295,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are additional areas that LLVM does not directly address:. * Registration of global roots with the runtime. * Registration of stack map entries with the runtime. * The functions used by the program to allocate memory, trigger a collection,; etc. * Computation or compilation of type maps, or registration of them with the; runtime. These are used to crawl the heap for object references. In general, LLVM's support for GC does not include features which can be; adequately addressed with other features of the IR and does not specify a; particular binary interface. On the plus side, this means that you should be; able to integrate LLVM with an e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:6659,safe,safe,6659,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"rves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; record",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:18352,unsafe,unsafe,18352,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['unsafe'],['unsafe']
Safety,"ry headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56959,detect,detection,56959,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['detect'],['detection']
Safety,"ry. Guarded Allocation Pool; -----------------------. The core of GWP-ASan is the guarded allocation pool. Each sampled allocation is; backed using its own *guarded* slot, which may consist of one or more accessible; pages. Each guarded slot is surrounded by two *guard* pages, which are mapped as; inaccessible. The collection of all guarded slots makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management librar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4156,detect,detection,4156,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"ry. Nodes have visualization attributes as the volume; has. When undefined by users, painting a node on a pad will take the; corresponding volume attributes. \anchor GP01b; ### Creating and Positioning Volumes. \anchor GP01ba; #### Making Volumes. As mentioned before, volumes are the basic objects used in building the; geometrical hierarchy. They represent objects that are not positioned,; but store all information about the placement of the other volumes they; may contain. Therefore a volume can be replicated several times in the; geometry. As it was explained, in order to create a volume, one has to; put together a shape and a medium, which are already defined. Volumes have to be named by users at creation time. Every different name; may represent a unique volume object, but may also represent more; general a family (class) of volume objects having the same shape type; and medium, but possibly different shape parameters. It is the user's; task to provide different names for different volume families in order; to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two; cases: when a parametric shape is used or when a division operation is; applied. Each volume in the geometry stores a unique ID corresponding to; its family. In order to ease-up their creation, the manager class is; providing an API that allows making a shape and a volume in a single; step. \anchor GP01bb; #### Example of Volume Creation. ~~~{.cpp}; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:24504,avoid,avoid,24504,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"ry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platfo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2788,detect,detect,2788,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['detect'],['detect']
Safety,"s (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up members.; (`#22413 <https://github.com/llvm/llvm-project/issues/22413>`_),; (`#29942 <https://github.com/llvm/llvm-project/issues/29942>`_),; (`#35574 <https://github.com/llvm/llvm-project/issues/35574>`_) and; (`#27224 <https://github.com/llvm/llvm-project/issues/27224>`_). - Clang emits an error on substitution failure within lambda body inside a; requires-expression. This fixes:; (`#64138 <https://github.com/llvm/llvm-project/issues/64138>`_) and; (`#71684 <https://github.com/llvm/llvm-project/issues/71684>`_). - Update ``FunctionDeclBitfields.NumFunctionDeclBi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:46490,avoid,avoid,46490,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['avoid'],['avoid']
Safety,"s a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = sub i32 4, %var ; yields i32:result = 4 - %var; <result> = sub i32 0, %val ; yields i32:result = -%var. .. _i_fsub:. '``fsub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fsub [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fsub``' instruction returns the difference of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fsub``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point difference of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fsub float 4.0, %var ; yields float:result = 4.0 - %var; <result> = fsub float -0.0, %val ; yields float:result = -%var. .. _i_mul:. '``mul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = mul <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:381687,unsafe,unsafe,381687,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"s a client of TGeoManager. The manager class also; controls the drawing/checking package (TGeoPainter client). This; is linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or comput",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:61988,detect,detector,61988,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"s about the technology found [here](../../README.CXXMODULES.md).; - The `ACLiC` can be configured to pass options to the `rootcling` invocation by enabling in the `.rootrc` the `ACLiC.ExtraRootclingFlags [-opts]` line.; - A call to `ROOT::EnableThreadSafety` is not required before using `TThreadExecutor` or `TTreeProcessorMT` anymore; - `TTreeProcessorMT` does not silently activate implicit multi-threading features anymore. An explicit call to; `ROOT::EnableImplicitMT` is required instead; - `TTreeProcessorMT` now has a constructor argument to set the number of threads for its thread-pool. ## I/O Libraries. ## TTree Libraries. - A new status bit was added to `TTree`: `kEntriesReshuffled`, which indicates a `TTree` that is the output of the; processing of another tree during which its entry order has been changed (this can happen, for instance, when; processing a tree in a multi-thread application). To avoid silent entry number mismatches, trees with this bit set; cannot add friend trees nor can be added as friends, unless the friend `TTree` has an appropriate `TTreeIndex`. ## Histogram Libraries. ## Math Libraries. ## RooFit Libraries. ### RooWorkspace::Import() for Python; `RooWorkspace.import()` cannot be used in Python, since it is a reserved keyword. Users therefore had to resort; to; getattr(workspace, 'import')(...); Now,; workspace.Import(...); has been defined for the new PyROOT, which makes calling the function easier. ### Modernised category classes; RooFit's categories were modernised. Previously, the class RooCatType was used to store category states. It stores; two members, an integer for the category index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:2384,avoid,avoid,2384,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['avoid'],['avoid']
Safety,"s and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26213,safe,safe,26213,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['safe'],['safe']
Safety,"s are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:15040,safe,safe,15040,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['safe'],['safe']
Safety,"s are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414255,safe,safe,414255,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"s can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:159819,avoid,avoid,159819,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['avoid'],['avoid']
Safety,"s compare greater than normal; states, which guarantees that they ""win"" when joined with normal states. Order; between failure states is determined by inclusion relation on the set of; accumulated violations (lattice's `⩽` is `⊆` on the set of violations). Order; between normal states is determined by reversed inclusion relation on the set of; overwritten parameter's member fields (lattice's `⩽` is `⊇` on the set of; overwritten fields). ![Lattice for data flow analysis that identifies output parameters](DataFlowAnalysisIntroImages/OutputParameterIdentificationLattice.svg). To determine whether a statement reads or writes a field we can implement; symbolic evaluation of `DeclRefExpr`s, `LValueToRValue` casts, pointer; dereference operator and `MemberExpr`s. ### Using data flow results to identify output parameters. Let's take a look at how we use data flow analysis to identify an output; parameter. The refactoring can be safely done when the data flow algorithm; computes a normal state with all of the fields proven to be overwritten in the; exit basic block of the function. ```c++; struct Customer {; int account_id;; std::string name;; };. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; c->name = ...; // Overwritten: {c->account_id, c->name}; } else {; c->name = ...; // Overwritten: {c->account_id, c->name}; }; // Overwritten: {c->account_id, c->name}; }; ```. When the data flow algorithm computes a normal state, but not all fields are; proven to be overwritten we can't perform the refactoring. ```c++; void target(bool b, Customer* c) {; // Overwritten: {}; if (b) {; c->account_id = 42; // Overwritten: {c->account_id}; } else {; c->name = ""Konrad""; // Overwritten: {c->name}; }; // Overwritten: {}; }; ```. Similarly, when the data flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:18368,safe,safely,18368,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['safe'],['safely']
Safety,"s determined when the ``typedef`` is used. The; following example shows that no pointer annotation is specified in the ``typedef; pint_t`` while each instance of ``typedef``'ed pointer gets its bounds; annotation based on the context in which the type is used. .. code-block:: c. typedef int * pint_t; // int *. pint_t glob; // int *__single glob;. void foo(void) {; pint_t local; // int *__bidi_indexable local;; }. Pointer types in a ``typedef`` can still have explicit annotations, e.g.,; ``typedef int *__single``, in which case the bounds annotation ``__single`` will; apply to every use of the ``typedef``. Array to pointer promotion to secure arrays (including VLAs); ------------------------------------------------------------. Arrays on function prototypes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, arrays on function prototypes are promoted (or ""decayed"") to a pointer to; its first element (e.g., ``&arr[0]``). In ``-fbounds-safety``, arrays are also; decayed to pointers, but with the addition of an implicit bounds annotation,; which includes variable-length arrays (VLAs). As shown in the following example,; arrays on function prototypes are decalyed to corresponding ``__counted_by``; pointers. .. code-block:: c. // Function prototype: void foo(int n, int *__counted_by(n) arr);; void foo(int n, int arr[n]);. // Function prototype: void bar(int *__counted_by(10) arr);; void bar(int arr[10]);. This means the array parameters are treated as `__counted_by` pointers within; the function and callers of the function also see them as the corresponding; `__counted_by` pointers. Incomplete arrays on function prototypes will cause a compiler error unless it; has ``__counted_by`` annotation in its bracket. .. code-block:: c. void f1(int n, int arr[]); // error. void f3(int n, int arr[__counted_by(n)]); // ok. void f2(int n, int arr[n]); // ok, decays to int *__counted_by(n). void f4(int n, int *__counted_by(n) arr); // ok. void f5(int n, int *arr); // ok, but decays to int *__single,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:32451,safe,safety,32451,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"s for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BITS ""Build 32 bits executables and libraries."" OFF); endif(). # Define the default arguments to use with 'lit', and an option for the user to; # override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC_IDE OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); if(LLVM_INDIVIDUAL_TEST_COVERAGE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28520,recover,recover,28520,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['recover'],['recover']
Safety,"s is selected/used.; When reading backwards, make sure to load a full (new) cluster and several other fixes to TTreeCache.; Reduce the memory used by a TTree in half. Refactor the code reading and writing the TBasket data.; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch.; In TTree::Fill, call FlushBasket before calling OptimizeBaskets so that we have a correct; and accurate value of fTotBytes to use as the requested memory.; In TTree::OptimizeBasket enforces hard minimun for the basket size (no lower than the; estimate size of one entry in the branch and no lower than 8 bytes). TTree::Process. Add support for the flag TSelector::kAbortFile. TTree::Draw. The line width setting was missing in a few places.; Namely support the option 'a' for TGraphs in TTree::Draw (delegate the axis management to the TGraph object). TTreeSQL. Allow TTreeSQL to see temporary tables.; Avoid creating the unnecessary array fEntryOffset ... which when its content is always set to zero actually prevent reading text field with TTreeSQL.; Properly find the column even if they were not created by TTreeSQL itself. Fix the loading of data for the last column. Other. Update the branch split mechanism to no longer split a base class; that can not be split (i.e. respect the information returned; by TStreamerElement::CannotSplit (and thus TClass::CanSplit).; In TChain::ls, print the name of the chain and indent the list of files (this fixes #79909).; When setting fBranch in the loaded basket, make sure to set it also for the first/only basket ; this prevents a crash when calling SetBasketSize for a split top level branch in a file produced by v4.00/08.; In TTree::Streamer, if the object we are reading in was already attached to a directory, let's make sure to unregister the object before setting fDirectory to zero.; Prevent TChainIndex and TTreeIndex from finding the branches from the friend tree when l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html:2920,Avoid,Avoid,2920,tree/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html,1,['Avoid'],['Avoid']
Safety,"s need to know what object they are constructing.; Moreover, if the aggregate contains; references, lifetime extension needs to be properly modeled. One can start untangling this problem by trying to replace the; current ad-hoc ; ParentMap lookup in ; CXXConstructionKind::NonVirtualBase branch of; ExprEngine::VisitCXXConstructExpr(); with proper support for the feature.; (Difficulty: Medium) . Handle array constructors.; When an array of objects is allocated (say, using the; operator new[] or defining a stack array),; constructors for all elements of the array are called.; We should model (potentially some of) such evaluations,; and the same applies for destructors called from; operator delete[].; See tests cases in handle_constructors_with_new_array.cpp.; . Constructing an array requires invoking multiple (potentially unknown); amount of constructors with the same construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move construct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:3149,avoid,avoid,3149,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,2,['avoid'],['avoid']
Safety,"s no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInterpreterMutex``` are deprecated and may be removed in future releases.; - Added ```TReadLockGuard```,```TWriteLockGuard```, ```R__READ_LOCKGUARD``` and```R__WRITE_LOCKGUARD``` to take advantage of the new lock. The legacy ```TLockGuard``` and ```R__LOCKGUARD``` use the write lock.; - Improved scaling of TROOT::RecursiveRemove in the case of large collection.; - Added a thread safe mode for the following ROOT collections: THashList, THashTable, TList and TObjArray. When ROOT's thread safe mode is enabled and the collection is set to use internal locks by calling:; ```; collection->UseRWLock();; ```; all operations on the collection will take the read or write lock when needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:5779,safe,safe,5779,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['safe'],['safe']
Safety,"s not need to have special knowledge of the; operand bundle to not miscompile programs containing it. - The bundle operands for an unknown operand bundle escape in unknown; ways before control is transferred to the callee or invokee.; - Calls and invokes with operand bundles have unknown read / write; effect on the heap on entry and exit (even if the call target specifies; a ``memory`` attribute), unless they're overridden with; callsite specific attributes.; - An operand bundle at a call site cannot change the implementation; of the called function. Inter-procedural optimizations work as; usual as long as they take into account the first two properties. More specific types of operand bundles are described below. .. _deopt_opbundles:. Deoptimization Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Deoptimization operand bundles are characterized by the ``""deopt""``; operand bundle tag. These operand bundles represent an alternate; ""safe"" continuation for the call site they're attached to, and can be; used by a suitable runtime to deoptimize the compiled frame at the; specified call site. There can be at most one ``""deopt""`` operand; bundle attached to a call site. Exact details of deoptimization is; out of scope for the language reference, but it usually involves; rewriting a compiled frame into a set of interpreted frames. From the compiler's perspective, deoptimization operand bundles make; the call sites they're attached to at least ``readonly``. They read; through all of their pointer typed operands (even if they're not; otherwise escaped) and the entire visible heap. Deoptimization; operand bundles do not capture their operands except during; deoptimization, in which case control will not be returned to the; compiled frame. The inliner knows how to inline through calls that have deoptimization; operand bundles. Just like inlining through a normal call site; involves composing the normal and exceptional continuations, inlining; through a call site with a deoptimi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:119116,safe,safe,119116,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"s of LLVM. .. code-block:: llvm. load i64* %p. becomes. .. code-block:: llvm. load i64, ptr %p. Address spaces are still used to distinguish between different kinds of pointers; where the distinction is relevant for lowering (e.g. data vs function pointers; have different sizes on some architectures). Opaque pointers are not changing; anything related to address spaces and lowering. For more information, see; `DataLayout <LangRef.html#langref-datalayout>`_. Opaque pointers in non-default; address space are spelled ``ptr addrspace(N)``. This was proposed all the way back in; `2015 <https://lists.llvm.org/pipermail/llvm-dev/2015-February/081822.html>`_. Issues with explicit pointee types; ==================================. LLVM IR pointers can be cast back and forth between pointers with different; pointee types. The pointee type does not necessarily represent the actual; underlying type in memory. In other words, the pointee type carries no real; semantics. Historically LLVM was some sort of type-safe subset of C. Having pointee types; provided an extra layer of checks to make sure that the Clang frontend matched; its frontend values/operations with the corresponding LLVM IR. However, as other; languages like C++ adopted LLVM, the community realized that pointee types were; more of a hindrance for LLVM development and that the extra type checking with; some frontends wasn't worth it. LLVM's type system was `originally designed; <https://llvm.org/pubs/2003-05-01-GCCSummit2003.html>`_ to support high-level; optimization. However, years of LLVM implementation experience have demonstrated; that the pointee type system design does not effectively support; optimization. Memory optimization algorithms, such as SROA, GVN, and AA,; generally need to look through LLVM's struct types and reason about the; underlying memory offsets. The community realized that pointee types hinder LLVM; development, rather than helping it. Some of the initially proposed high-level; optimization",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:1939,safe,safe,1939,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['safe'],['safe']
Safety,"s option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); handleFunctionDecl(D); handleFunctionDecl(D);; } else if (isa<VarDecl>(D)) { else if (isa<VarDecl>(D)); handleVarDecl(D); handleVarDecl(D);; }. if (isa<VarDecl>(D)) { vs. if (isa<VarDecl>(D)) {; for (auto *A : D.attrs()) { for (auto *A : D.attrs()); if (shouldProcessAttr(A)) { if (shouldProcessAttr(A)); handleAttr(A); handleAttr(A);; } }; }; }. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()) { for (auto *A : D.attrs()); handleAttr(A); handleAttr(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:102640,redund,redundant,102640,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['redund'],['redundant']
Safety,"s r2, ha16(.CPI_X_2); lfd f1, lo16(.CPI_X_2)(r2); lis r2, ha16(.CPI_X_3); lfd f2, lo16(.CPI_X_3)(r2); fmadd f1, f0, f1, f2; blr. It would be better to materialize .CPI_X into a register, then use immediates; off of the register to avoid the lis's. This is even more important in PIC ; mode. Note that this (and the static variable version) is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. Here's another example (the sgn function):; double testf(double a) {; return a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0);; }. it produces a BB like this:; LBB1_1: ; cond_true; lis r2, ha16(LCPI1_0); lfs f0, lo16(LCPI1_0)(r2); lis r2, ha16(LCPI1_1); lis r3, ha16(LCPI1_2); lfs f2, lo16(LCPI1_2)(r3); lfs f3, lo16(LCPI1_1)(r2); fsub f0, f0, f1; fsel f1, f0, f2, f3; blr . ===-------------------------------------------------------------------------===. PIC Code Gen IPO optimization:. Squish small scalar globals together into a single global struct, allowing the ; address of the struct to be CSE'd, avoiding PIC accesses (also reduces the size; of the GOT on targets with one). Note that this is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. ===-------------------------------------------------------------------------===. Fold add and sub with constant into non-extern, non-weak addresses so this:. static int a;; void bar(int b) { a = b; }; void foo(unsigned char *c) {; *c = a;; }. So that . _foo:; lis r2, ha16(_a); la r2, lo16(_a)(r2); lbz r2, 3(r2); stb r2, 0(r3); blr. Becomes. _foo:; lis r2, ha16(_a+3); lbz r2, lo16(_a+3)(r2); stb r2, 0(r3); blr. ===-------------------------------------------------------------------------===. We should compile these two functions to the same thing:. #include <stdlib.h>; void f(int a, int b, int *P) {; *P = (a-b)>=0?(a-b):(b-a);; }; void g(int a, int b, int *P) {; *P = abs(a-b);; }. Further, they should compile to something better than:. _g:; subf r2, r4, r3; subfic r3, r2, 0; cmpwi cr0, r2, -1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:2631,avoid,avoiding,2631,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,2,['avoid'],['avoiding']
Safety,"s source-language caller. '``llvm.swift.async.context.addr``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.swift.async.context.addr(). Overview:; """""""""""""""""". The '``llvm.swift.async.context.addr``' intrinsic returns a pointer to; the part of the extended frame record containing the asynchronous; context of a Swift execution. Semantics:; """""""""""""""""""". If the caller has a ``swiftasync`` parameter, that argument will initially; be stored at the returned address. If not, it will be initialized to null. '``llvm.localescape``' and '``llvm.localrecover``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.localescape(...); declare ptr @llvm.localrecover(ptr %func, ptr %fp, i32 %idx). Overview:; """""""""""""""""". The '``llvm.localescape``' intrinsic escapes offsets of a collection of static; allocas, and the '``llvm.localrecover``' intrinsic applies those offsets to a; live frame pointer to recover the address of the allocation. The offset is; computed during frame layout of the caller of ``llvm.localescape``. Arguments:; """""""""""""""""""". All arguments to '``llvm.localescape``' must be pointers to static allocas or; casts of static allocas. Each function can only call '``llvm.localescape``'; once, and it can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:513642,recover,recover,513642,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recover']
Safety,"s the library under test starts; its own threads. However, it is possible to run multiple libFuzzer processes in; parallel with a shared corpus directory; this has the advantage that any new; inputs found by one fuzzer process will be available to the other fuzzer; processes (unless you disable this with the ``-reload=0`` option). This is primarily controlled by the ``-jobs=N`` option, which indicates that; that `N` fuzzing jobs should be run to completion (i.e. until a bug is found or; time/iteration limits are reached). These jobs will be run across a set of; worker processes, by default using half of the available CPU cores; the count of; worker processes can be overridden by the ``-workers=N`` option. For example,; running with ``-jobs=30`` on a 12-core machine would run 6 workers by default,; with each worker averaging 5 bugs by completion of the entire process. Fork mode; ---------. **Experimental** mode ``-fork=N`` (where ``N`` is the number of parallel jobs); enables oom-, timeout-, and crash-resistant; fuzzing with separate processes (using ``fork-exec``, not just ``fork``). The top libFuzzer process will not do any fuzzing itself, but will; spawn up to ``N`` concurrent child processes providing them; small random subsets of the corpus. After a child exits, the top process; merges the corpus generated by the child back to the main corpus. Related flags:. ``-ignore_ooms``; True by default. If an OOM happens during fuzzing in one of the child processes,; the reproducer is saved on disk, and fuzzing continues.; ``-ignore_timeouts``; True by default, same as ``-ignore_ooms``, but for timeouts.; ``-ignore_crashes``; False by default, same as ``-ignore_ooms``, but for all other crashes. The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-fork=N``. Resuming merge; --------------. Merging large corpora may be time consuming, and it is often desirable to do it; on preemptable VMs, where the process may be killed at any time.; In order to seamless",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:7488,timeout,timeout,7488,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeout']
Safety,"s the unswizzled address; relative to the wave scratch base in the unswizzled private address space; of the lowest address stack allocated local variable. ``DW_AT_frame_base`` will be defined as the swizzled address in the; swizzled private address space by dividing the CFA by the wavefront size; (since CFA is always at least dword aligned which matches the scratch; swizzle element size). If no dynamic stack alignment was performed, the stack allocated arguments; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument passing is implemented by copying the input physical; registers to virtual registers on entry. The register allocator can spill if; necessary. These are copied back to physical registers at call sites. The; net effect is that each function call can have these values in entirely; distinct locations. The IPRA can help avoid shuffling argument registers.; 6. Call sites are implemented by setting up the arguments at positive offsets; from SP. Then SP is incremented to account for the known frame size before; the call and decremented after the call. .. note::. The CFI will reflect the changed calculation needed to compute the CFA; from SP. 7. 4 byte spill slots are used in the stack frame. One slot is allocated for an; emergency spill slot. Buffer instructions are used for stack accesses and; not the ``flat_scratch`` instruction. .. TODO::. Explain when the emergency spill slot is used. .. TODO::. Possible broken issues:. - Stack arguments must be aligned to required alignment.; - Stack is aligned to max(16, max formal argument alignment); - Direct argument < 64 bits should check register budget.; - Register budget calculation should respect ``inreg`` for SGPR.; - SGPR overflow is not handled.; - struct with 1 member unpeeling is not checking size of member.; - ``sret`` is after ``this`` pointer.; - Caller is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:399536,avoid,avoid,399536,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"s the writer to take a read lock. In other word, the lock is re-entrant for both reading and writing. The implementation tries to make faster the scenario when readers come and go but there is no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInterpreterMutex``` are deprecated and may be removed in future releases.; - Added ```TReadLockGuard```,```TWriteLockGuard```, ```R__READ_LOCKGUARD``` and```R__WRITE_LOCKGUARD``` to take advantage of the new lock. The legacy ```TLockGuard``` and ```R__LOCKGUARD``` use the write lock.; - Improved scaling of TROOT::RecursiveRemove in the case of large collection.; - Added a thread safe mode for the following ROOT collections: THashList, THashTable, TList and TObjArray. When ROOT's thread safe mode is enabled and the collection is set to use internal locks by calling:; ```; collection->UseRWLock();; ```; all operations on the collection will take the read or write lock when needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:5670,safe,safe,5670,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['safe'],['safe']
Safety,"s()` from causing an autoparse on an abstract base class. ## Histogram Libraries. * TH2Poly has a functional Merge method.; * Implemented the `TGraphAsymmErrors` constructor directly from an ASCII file. ## Math Libraries. * New template class `TRandomGen<Engine>` which derives from `TRandom` and integrate new random generator engines as TRandom classes.; * New TRandom specific types have been defined for these following generators:; * `TRandomMixMax` - recommended MIXMAX generator with N=240; * `TRandomMixMax17` - MIXMAX generator with smaller state (N=17) and faster seeding time; * `TRandomMixMax256` - old version of MIXMAX generator (N=256); * `TRandomMT64` - 64 bit Mersenenne Twister generator from the standard library (based on `std::mt19937_64`). This generates 64 bit random numbers, while `TRandom3` generates only 32 bit random numbers.; * `TRandomRanlux48` - 48 bit Ranlux generator. Note that `TRandom1` is a 24 bit generator. ; * Improve thread safety of `TMinuit` constructor [ROOT-8217]; * Vc has ben removed from the ROOT sources. If the option 'vc' is enabled, the package will be searched (by default),; alternatively the source tarfile can be downloded and build with the option 'builtin_vc'. ## TMVA Libraries. * New `DataLoader` class that allows flexibility in variable and dataset selection. ; * New Deep Neural Network. Three different versions are available, which can be selected with the 'Architecture' option. See also the tutorial`tmva/TMVAClassification.C` for using the new DNN.; * `Architecture=STANDARD` to select the earlier version.; * `Architecture=CPU` to select the newer version for CPU, but designed also for GPU and optimized for speed and with multi-class support. ; * `Architecture=GPU` to select the newer GPU version. Requires configuration of ROOT with CUDA or OpenCL enabled. ; * Support for Cross Validation (see tutorial `tmva/TMVACrossValidation` as an example).; * Support for Hyper-Parameter tuning for BDT and SVM methods.; * New Variable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:12248,safe,safety,12248,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['safe'],['safety']
Safety,"s, by default using half of the available CPU cores; the count of; worker processes can be overridden by the ``-workers=N`` option. For example,; running with ``-jobs=30`` on a 12-core machine would run 6 workers by default,; with each worker averaging 5 bugs by completion of the entire process. Fork mode; ---------. **Experimental** mode ``-fork=N`` (where ``N`` is the number of parallel jobs); enables oom-, timeout-, and crash-resistant; fuzzing with separate processes (using ``fork-exec``, not just ``fork``). The top libFuzzer process will not do any fuzzing itself, but will; spawn up to ``N`` concurrent child processes providing them; small random subsets of the corpus. After a child exits, the top process; merges the corpus generated by the child back to the main corpus. Related flags:. ``-ignore_ooms``; True by default. If an OOM happens during fuzzing in one of the child processes,; the reproducer is saved on disk, and fuzzing continues.; ``-ignore_timeouts``; True by default, same as ``-ignore_ooms``, but for timeouts.; ``-ignore_crashes``; False by default, same as ``-ignore_ooms``, but for all other crashes. The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-fork=N``. Resuming merge; --------------. Merging large corpora may be time consuming, and it is often desirable to do it; on preemptable VMs, where the process may be killed at any time.; In order to seamlessly resume the merge, use the ``-merge_control_file`` flag; and use ``killall -SIGUSR1 /path/to/fuzzer/binary`` to stop the merge gracefully. Example:. .. code-block:: console. % rm -f SomeLocalPath; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-INNER: using the control file 'SomeLocalPath'; ...; # While this is running, do `killall -SIGUSR1 my_fuzzer` in another console; ==9015== INFO: libFuzzer: exiting as requested. # This will leave the file SomeLocalPath with the partial state of the merge.; # Now, you can continue the merge by execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:8108,timeout,timeouts,8108,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeouts']
Safety,"s, extend tooltip.htm example; 3. Implement workaround for standard THREE.SVGRenderer - no need for patched version; 4. When producing 3D graphical images in batch, use normal THREE.CanvasRenderer; 5. Use WebGL renderer in Chrome headless mode for 3D images generation; 6. Provide possibility to create SVG files for canvas or frame (#172); 7. Support text drawing with TH1 bar option; 8. Fix - when drawing text, reserve extra y range to show it correctly; 9. Migrate to Node.js 8, do not support older versions. ## Changes in 5.5.2; 1. Fix - draw TH2Poly bins outline when no content specified; 2. Fix - always set axis interactive handlers (#170); 3. Fix - take into account zaxis properties when drawing color palette (#171). ## Changes in 5.5.1; 1. Fix - adjust v7 part to new class naming convention, started with R; 2. Fix - show RCanvas title; 3. New - implement 'nocache' option for JSROOT scripts loading. When specified in URL with; JSRootCore.js script, tries to avoid scripts caching problem by adding stamp parameter to all URLs; 4. New - provide simple drawing for TObjString (#164). ## Changes in 5.5.0; 1. Introduce JSROOT.StoreJSON() function. It creates JSON code for the; TCanvas with all drawn objects inside. Allows to store current canvas state; 2. Support ""item=img:file.png"" parameter to insert images in existing layout (#151); 3. Support TTree drawing into TGraph (#153), thanks @cozzyd; 4. Let configure ""&toolbar=right"" in URL to change position of tool buttons; 5. Let configure ""&divsize=500x400"" in URL of size of main div element (default - full browser); 6. Implement ""optstat1001"" and ""optfit101"" draw options for histograms; 7. Remove ""autocol"" options - standard ""plc"" should be used instead; 8. Provide drawing of artificial ""$legend"" item - it creates TLegend for all primitives in pad; Can be used when several histograms or several graphs superimposed; 9. Let configure ""&toolbar=vert"" in URL to change orientation of tool buttons; 10. Improve markers and erro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:33318,avoid,avoid,33318,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['avoid'],['avoid']
Safety,"s, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it is necessary that we explain the situation with; // this surprisingly long comment, so it would be unclear without the braces; // whether the following statement is in the scope of the `if`.; handleOtherDecl(D);; }. // This should also omit braces. The `for` loop contains only a single; // statement, so it shouldn't have braces. The `if` also only contains a; // single simple statement (the `for` loop), so it also should omit braces.; if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()); handleAttr(A);. // Use braces for a `do-while` loop and its enclosing statement.; if (Tok->is(tok::l_brace)) {; do {; Tok = Tok->Next;; } while (Tok);; }. // Use braces for the outer `if` since the nested `for` is braced.; if (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:63545,avoid,avoid,63545,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"s, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C`'; and `C`\"", having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation comes from the fact that any container is directly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D`, `E`, and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class TGeoVolumeAssembly, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ""unnecessary"" volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:31946,avoid,avoid,31946,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"s. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74842,avoid,avoiding,74842,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoiding']
Safety,"s:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132151,avoid,avoid,132151,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"s://llvm.org/doxygen/Statistic_8h_source.html>`_ class is; designed to be an easy way to expose various success metrics from passes.; These statistics are printed at the end of a run, when the :option:`-stats`; command line option is enabled on the command line. See the :ref:`Statistics; section <Statistic>` in the Programmer's Manual for details. .. _writing-an-llvm-pass-passmanager:. What PassManager does; ---------------------. The `PassManager <https://llvm.org/doxygen/PassManager_8h_source.html>`_ `class; <https://llvm.org/doxygen/classllvm_1_1PassManager.html>`_ takes a list of; passes, ensures their :ref:`prerequisites <writing-an-llvm-pass-interaction>`; are set up correctly, and then schedules passes to run efficiently. All of the; LLVM tools that run passes use the PassManager for execution of these passes. The PassManager does two main things to try to reduce the execution time of a; series of passes:. #. **Share analysis results.** The ``PassManager`` attempts to avoid; recomputing analysis results as much as possible. This means keeping track; of which analyses are available already, which analyses get invalidated, and; which analyses are needed to be run for a pass. An important part of work; is that the ``PassManager`` tracks the exact lifetime of all analysis; results, allowing it to :ref:`free memory; <writing-an-llvm-pass-releaseMemory>` allocated to holding analysis results; as soon as they are no longer needed. #. **Pipeline the execution of passes on the program.** The ``PassManager``; attempts to get better cache and memory usage behavior out of a series of; passes by pipelining the passes together. This means that, given a series; of consecutive :ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>`, it; will execute all of the :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>` on the first function, then all of the; :ref:`FunctionPasses <writing-an-llvm-pass-FunctionPass>` on the second; function, etc... until the entire program has bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:41258,avoid,avoid,41258,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['avoid'],['avoid']
Safety,"s; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has proper include protectors.; * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware; dictionary when it is invoked with `-cxxmodule` flag.; * Modularization of external dependencies -- if a header file is not explicitly; nominated as part of a module and it is transitively included in two modules,; both modules contain that header file content. In other words, the header is; duplicated. In turn, this leads to performance regressions. If a dictionary; depends on a header (directly or indirectly) from a external library (e.g.; libxml) it needs to be modularized. As part of our ongoing efforts to move; CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The; tool detects (based on the include paths of the compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] import Foo.*;; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. The implementation avoids recursive actions and relies on a well-defined (by; the C++ standard) behavior. Currently, this comes with a constant performance; overhead which we go in details bellow. ROOT uses the global module index (GMI) to av",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:15618,detect,detects,15618,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['detect'],['detects']
Safety,"s; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries. ## Database Libraries; - Fix issue related to time stamps manipulation done by `TPgSQLStatement` as suggested [here](https://root-forum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already on; - Decompress `TTreeCache` in parallel if IMT is on (upgrade of the `TTreeCacheUnzip` class).; - In `TTreeProcessorMT` delete friend chains after the main chain to avoid double deletes.; - If IMT is enabled, the multithreaded execution of the fit respects the number of threads IMT has been initialized with. ## Language Bindings. ### Notebook integration; - In the ROOT kernel, avoid import of unnecessary components.; - In the ROOT kernel, optimise regexes involved in tab-completion which could take up to minutes to be executed. ## JavaScript ROOT; ; Upgrade JSROOT to v5.4.1. Following new features implemented:. * New supported classes:; - TDiamond; - TArc; - TCurlyLine; - TCurlyArc; - TCrown; * New draw options:; - ""RX"" and ""RY"" for TGraph to reverse axis; - ""noopt"" for TGraph to disable drawing optimization; - ""CPN"" for TCanvas to create color palette from N last colors; - ""line"" for TGraph2D; * New features:; - support LZ4 compression; - tooltips and zooming in TGraphPolar drawings; - TPavesText with multiple underlying paves; - implement all fill styles; - draw borders for TWbox; - draw all objects from TList/TObjArray ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:15080,avoid,avoid,15080,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"s; -----------------------------------------------. The ``ScalarEvolution`` analysis can be used to analyze and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -----------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11385,safe,safety,11385,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['safe'],['safety']
Safety,"s; intrinsic is necessary because the `` llvm.va_start`` intrinsic may be; arbitrarily complex and require, for example, memory allocation. Accurate Garbage Collection Intrinsics; --------------------------------------. LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_; (GC) requires the frontend to generate code containing appropriate intrinsic; calls and select an appropriate GC strategy which knows how to lower these; intrinsics in a manner which is appropriate for the target collector. These intrinsics allow identification of :ref:`GC roots on the; stack <int_gcroot>`, as well as garbage collector implementations that; require :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers.; Frontends for type-safe garbage collected languages should generate; these intrinsics to make use of the LLVM garbage collectors. For more; details, see `Garbage Collection with LLVM <GarbageCollection.html>`_. LLVM provides an second experimental set of intrinsics for describing garbage; collection safepoints in compiled code. These intrinsics are an alternative; to the ``llvm.gcroot`` intrinsics, but are compatible with the ones for; :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. The; differences in approach are covered in the `Garbage Collection with LLVM; <GarbageCollection.html>`_ documentation. The intrinsics themselves are; described in :doc:`Statepoints`. .. _int_gcroot:. '``llvm.gcroot``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.gcroot(ptr %ptrloc, ptr %metadata). Overview:; """""""""""""""""". The '``llvm.gcroot``' intrinsic declares the existence of a GC root to; the code generator, and allows some metadata to be associated with it. Arguments:; """""""""""""""""""". The first argument specifies the address of a stack object that contains; the root pointer. The second pointer (which must be either a constant or; a global value address) contains the meta-data to be associated with the; root. Semantics:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:496338,safe,safepoints,496338,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safepoints']
Safety,"s; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:123311,safe,safe,123311,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"s; the theoretical uniform distribution of resource pressure for every; instruction in sequence. .. option:: -bottleneck-analysis. Print information about bottlenecks that affect the throughput. This analysis; can be expensive, and it is disabled by default. Bottlenecks are highlighted; in the summary view. Bottleneck analysis is currently not supported for; processors with an in-order backend. .. option:: -json. Print the requested views in valid JSON format. The instructions and the; processor resources are printed as members of special top level JSON objects.; The individual views refer to them by index. However, not all views are; currently supported. For example, the report from the bottleneck analysis is; not printed out in JSON. All the default views are currently supported. .. option:: -disable-cb. Force usage of the generic CustomBehaviour and InstrPostProcess classes rather; than using the target specific implementation. The generic classes never; detect any custom hazards or make any post processing modifications to; instructions. .. option:: -disable-im. Force usage of the generic InstrumentManager rather than using the target; specific implementation. The generic class creates Instruments that provide; no extra information, and InstrumentManager never overrides the default; schedule class for a given instruction. EXIT STATUS; -----------. :program:`llvm-mca` returns 0 on success. Otherwise, an error message is printed; to standard error, and the tool returns 1. USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS; ---------------------------------------------; :program:`llvm-mca` allows for the optional usage of special code comments to; mark regions of the assembly code to be analyzed. A comment starting with; substring ``LLVM-MCA-BEGIN`` marks the beginning of an analysis region. A; comment starting with substring ``LLVM-MCA-END`` marks the end of a region.; For example:. .. code-block:: none. # LLVM-MCA-BEGIN; ...; # LLVM-MCA-END. If no user-defined region i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:7556,detect,detect,7556,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,2,"['detect', 'hazard']","['detect', 'hazards']"
Safety,"s`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6814,avoid,avoid,6814,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['avoid'],['avoid']
Safety,"safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ~~~{.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ~~~. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:80220,safe,safety,80220,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59217,unsafe,unsafe-math-optimizations,59217,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe-math-optimizations']
Safety,"scripts/asan_symbolize.py / < log | c++filt; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:5786,detect,detect,5786,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detect']
Safety,"se it runs over 38 passes. Next, ``bugpoint`` tries removing functions from the test program, to reduce its; size. Usually it is able to reduce a test program to a single function, when; debugging intraprocedural optimizations. Once the number of functions has been; reduced, it attempts to delete various edges in the control flow graph, to; reduce the size of the function as much as possible. Finally, ``bugpoint``; deletes any individual LLVM instructions whose absence does not eliminate the; failure. At the end, ``bugpoint`` should tell you what passes crash, give you a; bitcode file, and give you instructions on how to reproduce the failure with; ``opt`` or ``llc``. .. _code generator debugger:. Code generator debugger; -----------------------. The code generator debugger attempts to narrow down the amount of code that is; being miscompiled by the selected code generator. To do this, it takes the test; program and partitions it into two pieces: one piece which it compiles with the; ""safe"" backend (into a shared object), and one piece which it runs with either; the JIT or the static LLC compiler. It uses several techniques to reduce the; amount of code pushed through the LLVM code generator, to reduce the potential; scope of the problem. After it is finished, it emits two bitcode files (called; ""test"" [to be compiled with the code generator] and ""safe"" [to be compiled with; the ""safe"" backend], respectively), and instructions for reproducing the; problem. The code generator debugger assumes that the ""safe"" backend produces; good code. .. _miscompilation debugger:. Miscompilation debugger; -----------------------. The miscompilation debugger works similarly to the code generator debugger. It; works by splitting the test program into two pieces, running the optimizations; specified on one piece, linking the two pieces back together, and then executing; the result. It attempts to narrow down the list of passes to the one (or few); which are causing the miscompilation,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:4405,safe,safe,4405,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['safe'],['safe']
Safety,"se, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is Defined. pi = new int; // pi is Conflicting; Borrow(pi);; delete pi;; // pi is Conflicting; }; ```. We could still handle this case by finding a maximal range in the code where; `pi` could be in the Compatible state, and only refactoring that part. ```c++; void ConflictingOwnership() {; int *pi;; pi = GetPtr();; Borrow(pi);. std::unique_ptr<int> pi_unique = std::make_unique<int>();; Borrow(pi_unique.get());; }; ```. ## Example: finding redundant branch conditions. In the code below `b1` should not be checked in both the outer and inner ""if""; statements. It is likely there is a bug in this code. ```c++; int F(bool b1, bool b2) {; if (b1) {; f();; if (b1 && b2) { // Check `b1` again -- unnecessary!; g();; }; }; }; ```. A checker that finds this pattern syntactically is already implemented in; ClangTidy using AST matchers (`bugprone-redundant-branch-condition`). To implement it using the data flow analysis framework, we can produce a warning; if any part of the branch condition is implied by the flow condition. ```c++; int F(bool b1, bool b2) {; // Flow condition: true.; if (b1) {; // Flow condition: b1.; f();; if (b1 && b2) { // `b1` is implied by the flow condition.; g();; }; }; }; ```. One way to check this implication is to use a SAT solver. Without a SAT solver,; we could keep the flow condition in the CNF form and then it would be easy to; check the implication. ## Example: finding unchecked `std::optional` unwraps. Calling `optional::value()` is only valid if `optional::has_value()` is true. We; want to show that when `x.value()` is executed, the flow condition implies; `x.has_value()`. In the example below `x.value()` is accessed safely because it is guarded by the; `x.has_value()` check. ```c++; void Example(std::optional<int> &x) {; if (x.has_value()) {; use(x.v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:26227,redund,redundant-branch-condition,26227,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['redund'],['redundant-branch-condition']
Safety,"sed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:7284,predict,predictable,7284,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['predict'],['predictable']
Safety,"sed the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`, where the; parameter `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAbsRealLValue::inRange(double value, const char* rangeName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEpsRel(epsRel)` and `RooNumber::setRangeEpsAbs(epsAbs)`. ## TMVA. ### SOFIE : Code generation for fast inference of Deep Learning models. A large number of new features have been added in the TMVA SOFIE library. The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. The interface of `RModel::Generate` has been changed to; ```; RModel::Generate(Options options = Options::kDefault, int batchsize = 1)`; ```; where `Options` is a new enumeration having 3 different values:; - `kDefault = 0x0` : default case, a session class is generated and the weights are stored in a separate `.dat` file (in text format).; - `kNoSession = 0x1` : no session class is generated and the internal intermediate tensors are declared in the global namespace `TMVA_SOFIE_$ModelName`.; - `kNoWeightFile = 0x2` the weight values are not written in a separate `.dat` file, but they a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:26124,avoid,avoid,26124,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoid']
Safety,"selective definition of env and rootrc; variables. Different values can be set for different users, groups, SVN; versions or ROOT versions.; Improve the diagnostic in case of exceptions. Information; about the event and file being processed at the moment the exception; was raised is sent to the client, e.g.;    0.5: caught exception triggered by signal '1' while; processing dset:'EventTree',; file:'http://root.cern.ch/files/data/event_3.root', event:1 - check; logs for possible stacktrace; The patch also fixes a problem with submergers observed when a worker; was stopped because above the memory limits: this worker was; established as merger but could not do the work, for obvious reasons,; freezing the session.; Add two new methods to TProof: ShowMissingFiles() to facilitate; the display of the list of missing files; and GetMissingFiles() to get; a TFileCollection (dataset) with the missing files for further; processing. Fixes. Fix a bug in error status transmission which avoid; session freezing in some cases; FIx; a few issues in libXrdProofd.so with handling of connection used for; admin operation: this should solve some cases where the daemon was not; responding. ; Fix a few memory leaks showing up when; running several queries in the same session; Fix a few issues affecting the new sub-merging option; Fix an issue preventing proper real-time notification; during VerifyDataSet; Fix an issue with TQueryResult ordering (was causing; random 'stressProof' failures); Fix; an issue with TProof::AskStatistics (fBytesRead, fRealTime and fCpuTime; were not correctly filled on the client; the values on the master,; displayed by TProof::Print were correct).; Fix several small issues affecting the handling of global; package directories; Fix an issue with socket handling in the main event-loop; while sendign or receiving files via TProofMgr.; Fix; a problem counting valid nodes in sequential or 'masteronly' mode,; generating the fake error message ""GoParallel: attaching to ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:9514,avoid,avoid,9514,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['avoid'],['avoid']
Safety,"sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual machine, we have much more room; for value add. The nice safe ""sandbox"" VM can be provided as a layer; on top of it. It also lets us focus on the more interesting compilers; related projects. > 2. Design issues to consider (an initial list that we should continue; > to modify). Note that I'm not trying to suggest actual solutions here,; > but just various directions we can pursue:. Understood. :). > a. A sing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:1663,safe,safe,1663,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['safe'],['safe']
Safety,"sertions are compiled out. Today, we have something much better: ``llvm_unreachable``:. .. code-block:: c++. llvm_unreachable(""Invalid radix for integer literal"");. When assertions are enabled, this will print the message if it's ever reached; and then exit the program. When assertions are disabled (i.e. in release; builds), ``llvm_unreachable`` becomes a hint to compilers to skip generating; code for this branch. If the compiler does not support this, it will fall back; to the ""abort"" implementation. Use ``llvm_unreachable`` to mark a specific point in code that should never be; reached. This is especially desirable for addressing warnings about unreachable; branches, etc., but can be used whenever reaching a particular code path is; unconditionally a bug (not originating from user input; see below) of some kind.; Use of ``assert`` should always include a testable predicate (as opposed to; ``assert(false)``). If the error condition can be triggered by user input then the; recoverable error mechanism described in :doc:`ProgrammersManual` should be; used instead. In cases where this is not practical, ``report_fatal_error`` may; be used. Another issue is that values used only by assertions will produce an ""unused; value"" warning when assertions are disabled. For example, this code will warn:. .. code-block:: c++. unsigned Size = V.size();; assert(Size > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value);; assert(NewToSet && ""The value shouldn't be in the set yet"");. These are two interesting different cases. In the first case, the call to; ``V.size()`` is only useful for the assert, and we don't want it executed when; assertions are disabled. Code like this should move the call into the assert; itself. In the second case, the side effects of the call must happen whether; the assert is enabled or not. In this case, the value should be cast to void to; disable the warning. To be specific, it is preferred to write the code like; this:. .. code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:47551,recover,recoverable,47551,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['recover'],['recoverable']
Safety,"served.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT TMVA tests.; # @author Kim Albertsson; ############################################################################. # Tests using google test; ROOT_ADD_GTEST(TestRandomGenerator; TestRandomGenerator.cxx; LIBRARIES TMVA); ROOT_ADD_GTEST(TestOptimizeConfigParameters; TestOptimizeConfigParameters.cxx; LIBRARIES TMVA). if(dataframe); # RTensor; ROOT_ADD_GTEST(rtensor rtensor.cxx LIBRARIES ROOTVecOps TMVA); ROOT_ADD_GTEST(rtensor-iterator rtensor_iterator.cxx LIBRARIES ROOTVecOps TMVA); ROOT_ADD_GTEST(rtensor-utils rtensor_utils.cxx LIBRARIES ROOTVecOps TMVA ROOTDataFrame); # RStandardScaler; ROOT_ADD_GTEST(rstandardscaler rstandardscaler.cxx LIBRARIES ROOTVecOps TMVA ROOTDataFrame); # RReader; ROOT_ADD_GTEST(rreader rreader.cxx LIBRARIES ROOTVecOps TMVA ROOTDataFrame); # Tree inference system and user interface; # Commented out right now because RBDT doesn't provide low-level interfaces; # since the sync with FastForest. Only the construction from XGBoost models; # is supported. If this feature becomes necessary to implement, one can; # resurrect these tests.; # ROOT_ADD_GTEST(branchlessForest branchlessForest.cxx LIBRARIES TMVA); # ROOT_ADD_GTEST(rbdt rbdt.cxx LIBRARIES ROOTVecOps TMVAUtils); endif(). if(dataframe); find_python_module(xgboost QUIET); if (PY_XGBOOST_FOUND); ROOT_ADD_PYUNITTEST(rbdt_xgboost rbdt_xgboost.py); endif(); endif(). #--stressTMVA--------------------------------------------------------------------------------------. ROOT_EXECUTABLE(stressTMVA stressTMVA.cxx LIBRARIES TMVA). if(tmva-gpu); target_compile_definitions(stressTMVA PRIVATE DNNCUDA); endif(). if(tmva-cpu); target_compile_definitions(stressTMVA PRIVATE DNNCPU); endif(). ROOT_ADD_TEST(test-stresstmva COMMAND stressTMVA -b LABELS longtest TIMEOUT 1800); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/CMakeLists.txt:2059,TIMEOUT,TIMEOUT,2059,tmva/tmva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/CMakeLists.txt,1,['TIMEOUT'],['TIMEOUT']
Safety,"set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can use the following suppression mechanism; to unblock yourself and continue on with the testing. This supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6566,detect,detection,6566,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"set(LLVM_LINK_COMPONENTS; Support; TargetParser; ). set(BUILDVARIABLES_SRCPATH ${CMAKE_CURRENT_SOURCE_DIR}/BuildVariables.inc.in); set(BUILDVARIABLES_OBJPATH ${CMAKE_CURRENT_BINARY_DIR}/BuildVariables.inc). # Add the llvm-config tool.; add_llvm_tool(llvm-config; llvm-config.cpp; # This utility doesn't use much of LLVM, so linking a shared library for the; # entire thing is overkill. Avoiding that especially saves on build time when cross; # compiling LLVM and building both cross and native `llvm-config`s. We don't; # want to build an entire native libLLVM.so in addition to the cross one just; # for the native `llvm-config`!; DISABLE_LLVM_LINK_LLVM_DYLIB; ). # Compute the substitution values for various items.; get_property(SUPPORT_SYSTEM_LIBS TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS); get_property(WINDOWSMANIFEST_SYSTEM_LIBS TARGET LLVMWindowsManifest PROPERTY LLVM_SYSTEM_LIBS). foreach(l ${SUPPORT_SYSTEM_LIBS} ${WINDOWSMANIFEST_SYSTEM_LIBS}); if(MSVC); if(IS_ABSOLUTE ${l}); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}.lib""); endif(); else(); if (l MATCHES ""^-""); # If it's an option, pass it without changes.; set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); # Otherwise assume it's a library name we need to link with.; if(IS_ABSOLUTE ${l}); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""-l${l}""); endif(); endif(); endif(); endforeach(). string(REPLACE "";"" "" "" SYSTEM_LIBS ""${SYSTEM_LIBS}""). # Fetch target specific compile options, e.g. RTTI option; get_property(COMPILE_FLAGS TARGET llvm-config PROPERTY COMPILE_FLAGS). # NOTE: We don't want to start extracting any random C/CXX flags that the; # user may add that could affect the ABI. We only want to extract flags; # that have been added by the LLVM build system.; string(REGEX MATCH ""-stdlib=[^ ]+"" LLVM_CXX_STDLIB_FLAG ${CMAKE_CXX_FLAGS}); string(REGEX MATCH ""-std=[^ ]+"" LLVM_C_STD_FLAG ${CMAKE_C_FLAGS}). # Use configure_file to create BuildVaria",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt:386,Avoid,Avoiding,386,interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,1,['Avoid'],['Avoiding']
Safety,"sformation options are specific to each transformation. In the; following, we present the model for each LLVM loop optimization pass and; the metadata to influence them. Loop Vectorization and Interleaving; -----------------------------------. Loop vectorization and interleaving is interpreted as a single; transformation. It is interpreted as forced if; ``!{""llvm.loop.vectorize.enable"", i1 true}`` is set. Assuming the pre-vectorization loop is. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; Stmt(i);. then the code after vectorization will be approximately (assuming an; SIMD width of 4):. .. code-block:: c. int i = 0;; if (rtc) {; for (; i + 3 < n; i+=4) // vectorized/interleaved loop; Stmt(i:i+3);; }; for (; i < n; i+=1) // epilogue loop; Stmt(i);. where ``rtc`` is a generated runtime check. ``llvm.loop.vectorize.followup_vectorized`` will set the attributes for; the vectorized loop. If not specified, ``llvm.loop.isvectorized`` is; combined with the original loop's attributes to avoid it being; vectorized multiple times. ``llvm.loop.vectorize.followup_epilogue`` will set the attributes for; the remainder loop. If not specified, it will have the original loop's; attributes combined with ``llvm.loop.isvectorized`` and; ``llvm.loop.unroll.runtime.disable`` (unless the original loop already; has unroll metadata). The attributes specified by ``llvm.loop.vectorize.followup_all`` are; added to both loops. When using a follow-up attribute, it replaces any automatically deduced; attributes for the generated loop in question. Therefore it is; recommended to add ``llvm.loop.isvectorized`` to; ``llvm.loop.vectorize.followup_all`` which avoids that the loop; vectorizer tries to optimize the loops again. Loop Unrolling; --------------. Unrolling is interpreted as forced any ``!{!""llvm.loop.unroll.enable""}``; metadata or option (``llvm.loop.unroll.count``, ``llvm.loop.unroll.full``); is present. Unrolling can be full unrolling, partial unrolling of a loop; with c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:6379,avoid,avoid,6379,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and sha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:55951,detect,detector,55951,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ~~~ {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ~~~. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. \defgroup Tubes Tubes; \ingroup Shapes_classes; Tubes have Z as their symmetry axis. \defgroup Cones Cones; \ingroup Shapes_classes; Conical tube classes. \defgroup Trapezoids Trapezoids; \ingroup Shapes_classes; In general, we will c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:9721,detect,detector,9721,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['detect'],['detector']
Safety,"should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for eac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:532734,detect,detect,532734,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detect']
Safety,"sic unit system based; on millimeters, nanoseconds and MegaElectronVolts was better suited for the LHC; experiments. All LHC experiments use Geant4 and effectively adopted this; convention for all areas of data processing: simulation, reconstruction and; data analysis. Hence experiments using the %ROOT geometry toolkit to describe; the geometry had two different system of units in the application code. To allow users having the same system of units in the geometry description and the; application it is now possible to choose the system of units at startup of the; application:. ``` {.cpp}; TGeoManager::SetDefaultUnits(xx); xx = kG4Units, kRootUnits; ```. To ensure backwards compatibility %ROOT's default system of units is - as it was before -; based on centimeters, seconds and GigaElectronVolts, ie. the defaults are equivalent to:. ``` {.cpp}; TGeoManager::SetDefaultUnits(kRootUnits);; ```. To avoid confusion between materials described in %ROOT units and materials described; in Geant4 units, this switch should by all means be set once, before any element or; material is constructed. If for whatever reason it is necessary to change the; system of units later, this is feasible disabling the otherwise fatal exception:. ``` {.cpp}; TGeoManager::LockDefaultUnits(kFALSE);; ```. followed later by a corresponding call to again lock the system of units:. ``` {.cpp}; TGeoManager::LockDefaultUnits(kTRUE);; ```. \anchor GP01; ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:16518,avoid,avoid,16518,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"sics should be placed to represent the original variable; locations in this code? Unfortunately the second, third and fourth; dbg.values for ``!1`` in the source function have had their operands; (%tval, %fval, %merge) optimized out. Assuming we cannot recover them, we; might consider this placement of dbg.values:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. However, this will cause ``!3`` to have the return value of ``@gazonk()`` at; the same time as ``!1`` has the constant value zero -- a pair of assignments; that never occurred in the unoptimized program. To avoid this, we must terminate; the range that ``!1`` has the constant value assignment by inserting a poison; dbg.value before the dbg.value for ``!3``:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 poison, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. There are a few other dbg.value configurations that mean it terminates; dominating location definitions without adding a new location. The complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:22104,avoid,avoid,22104,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"side ``BLOCKINFO`` blocks, but; unlike their occurrence in normal blocks, the abbreviation is defined for blocks; matching the block ID we are describing, *not* the ``BLOCKINFO`` block; itself. The abbreviations defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:17909,safe,safe,17909,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['safe'],['safe']
Safety,"signed int's are particularly common), but in this case, all; that will be added is an additional 'cast' instruction. I removed that; from the spec. > I agree with your comment that we don't need 'neg'. Removed. > There's a trade-off with the cast instruction:; > + it avoids having to define all the upcasts and downcasts that are; > valid for the operands of each instruction (you probably have; > thought of other benefits also); > - it could make the bytecode significantly larger because there could; > be a lot of cast operations. + You NEED casts to represent things like:; void foo(float);; ...; int x;; ...; foo(x);; in a language like C. Even in a Java like language, you need upcasts; and some way to implement dynamic downcasts.; + Not all forms of instructions take every type (for example you can't; shift by a floating point number of bits), thus SOME programs will need; implicit casts. To be efficient and to avoid your '-' point above, we just have to be; careful to specify that the instructions shall operate on all common; types, therefore casting should be relatively uncommon. For example all; of the arithmetic operations work on almost all data types. > Making the second arg. to 'shl' a ubyte seems good enough to me.; > 255 positions seems adequate for several generations of machines. Okay, that comment is removed. > and is more compact than uint. No, it isn't. Remember that the bytecode encoding saves value slots into; the bytecode instructions themselves, not constant values. This is; another case where we may introduce more cast instructions (but we will; also reduce the number of opcode variants that must be supported by a; virtual machine). Because most shifts are by constant values, I don't; think that we'll have to cast many shifts. :). > I still have some major concerns about including malloc and free in the; > language (either as builtin functions or instructions). Agreed. How about this proposal:. malloc/free are either built in functions or actual o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:3068,avoid,avoid,3068,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['avoid'],['avoid']
Safety,"signment in C++.; Incorrect usage of MPI APIs in C and C++. This check can be enabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing from NSLocalizedString macros.; These can be enabled by passing the following command to scan-build:.   -enable-checker alpha.osx.cocoa.NonLocalizedStringChecker,alpha.osx.cocoa.EmptyLocalizationContextChecker. New checks for _Nonnull type qualifiers. These can be enabled with:.   -enable-checker nullability.NullPassedToNonnull,nullability.NullReturnedFromNonnull; New checks for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1533,detect,detect,1533,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,2,['detect'],['detect']
Safety,"sing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20596,safe,safety,20596,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"sing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3517,recover,recovered,3517,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['recover'],['recovered']
Safety,"sion being browsed.; A set of scripts for quick interaction with a dataset; manager via PROOF are available under $ROOTSYS/etc/proof/utils/pq2 .; The scripts are prefixed; pq2 (proof; quick query - or; proof-dq2); and allow to {browse, register, remove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5665,redund,redundant,5665,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['redund'],['redundant']
Safety,"sion of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpret roundoff noise as; significant and will usually either fail to find a minimum, or give; incorrect values for the parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26431,safe,safety,26431,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['safe'],['safety']
Safety,"size""`` attribute is inlined into; a function with another ``""stack-probe-size""`` attribute, the resulting; function has the ``""stack-probe-size""`` attribute that has the lower; numeric value. If a function that has a ``""stack-probe-size""`` attribute is; inlined into a function that has no ``""stack-probe-size""`` attribute; at all, the resulting function has the ``""stack-probe-size""`` attribute; of the callee.; ``""no-stack-arg-probe""``; This attribute disables ABI-required stack probes, if any.; ``returns_twice``; This attribute indicates that this function can return twice. The C; ``setjmp`` is an example of such a function. The compiler disables; some optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100111,safe,safestack,100111,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,3,['safe'],['safestack']
Safety,"sm that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4812,safe,safe,4812,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,['safe'],['safe']
Safety,"software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is incomplete and only catches a small and limited; subset of attackable patterns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear to be an adequate systematic mitigation. ## Performance Overhead. The performance overhead of this style of comprehensive mitigation is very; high. However, it compares very favorably with previously recommended; approaches such as the `lfence` instruction. Just as users can restrict the; scope of `lfence` to control its performance impact, this mitigation technique; could be restricted in scope as well. However, it is important to understand what",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45918,risk,risk,45918,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['risk'],['risk']
Safety,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1726,detect,detect,1726,interpreter/cling/www/contribute.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html,8,"['detect', 'recover']","['detect', 'recovery']"
Safety,"specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes describing; 2 and 3 component direction and magnitude vectors, not rooted at any; particular point;. - `ROOT::Math::`**`PositionVector2D`** and; `ROOT::Math::`**`PositionVector3D`** template classes modeling the; points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them,; `ROOT::Math::`**`LorentzVector`**, since we have recognized a limited; need for modeling the functionality of a 4D po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:69337,avoid,avoid,69337,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75779,avoid,avoid,75779,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['avoid'],['avoid']
Safety,"ss. #. Be wary of ordered and atomic memory operations. They are hard to optimize; and may not be well optimized by the current optimizer. Depending on your; source language, you may consider using fences instead. #. If calling a function which is known to throw an exception (unwind), use; an invoke with a normal destination which contains an unreachable; instruction. This form conveys to the optimizer that the call returns; abnormally. For an invoke which neither returns normally or requires unwind; code in the current function, you can use a noreturn call instruction if; desired. This is generally not required because the optimizer will convert; an invoke with an unreachable unwind destination to a call instruction. #. Use profile metadata to indicate statically known cold paths, even if; dynamic profiling information is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:7269,avoid,avoid,7269,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['avoid'],['avoid']
Safety,"ss; through transient states that violate the ""Should"" guidelines above, or would; otherwise make them unsuitable for direct inclusion in the monorepo (e.g.; dependencies that have not yet been factored appropriately, leveraging; experimental components or APIs that are not yet upstream, etc). When approved, the llvm-admin group can grant the new project:; * A new repository in the LLVM Github Organization - but not the LLVM monorepo.; * New mailing list, discourse forum, and/or discord chat hosted with other LLVM; forums.; * Other infrastructure integration can be discussed on a case-by-case basis. Graduation to the mono-repo would follow existing processes and standards for; becoming a first-class part of the monorepo. Similarly, an incubating project; may be eventually retired, but no process has been established for that yet. If; and when this comes up, please start an RFC discussion on the `LLVM Discourse forums`_. This process is very new - please expect the details to change, it is always; safe to ask on the `LLVM Discourse forums`_ about this. Suggested disclaimer for the project README and the main project web page:. ::. This project is participating in the LLVM Incubator process: as such, it is; not part of any official LLVM release. While incubation status is not; necessarily a reflection of the completeness or stability of the code, it; does indicate that the project is not yet endorsed as a component of LLVM. .. _copyright-license-patents:. Copyright, License, and Patents; ===============================. .. note::. This section deals with legal matters but does not provide legal advice. We; are not lawyers --- please seek legal counsel from a licensed attorney. This section addresses the issues of copyright, license and patents for the LLVM; project. The copyright for the code is held by the contributors of; the code. The code is licensed under permissive `open source licensing terms`_,; namely the Apache-2.0 with LLVM-exception license, which includes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:50085,safe,safe,50085,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['safe'],['safe']
Safety,"sses; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2066,detect,detect,2066,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['detect'],['detect']
Safety,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24626,safe,safe,24626,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"ssingDictionaries activate the search through the base classes.; - Added a TStatusBitsChecker to avoid Status Bits overlap in class hierarchy deriving from TObject (and resolved a handful of conflicts).; - Introduced support for type safe range-for-loop for ROOT collection. The typical use is:. ```; for(auto bcl : TRangeDynCast<TBaseClass>( * cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; ```; - ClassDefInline has been enhanced even for some compiled class (without a dictionary). ClassDefInline can still not be used for class template instance using Double32_t or Float16_t as a template parameter or for class or class template that do not have a public default constructor.; - ROOT's backport of `std::string_view` has been updated to follow what's available in C++17, notably its `to_string` member function has been removed. ### Thread safety. Resolved the race conditions inherent to the use of the RecursiveRemove mechanism. - Introduced ```ROOT::TReentrantRWLock```, an implementation of a reentrant read-write lock with a configurable internal mutex/lock and a condition variable to synchronize readers and writers when necessary. The implementation allows a single reader to take the write lock without releasing the reader lock. It also allows the writer to take a read lock. In other word, the lock is re-entrant for both reading and writing. The implementation tries to make faster the scenario when readers come and go but there is no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:4293,safe,safety,4293,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['safe'],['safety']
Safety,"ssors and; multiple successors. If one or more of the predecessors of the block can be; proven to always cause a jump to one of the successors, we forward the edge; from the predecessor to the successor by duplicating the contents of this; block. An example of when this can occur is code like this:. .. code-block:: c++. if () { ...; X = 4;; }; if (X < 3) {. In this case, the unconditional branch at the end of the first if can be; revectored to the false side of the second if. .. _passes-lcssa:. ``lcssa``: Loop-Closed SSA Form Pass; ------------------------------------. This pass transforms loops by placing phi nodes at the end of the loops for all; values that are live across the loop boundary. For example, it turns the left; into the right code:. .. code-block:: c++. for (...) for (...); if (c) if (c); X1 = ... X1 = ...; else else; X2 = ... X2 = ...; X3 = phi(X1, X2) X3 = phi(X1, X2); ... = X3 + 4 X4 = phi(X3); ... = X4 + 4. This is still valid LLVM; the extra phi nodes are purely redundant, and will be; trivially eliminated by ``InstCombine``. The major benefit of this; transformation is that it makes many other loop optimizations, such as; ``LoopUnswitch``\ ing, simpler. You can read more in the; :ref:`loop terminology section for the LCSSA form <loop-terminology-lcssa>`. .. _passes-licm:. ``licm``: Loop Invariant Code Motion; ------------------------------------. This pass performs loop invariant code motion, attempting to remove as much; code from the body of a loop as possible. It does this by either hoisting code; into the preheader block, or by sinking code to the exit blocks if it is safe.; This pass also promotes must-aliased memory locations in the loop to live in; registers, thus hoisting and sinking ""invariant"" loads and stores. Hoisting operations out of loops is a canonicalization transform. It enables; and simplifies subsequent optimizations in the middle-end. Rematerialization; of hoisted instructions to reduce register pressure is the responsibilit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:23098,redund,redundant,23098,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['redund'],['redundant']
Safety,"st a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your change before pushing; it to the repo. LLVM currently has a linear-history policy, which means that merge commits are; not allowed. The `llvm-project` repo on github is configured to reject pushes; that include merges, so the `git rebase` step above is required. Please ask for help if you're having trouble with your particular git workflow. .. _git_pre_push_hook:. Git pre-push hook; ^^^^^^^^^^^^^^^^^. We include an optional pre-push hook that run some sanity checks on the revisions; you are about to push and ask confirmation if you push multiple commits at once.; You can set it up (on Unix systems) by running from the repository root:. .. code-block:: console. % ln -sf ../../llvm/utils/git/pre-push.py .git/hooks/pre-push. Helpful Information About LLVM; ==============================; :doc:`LLVM's documentation <index>` provides a wealth of information about LLVM's internals as; well as various user guides. The pages listed below should provide a good overview; of LLVM's high-level design, as well as its internals:. :doc:`GettingStarted`; Discusses how to get up and running quickly with the LLVM infrastructure.; Everything from unpacking and compilation of the distribution to execution; of some tools. :doc:`LangRef`; Defines the LLVM intermediate representation. :doc:`ProgrammersManual`; Introduction to the general layout of the LLVM sourcebase, important classes; and APIs, and some tips & tricks. `LLVM for Grad Students`__; This is an introduction to the LLVM i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:5997,sanity check,sanity checks,5997,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['sanity check'],['sanity checks']
Safety,"stance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracket syntax in C mode. The argument; can either be a single identifier or a scoped identifier. If the attribute is; supported, a nonzero value is returned. If the attribute is not supported by the; current compilation target, this macro evaluates to 0. It can be used like this:. .. code-block:: c. #ifndef __has_c_attribute // Optional of course.; #define __has_c_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_c_attribute(fallthrough); #define FALLTHROUGH [[fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_attribute``; -------------------. This function-like macro takes a single identifier argument that is the name of; a GNU-style attribute. It evaluates to 1 if the attribute is supported by the; current compilation target, or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_attribute // Optional of course.; #define __has_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_attribute(always_inline); #define ALWAYS_INLINE __attribute__((always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:7366,avoid,avoid,7366,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"sters. `TargetInstrInfo::isLoadFromStackSlotPostFE` and; `TargetInstrInfo::isStoreToStackSlotPostFE` are needed to identify spill and; restore instructions. Each should return the destination or source register; respectively. `LiveDebugValues` will track the movement of a value from / to; the stack slot. In addition, any instruction that writes to a stack spill; should have a `MachineMemoryOperand` attached, so that `LiveDebugValues` can; recognise that a slot has been clobbered. ## Target-specific optimisation instrumentation. Optimisations come in two flavours: those that mutate a `MachineInstr` to make; it do something different, and those that create a new instruction to replace; the operation of the old. The former _must_ be instrumented -- the relevant question is whether any; register def in any operand will produce a different value, as a result of the; mutation. If the answer is yes, then there is a risk that a `DBG_INSTR_REF`; instruction referring to that operand will end up assigning the different; value to a variable, presenting the debugging developer with an unexpected; variable value. In such scenarios, call `MachineInstr::dropDebugNumber()` on the; mutated instruction to erase its instruction number. Any `DBG_INSTR_REF`; referring to it will produce an empty variable location instead, that appears; as ""optimised out"" in the debugger. For the latter flavour of optimisation, to increase coverage you should record; an instruction number substitution: a mapping from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:6722,risk,risk,6722,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['risk'],['risk']
Safety,"still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and speci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145502,detect,detector,145502,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"stly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3363,detect,detect,3363,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['detect'],['detect']
Safety,structor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-de,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134045,Redund,Redundant,134045,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Redund'],['Redundant']
Safety,"sule**: Takes a cppyy bound C++ object and returns its address as; a PyCapsule object.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_cobject**: Takes a cppyy bound C++ object and returns its address as; a PyCObject object for Python2 and a PyCapsule object for Python3.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_ctypes**: Takes a cppyy bound C++ object and returns its address as; a ``ctypes.c_void_p`` object.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. `ctypes`; --------. The `ctypes module`_ has been part of Python since version 2.5 and provides a; Python-side foreign function interface.; It is clunky to use and has very bad performance, but it is guaranteed to be; available.; It does not have a public C interface, only the Python one, but its internals; have been stable since its introduction, making it safe to use for tight and; efficient integration at the C level (with a few Python helpers to assure; lazy lookup). Objects from ``ctypes`` can be passed through arguments of functions that; take a pointer to a single C++ builtin, and ``ctypes`` pointers can be passed ; when a pointer-to-pointer is expected, e.g. for array out-parameters.; This leads to the following set of possible mappings:. ======================================== ========================================; C++ ctypes; ======================================== ========================================; by value (ex.: ``int``) ``.value`` (ex.: ``c_int(0).value``); by const reference (ex.: ``const int&``) ``.value`` (ex.: ``c_int(0).value``); by reference (ex.: ``int&``) direct (ex.: ``c_int(0)``); by pointer (ex.: ``int*``) direct (ex.: ``c_int(0)``); by ptr-ref (ex.: ``int*&``) ``pointer`` (ex.: ``pointer(c_int(0))``); by ptr-ptr **in** (ex.: ``int**``) ``pointer`` (ex.: ``pointer(c_int(0))``); by ptr-ptr **out*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:7538,safe,safe,7538,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['safe'],['safe']
Safety,"symbol. Unlike regular reexports however, lookups of lazy reexports; do not trigger immediate materialization of the reexported symbol. Instead, they; only trigger materialization of a function stub. This function stub is; initialized to point at a *lazy call-through*, which provides reentry into the; JIT. If the stub is called at runtime then the lazy call-through will look up; the reexported symbol (triggering materialization for it if necessary), update; the stub (to call directly to the reexported symbol on subsequent calls), and; then return via the reexported symbol. By re-using the existing symbol lookup; mechanism, lazy reexports inherit the same concurrency guarantees: calls to lazy; reexports can be made from multiple threads concurrently, and the reexported; symbol can be any state of compilation (uncompiled, already in the process of; being compiled, or already compiled) and the call will succeed. This allows; laziness to be safely mixed with features like remote compilation, concurrent; compilation, concurrent JIT'd code, and speculative compilation. There is one other key difference between regular reexports and lazy reexports; that some clients must be aware of: The address of a lazy reexport will be; *different* from the address of the reexported symbol (whereas a regular; reexport is guaranteed to have the same address as the reexported symbol).; Clients who care about pointer equality will generally want to use the address; of the reexport as the canonical address of the reexported symbol. This will; allow the address to be taken without forcing materialization of the reexport. Usage example:. If JITDylib ``JD`` contains definitions for symbols ``foo_body`` and; ``bar_body``, we can create lazy entry points ``Foo`` and ``Bar`` in JITDylib; ``JD2`` by calling:. .. code-block:: c++. auto ReexportFlags = JITSymbolFlags::Exported | JITSymbolFlags::Callable;; JD2.define(; lazyReexports(CallThroughMgr, StubsMgr, JD,; SymbolAliasMap({; { Mangle(""foo""), { M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:17702,safe,safely,17702,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['safe'],['safely']
Safety,"symmetric errors, then becomes essentially meaningless. On the; other hand, the $\mbox{MINOS}$ analysis is still meaningful, at; least in principle, as long as $\mbox{MIGRAD}$ (which is called; internally by $\mbox{MINOS}$) does not get blocked at a limit.; Unfortunately, the user has no control over this aspect of the; $\mbox{MINOS}$ calculation, although it is possible to get enough; printout from the $\mbox{MINOS}$ result to be able to determine; whether the results are reliable or not. ## Fixing and releasing parameters ##. When M needs to be guided to the ""right"" minimum, often the best way to; do this is with the methods e.g. MnMigrad::fix(...) and; MnMigrad::release(...). That is, suppose you have a problem with ten; free parameters, and when you minimize with respect to all at once, M; goes to an unphysical solution characterized by an unphysical or; unwanted value of parameter number four. One way to avoid this is to fix; parameter four at a ""good"" value (not necessarily the best, since you; presumably don't know that yet), and minimize with respect to the; others. Then release parameter four and minimize again. If the problem; admits a ""good"" physical solution, you will normally find it this way.; If it doesn't work, you may see what is wrong by the following sequence; (where $\mbox{xxx}$ is the expected physical value for parameter; four):. MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);. where $\mbox{SCAN}$ gives you a picture of $\mbox{FCN}$ as a; function of parameter four alone, the others being fixed at their; current best values. If you suspect the difficulty is due to parameter; five, then add. MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);. to see a two-dimensional picture. ## Interpretation of parameter errors ##. There are two kinds of problems that can arise:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:66904,avoid,avoid,66904,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoid']
Safety,"t -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check lines. In cases where this can't be avoided (say, if a test wouldn't; be precise enough), moving the test to its own file is preferred. .. _MIRDebugify:. Test original debug info preservation in optimizations; ------------------------------------------------------. In addition to automatically generating debug info, the checks provided by; the ``debugify`` utility pass can also be used to test the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test sample.ll. # Check the preservation of original Debug Info after each pass.; $ opt -verify-each-debuginfo-preserve -O2 sample.ll. Limit number of observed functions to speed up the analysis:. .. code-block:: bash. # Test up to 100 functions (per compile unit) per pass.; $ opt -verify-each-debuginfo-preserve -O2 -debugify-func-limit=100 sample.ll. Please do note that running ``-verify-each-debuginfo-preserve`` on big projects; could be heavily time consumi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:13499,avoid,avoided,13499,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['avoid'],['avoided']
Safety,"t an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about general control flow and arithmetic, it is; not anywhere near as strong at reasoning about the various intrinsics. If; profitable for code generation purposes, the optimizer will likely form the; intrinsics itself late in the optimization pipeline. It is *very* rarely; profitable to emit these directly in the language frontend. This item; explicitly includes the use of the :ref:`overflow intrinsics <int_overflow>`. #. Avoid using the :ref:`assume intrinsic <int_assume>` until you've; established that a) there's no other way to express the given fact and b); that fact is critical for optimization purposes. Assumes are a great; prototyping mechanism, but the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:8571,redund,redundant,8571,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['redund'],['redundant']
Safety,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76672,recover,recover,76672,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recover']
Safety,"t and; Nathaniel Smith. It is now matplotlib's current default color map. ![Viridis](palette_112.png). ### TMultiGraph. Ignore empty graphs when computing the multi-graph range at painting time. ### TASImage. A left click on a image produced a one pixel zoom. ### TCreatePrimitives. The ending of a polyline creation is based on the closeness of the two last; entered points. The previous algorithm was based on user coordinates. It is now; based on pixel to avoid the problem reported; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20343). ### TCanvas. When the first canvas created by ROOT was in batch mode, it was note possible to; come back in interactive mode for the next canvases. this problem was reported; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20354). ### Cocoa Backend. Sometimes the mouse cursor did not change back to the window manager arrow when; exiting a `TCanvas`. ### `freetype` library. Updates `builtin_freetype` to 2.6.1 (current upstream version), which can detect; `PPC64LE` machine. This was compiled and tested on `SLC6 + ICC + x86_64`,; `F21 + GCC + ppc64le`, `MacOSX 10.11.1 + Xcode 7.1` and `Windows (ROOT 5.34)`.; `$ROOTSYS/graf2d/freetype/src/README` was removed, because no issues were noticed; with `ICC` compiler and `-Wall -pedantic -ansi` flags.; Additionally `--with-png=no --with-bzip2=no` flags are passed to freetype; configuration script. Default values for these options are auto.; `freetype` finds `libpng` and `libbzip2` on the system and builds extra; modules. Then attempting to link against `freetype` one would need to link; `-lpng -lbzip2` explicitly otherwise linking will returns in undefined; references. Otherwise we would need to check for `libpng` and `libbzip2` on the system; and adjust `FREETYPE_LIBRARIES` to include `-lpng` and `-lbzip2`.; The current solution goes for the minimal configuration. The original request for; this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:17614,detect,detect,17614,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['detect'],['detect']
Safety,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18377,abort,abort,18377,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"t element) serving as the upper bound. This applies to all; types of arrays including constant-length arrays, variable-length arrays (VLAs),; and flexible array members annotated with `__counted_by`. In the following example, reference to ``vla`` promotes to ``int; *__bidi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actually allocated.; // ...; }. By promoting array references to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35051,safe,safety,35051,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"t from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad' was interrupted; the interrupt was de facto; ineffective, so that collection stayed always until the timeout expired; (default: 5 minutes). Should solve some of the cases were slow response; was experienced.; Fix a problem with log path transmission when the node dies early or; not even starts. The log path was empty and wrong was filled in when; retrieving the log buffers, disorienting debugging.; Fix a bug checking the first event which rendered ineffective the; request for processing a subset of events in a given dataset or; chain.; In pq2-ana-dist, fix problem with the labels of the distribution; histo occuring when machines are represented by IPs instead of; names.; Add missing calls to closedir() and TSystem::FreeDirectory, cuasing a; large number of filedescriptors remaining opened after xproofd; initialization.; Fix a problem with the final update of the progress information; affecting occasionally cases with skipped events.; Fix merging of TproofOutputFile when using submergers (the; intermediate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:6982,timeout,timeout,6982,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['timeout'],['timeout']
Safety,"t is sensible to version this document by the releases of its sole; implementation (and its host project), clang. ""LLVM X.Y"" refers to an; open-source release of clang from the LLVM project. ""Apple X.Y"" refers to an; Apple-provided release of the Apple LLVM Compiler. Other organizations that; prepare their own, separately-versioned clang releases and wish to maintain; similar information in this document should send requests to cfe-dev. If a change decreases the expressiveness of the language, for example by; imposing a new restriction, this should be taken as an oversight in the; original specification and something to be avoided in all versions. Such; changes are generally to be avoided. .. _arc.general:. General; =======. Automatic Reference Counting implements automatic memory management for; Objective-C objects and blocks, freeing the programmer from the need to; explicitly insert retains and releases. It does not provide a cycle collector;; users must explicitly manage the lifetime of their objects, breaking cycles; manually or with weak or unsafe references. ARC may be explicitly enabled with the compiler flag ``-fobjc-arc``. It may; also be explicitly disabled with the compiler flag ``-fno-objc-arc``. The last; of these two flags appearing on the compile line ""wins"". If ARC is enabled, ``__has_feature(objc_arc)`` will expand to 1 in the; preprocessor. For more information about ``__has_feature``, see the; :ref:`language extensions <langext-__has_feature-__has_extension>` document. .. _arc.objects:. Retainable object pointers; ==========================. This section describes retainable object pointers, their basic operations, and; the restrictions imposed on their use under ARC. Note in particular that it; covers the rules for pointer *values* (patterns of bits indicating the location; of a pointed-to object), not pointer *objects* (locations in memory which store; pointer values). The rules for objects are covered in the next section. A :arc-term:`retainabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:9082,unsafe,unsafe,9082,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['unsafe'],['unsafe']
Safety,"t memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to use the `RooFit::OwningPtr`; return type, which is an alias for `std::unique_ptr` in memory-safe mode or an; alias for a raw pointer otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatibl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:9592,safe,safe,9592,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['safe'],['safe']
Safety,"t method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. Mixing References and Raw Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Support for languages which allow unmanaged pointers to garbage collected; objects (i.e. pass a pointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides the connection between; the reference value and the raw pointer. The problem is that having a; ptrtoint or inttoptr cast (which is common for such use cases) breaks the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33582,safe,safepoint,33582,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"t of entries requested by the user if called; together with other operations ([PR](https://github.com/root-project/root/pull/11398)).; - Requesting variations for `Stats` results with `VariationsFor` is now supported.; - Factory functions for RDataFrames reading CSV files, RNTuples, Arrow tables, etc. have been renamed in order to; increase consistency, e.g. `MakeCsvDataFrame` is now `FromCSV`. The old wording is still available but deprecated.; - The precision of `Sum`s and `Mean`s of single-precision floating point values has been greatly improved by employing; Kahan summations.; - The content of [execution logs](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#rdf-logging) from RDataFrame; has been streamlined in order to make them more useful. ### Distributed RDataFrame. - Add support for systematic variations (e.g. `Vary` and `VariationsFor` operations) in distributed mode.; - If an instant action (e.g. `Snapshot`) is purposely made lazy by the user, distributed RDataFrame now respects this; and avoids triggering the computations right away.; - The algorithm for automatic splitting of the input dataset has been reworked, bringing the startup time cost of; distributed RDataFrame close to zero.; - A histogram model (name, title, binning) for the `Histo*D` actions is now required in distributed mode. See the; [relative PR](https://github.com/root-project/root/pull/10368) for more discussion.; - The performance of distributed RDataFrame for large computation graphs (>1000 operations) has been greatly improved.; - If the `npartitions` argument is not set by the user, the default number of tasks created by a distributed RDataFrame; is equal to the number of cores specified by the user when connecting to the cluster.; - C++ exceptions (i.e. instances of `std::exception` and derived) are now correctly propagated from the processes of the; computing nodes to the user side.; - The minimum `dask` version required to support distributed RDataFrame is 2022.8.1, sinc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:13255,avoid,avoids,13255,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoids']
Safety,"t offset from the coroutine frame. Note that there is also an ABI independent method:. .. parsed-literal::. print std::coroutine_handle<task::promise_type>::from_address((void*)0x416eb0).promise(). The functions `from_address(void*)` and `promise()` are often small enough to; be removed during optimization, so this method may not be possible. Print coroutine frames; ======================. LLVM generates the debug information for the coroutine frame in the LLVM middle; end, which permits printing of the coroutine frame in the debugger. Much like; the `promise_type`, when stopped at a breakpoint inside a coroutine we can; print the coroutine frame by:. .. parsed-literal::. print __coro_frame. Just as printing the `promise_type` is possible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_ty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5232,avoid,avoid,5232,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['avoid'],['avoid']
Safety,"t pattern or if there are multiple substitutions whose patterns; contain ``%{name}``. The substitution's current position in the substitution; list does not change so that expansion order relative to other existing; substitutions is preserved. The following properties apply to both the ``DEFINE:`` and ``REDEFINE:``; directives:. - **Substitution name**: In the directive, whitespace immediately before or; after ``%{name}`` is optional and discarded. ``%{name}`` must start with; ``%{``, it must end with ``}``, and the rest must start with a letter or; underscore and contain only alphanumeric characters, hyphens, underscores, and; colons. This syntax has a few advantages:. - It is impossible for ``%{name}`` to contain sequences that are special in; python's ``re.sub`` patterns. Otherwise, attempting to specify; ``%{name}`` as a substitution pattern in a lit configuration file could; produce confusing expansions.; - The braces help avoid the possibility that another substitution's pattern; will match part of ``%{name}`` or vice-versa, producing confusing; expansions. However, the patterns of substitutions defined by lit; configuration files and by lit itself are not restricted to this form, so; overlaps are still theoretically possible. - **Substitution value**: The value includes all text from the first; non-whitespace character after ``=`` to the last non-whitespace character. If; there is no non-whitespace character after ``=``, the value is the empty; string. Escape sequences that can appear in python ``re.sub`` replacement; strings are treated as plain text in the value.; - **Line continuations**: If the last non-whitespace character on the line after; ``:`` is ``\``, then the next directive must use the same directive keyword; (e.g., ``DEFINE:``) , and it is an error if there is no additional directive.; That directive serves as a continuation. That is, before following the rules; above to parse the text after ``:`` in either directive, lit joins that text; togethe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:34288,avoid,avoid,34288,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoid']
Safety,"t removing it; entirely, or you want to write comments that mention a directive by name. The; ""``COM:``"" directive makes it easy to do this. For example, you might have:. .. code-block:: llvm. ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; COM: FIXME: X64 isn't working correctly yet for this part of codegen, but; ; COM: X64 will have something similar to X32:; ; COM:; ; COM: X64: pinsrd_1:; ; COM: X64: pinsrd $1, %edi, %xmm0. Without ""``COM:``"", you would need to use some combination of rewording and; directive syntax mangling to prevent FileCheck from recognizing the commented; occurrences of ""``X32:``"" and ""``X64:``"" above as directives. Moreover,; FileCheck diagnostics have been proposed that might complain about the above; occurrences of ""``X64``"" that don't have the trailing ""``:``"" because they look; like directive typos. Dodging all these problems can be tedious for a test; author, and directive syntax mangling can make the purpose of test code unclear.; ""``COM:``"" avoids all these problems. A few important usage notes:. * ""``COM:``"" within another directive's pattern does *not* comment out the; remainder of the pattern. For example:. .. code-block:: llvm. ; X32: pinsrd $1, 4(%esp), %xmm0 COM: This is part of the X32 pattern!. If you need to temporarily comment out part of a directive's pattern, move it; to another line. The reason is that FileCheck parses ""``COM:``"" in the same; manner as any other directive: only the first directive on the line is; recognized as a directive. * For the sake of LIT, FileCheck treats ""``RUN:``"" just like ""``COM:``"". If this; is not suitable for your test environment, see :option:`--comment-prefixes`. * FileCheck does not recognize ""``COM``"", ""``RUN``"", or any user-defined comment; prefix as a comment directive if it's combined with one of the usual check; directive suffixes, such as ""``-NEXT:``"" or ""``-NOT:``"", discussed below.; FileCheck treats such a combination as plain text instead. If it needs to act; as a comment d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:11851,avoid,avoids,11851,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['avoid'],['avoids']
Safety,"t stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spill",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25687,abort,abort,25687,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['abort'],['abort']
Safety,"t the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is also send in kPROOF_GETPACKET and; kPROOF_STOPPROCESS messages. ; The class TPacketizerProgressive is removed. . Fixes. Enable; the max number of sessions ('mxsess' parameter in the xpd.schedparam; directive); users are just refused to start a session if this limit is; reached.Make sure to collect consistently input messages when running in asynchronous modeFix; a few problems with TProof::SendFile (used by UploadPackage, Load); appearing when a rapid sequence of these commands was submitted Invalidate the TProofMgr when the physical connection is; closed; avoids; crashing when trying to get the logs after a failure. ; Fix a memory leak in log retrieval (the TProofLog object; was never; deleted); Add protections for the cases the manager cannot be; initialized; Fix a race condition possibly affecting the handling of; workers death; Avoid duplicating worker logs in the master log file; unless; when explicitly needed by the request (Exec(...), Print(...)) or when; an error occuredFix; problem with the determination and transmission of the name of the; object to be processed. The problem appeared when processing files; containing >1 trees in changing order.Fix problem with TProof::Load loading the macro to one worker only per machineFix wrong return code preventing the correct propagation of the full ClearPackage to workersFix a problem causing the whole query to stop even in the case a worker was terminated gently with SIGTERM.; Fix a problem triggering full re-build of a package upon change of a; single file; the version info file was wrongly reset; this should; happen only after a re-build.Make sure that in case multiple TProofOutputFile are present, each get merged correctlyFix problem in TProofServLogHandler::Notify due to bad usage of Form(...). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:6663,Avoid,Avoid,6663,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['Avoid'],['Avoid']
Safety,"t to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support incremental merges. Add new tutorials (net/treeClient.C + net/fastMergeServer.C); demonstrating how a TMemFile can be used to do parallel merge; from many clients. (TMemFile still needs to be better integrated; with TMessage and TSocket). The new TMemFile class support the TFile interface but only store; the information in memory. This version is limited to 32MB. TMessage mess;; ...; mess->ReadFastArray(scratch,length);; transient = new TMemFile(""hsimple.memroot"",scratch,length);. will copy the content of 'scratch' into the in-memory buffer; created by/for the TMemFile. TMemFile *file = new TMemFile(""hsimple.memroot"",""RECREATE"");. Will create an empty in-memory of (currently fixed) size 32MB. file->ResetAfterMerge(0);. Wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:3763,risk,risk,3763,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['risk'],['risk']
Safety,"t, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add; that to the redeclaration chain of the found node. This behaviour is essential; when we merge ASTs from different translation units which include the same; header file(s). For example, we want to have only one definition for the class; template ``std::vector``, even if we included ``<vector>`` in several; translation units. To find a structurally equivalent node we can use the regular C/C++ lookup; functions: ``DeclContext::noload_lookup()`` and; ``DeclContext::localUncachedLookup()``. These functions do respect the C/C++; name hiding rules, thus you cannot find certain declarations in a given; declaration context. For instance, unnamed declarations (anonymous structs),; non-first ``friend`` declarations and template specializations are hidden. This; is a problem, because if we use the regular C/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (repr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:105705,redund,redundant,105705,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['redund'],['redundant']
Safety,"t: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1509,detect,detect,1509,interpreter/cling/www/old/contact.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html,2,['detect'],['detect']
Safety,"t; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unrea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16525,recover,recoverable,16525,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['recover'],['recoverable']
Safety,"tGeneration TOffsetGeneration.cxx ElementStruct.cxx ElementStructDict.cxx; LIBRARIES RIO Tree MathCore; ); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET testTOffsetGeneration POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/libElementStructDict_rdict.pcm; ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libElementStructDict_rdict.pcm); endif(); target_include_directories(testTOffsetGeneration PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_STANDARD_LIBRARY_PACKAGE(SillyStruct NO_INSTALL_HEADERS HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/SillyStruct.h SOURCES SillyStruct.cxx LINKDEF SillyStructLinkDef.h DEPENDENCIES RIO); ROOT_ADD_GTEST(testBulkApi BulkApi.cxx LIBRARIES RIO Tree TreePlayer); #FIXME: tests are having timeout on 32bit CERN VM (in docker container everything is fine),; # to be reverted after investigation.; if(NOT CMAKE_SIZEOF_VOID_P EQUAL 4); ROOT_ADD_GTEST(testBulkApiMultiple BulkApiMultiple.cxx LIBRARIES RIO Tree TreePlayer TIMEOUT 3000); ROOT_ADD_GTEST(testBulkApiVarLength BulkApiVarLength.cxx LIBRARIES RIO Tree TreePlayer); ROOT_ADD_GTEST(testBulkApiSillyStruct BulkApiSillyStruct.cxx LIBRARIES RIO Tree TreePlayer SillyStruct); endif(); ROOT_ADD_GTEST(testTBasket TBasket.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTBranch TBranch.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTIOFeatures TIOFeatures.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeCluster TTreeClusterTest.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTChainParsing TChainParsing.cxx LIBRARIES RIO Tree); if(imt); ROOT_ADD_GTEST(testTTreeImplicitMT ImplicitMT.cxx LIBRARIES RIO Tree); endif(); ROOT_ADD_GTEST(testTChainSaveAsCxx TChainSaveAsCxx.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTChainRegressions TChainRegressions.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeTruncatedDatatypes TTreeTruncatedDatatypes.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeRegressions TTreeRegressions.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(entrylist_addsubl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt:1322,TIMEOUT,TIMEOUT,1322,tree/tree/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt,1,['TIMEOUT'],['TIMEOUT']
Safety,"tMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121993,safe,safety,121993,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ta, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kernels), these approaches require manual and/or static analysis aided auditing; of code and explicit source changes to apply the mitigation. They are unlikely; to scale well to large applications. We are proposing a comprehensive; mitigation approach that would apply automatically across an entire program; rather than through manual changes to the code. While this is likely to have a; high performance cost, some applications may be in a good position to take this; performance / security tradeoff. The specific ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:2069,predict,predictor,2069,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,2,['predict'],"['predict', 'predictor']"
Safety,"ta>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307799,unsafe,unsafe,307799,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"tack, and other context elements corresponding to the source language; thread of execution upon which the user is focused, if any. The resulting; value V\ :sub:`3` is the value in L\ :sub:`2` at the time of the call made; by the call site. The result of these attributes is undefined if the current call frame is not; for the subprogram containing the ``DW_TAG_call_site_parameter`` debugger; information entry or the current program location is not for the call site; containing the ``DW_TAG_call_site_parameter`` debugger information entry in; the current call frame. *The consumer may have to virtually unwind to the call site (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) in order to evaluate these; attributes. This will ensure the source language thread of execution upon; which the user is focused corresponds to the call site needed to evaluate; the expression.*. If it is not possible to avoid the expressions of these attributes from; accessing registers or memory locations that might be clobbered by the; subprogram being called by the call site, then the associated attribute; should not be provided. *The reason for the restriction is that the parameter may need to be; accessed during the execution of the callee. The consumer may virtually; unwind from the called subprogram back to the caller and then evaluate the; attribute expressions. The call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) will not be able to restore; registers that have been clobbered, and clobbered memory will no longer have; the value at the time of the call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:170781,avoid,avoid,170781,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoid']
Safety,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77060,recover,recovery,77060,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recovery']
Safety,"tants may also be represented as a double-quoted string using the ``c``; prefix. For example: ""``c""Hello World\0A\00""``"".; **Vector constants**; Vector constants are represented with notation similar to vector; type definitions (a comma separated list of elements, surrounded by; less-than/greater-than's (``<>``)). For example:; ""``< i32 42, i32 11, i32 74, i32 100 >``"". Vector constants; must have :ref:`vector type <t_vector>`, and the number and types of; elements must match those specified by the type. When creating a vector whose elements have the same constant value, the; preferred syntax is ``splat (<Ty> Val)``. For example: ""``splat (i32 11)``"".; These vector constants must have ::ref:`vector type <t_vector>` with an; element type that matches the ``splat`` operand.; **Zero initialization**; The string '``zeroinitializer``' can be used to zero initialize a; value to zero of *any* type, including scalar and; :ref:`aggregate <t_aggregate>` types. This is often used to avoid; having to print large zero initializers (e.g. for large arrays) and; is always exactly equivalent to using explicit zero initializers.; **Metadata node**; A metadata node is a constant tuple without types. For example:; ""``!{!0, !{!2, !0}, !""test""}``"". Metadata can reference constant values,; for example: ""``!{!0, i32 0, ptr @global, ptr @function, !""str""}``"".; Unlike other typed constants that are meant to be interpreted as part of; the instruction stream, metadata is a place to attach additional; information such as debug info. Global Variable and Function Addresses; --------------------------------------. The addresses of :ref:`global variables <globalvars>` and; :ref:`functions <functionstructure>` are always implicitly valid; (link-time) constants. These constants are explicitly referenced when; the :ref:`identifier for the global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:189612,avoid,avoid,189612,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"tation-based profile; the output format is the indexed binary format. .. option:: --extbinary. Emit the profile using an extensible binary encoding. This option can only; be used with sample-based profile. The extensible binary encoding can be; more compact with compression enabled and can be loaded faster than the; default binary encoding. .. option:: --text. Emit the profile in text mode. This option can also be used with both; sample-based and instrumentation-based profile. When this option is used; the profile will be dumped in the text format that is parsable by the profile; reader. .. option:: --gcc. Emit the profile using GCC's gcov format (Not yet supported). .. option:: --sparse[=true|false]. Do not emit function records with 0 execution count. Can only be used in; conjunction with -instr. Defaults to false, since it can inhibit compiler; optimization during PGO. .. option:: --num-threads=<N>, -j. Use N threads to perform profile merging. When N=0, llvm-profdata auto-detects; an appropriate number of threads to use. This is the default. .. option:: --failure-mode=[any|all]. Set the failure mode. There are two options: 'any' causes the merge command to; fail if any profiles are invalid, and 'all' causes the merge command to fail; only if all profiles are invalid. If 'all' is set, information from any; invalid profiles is excluded from the final merged product. The default; failure mode is 'any'. .. option:: --prof-sym-list=<path>. Specify a file which contains a list of symbols to generate profile symbol; list in the profile. This option can only be used with sample-based profile; in extbinary format. The entries in this file are newline-separated. .. option:: --compress-all-sections=[true|false]. Compress all sections when writing the profile. This option can only be used; with sample-based profile in extbinary format. .. option:: --use-md5=[true|false]. Use MD5 to represent string in name table when writing the profile.; This option can only be used with sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profdata.rst:3961,detect,detects,3961,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profdata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profdata.rst,1,['detect'],['detects']
Safety,"tax:; """""""""""""". ::. declare i1 @llvm.type.test(ptr %ptr, metadata %type) nounwind memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer to be tested. The second argument is a; metadata object representing a :doc:`type identifier <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.test`` intrinsic tests whether the given pointer is associated; with the given type identifier. .. _type.checked.load:. '``llvm.type.checked.load``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare {ptr, i1} @llvm.type.checked.load(ptr %ptr, i32 %offset, metadata %type) nounwind memory(argmem: read). Arguments:; """""""""""""""""""". The first argument is a pointer from which to load a function pointer. The; second argument is the byte offset from which to load the function pointer. The; third argument is a metadata object representing a :doc:`type identifier; <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.checked.load`` intrinsic safely loads a function pointer from a; virtual table pointer using type metadata. This intrinsic is used to implement; control flow integrity in conjunction with virtual call optimization. The; virtual call optimization pass will optimize away ``llvm.type.checked.load``; intrinsics associated with devirtualized calls, thereby removing the type; check in cases where it is not needed to enforce the control flow integrity; constraint. If the given pointer is associated with a type metadata identifier, this; function returns true as the second element of its return value. (Note that; the function may also return true if the given pointer is not associated; with a type metadata identifier.) If the function's return value's second; element is true, the following rules apply to the first element:. - If the given pointer is associated with the given type metadata identifier,; it is the function pointer loaded from the given byte offset from the given; pointer. - If the given pointer is not associated with the given type meta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:938235,safe,safely,938235,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3819,unsafe,unsafe,3819,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"tead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAULT)). It is also possible to tune this 'cache-and-track' optimization to perform a more fine-grained caching; of components than Optimize(2) implements: to do so, call arg->setAttribute(""CacheAndTrack"") on each; pdf component that you'd like to be cache-and-tracked individually. New pdf/data attach mechanism in likelihood objects (RooAbsOptTestStatistic). The new mechanism only; reattaches the dataset branch buffers and not the RooRealVars representing the data. This new designs; allows for a much faster RooAbsTestStatistic::setData() implementation, which changes the dataset in; an existing likelihood object. This will speed up RooStats tools based on 'simple' likelihood models; substantially. Automatic detections of 'binned' pdfs and automatic generation of binned data in generate(). RooFit will; now automatically generate binned pdf shapes. Binned pdfs shapes are fundamentally RooHistPdf and RooHistFuncs; (with interpolation order set to zero). Products and sums of exclusively binned shapes are also recognized; as binned shapes. For such binned shapes generate() will now by default follow the 'binned' strategy ; -- that is, take the expectation value in each bin and sample a Poisson distribution from that -- rather; than follow the unbinned strategy. The rationale is that such datasets result in much faster likelihood; calculations (for nbin smaller than nevent). The optimization is also exact: the likelihood of a binned ; data using a binned pdf is identical to that of an unbinned dataset with a binned pdf. Nevertheless you can ; switch off this feature by passing AutoBinned(false) to RooAbsPdf::generate(). Mixed binned/unbinned generation from simultaneous pdf. For a RooSimultaneous consisting of exclusively; extend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:4394,detect,detections,4394,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['detect'],['detections']
Safety,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68975,safe,safe,68975,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"tegy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7252,safe,safety,7252,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ter and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:32210,safe,safepoint,32210,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"ter into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointer. There are no DWARF extensions needed to support wide pointers.; In our implementation, LLDB recognizes wide pointer types by name and; reconstructs them as wide pointer Clang AST types for use in the expression; evaluator. External bounds annotations; ---------------------------. Similar to internal bounds annotations, external bound annotations are described; as a typedef to their underlying pointer type in the debug info, and the bounds; are encoded as strings in the typedef’s name (e.g.,; ``__bounds_safety$counted_by:N``). Recognizing ``-fbounds-safety`` traps; -------------------------------------. Clang emits debug info for ``-fbounds-safety`` traps as inlined functions, where; the function name encodes the error message. LLDB implements a frame recognizer; to surface a human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:9306,safe,safety,9306,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ter on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2846,safe,safely,2846,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safely']
Safety,"terType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * Use ``getLoadStoreType()`` to handle both of the above in one call.; * For getelementptr instructions, use ``getSourceElementType()``.; * For calls, use ``getFunctionType()``.; * For allocas, use ``getAllocatedType()``.; * For globals, use ``getValueType()``.; * For consistency assertions, use; ``PointerType::isOpaqueOrPointeeTypeEquals()``.; * To create a pointer type in a different address space, use; ``PointerType::getWithSamePointeeType()``.; * To check that two pointers have the same element type, use; ``PointerType::hasSameElementTypeAs()``.; * While it is preferred to write code in a way that accepts both typed and; opaque pointers, ``Type::isOpaquePointerTy()`` and; ``PointerType::isOpaque()`` can be used to handle opaque pointers specially.; ``PointerType::getNonOpaquePointerElementType()`` can be used as a marker in; code-paths where opaque pointers have b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:6782,avoid,avoid,6782,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['avoid'],['avoid']
Safety,"terating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,; `derived pointers`_ must not be retained across safe points and `object; pointers`_ must be reloaded from stack roots. **SDISel**; Selection DAG Instruction Selection. **SCC**; Strongly Connected Component. **SCCP**; Sparse Conditional Constant Propagation. **SLP**; Superword-Level Parallelism, same as :ref:`Basic-Block Vectorization; <lexicon-bb-vectorization>`. **Splat**; Splat refers to a vector of identical scalar elements. The term is based on the PowerPC Altivec instructions that provided; this functionality in hardware. For example, ""vsplth"" and the corresponding; software intrinsic ""vec_splat()"". Examples of other hardware names for this; action include ""duplicate"" (ARM) and ""broadcast"" (x86). **SRoA**; Scalar Replacement of Aggregates. **SSA**; Static Single Assignment. **Stack Map**; In garbage collection, metadata emitted by the code generator which; identifies `roots`_ withi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:7785,safe,safe,7785,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['safe'],['safe']
Safety,"ters visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. This semantic quirk allows the runtime to pick a; integer mapping for each point in the program allowing relocations of objects; without visible effects. This high level abstract machine model is used for most of the optimizer. As; a result, transform passes do not need to be e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:4216,safe,safepoint,4216,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"tes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15531,recover,recovery,15531,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recovery']
Safety,"tever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14688,detect,detected,14688,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['detect'],['detected']
Safety,"text will be updated; once the API churn dies down.**. Welcome to Chapter 3 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter discusses lazy JITing and shows you how to enable it by adding an ORC; CompileOnDemand layer the JIT from `Chapter 2 <BuildingAJIT2.html>`_. Lazy Compilation; ================. When we add a module to the KaleidoscopeJIT class from Chapter 2 it is; immediately optimized, compiled and linked for us by the IRTransformLayer,; IRCompileLayer and RTDyldObjectLinkingLayer respectively. This scheme, where all the; work to make a Module executable is done up front, is simple to understand and; its performance characteristics are easy to reason about. However, it will lead; to very high startup times if the amount of code to be compiled is large, and; may also do a lot of unnecessary compilation if only a few compiled functions; are ever called at runtime. A truly ""just-in-time"" compiler should allow us to; defer the compilation of any given function until the moment that function is; first called, improving launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each function in them to be compiled the; first time it is called. To do this, the CompileOnDemandLayer creates two small; utilities for each function that it scans: a *stub* and a *compile; callback*. The stub is a pair of a function pointer (which will be pointed at; the function's implementation once the function has been compiled) and an; indirect jump through the pointer. By fixing the address of the indirect jump; for the lifetime of the program we can give the function a permanent ""effective; address"", one that can be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:1612,redund,redundant,1612,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['redund'],['redundant']
Safety,"th :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46052,redund,redundant,46052,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['redund'],['redundant']
Safety,"th access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312782,safe,safe,312782,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"th are optional. The ""selection of target"" behavior is defined as follows:. (1) If the user does not specify -triple, we default to the host triple.; (2) If the user specifies a -arch, that overrides the arch in the host or; specified triple. //===---------------------------------------------------------------------===//. verifyInputConstraint and verifyOutputConstraint should not return bool. Instead we should return something like:. enum VerifyConstraintResult {; Valid,. // Output only; OutputOperandConstraintLacksEqualsCharacter,; MatchingConstraintNotValidInOutputOperand,. // Input only; InputOperandConstraintContainsEqualsCharacter,; MatchingConstraintReferencesInvalidOperandNumber,. // Both; PercentConstraintUsedWithLastOperand; };. //===---------------------------------------------------------------------===//. Blocks should not capture variables that are only used in dead code. The rule that we came up with is that blocks are required to capture; variables if they're referenced in evaluated code, even if that code; doesn't actually rely on the value of the captured variable. For example, this requires a capture:; (void) var;; But this does not:; if (false) puts(var);. Summary of <rdar://problem/9851835>: if we implement this, we should; warn about non-POD variables that are referenced but not captured, but; only if the non-reachability is not due to macro or template; metaprogramming. //===---------------------------------------------------------------------===//. We can still apply a modified version of the constructor/destructor; delegation optimization in cases of virtual inheritance where:; - there is no function-try-block,; - the constructor signature is not variadic, and; - the parameter variables can safely be copied and repassed; to the base constructor because either; - they have not had their addresses taken by the vbase initializers or; - they were passed indirectly. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt:3744,safe,safely,3744,interpreter/llvm-project/clang/NOTES.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt,1,['safe'],['safely']
Safety,"th libc++; newer than 2016-11-16. ``<algorithm>``; ---------------. In C++14, many useful functions from ``<algorithm>`` (notably, ``std::min`` and; ``std::max``) become constexpr. You can therefore use these in device code,; when compiling with clang. Detecting clang vs NVCC from code; =================================. Although clang's CUDA implementation is largely compatible with NVCC's, you may; still want to detect when you're compiling CUDA code specifically with clang. This is tricky, because NVCC may invoke clang as part of its own compilation; process! For example, NVCC uses the host compiler's preprocessor when; compiling for device code, and that host compiler may in fact be clang. When clang is actually compiling CUDA code -- rather than being used as a; subtool of NVCC's -- it defines the ``__CUDA__`` macro. ``__CUDA_ARCH__`` is; defined only in device mode (but will be defined if NVCC is using clang as a; preprocessor). So you can use the following incantations to detect clang CUDA; compilation, in host and device modes:. .. code-block:: c++. #if defined(__clang__) && defined(__CUDA__) && !defined(__CUDA_ARCH__); // clang compiling CUDA code, host mode.; #endif. #if defined(__clang__) && defined(__CUDA__) && defined(__CUDA_ARCH__); // clang compiling CUDA code, device mode.; #endif. Both clang and nvcc define ``__CUDACC__`` during CUDA compilation. You can; detect NVCC specifically by looking for ``__NVCC__``. Dialect Differences Between clang and nvcc; ==========================================. There is no formal CUDA spec, and clang and nvcc speak slightly different; dialects of the language. Below, we describe some of the differences. This section is painful; hopefully you can skip this section and live your life; blissfully unaware. Compilation Models; ------------------. Most of the differences between clang and nvcc stem from the different; compilation models used by clang and nvcc. nvcc uses *split compilation*,; which works roughly as follows",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:8235,detect,detect,8235,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['detect'],['detect']
Safety,"that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC mode",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71578,unsafe,unsafe,71578,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"that we try to maintain some; backwards compatibility. The rules are intended as a balance between convenience; for llvm users and not imposing a big burden on llvm developers:. * The textual format is not backwards compatible. We don't change it too often,; but there are no specific promises. * Additions and changes to the IR should be reflected in; ``test/Bitcode/compatibility.ll``. * The current LLVM version supports loading any bitcode since version 3.0. * After each X.Y release, ``compatibility.ll`` must be copied to; ``compatibility-X.Y.ll``. The corresponding bitcode file should be assembled; using the X.Y build and committed as ``compatibility-X.Y.ll.bc``. * Newer releases can ignore features from older releases, but they cannot; miscompile them. For example, if nsw is ever replaced with something else,; dropping it would be a valid way to upgrade the IR. * Debug metadata is special in that it is currently dropped during upgrades. * Non-debug metadata is defined to be safe to drop, so a valid way to upgrade; it is to drop it. That is not very user friendly and a bit more effort is; expected, but no promises are made. C API Changes; -------------. * Stability Guarantees: The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:32397,safe,safe,32397,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['safe'],['safe']
Safety,"the ROOT file embedding (PR [#10558](https://github.com/root-project/root/pull/10558)). In particular, a `RNTupleReader` or `RDataFrame` object can be created from a `TFile` instance as follows; ```; auto f = TFile::Open(""data.root"");; auto ntpl = f->Get<ROOT::Experimental::RNTuple>(""Events"");. auto reader = ROOT::Experimental::RNTupleReader::Open(ntpl);; // or for RDataFrame; auto rdf = ROOT::Experimental::MakeNTupleDataFrame(ntpl);; ```. - If buffered write is enabled, vector writes are used where possible. In particular, this yields important improvements in storage backends leveraging parallel writes, e.g. in object storages. - Large read/write throughput improvements in the experimental Intel DAOS backend. - `RNTupleWriter::Fill()` now returns the number of uncompressed bytes written, which is align with TTree behavior. - Support for user-defined classes that behave as a collection via the `TVirtualCollectionProxy` interface.; Fields created via `RFieldBase::Create()` automatically detect the presence of a collection proxy at run-time. However, if `RField<T>` (`T` being a class) is used instead, the trait `IsCollectionProxy<T>` must be set for the given type (see PR [#11525](https://github.com/root-project/root/pull/11525) for details).; Note that associative collections are not yet supported. - Some internal support for per field post-read callbacks. This functionality will be presented in upcoming releases through custom I/O rules. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. ## RDataFrame. ### New features. - Add [`GraphAsymmErrors`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#acea30792eef607489d498bf6547a00a6) action that fills a TGraphAsymmErrors object.; - Introduce [`RDatasetSpec`](https://root.cern/doc/master/classROOT_1_1RDF_1_1Experimental_1_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:9978,detect,detect,9978,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['detect'],['detect']
Safety,"the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));; ```. ### Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10811,avoid,avoid,10811,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['avoid'],['avoid']
Safety,"the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99338,predict,predictable,99338,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['predict'],['predictable']
Safety,"the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:128049,redund,redundancy,128049,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['redund'],['redundancy']
Safety,"the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192327,unsafe,unsafe,192327,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161449,safe,safety,161449,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:41420,detect,detect,41420,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['detect'],['detect']
Safety,"the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .. code-block:: console. $ cmake -G Ninja -C <path to clang>/cmake/caches/DistributionExample.cmake <path to LLVM source>; $ ninja stage2-distribution; $ ninja stage2-install-distribution. Difference between ``install`` and ``install-distribution``; -----------------------------------------------------------. One subtle but important thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific part",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:2440,safe,safe,2440,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['safe'],['safe']
Safety,"the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414423,safe,safely,414423,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20206,avoid,avoid,20206,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,"['avoid', 'safe']","['avoid', 'safety']"
Safety,"the program, or inlined away; completely. The :doc:`LLVM test-suite <TestSuiteMakefileGuide>` provides a framework to; test the optimizer's handling of debugging information. It can be run like; this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=dbgopt. This will test impact of debugging information on optimization passes. If; debugging information influences optimization passes then it will be reported; as a failure. See :doc:`TestingGuide` for more information on LLVM test; infrastructure and how to run various tests. .. _format:. Debugging information format; ============================. LLVM debugging information has been carefully designed to make it possible for; the optimizer to optimize the program and debugging information without; necessarily having to know anything about debugging information. In; particular, the use of metadata avoids duplicated debugging information from; the beginning, and the global dead code elimination pass automatically deletes; debugging information for a function if it decides to delete the function. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:6555,avoid,avoids,6555,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoids']
Safety,"the resulting object at all. It is just used; in the assembler to differentiate the sections. The 'o' flag is mapped to SHF_LINK_ORDER. If it is present, a symbol; must be given that identifies the section to be placed is the; .sh_link. .. code-block:: gas. .section .foo,""a"",@progbits; .Ltmp:; .section .bar,""ao"",@progbits,.Ltmp. which is equivalent to just. .. code-block:: gas. .section .foo,""a"",@progbits; .section .bar,""ao"",@progbits,.foo. ``.linker-options`` Section (linker options); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to support passing linker options from the frontend to the linker, a; special section of type ``SHT_LLVM_LINKER_OPTIONS`` (usually named; ``.linker-options`` though the name is not significant as it is identified by; the type). The contents of this section is a simple pair-wise encoding of; directives for consideration by the linker. The strings are encoded as standard; null-terminated UTF-8 strings. They are emitted inline to avoid having the; linker traverse the object file for retrieving the value. The linker is; permitted to not honour the option and instead provide a warning/error to the; user that the requested option was not honoured. The section has type ``SHT_LLVM_LINKER_OPTIONS`` and has the ``SHF_EXCLUDE``; flag to ensure that the section is treated as opaque by linkers which do not; support the feature and will not be emitted into the final linked binary. This would be equivalent to the follow raw assembly:. .. code-block:: gas. .section "".linker-options"",""e"",@llvm_linker_options; .asciz ""option 1""; .asciz ""value 1""; .asciz ""option 2""; .asciz ""value 2"". The following directives are specified:. - lib. The parameter identifies a library to be linked against. The library will; be looked up in the default and any specified library search paths; (specified to this point). - libpath. The parameter identifies an additional library search path to be considered; when looking up libraries after the inclusion of this option. ``SHT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:6441,avoid,avoid,6441,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,1,['avoid'],['avoid']
Safety,"the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer beyond it is; prevented at run time. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:19906,safe,safety,19906,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple platform. For all other targets the ``extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Because a list; cannot contain an element with a semi-colon to construct a list of lists you; make a list of variable names that refer to other lists. For example:. .. code-block:: cmake. set(list_of_lists a b c); set(a 1 2 3); set(b 4 5 6); set(c 7 8 9). With this layout you can iterate through the list of lists printing each value; with the following code:. .. code-block:: cmake. foreach(list_name IN LISTS list_of_lists); foreach(value IN LISTS ${list_name}); message(${value}); endforeach(); endforeach(). You'll notice that the inner foreach loop's list is doubly dereferenced. This is; because the first dereferenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:4325,avoid,avoid,4325,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['avoid'],['avoid']
Safety,"the; profile. As you make changes to your code, clang may no longer be able to; use the profile data. It will warn you when this happens. Note that ``-fprofile-use`` option is semantically equivalent to; its GCC counterpart, it *does not* handle profile formats produced by GCC.; Both ``-fprofile-use`` and ``-fprofile-instr-use`` accept profiles in the; indexed format, regardeless whether it is produced by frontend or the IR pass. .. option:: -fprofile-generate[=<dirname>]. The ``-fprofile-generate`` and ``-fprofile-generate=`` flags will use; an alternative instrumentation method for profile generation. When; given a directory name, it generates the profile file; ``default_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-prof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:107885,risk,risk,107885,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['risk'],['risk']
Safety,"ther SIMD; operations are enabled or not. The default set of attributes is set by the; current CPU. For a list of available attributes, use:. .. code-block:: none. llvm-as < /dev/null | llc -march=xyz -mattr=help. .. option:: --frame-pointer. Specify effect of frame pointer elimination optimization (all,non-leaf,none). .. option:: --disable-excess-fp-precision. Disable optimizations that may produce excess precision for floating point.; Note that this option can dramatically slow down code on some systems; (e.g. X86). .. option:: --enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: --enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: --enable-no-signed-zeros-fp-math. Enable FP math optimizations that assume the sign of 0 is insignificant. .. option:: --enable-no-trapping-fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:3864,unsafe,unsafe,3864,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['unsafe'],['unsafe']
Safety,ther we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; },MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82509,safe,safe,82509,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ther; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9710,timeout,timeout,9710,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['timeout'],['timeout']
Safety,"therwise make it part of the module. **Example:** The C header ``assert.h`` is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different ``NDEBUG`` settings). However, declarations within it should typically be split into a separate modular header. .. parsed-literal::. module std [system] {; textual header ""assert.h""; }. A given header shall not be referenced by more than one *header-declaration*. Two *header-declaration*\s, or a *header-declaration* and a ``#include``, are; considered to refer to the same file if the paths resolve to the same file; and the specified *header-attr*\s (if any) match the attributes of that file,; even if the file is named differently (for instance, by a relative path or; via symlinks). .. note::; The use of *header-attr*\s avoids the need for Clang to speculatively; ``stat`` every header referenced by a module map. It is recommended that; *header-attr*\s only be used in machine-generated module maps, to avoid; mismatches between attribute values and the corresponding files. Umbrella directory declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; An umbrella directory declaration specifies that all of the headers in the specified directory should be included within the module. .. parsed-literal::. *umbrella-dir-declaration*:; ``umbrella`` *string-literal*. The *string-literal* refers to a directory. When the module is built, all of the header files in that directory (and its subdirectories) are included in the module. An *umbrella-dir-declaration* shall not refer to the same directory as the location of an umbrella *header-declaration*. In other words, only a single kind of umbrella can be specified for a given directory. .. note::. Umbrella directories are useful for libraries that have a large number of headers but do not have an umbrella header. Submodule declaration; ~~~~~~~~~~~~~~~~~~~~~; Submodule declarations describe modules that are nested within their enclosing module. .. pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:38765,avoid,avoid,38765,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['avoid'],['avoid']
Safety,"thmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards under the rules for excess precision in intermediate operands;; see the discussion of evaluation formats in the C standard and [expr.pre] in; the C++ standard. The use of excess precision can be independently controlled for these two; types with the ``-ffloat16-excess-precision=`` and; ``-fbfloat16-excess-precision=`` options. Valid values include:. * ``none``: meaning to perform strict operation-by-operation emulation; * ``standard``: meaning that excess precision is permitted under the rules; described in the standard, i.e. never across explicit casts or statements; * ``fast``: meaning that excess precision is permitted whenever the; optimizer sees an opportunity to avoid truncations; currently this has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:33668,avoid,avoid,33668,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"thout call Hash (and hence be linear rather than; logarithmic complexity). You will also see warnings like; ```; Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; ```; - When a container relies on TObject::Hash and RecursiveRemove, for example THashTable, the container uses ```TObject::CheckedHash()``` instead of ```TObject::Hash``` during insertion operation to record in the object whether the Hash/RecursiveRemove setup is done properly (as explain above). It this is not the case ```TObject::HasInconsistentHash()``` will return true. This can then be used to select, in RecursiveRemove, whether the call to Hash can be trusted or if one needs to do a linear search (as was done in v6.10 and earlier).; - In TClass::GetMissingDictionaries activate the search through the base classes.; - Added a TStatusBitsChecker to avoid Status Bits overlap in class hierarchy deriving from TObject (and resolved a handful of conflicts).; - Introduced support for type safe range-for-loop for ROOT collection. The typical use is:. ```; for(auto bcl : TRangeDynCast<TBaseClass>( * cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; ```; - ClassDefInline has been enhanced even for some compiled class (without a dictionary). ClassDefInline can still not be used for class template instance using Double32_t or Float16_t as a template parameter or for class or class template that do not have a public default constructor.; - ROOT's backport of `std::string_view` has been updated to follow what's available in C++17, notably its `to_string` member function has been removed. ### Thread safety. Resolved the race conditions inherent to the use of the RecursiveRemove mechanism. - Introduced ```ROOT::TReentrantRWLock`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:3387,avoid,avoid,3387,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['avoid'],['avoid']
Safety,tializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159136,Redund,Redundancy,159136,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Redund'],['Redundancy']
Safety,"till 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:8158,avoid,avoid,8158,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['avoid'],['avoid']
Safety,"till load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8720,predict,prediction,8720,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['prediction']
Safety,"time) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75486,detect,detector,75486,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detector']
Safety,"ting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes over (in processCallExit) and finds the return value of the; function, if it has one. This is bound to the expression that triggered the; call. (In the case of calls without origin expressions, such as destructors,; this step is skipped.). 3. Dead symbols and bindings are cleaned out from the state, including any local; bindings. 4. A CallExitEnd node is generated, which marks the transition back to the; caller's LocationContext. 5. Custom post-call checks are processed and the final nodes are pushed back; onto the work list, so that evaluation of the caller can continue. Retry Without Inlining; ^^^^^^^^^^^^^^^^^^^^^^. In some cases, we would like to retry analysis without inlining a particular; call. Currently, we use this technique to recover coverage in case we stop; analyzing a path due to exceeding the maximum block count inside an inlined; function. When this situation is detected, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:6514,recover,recover,6514,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['recover'],['recover']
Safety,"ting the limit higher than; 2 is thus harmless. To facilitate debugging, after reaching the limit, lit will make one extra pass; and report an error if the ``RUN:`` line changes again. In the above example,; setting the limit to 1 will thus cause lit to report an error instead of; producing incorrect output. Options; -------. The llvm lit configuration allows to customize some things with user options:. ``llc``, ``opt``, ...; Substitute the respective llvm tool name with a custom command line. This; allows to specify custom paths and default arguments for these tools.; Example:. % llvm-lit ""-Dllc=llc -verify-machineinstrs"". ``run_long_tests``; Enable the execution of long running tests. ``llvm_site_config``; Load the specified lit configuration instead of the default one. Other Features; --------------. To make RUN line writing easier, there are several helper programs. These; helpers are in the PATH when running tests, so you can just call them using; their name. For example:. ``not``; This program runs its arguments and then inverts the result code from it.; Zero result codes become 1. Non-zero result codes become 0. To make the output more useful, :program:`lit` will scan; the lines of the test case for ones that contain a pattern that matches; ``PR[0-9]+``. This is the syntax for specifying a PR (Problem Report) number; that is related to the test case. The number after ""PR"" specifies the; LLVM Bugzilla number. When a PR number is specified, it will be used in; the pass/fail reporting. This is useful to quickly get some context when; a test fails. Finally, any line that contains ""END."" will cause the special; interpretation of lines to terminate. This is generally done right after; the last RUN: line. This has two side effects:. (a) it prevents special interpretation of lines that are part of the test; program, not the instructions to the test case, and. (b) it speeds things up for really big test cases by avoiding; interpretation of the remainder of the file.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:39326,avoid,avoiding,39326,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoiding']
Safety,"ting-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:175895,unsafe,unsafe-floating,175895,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe-floating']
Safety,"tinual evolution, and this document must be updated as the; language progresses. If a change increases the expressiveness of the language, for example by; lifting a restriction or by adding new syntax, the change will be annotated; with a revision marker, like so:. ARC applies to Objective-C pointer types, block pointer types, and; :when-revised:`[beginning Apple 8.0, LLVM 3.8]` :revision:`BPTRs declared; within` ``extern ""BCPL""`` blocks. For now, it is sensible to version this document by the releases of its sole; implementation (and its host project), clang. ""LLVM X.Y"" refers to an; open-source release of clang from the LLVM project. ""Apple X.Y"" refers to an; Apple-provided release of the Apple LLVM Compiler. Other organizations that; prepare their own, separately-versioned clang releases and wish to maintain; similar information in this document should send requests to cfe-dev. If a change decreases the expressiveness of the language, for example by; imposing a new restriction, this should be taken as an oversight in the; original specification and something to be avoided in all versions. Such; changes are generally to be avoided. .. _arc.general:. General; =======. Automatic Reference Counting implements automatic memory management for; Objective-C objects and blocks, freeing the programmer from the need to; explicitly insert retains and releases. It does not provide a cycle collector;; users must explicitly manage the lifetime of their objects, breaking cycles; manually or with weak or unsafe references. ARC may be explicitly enabled with the compiler flag ``-fobjc-arc``. It may; also be explicitly disabled with the compiler flag ``-fno-objc-arc``. The last; of these two flags appearing on the compile line ""wins"". If ARC is enabled, ``__has_feature(objc_arc)`` will expand to 1 in the; preprocessor. For more information about ``__has_feature``, see the; :ref:`language extensions <langext-__has_feature-__has_extension>` document. .. _arc.objects:. Retainable objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:8650,avoid,avoided,8650,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoided']
Safety,"tinuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather than. ```sh; C:\Program Files (x86)\Python 2.7; ```; * Path to all the required executables should be present in the Windows; **PATH** environment variable.; * In case of MSYS Git, choose the option ""Run Git from Windows; Command Prompt"" during installation. A good way to check if everything is detected properly by the script is to; run the following command:; ```sh; cd tools/packaging/; ./cpt.py --check-requirements; ```. #### Red Hat Linux (Fedora/Scientific Linux CERN); This section applies to all distros based on Red Hat Linux like Fedora, and; Scientific Linux CERN (SLC). Apparently, you can build RPM packages in any; distro regardless of the package manager it uses. This has been tested on; Fedora, SLC, Ubuntu, and CrunchBang. If you are interested, you can test it; on your favourite platform and email me the results. Depending on the package manager of your distro, you can install the; packages required by CPT to build RPM bundles. For a Red Hat based distro; (which uses ```yum``` package manager), you can use the following command; (also performed automatically by CPT):; ```sh; sudo yum update; sudo yum install git gcc gcc-c++ rpm-build python; ```. #### Mac OS X; Mac OS X provides a sane environement for CPT to build Apple Disk Images; (DMG Installers). On older versions of Mac OS, you need to u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:4644,detect,detected,4644,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['detect'],['detected']
Safety,"tion may include more detailed data than a logical; view created from a binary file with CodeView/COFF debug information. The following options describe the elements to compare. .. option:: --compare=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below elements. .. code-block:: text. =lines: Include lines.; =scopes: Include scopes.; =symbols: Include symbols.; =types: Include types. :program:`llvm-debuginfo-analyzer` takes the first binary file on the; command line as the **reference** and the second one as the **target**.; To get a more descriptive report, the comparison is done twice. The; reference and target views are swapped, in order to produce those; **missing** elements from the target view and those **added** elements; to the reference view. See :option:`--report` options on how to describe the comparison; reports. .. _warning_:. WARNING; ~~~~~~~; When reading the input object files, :program:`llvm-debuginfo-analyzer`; can detect issues in the raw debug information. These may not be; considered fatal to the purpose of printing a logical view but they can; give an indication about the quality and potentially expose issues with; the generated debug information. The following options describe the warnings to be recorded for later; printing, if they are requested by :option:`--print`. .. option:: --warning=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below warnings. The following options collect additional information during the creation; of the logical view, to include invalid coverage values and locations; for symbols; invalid code ranges; lines that are zero. .. code-block:: text. =coverages: Invalid symbol coverages values.; =lines: Debug lines that are zero.; =locations: Invalid symbol locations.; =ranges: Invalid code ranges. .. _internal_:. INTERNAL; ~~~~~~~~; For a better understanding of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:21366,detect,detect,21366,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['detect'],['detect']
Safety,"tion system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimensions and the type in a single list.; That is just too confusing:; [10, 40, int]; This seems to be a 3-D array where the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:1994,risk,risky,1994,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['risk'],['risky']
Safety,"tion that we can only; have one ""top level"" command at a time to reduce the number of; changes necessary. Here's the sample program we'll be compiling:. .. code-block:: python. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. fib(10). Why is this a hard problem?; ===========================. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly created instructions, but merged; instructions only get to keep a single location - this can cause jumping; around when stepping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables, or difficult to track. For the purposes of this; tutorial we're going to avoid optimization (as you'll see with one of the; next sets of patches). Ahead-of-Time Compilation Mode; ==============================. To highlight only the aspects of adding debug information to a source; language without needing to worry about the complexities of JIT debugging; we're going to make a few changes to Kaleidoscope to support compiling; the IR emitted by the front end into a simple standalone program that; you can execute, debug, and see results. First we make our anonymous function that contains our top level; statement be our ""main"":. .. code-block:: udiff. - auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; + auto Proto = std::make_unique<PrototypeAST>(""main"", std::vector<std::string>());. just with the simple change of giving it a name. Then we're going to remove the command line code wherever it exists:. .. code-block:: udiff. @@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {; /// top ::= definition | external | expression | ';'; stat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:2351,avoid,avoid,2351,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['avoid'],['avoid']
Safety,"tion-macros) (either in a single translation unit or in the build system), and creating a legacy iterator will trigger a compiler warning such as:; ```; <path>/RooChebychev.cxx:66:34: warning: 'createIterator' is deprecated: There is a superior alternative: begin(), end() and range-based for loops. [-Wdeprecated-declarations]; TIterator* coefIter = coefList.createIterator() ;; ^; 1 warning generated.; ```. ## TMVA. This release provides a consolidation and several fixes of the new machine learning tools provided in TMVA such as the Deep Learning module.; The method `TMVA::Types::kDL` should be used now for building Deep Learning architecture in TMVA, while `TMVA::Types::kDNN` is now deprecated. `TMVA::Types::kDL` provides all the functionality of `TMVA::Types::kDNN`, i.e building fully connected dense layer, but in addition supports building convolutional and recurrent neural network architectures.; These release contains improvements in the `MethodDL` such as:; - fix droput support for dense layer; - add protection to avoid returning NaN in the cross-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number of threads; - add possibility to control options for configuring GPU running. FOr example we can now set the mode to allocate memory only as needed. This is required when using the new RTX gaming cards from NVIDIA. ## 2D Graphics Libraries. - In the statistics painting for 2D histograms, the central cell of; the underflow/overflow grid was not properly rendered for very large contents.; This problem was reported [here](https://root-forum.cern.ch/t/stat-box-for-th2/).; - The automatic placement of legend now ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:17795,avoid,avoid,17795,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['avoid'],['avoid']
Safety,"tion. A; retainable object pointer type is **weak-unavailable** if; is a pointer to an (optionally protocol-qualified) Objective-C class ``T`` where; ``T`` or one of its superclasses has the ``objc_arc_weak_reference_unavailable``; attribute. A program is ill-formed if it applies the ``__weak`` ownership; qualifier to a weak-unavailable type or if the value operand of a weak; assignment operation has a weak-unavailable type. .. _arc.ownership.restrictions.autoreleasing:. Storage duration of ``__autoreleasing`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it declares an ``__autoreleasing`` object of; non-automatic storage duration. A program is ill-formed if it captures an; ``__autoreleasing`` object in a block or, unless by reference, in a C++11; lambda. .. admonition:: Rationale. Autorelease pools are tied to the current thread and scope by their nature.; While it is possible to have temporary objects whose instance variables are; filled with autoreleased objects, there is no way that ARC can provide any; sort of safety guarantee there. It is undefined behavior if a non-null pointer is assigned to an; ``__autoreleasing`` object while an autorelease pool is in scope and then that; object is read after the autorelease pool's scope is left. .. _arc.ownership.restrictions.conversion.indirect:. Conversion of pointers to ownership-qualified types; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if an expression of type ``T*`` is converted,; explicitly or implicitly, to the type ``U*``, where ``T`` and ``U`` have; different ownership qualification, unless:. * ``T`` is qualified with ``__strong``, ``__autoreleasing``, or; ``__unsafe_unretained``, and ``U`` is qualified with both ``const`` and; ``__unsafe_unretained``; or; * either ``T`` or ``U`` is ``cv void``, where ``cv`` is an optional sequence; of non-ownership qualifiers; or; * the conversion is requested with a ``reinterpret_cast`` in Objective-C++;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:43102,safe,safety,43102,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safety']
Safety,"tive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. \defgroup Tubes Tubes; \ingroup Shapes_classes; Tubes have Z as their symmetry axis. \defgroup Cones Cones; \ingroup Shapes_classes; Conical tube classes. \defgroup Trapezoids Trapezoids; \ingroup Shapes_classes; In general, we will call trapezoidal shapes having 8 vertices and up to; 6 trapezoid faces. Besides that, two of the opposite faces are parallel; to XY plane and are positioned at ` dZ`. Since general trapezoids are; seldom used in detector geometry descriptions, there are several; primitives implemented in the modeller for particular cases. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:10927,detect,detector,10927,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['detect'],['detector']
Safety,"tly call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape fr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161566,safe,safety,161566,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,2,['safe'],"['safe', 'safety']"
Safety,"tness of bounds annotations; when the pointer and/or the related value containing the bounds information are; updated or passed as arguments. This is done by compile-time restrictions or; run-time checks (see `Maintaining correctness of bounds annotations`_; for more detail). For instance, initializing ``buf`` with ``null`` while; assigning non-zero value to ``count``, as shown in the following example, would; violate the ``__counted_by`` annotation because a null pointer does not point to; any valid memory location. To avoid this, the compiler produces either a; compile-time error or run-time trap. .. code-block:: c. void null_with_count_10(int *__counted_by(count) buf, unsigned count) {; buf = 0;; // This is not allowed as it creates a null pointer with non-zero length; count = 10;; }. However, there are use cases where a pointer is either a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:12478,safe,safety,12478,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the options `para`and `candle`.; * Fix detection of errors that appears in nested TTreeFormula [ROOT-8218]; * Better basket size optimization by taking into account meta data and rounding up to next 512 bytes, ensuring a complete cluster fits into a single basket. ### Fast Cloning. We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078]. It can be controlled from the `TTreeCloner`, `TTree::CopyEntries` or `hadd` interfaces. The new cache is enabled by default, to update the size of the cache or disable it from `TTreeCloner` use: `TTreeCloner::SetCacheSize`. To do the same from `TTree::CopyEntries` add to the option string ""cachesize=SIZE"". To update the size of the cache or disable it from `hadd`, use the command line option `-cachesize SIZE`. `SIZE` shouyld be given in number bytes and can be expressed in 'human readable form' (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. ### Other Changes. * Update `TChain::LoadTree` so that the user call back routine is actually call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:9238,detect,detection,9238,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['detect'],['detection']
Safety,"to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59803,unsafe,unsafe-math-optimizations,59803,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe-math-optimizations']
Safety,"to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The ocaml frametable structure supports liveness information. It would be good; to support it. //===---------------------------------------------------------------------===//. The FIXME in ComputeCommonTailLength in BranchFolding.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the wrong thing. //===---------------------------------------------------------------------===//. It would be really nice to be able to write patterns in .td files for copies,; which would eliminate a bunch of explicit predicates on them (e.g. no side; effects). Once this is in place, it would be even better to have tblgen; synthesize the various copy insertion/inspection methods in TargetInstrInfo. //===---------------------------------------------------------------------===//. Stack coloring improvements:. 1. Do proper LiveStacks analysis on all stack objects including those which are; not spill slots.; 2. Reorder objects to fill in gaps between objects.; e.g. 4, 1, <gap>, 4, 1, 1, 1, <gap>, 4 => 4, 1, 1, 1, 1, 4, 4. //===---------------------------------------------------------------------===//. The scheduler should be able to sort nearby instructions by their address. For; example, in an expanded memset sequence it's not uncommon to see code like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:4354,detect,detect,4354,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['detect'],['detect']
Safety,"to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer annotation.; Type conversions that change bounds attributes may be allowed if it does not; violate the invariant of the destination or that can be verified at run time.; Here are some of the important cast rules. Two pointers that have different bounds annotations on their nested pointer; types are incompatible and cannot implicitly cast to each other. For example,; ``T *__single *__single`` cannot be converted to ``T *__bidi_indexable; *__single``. Such a conversion between incompatible nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:38934,safe,safety,38934,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['safe'],['safety']
Safety,"to replace; it with any other `i1` value. Any pass can; freely do it if it can benefit from non-default lowering. '``llvm.load.relative``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.load.relative.iN(ptr %ptr, iN %offset) nounwind memory(argmem: read). Overview:; """""""""""""""""". This intrinsic loads a 32-bit value from the address ``%ptr + %offset``,; adds ``%ptr`` to that value and returns it. The constant folder specifically; recognizes the form of this intrinsic and the constant initializers it may; load from; if a loaded constant initializer is known to have the form; ``i32 trunc(x - %ptr)``, the intrinsic call is folded to ``x``. LLVM provides that the calculation of such a constant initializer will; not overflow at link time under the medium code model if ``x`` is an; ``unnamed_addr`` function. However, it does not provide this guarantee for; a constant initializer folded into a function body. This intrinsic can be; used to avoid the possibility of overflows when loading from such a constant. .. _llvm_sideeffect:. '``llvm.sideeffect``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.sideeffect() inaccessiblememonly nounwind willreturn. Overview:; """""""""""""""""". The ``llvm.sideeffect`` intrinsic doesn't perform any operation. Optimizers; treat it as having side effects, so it can be inserted into a loop to; indicate that the loop shouldn't be assumed to terminate (which could; potentially lead to the loop being optimized away entirely), even if it's; an infinite loop with no other side effects. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic actually does nothing, but optimizers must assume that it; has externally observable side effects. '``llvm.is.constant.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.is.constant with any argument type. ::. declare i1 @llvm.is.constant.i32(i32 %operand) nounwind m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:951583,avoid,avoid,951583,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531072,detect,detect,531072,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detect']
Safety,"to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ``` {.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ```. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig `(default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telling if the current track will enter inside some daughter of the; current volume or it will exit inside its container:. ``` {.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ```. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:117493,safe,safety,117493,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ~~~{.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig ` (default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telling if the current track will enter inside some daughter of the; current volume or it will exit inside its container:. ~~~{.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ~~~. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:77941,safe,safety,77941,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"to zero out all of the loaded bits. Even; though this code pattern may still execute speculatively, *invalid* speculative; executions are prevented from leaking secret data from memory (but note that; this data might still be loaded in safe ways, and some regions of memory are; required to not hold secrets, see below for detailed limitations). This; approach only requires the underlying hardware have a way to implement a; branchless and unpredicted conditional update of a register's value. All modern; architectures have support for this, and in fact such support is necessary to; correctly implement constant time cryptographic primitives. Crucial properties of this approach:; * It is not preventing any particular side-channel from working. This is; important as there are an unknown number of potential side channels and we; expect to continue discovering more. Instead, it prevents the observation of; secret data in the first place.; * It accumulates the predicate state, protecting even in the face of nested; *correctly* predicted control flows.; * It passes this predicate state across function boundaries to provide; [interprocedural protection](#interprocedural-checking).; * When hardening the address of a load, it uses a *destructive* or; *non-reversible* modification of the address to prevent an attacker from; reversing the check using attacker-controlled inputs.; * It does not completely block speculative execution, and merely prevents; *mis*-speculated paths from leaking secrets from memory (and stalls; speculation until this can be determined).; * It is completely general and makes no fundamental assumptions about the; underlying architecture other than the ability to do branchless conditional; data updates and a lack of value prediction.; * It does not require programmers to identify all possible secret data using; static source code annotations or code vulnerable to a variant #1 style; attack. Limitations of this approach:; * It requires re-compiling source code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:5468,predict,predicted,5468,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['predicted']
Safety,"to; ``3 * sizeof(int*)``). When ``sizeof()`` takes an expression, i.e., ``sizeof(expr``, it behaves as; ``sizeof(typeof(expr))``, except that ``sizeof(expr)`` does not report an error; with ``expr`` that has a type with an external bounds annotation dependent on; another declaration, whereas ``typeof()`` on the same expression would be an; error as described in :ref:`Default pointer types in typeof`.; The following example describes this behavior. .. code-block:: c. void foo(int *__counted_by(size) p, size_t size) {; // sizeof(p) == sizeof(int *__counted_by(size)) == sizeof(int *); // typeof(p): error; };. Default pointer types in ``alignof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``alignof()`` only takes a type name as the argument and it doesn't take an; expression. Similar to ``sizeof()`` and ``typeof``, the compiler doesn't apply; an implicit bounds annotation on the pointer types named inside ``alignof()``.; Therefore, ``alignof(T *)`` remains the same with or without; ``-fbounds-safety``, evaluating into the alignment of the raw pointer ``T *``.; The programmers can explicitly add a bounds annotation to the types, e.g.,; ``alignof(int *__bidi_indexable)``, which returns the alignment of ``int; *__bidi_indexable``. A bounds annotation including an internal bounds annotation; (i.e., ``__indexable`` and ``__bidi_indexable``) doesn't affect the alignment of; the original pointer. Therefore, ``alignof(int *__bidi_indexable)`` is equal to; ``alignof(int *)``. Default pointer types used in C-style casts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer type used in a C-style cast (e.g., ``(int *)src``) inherits the same; pointer attribute in the type of src. For instance, if the type of src is ``T; *__single`` (with ``T`` being an arbitrary C type), ``(int *)src`` will be ``int; *__single``. The reasoning behind this behavior is so that a C-style cast; doesn't introduce any unexpected side effects caused by an implicit cast of; bounds attribute. Pointer cas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:29575,safe,safety,29575,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"to; the LLVM infrastructure at all. It works with any and all LLVM passes and code; generators, and does not need to ""know"" how they work. Because of this, it may; appear to do stupid things or miss obvious simplifications. ``bugpoint`` is; also designed to trade off programmer time for computer time in the; compiler-debugging process; consequently, it may take a long period of; (unattended) time to reduce a test case, but we feel it is still worth it. Note; that ``bugpoint`` is generally very quick unless debugging a miscompilation; where each test of the program (which requires executing it) takes a long time. Automatic Debugger Selection; ----------------------------. ``bugpoint`` reads each ``.bc`` or ``.ll`` file specified on the command line; and links them together into a single module, called the test program. If any; LLVM passes are specified on the command line, it runs these passes on the test; program. If any of the passes crash, or if they produce malformed output (which; causes the verifier to abort), ``bugpoint`` starts the `crash debugger`_. Otherwise, if the ``-output`` option was not specified, ``bugpoint`` runs the; test program with the ""safe"" backend (which is assumed to generate good code) to; generate a reference output. Once ``bugpoint`` has a reference output for the; test program, it tries executing it with the selected code generator. If the; selected code generator crashes, ``bugpoint`` starts the `crash debugger`_ on; the code generator. Otherwise, if the resulting output differs from the; reference output, it assumes the difference resulted from a code generator; failure, and starts the `code generator debugger`_. Finally, if the output of the selected code generator matches the reference; output, ``bugpoint`` runs the test program after all of the LLVM passes have; been applied to it. If its output differs from the reference output, it assumes; the difference resulted from a failure in one of the LLVM passes, and enters the; `miscompil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:1961,abort,abort,1961,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['abort'],['abort']
Safety,"toc@ha; addis 4, 2, .LCPI0_1@toc@ha; addi 3, 3, .LCPI0_0@toc@l; addi 4, 4, .LCPI0_1@toc@l; lxvw4x 0, 0, 3; addi 3, 1, -16; lxvw4x 35, 0, 4; stxvw4x 0, 0, 3; ori 2, 2, 0; lxvw4x 34, 0, 3; addi 3, 1, -32; stxvw4x 35, 0, 3; vpmsumb 2, 2, 3; blr; .long 0; .quad 0. The two stxvw4x instructions are not needed.; With -mtriple=powerpc64le-unknown-linux-gnu, the associated permutes; are present too. //===----------------------------------------------------------------------===//. The following example is found in test/CodeGen/PowerPC/vec_add_sub_doubleword.ll:. define <2 x i64> @increment_by_val(<2 x i64> %x, i64 %val) nounwind {; %tmpvec = insertelement <2 x i64> <i64 0, i64 0>, i64 %val, i32 0; %tmpvec2 = insertelement <2 x i64> %tmpvec, i64 %val, i32 1; %result = add <2 x i64> %x, %tmpvec2; ret <2 x i64> %result. This will generate the following instruction sequence:; std 5, -8(1); std 5, -16(1); addi 3, 1, -16; ori 2, 2, 0; lxvd2x 35, 0, 3; vaddudm 2, 2, 3; blr. This will almost certainly cause a load-hit-store hazard. ; Since val is a value parameter, it should not need to be saved onto; the stack, unless it's being done set up the vector register. Instead,; it would be better to splat the value into a vector register, and then; remove the (dead) stores to the stack. //===----------------------------------------------------------------------===//. At the moment we always generate a lxsdx in preference to lfd, or stxsdx in; preference to stfd. When we have a reg-immediate addressing mode, this is a; poor choice, since we have to load the address into an index register. This; should be fixed for P7/P8. . //===----------------------------------------------------------------------===//. Right now, ShuffleKind 0 is supported only on BE, and ShuffleKind 2 only on LE.; However, we could actually support both kinds on either endianness, if we check; for the appropriate shufflevector pattern for each case ... this would cause; some additional shufflevectors to be recognized and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:7925,hazard,hazard,7925,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,2,['hazard'],['hazard']
Safety,"together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75175,avoid,avoids,75175,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"tom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _RawStringFormats:. **RawStringFormats** (``List of RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting supported languages code blocks in raw; strings. A raw string with a matching delimiter or a matching enclosing function; name will be reformatted assuming the specified language based on the; style for that language defined in the .clang-format file. If no style has; been defined in the .clang-format file for the specific language, a; predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; found, the formatting is based on llvm style. A matching delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:98496,detect,detecting,98496,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['detect'],['detecting']
Safety,"tor operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and count assignments and the likes.; * Bounds check expressions in AST and the Clang code generation (this could also; be divided into multiple sub-PRs). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:11339,safe,safety,11339,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],['safety']
Safety,"tra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56720,detect,detect,56720,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['detect'],['detect']
Safety,"trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3478,recover,recover,3478,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10211,recover,recover,10211,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,2,['recover'],['recover']
Safety,"tructions at a maximum vector; length of 512 bits, which is a superset of instructions ``-mavx10.N`` enabled. Current binaries built with AVX512 features can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:159561,avoid,avoid,159561,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['avoid'],['avoid']
Safety,"try (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In **`TGeo`**, physical nodes are represented by; the class **`TGeoPhysicalNo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145687,detect,detector,145687,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"try block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9000,avoid,avoiding,9000,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['avoid'],['avoiding']
Safety,"ts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3167,avoid,avoid,3167,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,1,['avoid'],['avoid']
Safety,"ts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from target code (e.g. messages on assert failure). - 0 (default): close neither ``stdout`` nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list of flags run the fuzzer binary with ``-help=1``. Output; ======. During operation the fuzzer prints information to ``stderr``, for example::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:14141,detect,detect,14141,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"tself may be; annotated with ``__ended_by(Q)``. In this case, the end of the range extends; to the pointer ``Q``. This is used for ""iterator"" support in C where you're; iterating from one pointer value to another until a final pointer value is; reached (and the final pointer value is not dereferencable). Accessing a pointer outside the specified bounds causes a run-time trap or a; compile-time error. Also, the model maintains correctness of bounds annotations; when the pointer and/or the related value containing the bounds information are; updated or passed as arguments. This is done by compile-time restrictions or; run-time checks (see `Maintaining correctness of bounds annotations`_; for more detail). For instance, initializing ``buf`` with ``null`` while; assigning non-zero value to ``count``, as shown in the following example, would; violate the ``__counted_by`` annotation because a null pointer does not point to; any valid memory location. To avoid this, the compiler produces either a; compile-time error or run-time trap. .. code-block:: c. void null_with_count_10(int *__counted_by(count) buf, unsigned count) {; buf = 0;; // This is not allowed as it creates a null pointer with non-zero length; count = 10;; }. However, there are use cases where a pointer is either a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:12051,avoid,avoid,12051,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"ttern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement for raw profile data files is greatly; increased. To avoid issues like this, the ``%m`` specifier can used in the profile; name. When this specifier is used, the profiler runtime will substitute ``%m``; with a unique integer identifier associated with the instrumented binary. Additionally,; multiple raw profiles dumped from different processes that share a file system (can be; on different hosts) will be automatically merged by the profiler runtime during the; dumping. If the program links in multiple instrumented shared libraries, each library; will dump the profile data into its own profile data file (with its unique integer; id embedded in the profile name). Note that the merging enabled by ``%m`` is for raw; profile data generated by profiler runtime. The resulting merged ""raw"" profile data; file still needs to be converted to a different format expected by the compiler (; see step 3 below). .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%m.profraw"" ./code. See `this <SourceBasedCodeCoverage.html#running-the-instrumented-program>`_ section; about the ``%t``, and ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:105107,avoid,avoid,105107,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['avoid'],['avoid']
Safety,"tting it into another is not necessarily easier than re-doing it.; > Optimization code is usually heavily tied in to the specific IR they use. Understood. The only reason that I brought this up is because SGI's IR is; more similar to LLVM than it is different in many respects (SSA based,; relatively low level, etc), and could be easily adapted. Also their; optimizations are written in C++ and are actually somewhat; structured... of course it would be no walk in the park, but it would be; much less time consuming to adapt, say, SSA-PRE than to rewrite it. > But your larger point is valid that adding SSA based optimizations is; > feasible and should be fun. (Again, link time cost is the issue.). Assuming linktime cost wasn't an issue, the question is: ; Does using GCC's backend buy us anything?. > It also occurs to me that GCC is probably doing quite a bit of back-end; > optimization (step 16 in your list). Do you have a breakdown of that?. Not really. The irritating part of GCC is that it mixes it all up and; doesn't have a clean separation of concerns. A lot of the ""back end; optimization"" happens right along with other data optimizations (ie, CSE; of machine specific things). As far as REAL back end optimizations go, it looks something like this:. 1. Instruction combination: try to make CISCy instructions, if available; 2. Register movement: try to get registers in the right places for the; architecture to avoid register to register moves. For example, try to get; the first argument of a function to naturally land in %o0 for sparc.; 3. Instruction scheduling: 'nuff said :); 4. Register class preferencing: ??; 5. Local register allocation; 6. global register allocation; 7. Spilling; 8. Local regalloc; 9. Jump optimization; 10. Delay slot scheduling; 11. Branch shorting for CISC machines; 12. Instruction selection & peephole optimization; 13. Debug info output. But none of this would be usable for LLVM anyways, unless we were using; GCC as a static compiler. -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt:2426,avoid,avoid,2426,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,1,['avoid'],['avoid']
Safety,"tween. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6407,safe,safety,6407,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ty of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1391,predict,predictable,1391,interpreter/llvm-project/clang/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst,1,['predict'],['predictable']
Safety,"type.; For instance, a `std::vector<Event>` can be projected onto a `std::vector<float>` for a float member of `Event`.; Projected fields are stored as header meta-data. Fields can be added to a model after the writing process has started (cf. `RNTupleWriter::CreateModelUpdater()`).; This is called _late model extension_.; Addition of fields invalidates previously created entries.; The values of deferred fields for the already written entries is set to the default constructed type of the field. ### REntry; The REntry represents a row/entry in an RNTuple.; It contains a list of `RValue` objects that correspond to the top-level fields of the originating model.; The entry gives access to the shared pointers corresponding to the top-level fields.; It also provides functionality to bind application-provided pointers. An REntry can be passed to `RNTupleWriter::Fill()` and `RNTupleReader::LoadEntry()`.; Otherwise, the reader/writer uses the default entry of its model. An entry can safely outlive its originating model.; New objects cannot anymore be created (`EmplaceNewValue` will throw an exception), but the entry is still properly destructed. ### RNTupleWriter, RNTupleParallelWriter; The RNTupleWriter is the primary interface to create an RNTuple.; The writer takes ownership of a given model.; The writer can either add an RNTuple to an existing ROOT file (`RNTupleWriter::Append()`) or create a new ROOT file with an RNTuple (`RNTupleWriter::Recreate()`).; Once created, entries are added to an RNTuple either serially (`RNTupleWriter::Fill()`) or in concurrently in multiple threads with the `RNTupleParallelWriter`.; Once committed (e.g. by releasing the RNTupleWriter), the RNTuple is immutable and cannot be amended.; An RNTuple that is currently being written cannot be read. ### RNTupleReader; The RNTupleReader is the primary interface to read and inspect an RNTuple.; An RNTupleReader owns a model: either a model created from the on-disk information or an imposed, user-provid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:11910,safe,safely,11910,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['safe'],['safely']
Safety,"types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187787,redund,redundant,187787,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['redund'],['redundant']
Safety,"typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13959,redund,redundant,13959,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['redund'],['redundant']
Safety,"u=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will filter out all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific configurations, such as; with debug builds or on particular platforms. Use ``REQUIRES``; and ``UNSUPPORTED`` to control when the test is enabled. Some tests are expected to fail. For example, there may be a known bug; that the test detect. Use ``XFAIL`` to mark a test as an expected failure.; An ``XFAIL`` test will be successful if its execution fails, and; will be a failure if its execution succeeds. .. code-block:: llvm. ; This test will be only enabled in the build with asserts.; ; REQUIRES: asserts; ; This test is disabled when running on Linux.; ; UNSUPPORTED: system-linux; ; This test is expected to fail when targeting PowerPC.; ; XFAIL: target=powerpc{{.*}}. ``REQUIRES`` and ``UNSUPPORTED`` and ``XFAIL`` all accept a comma-separated; list of boolean expressions. The values in each expression may be:. - Features added to ``config.available_features`` by configuration files such as ``lit.cfg``.; String comparison of features is case-sensitive. Furthermore, a boolean expression can; contain any Python regular expression enclosed in ``{{ }}``, in which case the boolean; expression is satisfied if any feature matches the regular expression. Regular; expressions can appear inside an identi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:19821,detect,detect,19821,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['detect'],['detect']
Safety,"ual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:35962,unsafe,unsafe,35962,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"uc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLVM a bit more. That might give us clues on how to; structure LLVM to support one or more language VMs. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:1162,safe,safety,1162,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,4,"['risk', 'safe']","['risk', 'safety']"
Safety,"uces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking Methods. ![Safety computation checking](pictures/030001E0.png). In order to check a given point, `CheckPoint(x,y,z)` method of; **`TGeoManager`** draws the daughters of the volume containing the point; one le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134615,detect,detected,134615,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detected']
Safety,"uction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. This semantic quirk allows the runtime to pick a; integer mapping for eac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3968,safe,safepoints,3968,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"ude ""llvm/IR/Function.h""; #include ""llvm/IR/DataLayout.h""; #include ""llvm/Target/TargetAsmInfo.h""; #include ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. // And for each live root...; for (GCFunctionInfo::liv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37774,safe,safe,37774,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ude ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. // And for each live root...; for (GCFunctionInfo::live_iterator LI = MD.live_begin(PI),; LE = MD.live_end(PI);; LI != LE; ++LI) {; // Emit live root's offset",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37898,safe,safe,37898,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ueries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ``` {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51290,safe,safe,51290,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"ueries might be sometimes useful:. ~~~ {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ~~~. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ~~~ {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ~~~. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ~~~ {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ~~~. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ~~~ {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ~~~. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ~~~ {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:5006,safe,safe,5006,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,"uffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, follo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23308,abort,abort,23308,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"uffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; }; // Complete kRaw tesselation section; if ((reqSections & TBuffer3D::kRaw) &&; buffer.SectionsValid(TBuffer3D::kRawSizes)) {; SetPoints(buffer.fPnts);; // Transform points to master frame if viewer requires it; // The fLocalFrame flag and translation matrix will have; // already been set in TGeoShape::FillBuffer3D() as required; if (!buffer.fLocalFrame); TransformPoints(buffer.fPnts, buffer.NbPnts());; SetSegsAndPols(buffer);; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; return buffer;; }; ```. Note:. - we use a static **`TBuffer3D`** derived object for efficiency - once; the object is added the buffer can be reused. - `kRawSize` (the calculation of tessellation sizing required in; buffer) and `kRaw` (the actual filling of tessellation) is split, as; the X3D viewer requires two publication passes - one to establish; the full tessellation capacity for all shapes, and another to; actually add them. Splitting avoids having to do the expensive; tessellation on the first pass. #### Shape Specific TBuffer3D Derived Classes. Currently we provide the following shape specific classes, which the GL; Viewer can take advantage of (see `TBuffer3D.h` and `TBuffer3DTypes.h`). - **`TBuffer3DSphere`** - solid, hollow and cut spheres (GL Viewer; only supports solid spheres at present - cut / hollow ones will be; requested as tessellated objects by client.). - **`TBuffer3DTube`** - basic tube with inner/outer radius and length. - **`TBuffer3DTubeSeg`** - angle tube segment. - **`TBuffer3DCutTube`** - angle tube segment with plane cut ends. See the above example from `TGeoSphere::GetBuffer3D` and also equivalent; functions in **`TGeoTube`**, **`TGeoTubeSeg`** and **`TGeoCtub`**.; Anyone is free to add new **`TBuffer3D`** classes, but it should be; clear that one or more viewers will require updating to be able to take; advantage of them. Hence we only provide classes which existing viewers; can benefit from. The number of native shape",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:131438,avoid,avoids,131438,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['avoid'],['avoids']
Safety,"uild your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Anot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3965,abort,aborting,3965,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,2,"['abort', 'recover']","['aborting', 'recover']"
Safety,"uivalent to ""``catch i8* null``"",; because ``filter`` and ``catch`` produce negative and positive selector; values respectively.). - ``cleanup``. - This clause means that the landingpad should always be entered. - C++ front-ends use this for calling objects' destructors. - When this clause is matched, the selector value will be zero. - The runtime may treat ""``cleanup``"" differently from ""``catch <type>; null``"". In C++, if an unhandled exception occurs, the language runtime will call; ``std::terminate()``, but it is implementation-defined whether the runtime; unwinds the stack and calls object destructors first. For example, the GNU; C++ unwinder does not call object destructors when an unhandled exception; occurs. The reason for this is to improve debuggability: it ensures that; ``std::terminate()`` is called from the context of the ``throw``, so that; this context is not lost by unwinding the stack. A runtime will typically; implement this by searching for a matching non-``cleanup`` clause, and; aborting if it does not find one, before entering any landingpad blocks. Once the landing pad has the type info selector, the code branches to the code; for the first catch. The catch then checks the value of the type info selector; against the index of type info for that catch. Since the type info index is not; known until all the type infos have been gathered in the backend, the catch code; must call the `llvm.eh.typeid.for`_ intrinsic to determine the index for a given; type info. If the catch fails to match the selector then control is passed on to; the next catch. Finally, the entry and exit of catch code is bracketed with calls to; ``__cxa_begin_catch`` and ``__cxa_end_catch``. * ``__cxa_begin_catch`` takes an exception structure reference as an argument; and returns the value of the exception object. * ``__cxa_end_catch`` takes no arguments. This function:. #. Locates the most recently caught exception and decrements its handler; count,. #. Removes the exception fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:10679,abort,aborting,10679,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['abort'],['aborting']
Safety,"ularity** --- SelectionDAG and FastISel are radically different and share; very little code. GlobalISel is built in a way that enables code reuse. For instance, both the; optimized and fast selectors share the :ref:`pipeline`, and targets can; configure that pipeline to better suit their needs. Design and Implementation Reference; ===================================. More information on the design and implementation of GlobalISel can be found in; the following sections. .. toctree::; :maxdepth: 1. GMIR; GenericOpcode; MIRPatterns; Pipeline; Porting; Resources. More information on specific passes can be found in the following sections:. .. toctree::; :maxdepth: 1. IRTranslator; Legalizer; RegBankSelect; InstructionSelect; KnownBits. .. _progress:. Progress and Future Work; ========================. The initial goal is to replace FastISel on AArch64. The next step will be to; replace SelectionDAG as the optimized ISel. ``NOTE``:; While we iterate on GlobalISel, we strive to avoid affecting the performance of; SelectionDAG, FastISel, or the other MIR passes. For instance, the types of; :ref:`gmir-gvregs` are stored in a separate table in ``MachineRegisterInfo``,; that is destroyed after :ref:`instructionselect`. .. _progress-fastisel:. FastISel Replacement; --------------------. For the initial FastISel replacement, we intend to fallback to SelectionDAG on; selection failures. Currently, compile-time of the fast pipeline is within 1.5x of FastISel.; We're optimistic we can get to within 1.1/1.2x, but beating FastISel will be; challenging given the multi-pass approach.; Still, supporting all IR (via a complete legalizer) and avoiding the fallback; to SelectionDAG in the worst case should enable better amortized performance; than SelectionDAG+FastISel. ``NOTE``:; We considered never having a fallback to SelectionDAG, instead deciding early; whether a given function is supported by GlobalISel or not. The decision would; be based on :ref:`milegalizer` queries.; We abandoned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/index.rst:2082,avoid,avoid,2082,interpreter/llvm-project/llvm/docs/GlobalISel/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/index.rst,1,['avoid'],['avoid']
Safety,"uld leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6030,safe,safe-stack,6030,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['safe'],['safe-stack']
Safety,"uld; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_sta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6684,safe,safe-stack,6684,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,3,['safe'],"['safe', 'safe-stack']"
Safety,"ules to nontrivial ownership qualifiers; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Nontrivially ownership-qualified types are considered non-trivial; to copy, destroy, and default-initialize. A dynamic object of nontrivially ownership-qualified type contingently; exists at a location if the memory is filled with a zero pattern, e.g.; by ``calloc`` or ``bzero``. Such an object can be safely accessed in; all of the cases above, but its memory can also be safely repurposed.; Assigning a null pointer into an l-value of ``__weak`` or; ``__strong``-qualified type accesses the dynamic object there (and thus; may have undefined behavior if no such object exists), but afterwards; the object's memory is guaranteed to be filled with a zero pattern; and thus may be either further accessed or repurposed as needed.; The upshot is that programs may safely initialize dynamically-allocated; memory for nontrivially ownership-qualified types by ensuring it is zero-initialized, and they may safely deinitialize memory before; freeing it by storing ``nil`` into any ``__strong`` or ``__weak``; references previously created in that memory. C/C++ compatibility for structs and unions with non-trivial members; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Structs and unions with non-trivial members are compatible in; different language modes (e.g. between Objective-C and Objective-C++,; or between ARC and non-ARC modes) under the following conditions:. - The types must be compatible ignoring ownership qualifiers according; to the baseline, non-ARC rules (e.g. C struct compatibility or C++'s; ODR). This condition implies a pairwise correspondence between; fields. Note that an Objective-C++ class with base classes, a user-provided; copy or move constructor, or a user-provided destructor is never; compatible with an Objective-C type. - If two fields correspond as above, and at least one of the fields is; ownership-qualified, then:. - the fields m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:60571,safe,safely,60571,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['safe'],['safely']
Safety,"ull as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shift-base`` or; ``-fsanitize=shift-exponent`` to check only left-hand side or; right-hand side of shift operation, respectively.; - ``-fsanitize=unsigned-shift-base``: check that an unsigned l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7506,detect,detect,7506,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['detect'],['detect']
Safety,"ume or it will exit inside its container:. ``` {.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ```. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:118861,safe,safety,118861,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"und or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect the standard input of the test program, whenever; it runs, to come from that file. **--load** *plugin*. Load the dynamic object *plugin* into **bugpoint** itself. This object should; register new optimization passes. Once loaded, the object will add new command; line options to enable various optimizations. To see the new complete list of; optimizations, use the **-help** and **--load** options together; for example:. .. code-block:: bash. bugpoint --load myNewPass.so -help. **--mlimit** *megabytes*. Specifies an upper limit on memory usage of the optimization and codegen. Set; to zero to disable the limit. **--output** *filename*. Whenever the test program produces output on its standard output stream, it; should match the contents of *filename* (the ""reference output""). If you; do not use this option, **bugpoint** will attempt to generate a reference output; by compiling the program with the ""safe"" backend and running it. **--run-{int,jit,llc,custom}**. Whenever the test program is compiled, **bugpoint** should generate code for it; using the specified code generator. These options allow you to choose the; interpreter, the JIT compiler, the static native code compiler, or a; custom command (see **--exec-command**) respectively. **--safe-{llc,custom}**. When debugging a code generator, **bugpoint** should use the specified code; generator as the ""safe"" code generator. This is a known-good code generator; used to generate the ""reference output"" if it has not been provided, and to; compile portions of the program that as they are excluded from the testcase.; These options allow you to choose the; static native code compiler, or a custom command, (see **--exec-command**); respectively. The interpreter and the JIT backends cannot currently; be used as the ""safe"" backends. **--exec-command** *command*. This option defines the comman",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:4117,safe,safe,4117,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['safe'],['safe']
Safety,"unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5351,safe,safe,5351,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['safe'],['safe']
Safety,"unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isolated loops with unsafe; memory dependencies will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_fallback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:308812,unsafe,unsafe,308812,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"unsigned int test(int i) {; return i;; }. different.NumericTruncation; (C); Numeric truncation might take place.; Source: ; CWE-197. unsigned long test(unsigned long long ull) {; unsigned long ul = ull; // warn; return ul;; }. void f(int i);. void test(long long sll) {; f(sll); // warn; }. int f();. short test(long long sll) {; short ss = f();; return ss;; }. different.MissingCopyCtorAssignOp; (C++); A class has dynamically allocated data members but do not define a copy; constructor/assignment operator.; Source: Scott Meyers ""Effective C++"", item 11: Prevent exceptions from; leaving destructors. class C {; int *p; // warn; public:; C() { p = new int; }; ~C() { delete p; }; };. WinAPI. Name, DescriptionExampleProgress. WinAPI.CreateProcess; (C); CreateProcess(): if the first parameter ; lpApplicationName is NULL then the executable name must be in the; white space-delimited string pointed to by lpCommandLine.; If the executable or path name has a space in it, there is a risk that a; different executable could be run because of the way the function parses; spaces.; Source: ; MSDN: CreateProcess function, Security Remarks. #include <windows.h>. void test() {; STARTUPINFO si;; PROCESS_INFORMATION pi;; CreateProcess(NULL, TEXT(""C:\\Program Files\\App -L -S""),; NULL, NULL, TRUE, 0, NULL, NULL, &si, π);; // warn; }. WinAPI.LoadLibrary; (C); The SearchPath() function is used to retrieve a path to a DLL for; a subsequent LoadLibrary() call.; Source: ; MSDN: LoadLibrary function, Security Remarks. #include <windows.h>. HINSTANCE test() {; char filePath[100];; SearchPath(NULL, ""file.dll"", NULL, 100, filePath, NULL);; return LoadLibrary(filePath); // warn; }. WinAPI.WideCharToMultiByte; (C); Buffer overrun while calling WideCharToMultiByte(). The size of; the input buffer equals the number of characters in the Unicode string, while; the size of the output buffer equals the number of bytes.; Source: ; MSDN: WideCharToMultiByte function. #include <windows.h>. void test() {; wchar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:26097,risk,risk,26097,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,2,['risk'],['risk']
Safety,"unted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6250,redund,redundant,6250,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['redund'],['redundant']
Safety,"untime provide :block-term:`copy` and; :block-term:`release` operations for Block references that create and,; in matched use, release allocated storage for referenced Blocks. The copy operation ``Block_copy()`` is styled as a function that takes; an arbitrary Block reference and returns a Block reference of the same; type. The release operation, ``Block_release()``, is styled as a; function that takes an arbitrary Block reference and, if dynamically; matched to a Block copy operation, allows recovery of the referenced; allocated memory. The ``__block`` Storage Qualifier; =================================. In addition to the new Block type we also introduce a new storage; qualifier, :block-term:`__block`, for local variables. [testme: a; __block declaration within a block literal] The ``__block`` storage; qualifier is mutually exclusive to the existing local storage; qualifiers auto, register, and static. [testme] Variables qualified by; ``__block`` act as if they were in allocated storage and this storage; is automatically recovered after last use of said variable. An; implementation may choose an optimization where the storage is; initially automatic and only ""moved"" to allocated (heap) storage upon; a Block_copy of a referencing Block. Such variables may be mutated as; normal variables are. In the case where a ``__block`` variable is a Block one must assume; that the ``__block`` variable resides in allocated storage and as such; is assumed to reference a Block that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specificat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:7348,recover,recovered,7348,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['recover'],['recovered']
Safety,"upport LZMA decompression of ROOT files #272; 11. Include ZSTD decompression to repository #274; 12. Support opacity transfer function for `TH3`, see tutorials/gl/glvox2.C; 13. Upgrade three.js r155 -> r158; 14. Handle TCanvas IsEdiatable flag to disable some interactive features; 15. Support PDF creation using jsPDF and svg2pdf.js - in browser and node.js; 16. Implement custom fonts support in TWebCanvas; 17. List of ROOT/JSON files on server with `&dir=<path>` URL parameter #283; 18. Load TGaxis function from the file #282; 19. Let display progress messages in modal element #285; 20. Fix - do not add `THStack` and `TMultiGraph` to legend; 21. Fix - correctly use margin in `TPaveText` class; 22. Fix - correctly draw endcaps in legend errors; 23. Fix - vertical position of up elements like {M}^{2} in TLatex; 24. Fix - let draw THStack with diff binning hists; 25. Fix - better tooltip name for the items; 26. Fix - better logy scale selection. ## Changes in 7.5.5; 1. Fix - abort tree draw operation faster; 2. Fix - support plain TRI option for TGraph2D; 3. Fix - use latest npm ""gl"" module. ## Changes in 7.5.4; 1. Fix - catch exception when parsing TF1 formula; 2. Fix - properly check THStack histograms axes when doing sum; 3. Fix - correctly handle negative offset on time axis; 4. Fix - do not use `inset` because of old Chrome browsers; 5. Fix - properly provide object hints. ## Changes in 7.5.3; 1. Fix - draw histograms with negative bins #276; 2. Fix - correctly read TLeaf with fixed-size array; 3. Fix - bug in options handling in startGUI; 4. Fix - greyscale support in TLegend drawing; 5. Fix - correctly use text font for TGaxis title; 6. Fix - preserve auto colors in THStack #277; 7. Fix - correctly set pave name #278. ## Changes in 7.5.2; 1. Fix - proper fit pars display in stats, proper #chi^{2}; 2. Fix - several bugs in TFormula parsing; 3. Fix - correctly use saved buffer in TF1/TF2; 4. Fix - properly adjust size of stats box; 5. Fix - support pol0..pol9 functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:7437,abort,abort,7437,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['abort'],['abort']
Safety,"upport atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144227,risk,risk,144227,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['risk'],['risk']
Safety,"urce file (default: `""""`). ``` {.cpp}; Root.Html.DescriptionStyle:; ```. Search path for the source and header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9524,detect,detecting,9524,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['detect'],['detecting']
Safety,"urce; consumption, but makes it easy for each bot to keep up with commit flow.; Additionally, splitting bots may assist in triage by narrowing attention to; relevant parts of the failing configuration. In general, we recommend Release build types with Assertions enabled. This; generally provides a good balance between build times and bug detection for; most buildbots. There may be room for including some debug info (e.g. with; `-gmlt`), but in general the balance between debug info quality and build; times is a delicate one. Use Ninja & LLD; Ninja really does help build times over Make, particularly for highly; parallel builds. LLD helps to reduce both link times and memory usage; during linking significantly. With a build machine with sufficient; parallelism, link times tend to dominate critical path of the build, and are; thus worth optimizing. Use CCache and NOT incremental builds; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the; builder less sensitive to which projects are being monitored vs built.; If a change triggers a build request, but doesn't change the build output; (e.g. doc changes, python utility changes, etc..), the build will entirely; hit in cache and the build request will complete in just the testing time. With multiple workers, it is tempting to try to configure a shared cache; between the workers. Experience to date indicates this is difficult to; well, and that having local per-worker caches gets most of the benefit; anyways. We don't currently recommend shared caches. CCache does depend on the builder hardware having sufficient IO to access; the cache with reasonable access t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:11201,risk,risk,11201,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['risk'],['risk']
Safety,"ure. - Header checksum (XxHash-3 64bit); - List frame of cluster summary record frames; - Nested list frame of page locations. #### Cluster Summary Record Frame; The cluster summary record frame contains the entry range of a cluster:. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + First Entry Number +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Entries |; + +-+-+-+-+-+-+-+-+; | | Flags |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. The order of the cluster summaries defines the cluster IDs,; starting from the first cluster ID of the cluster group that corresponds to the page list. Flag 0x01 is reserved for a future specification version that will support sharded clusters.; The future use of sharded clusters will break forward compatibility and thus introduce a corresponding feature flag.; For now, readers should abort when this flag is set.; Other flags should be ignored. #### Page Locations. The page locations are stored in a nested list frame as follows.; A top-most list frame where every item corresponds to a cluster.; The order of items corresponds to the cluster IDs as defined by the cluster groups and cluster summaries. Every item of the top-most list frame consists of an outer list frame where every item corresponds to a column.; Every item of the outer list frame is an inner list frame; whose items correspond to the pages of the column in the cluster.; The inner list is followed by a 64bit signed integer element offset and,; unless the column is suppressed, the 32bit compression settings; See next Section on ""Suppressed Columns"" for additional details.; Note that the size of the inner list frame includes the element offset and compression settings.; The order of the outer items must match the order of columns in the header and the extension header (small to large). The order of the inne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:33040,abort,abort,33040,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['abort'],['abort']
Safety,"ure.png; :align: center; :alt: Driver Architecture Diagram. Driver Stages; -------------. The driver functionality is conceptually divided into five stages:. #. **Parse: Option Parsing**. The command line argument strings are decomposed into arguments; (``Arg`` instances). The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4710,avoid,avoid,4710,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['avoid'],['avoid']
Safety,"ure_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has_constexpr_builtin`` is used in libcxx's implementation of; the ``<cmath>`` header file to conditionall",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1596,detect,detect,1596,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['detect'],['detect']
Safety,"used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; into some string that it owns. .. _dss_twine:. llvm/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallStr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:73965,safe,safe,73965,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"uses an IRCompileLayer and RTDyldObjectLinkingLayer to support; compilation of LLVM IR and linking of relocatable object files. All operations; are performed eagerly on symbol lookup (i.e. a symbol's definition is compiled; as soon as you attempt to look up its address). LLJIT is a suitable replacement; for MCJIT in most cases (note: some more advanced features, e.g.; JITEventListeners are not supported yet). The LLLazyJIT extends LLJIT and adds a CompileOnDemandLayer to enable lazy; compilation of LLVM IR. When an LLVM IR module is added via the addLazyIRModule; method, function bodies in that module will not be compiled until they are first; called. LLLazyJIT aims to provide a replacement of LLVM's original (pre-MCJIT); JIT API. LLJIT and LLLazyJIT instances can be created using their respective builder; classes: LLJITBuilder and LLazyJITBuilder. For example, assuming you have a; module ``M`` loaded on a ThreadSafeContext ``Ctx``:. .. code-block:: c++. // Try to detect the host arch and construct an LLJIT instance.; auto JIT = LLJITBuilder().create();. // If we could not construct an instance, return an error.; if (!JIT); return JIT.takeError();. // Add the module.; if (auto Err = JIT->addIRModule(TheadSafeModule(std::move(M), Ctx))); return Err;. // Look up the JIT'd code entry point.; auto EntrySym = JIT->lookup(""entry"");; if (!EntrySym); return EntrySym.takeError();. // Cast the entry point address to a function pointer.; auto *Entry = EntrySym.getAddress().toPtr<void(*)()>();. // Call into JIT'd code.; Entry();. The builder classes provide a number of configuration options that can be; specified before the JIT instance is constructed. For example:. .. code-block:: c++. // Build an LLLazyJIT instance that uses four worker threads for compilation,; // and jumps to a specific error handler (rather than null) on lazy compile; // failures. void handleLazyCompileFailure() {; // JIT'd code will jump here if lazy compilation fails, giving us an; // opportunity to exit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:4788,detect,detect,4788,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['detect'],['detect']
Safety,"using a different coordinate; system, or even an object from a different package as long as it implements the required signatures.; One such vector type is CLHEP's `Hep3Vector`:. ~~~{.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); ~~~. ### Arithmetic Operations. The following operations are possible between vector classes, even of different; coordinate system types:. ~~~{.cpp}; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; ~~~. Note that the multiplication between two vectors using the `operator *` is not supported; because it is ambiguous. ### Other Methods. The vector classes support methods for:. - computation of the dot product via Dot(),; - computation of the cross product via Cross(),; - construction of a unit vector via Unit(). \anchor GenVectorTransformations; ## Transformations. The transformations are modeled using simple (non-template) classes, using `double` as; the scalar type to avoid too large numerical errors. The transformations are grouped; in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may; model physically equivalent transformations but with different internal representations.; Transformation classes can operate on all type of vectors using the `operator()`; or the `operator *` and the transformations can also be combined via the `operator *`.; In more detail the transformations available are:. ### 3D Rotations. * ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; * ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein [definition](http://mathworld.wolfram.com/EulerAngles.html).; * ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; * ROOT::Math::AxisAngle, rotation described",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/doc/index.md:7540,avoid,avoid,7540,math/genvector/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/doc/index.md,1,['avoid'],['avoid']
Safety,"using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:2526,avoid,avoid,2526,hist/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html,2,['avoid'],['avoid']
Safety,"ustrated in several scripts referenced by the **`TPostScript`**; constructor. ### Writing Several Canvases to the Same PostScript File. The following sequence writes the canvas to ""`c1.ps`"" and closes the; postscript file:. ``` {.cpp}; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");; ```. If the Postscript file name finishes with ""`(`"", the file remains opened; (it is not closed). If the Postscript file name finishes with ""`)`"" and; the file has been opened with ""`(`"", the file is closed. ``` {.cpp}; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps""; // and ps file is closed; }; ```. The `TCanvas::Print(""file.ps("")` mechanism is very useful, but it can be; a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated; in some loop, one needs to detect the special cases of first and last; page. The ""`[`"" and ""`]`"" can be used instead of ""`(`"" and ""`)`"" as; shown in the next example. ``` {.cpp}; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; ```. The following script illustrates how to open a postscript file and draw; several pictures. The generation of a new postscript page is automatic; when **`TCanvas::Clear` is called by `object->Draw()`.**. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:96512,detect,detect,96512,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['detect'],['detect']
Safety,"utions in that; ``RUN:`` line using their current values from the substitution list. No; substitution expansion is performed immediately at ``DEFINE:`` and; ``REDEFINE:`` directives except ``%(line)``, ``%(line+<number>)``, and; ``%(line-<number>)``.; - When expanding substitutions in a ``RUN:`` line, lit makes only one pass; through the substitution list by default. In this case, a substitution must; have been inserted earlier in the substitution list than any substitution; appearing in its value in order for the latter to expand. (For greater; flexibility, you can enable multiple passes through the substitution list by; setting `recursiveExpansionLimit`_ in a lit configuration file.); - While lit configuration files can insert anywhere in the substitution list,; the insertion behavior of the ``DEFINE:`` and ``REDEFINE:`` directives is; specified below and is designed specifically for the use case presented in the; example above.; - Defining a substitution in terms of itself, whether directly or via other; substitutions, should be avoided. It usually produces an infinitely recursive; definition that cannot be fully expanded. It does *not* define the; substitution in terms of its previous value, even when using ``REDEFINE:``. The relationship between the ``DEFINE:`` and ``REDEFINE:`` directive is; analogous to the relationship between a variable declaration and variable; assignment in many programming languages:. - ``DEFINE: %{name} = value``. This directive assigns the specified value to a new substitution whose; pattern is ``%{name}``, or it reports an error if there is already a; substitution whose pattern contains ``%{name}`` because that could produce; confusing expansions (e.g., a lit configuration file might define a; substitution with the pattern ``%{name}\[0\]``). The new substitution is; inserted at the start of the substitution list so that it will expand first.; Thus, its value can contain any substitution previously defined, whether in; the same test fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:32140,avoid,avoided,32140,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoided']
Safety,"utomatically carry; bounds information and have no restrictions on kinds of pointer operations that; can be used with these pointers, most code inside a function works as is without; modification. In the example below, ``int *buf`` doesn't require manual; annotation as it's implicitly ``int *__bidi_indexable buf``, carrying the bounds; information passed from the return value of malloc, which is necessary to insert; bounds checking for ``buf[i]``. .. code-block:: c. void *__sized_by(size) malloc(size_t size);. int *__counted_by(n) get_array_with_0_to_n_1(size_t n) {; int *buf = malloc(sizeof(int) * n);; for (size_t i = 0; i < n; ++i); buf[i] = i;; return buf;; }. Annotations for sentinel-delimited arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A C string is an array of characters. The null terminator — the first null; character ('\0') element in the array — marks the end of the string.; ``-fbounds-safety`` provides ``__null_terminated`` to annotate C strings and the; generalized form ``__terminated_by(T)`` to annotate pointers and arrays with an; end marked by a sentinel value. The model prevents dereferencing a; ``__terminated_by`` pointer beyond its end. Calculating the location of the end; (i.e., the address of the sentinel value), requires reading the entire array in; memory and would have some performance costs. To avoid an unintended performance; hit, the model puts some restrictions on how these pointers can be used.; ``__terminated_by`` pointers cannot be indexed and can only be incremented one; element at a time. To allow these operations, the pointers must be explicitly; converted to ``__indexable`` pointers using the intrinsic function; ``__unsafe_terminated_by_to_indexable(P, T)`` (or; ``__unsafe_null_terminated_to_indexable(P)``) which converts the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:18015,safe,safety,18015,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"uts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; represented by a pointer to a memory location (in this case, a pointer; to an array of char, and a pointer to a function), and have one of the; following :ref:`linkage types <linkage>`. .. _linkage:. Linkage Types; -------------. All Global Variables and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references can be updated. This; doesn't show up in any symbol table in the object file.; ``internal``; Similar to private, but the value shows as a local symbol; (``STB_LOCAL`` in the case of ELF) in the object file. This; corresponds to the notion of the '``static``' keyword in C.; ``available_externally``; Globals with ""``available_externally``"" linkage are never emitted into; the object file corresponding to the LLVM module. From the linker's; perspective, an ``available_externally`` global is equivalent to; an external declaration. They exist to allow inlining and other; optimizations to take place given knowledge of the definition of the; global, which is known to be somewhere outside the module. Globals; with ``available_externally`` linkage are allowed to be discarded at; will, and allow inlining and other optimizations. This linkage type is; only allowed on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:7608,avoid,avoid,7608,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"ve optimization algorithm; 3. Fix - correct histogram Y-axis range selection in logarithmic scale; 4. Fix - for TH2 draw options allow combination ""colztext"" (#162); 5. Fix - PNG file generation with 3D drawings inside. ## Changes in 5.4.2; 1. Fix - take into account extra quotes in multipart http reply (#157); 2. Fix - display of labels on X axis with TProfile; 3. Fix - support time display in TMultiGraph; 4. Fix - correctly parse ""optstat"" and ""optfit"" in URL; 5. Fix - correctly update TGraph drawing when X range is changing; 6. Fix - return only TF1/TF2 object when searching function (#158). ## Changes in 5.4.1; 1. Fix - monitoring mode in draw.htm page; 2. Fix - zooming in colz palette; 3. Fix - support both 9.x and 10.x jsdom version in Node.js (#149); 4. Fix - draw axis main line with appropriate attributes (#150); 5. Fix - use axis color when drawing grids lines (#150); 6. Fix - when set pad logx/logy, reset existing user ranges in pad; 7. Fix - avoid too deep calling stack when drawing many graphs or histos (#154); 8. Fix - correctly (re)draw tooltips on canvas with many subpads. ## Changes in 5.4.0; 1. New supported classes:; - TDiamond; - TArc; - TCurlyLine; - TCurlyArc; - TCrown; 2. New draw options:; - ""RX"" and ""RY"" for TGraph to reverse axis; - ""noopt"" for TGraph to disable drawing optimization; - ""CPN"" for TCanvas to create color palette from N last colors; - ""line"" for TGraph2D; 3. New features:; - support LZ4 compression; - tooltips and zooming in TGraphPolar drawings; - TPavesText with multiple underlying paves; - implement all fill styles; - draw borders for TWbox; - draw all objects from TList/TObjArray as they appear in list of primitives; - let enable/disable highlight of extra objects in geometry viewer; - draw axis labels on both sides when pad.fTick[x/y] > 1; - make drawing of TCanvas with many primitives smoother; - add fOptTitle, fOptLogx/y/z fields in JSROOT.gStyle; 4. Behavior changes:; - disable automatic frame adjustment, can be enabled ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:35481,avoid,avoid,35481,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['avoid'],['avoid']
Safety,"ve. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an interleave count to the loop interleaver.; The first operand is the string ``llvm.loop.interleave.count`` and the; second operand is an integer specifying the interleave count. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.interleave.count"", i32 4}. Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving; multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0; then the interleave count will be determined automatically. '``llvm.loop.vectorize.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables vectorization for the loop. The; first operand is the string ``llvm.loop.vectorize.enable`` and the second operand; is a bit. If the bit operand value is 1 vectorization is enabled. A value of; 0 d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:296748,safe,safety,296748,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"vely, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4217,detect,detection,4217,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['detect'],['detection']
Safety,"verage` is now deprecated and will be removed in 6.32. It was only supposed to be an implementation detail of RooFits plotting that is now not necessary anymore.; - The `RooSpan` class was removed and its place in the implementation details of RooFit is now taken by `std::span`.; - The `RooAbsArg::isCloneOf()` and `RooAbsArg::getCloningAncestors()` member functions were removed because they didn't work (always returned `false` and an empty list respectively); - `ROOT::Math::KelvinFunctions` had an incompatible license and needed to be removed without deprecation.; - The use of `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT` have been deprecated in favor of parsing `etc/gitinfo.txt`. This later file is now generated as part of the build of ROOT; `RGitCommit.h` (defining `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT`) is not updated anymore. This simplifies ROOT's build and release procedure. ## Core Libraries. - Increase thread-safety in parts of core libraries (TCling, TClingMethodInfo, TClingTypeInfo, TFunction) to allow for parallel workflows using RDataFrame in multiple C++ `std::thread`s. ## I/O Libraries. - Improve parsing of input argument to `TChain::Add`. Now it supports the case of globbing files while also using the `?#` token to specify the tree name. ## RDataFrame; - instead of returning nothing, `ROOT::RDF::RunGraphs` now returns the number of separate computation graphs that have been run. - Introduce [`ProgressBar`](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#progressbar) feature that can be added to any RDataFrame program. - The `RDatasetSpec` class and its users now employ the concept of 'sample' rather than the original naming 'group' for groups of files with associated metadata. - `df106_HiggsToFourLeptons` tutorials (both python and C++) now showcase the `ProgressBar`. They now use `FromSpec` to define multiple samples and `Vary` for systematic variations. ### Distributed RDataFrame. - Vastly improve runtime performance when using an RDataFrame wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:4501,safe,safety,4501,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['safe'],['safety']
Safety,"version on, building ROOT with CMake requires CMake &gt;= 3.4.3. ## Core Libraries. ROOT prepares for [cxx modules](http://clang.llvm.org/docs/Modules.html). One of; the first requirements is its header files to be self-contained (section ""Missing; Includes""). ROOT header files were cleaned up from extra includes and the missing; includes were added. This could be considered as backward incompatibility (for good however). User; code may need to add extra includes, which were previously resolved indirectly; by including a ROOT header. For example:. * TBuffer.h - TObject.h doesn't include TBuffer.h anymore. Third party code,; replying on the definition of TBufer will need to include TBuffer.h, along; with TObject.h.; * TSystem.h - for some uses of gSystem.; * GeneticMinimizer.h; * ... Other improvements, which may cause compilation errors in third party code:. * If you get `std::type_info` from Rtypeinfo.h, `type_info` should be spelled; `std::type_info`. Also:. * `TPluginManager` was made thread-safe [ROOT-7927].; * On MacOSX, backtraces are now generated without external tools [ROOT-6667].; * The set of include paths considered by the interpreter has been reduced to the bare minimum. ### Containers. * A pseudo-container (generator) was created, `ROOT::TSeq<T>`. This template is inspired by the xrange built-in function of Python. See the example [here](https://root.cern.ch/doc/master/cnt001__basictseq_8C.html). ### Meta Library. Add a new mode for `TClass::SetCanSplit` (2) which indicates that this class and any derived class should not be split. This included a rework the mechanism checking the base classes. Instead of using `InheritsFrom`, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of `fCanSplit`. This also has the side-effect of allowing the extension of the concept '",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:3004,safe,safe,3004,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['safe'],['safe']
Safety,"visibility flag of specified volume and '-' sign to disable visibility.; One could use wildcard symbol like '+TUBE1*'. Another way to configure visibility flags is usage of ROOT macros, which typically looks like:. ```cpp; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; ```. Example of such macro can be found in root tutorials. From provided macro only following calls will be executed in JSROOT:. * `gGeoManager->DefaultColors()`; * `gGeoManager->GetVolume(""HALL"")->InvisibleAll()`; * `gGeoManager->GetVolume(""HALL"")->SetTransparency(30)`; * `gGeoManager->GetVolume(""HALL"")->SetLineColor(5)`; * `gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"")`. All other will be ignored. Example of major LHC detectors:; * ALICE: [full](https://root.cern/js/latest/?file=https://root.cern/files/alice2.root&item=Geometry;1&opt=macro:https://root.cern/js/files/geomAlice.C); * ATLAS: [full](https://root.cern/js/latest/?file=https://root.cern/files/atlas.root&item=atlas;1&opt=clipxyz), [cryo](https://root.cern/js/latest/?file=https://root.cern/files/atlas.root&item=atlas;1&opt=macro:https://root.cern/files/atlas_cryo.C), [sctt](https://root.cern/js/latest/?file=https://root.cern/files/atlas.root&item=atlas;1&opt=macro:https://root.cern/files/atlas_sctt.C); * CMS: [cmse](https://root.cern/js/latest/?file=https://root.cern/files/cms.root&item=cms;1&opt=macro:https://root.cern/files/cms_cmse.C;clipxyz), [calo](https://root.cern/js/latest/?file=https://root.cern/files/cms.root&item=cms;1&opt=macro:https://root.cern/files/cms_calo.C;clipxyz); * LHCb: [full](https://root.cern/js/latest/?file=https://root.cern/files/lhcbfull.root&item=Geometry;1&opt=all;dflt). Other detectors examples:; * HADES: [full](https://r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:23948,detect,detectors,23948,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['detect'],['detectors']
Safety,"void callee(uint32x2_t v) {; ...; }. <caller.c>; extern void callee(uint32x2_t);; void caller() {; callee(...);; }. If ``callee`` changed its signature to ``uint16x4_t``, which is equivalent in register content, if we passed as ``LD1`` we'd break this code until ``caller`` was updated and recompiled. There is an argument that if the signatures of the two functions are different then the behaviour should be undefined. But there may be functions that are agnostic to the lane layout of the vector, and treating the vector as an opaque value (just loading it and storing it) would be impossible without a common format across ABI boundaries. So to preserve ABI compatibility, we need to use the ``LDR`` lane layout across function calls. Alignment; ---------. In strict alignment mode, ``LDR qX`` requires its address to be 128-bit aligned, whereas ``LD1`` only requires it to be as aligned as the lane size. If we canonicalised on using ``LDR``, we'd still need to use ``LD1`` in some places to avoid alignment faults (the result of the ``LD1`` would then need to be reversed with ``REV``). Most operating systems however do not run with alignment faults enabled, so this is often not an issue. Summary; -------. The following table summarises the instructions that are required to be emitted for each property mentioned above for each of the two solutions. +-------------------------------+-------------------------------+---------------------+; | | ``LDR`` layout | ``LD1`` layout |; +===============================+===============================+=====================+; | Lane ordering | ``LDR + REV`` | ``LD1`` |; +-------------------------------+-------------------------------+---------------------+; | AAPCS | ``LDR`` | ``LD1 + REV`` |; +-------------------------------+-------------------------------+---------------------+; | Alignment for strict mode | ``LDR`` / ``LD1 + REV`` | ``LD1`` |; +-------------------------------+-------------------------------+---------------------+. Neither ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:7686,avoid,avoid,7686,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['avoid'],['avoid']
Safety,"vs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25303,safe,safety,25303,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['safe'],['safety']
Safety,"w. .. code-block:: c. typedef struct {; int *__counted_by(count) buf;; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. // Transformed pseudo code:; void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; // Materialize RHS values:; int *tmp_ptr = (int *)malloc(sizeof(int) * nelems);; int tmp_count = nelems;; // Inserted check:; // - checks to ensure that `lower <= tmp_ptr <= upper`; // - if (upper(tmp_ptr) - tmp_ptr < tmp_count) trap();; sbuf->buf = tmp_ptr;; sbuf->count = tmp_count;; }. Whether the compiler can optimize such run-time checks depends on how the upper; bound of the pointer is derived. If the source pointer has ``__sized_by``,; ``__counted_by``, or a variant of such, the compiler assumes that the upper; bound calculation doesn't overflow, e.g., ``ptr + size`` (where the type of; ``ptr`` is ``void *__sized_by(size)``), because when the ``__sized_by`` pointer; is initialized, ``-fbounds-safety`` inserts run-time checks to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-saf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:37957,safe,safety,37957,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"w_ostream_). More detailed information on these; subjects is available in the :doc:`ProgrammersManual`. For more information about LLVM's data structures and the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current minimum version of Python required is documented in the :doc:`GettingStarted`; section. Python code in the LLVM repository should only use language features; available in this version of Python. The Python code within the LLVM repository should adhere to the formatting guidelines; outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_. For consistency and to limit churn, code should be automatically formatted with; the `black <https://github.com/psf/black>`_ utility, which is PEP 8 compliant.; Use its default rules. For example, avoid specifying ``--line-length`` even; though it does not default to 80. The default rules can change between major; versions of black. In order to avoid unnecessary churn in the formatting rules,; we currently use black version 23.x in LLVM. When contributing a patch unrelated to formatting, you should format only the; Python code that the patch modifies. For this purpose, use the `darker; <https://pypi.org/project/darker/>`_ utility, which runs default black rules; over only the modified Python code. Doing so should ensure the patch will pass; the Python format checks in LLVM's pre-commit CI, which also uses darker. When; contributing a patch specifically for reformatting Python files, use black,; which currently only supports formatting entire files. Here are some quick examples, but see the black and darker documentation for; details:. .. code-block:: bash. $ pip install black=='23.*' darker # install black 23.x and darker; $ darker test.py # format uncommitted changes; $ darker -r HEAD^ test.py # also format",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:5196,avoid,avoid,5196,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22993,safe,safe,22993,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['safe'],['safe']
Safety,"ween remat and spill folding. This has redundant subtractions of %eax from a stack slot. However, %ecx doesn't; change, so we could simply subtract %eax from %ecx first and then use %ecx (or; vice-versa). //===---------------------------------------------------------------------===//. This code:. 	%tmp659 = icmp slt i16 %tmp654, 0		; <i1> [#uses=1]; 	br i1 %tmp659, label %cond_true662, label %cond_next715. produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; compares. GCC produces multiple branches, which is much nicer:. compare:; subl $12, %esp; movl 20(%esp), %edx; movl 16(%esp), %eax; decl %edx; jle .L7; .L5:; addl $12, %esp; ret; .p2align 4,,7; .L7:; jl .L4; cmpl $0, %eax; .p2align 4,,8; ja .L5; .L4:; .p2align 4,,9; call abort. //===---------------------------------------------------------------------===//. Tail call optimization improvements: Tail call optimization currently; pushes all arguments on the top of the stack (their normal place for; non-tail call optimized calls) that source from the callers arguments; or that source from a virtual register (also possibly sourcing from; callers arguments).; This is done to prevent overwriting of parameters (see example; below) that might be used later. example: . int callee(int32, int64); ; int caller(int32 arg1, int32 arg2) { ; int64 local = arg2 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:17491,abort,abort,17491,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,2,['abort'],['abort']
Safety,"which runs a; single fuzzing process until completion. If the value is >= 1, then this; number of jobs performing fuzzing are run, in a collection of parallel; separate worker processes; each such worker process has its; ``stdout``/``stderr`` redirected to ``fuzz-<JOB>.log``.; ``-workers``; Number of simultaneous worker processes to run the fuzzing jobs to completion; in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is used.; ``-dict``; Provide a dictionary of input keywords; see Dictionaries_.; ``-use_counters``; Use `coverage counters`_ to generate approximate counts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from target code (e.g. messages on assert failure). - 0 (default): close neither ``stdout`` nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:13553,timeout,timeout,13553,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeout']
Safety,"while LLVM; has a mostly linear history, it has a few merge commits that added projects --; and these merged the linear history of those projects. As a consequence, the; LLVM repository has multiple roots: One ""normal"" root, and then one for each; toplevel project that was developed out-of-tree and then merged later.; As of early 2020, the only such merged project is MLIR, but flang will likely; be merged in a similar way soon. Basic operation; ===============. See https://git-scm.com/docs/git-bisect for a good overview. In summary:. .. code-block:: bash. git bisect start; git bisect bad main; git bisect good f00ba. git will check out a revision in between. Try to reproduce your problem at; that revision, and run ``git bisect good`` or ``git bisect bad``. If you can't repro at the current commit (maybe the build is broken), run; ``git bisect skip`` and git will pick a nearby alternate commit. (To abort a bisect, run ``git bisect reset``, and if git complains about not; being able to reset, do the usual ``git checkout -f main; git reset --hard; origin/main`` dance and try again). ``git bisect run``; ==================. A single bisect step often requires first building clang, and then compiling; a large code base with just-built clang. This can take a long time, so it's; good if it can happen completely automatically. ``git bisect run`` can do; this for you if you write a run script that reproduces the problem; automatically. Writing the script can take 10-20 minutes, but it's almost; always worth it -- you can do something else while the bisect runs (such; as writing this document). Here's an example run script. It assumes that you're in ``llvm-project`` and; that you have a sibling ``llvm-build-project`` build directory where you; configured CMake to use Ninja. You have a file ``repro.c`` in the current; directory that makes clang crash at trunk, but it worked fine at revision; ``f00ba``. .. code-block:: bash. # Build clang. If the build fails, `exit 125` causes th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst:1140,abort,abort,1140,interpreter/llvm-project/llvm/docs/GitBisecting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst,1,['abort'],['abort']
Safety,"with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The calls; to the `Branch` methods are the same as if Geant3 were used. ``` {.cpp}; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:44049,safe,safety,44049,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['safe'],['safety']
Safety,"with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -------------------------------------------------------------. This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; practice, this means looking for internal functions that have pointer; arguments. If it can prove, through the use of ali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11653,avoid,avoid,11653,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"with; ReqdWorkGroupSize if; not 0, 0, 0.; ""NumSpilledSGPRs"" integer Number of stores from; a scalar register to; a register allocator; created spill; location.; ""NumSpilledVGPRs"" integer Number of stores from; a vector register to; a register allocator; created spill; location.; ============================ ============== ========= =====================. .. _amdgpu-amdhsa-code-object-metadata-v3:. Code Object V3 Metadata; +++++++++++++++++++++++. .. warning::; Code object V3 generation is no longer supported by this version of LLVM. Code object V3 and above metadata is specified by the ``NT_AMDGPU_METADATA`` note; record (see :ref:`amdgpu-note-records-v3-onwards`). The metadata is represented as Message Pack formatted binary data (see; [MsgPack]_). The top level is a Message Pack map that includes the; keys defined in table; :ref:`amdgpu-amdhsa-code-object-metadata-map-table-v3` and referenced; tables. Additional information can be added to the maps. To avoid conflicts,; any key names should be prefixed by ""*vendor-name*."" where; ``vendor-name`` can be the name of the vendor and specific vendor; tool that generates the information. The prefix is abbreviated to; simply ""."" when it appears within a map that has been added by the; same *vendor-name*. .. table:: AMDHSA Code Object V3 Metadata Map; :name: amdgpu-amdhsa-code-object-metadata-map-table-v3. ================= ============== ========= =======================================; String Key Value Type Required? Description; ================= ============== ========= =======================================; ""amdhsa.version"" sequence of Required - The first integer is the major; 2 integers version. Currently 1.; - The second integer is the minor; version. Currently 0.; ""amdhsa.printf"" sequence of Each string is encoded information; strings about a printf function call. The; encoded information is organized as; fields separated by colon (':'):. ``ID:N:S[0]:S[1]:...:S[N-1]:FormatString``. where:. ``ID``; A 32-bit intege",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:130052,avoid,avoid,130052,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"wkward special cases in the optimizers, and fundamental inconsistency; in the IR. In the future, it will probably be outright disallowed. What effect do address spaces have on GEPs?; -------------------------------------------. None, except that the address space qualifier on the second operand pointer type; always matches the address space qualifier on the result type. How is GEP different from ``ptrtoint``, arithmetic, and ``inttoptr``?; ---------------------------------------------------------------------. It's very similar; there are only subtle differences. With ptrtoint, you have to pick an integer type. One approach is to pick i64;; this is safe on everything LLVM supports (LLVM internally assumes pointers are; never wider than 64 bits in many places), and the optimizer will actually narrow; the i64 arithmetic down to the actual pointer size on targets which don't; support 64-bit arithmetic in most cases. However, there are some cases where it; doesn't do this. With GEP you can avoid this problem. Also, GEP carries additional pointer aliasing rules. It's invalid to take a GEP; from one object, address into a different separately allocated object, and; dereference it. IR producers (front-ends) must follow this rule, and consumers; (optimizers, specifically alias analysis) benefit from being able to rely on; it. See the `Rules`_ section for more information. And, GEP is more concise in common cases. However, for the underlying integer computation implied, there is no; difference. I'm writing a backend for a target which needs custom lowering for GEP. How do I do this?; -----------------------------------------------------------------------------------------. You don't. The integer computation implied by a GEP is target-independent.; Typically what you'll need to do is make your backend pattern-match expressions; trees involving ADD, MUL, etc., which are what GEP is lowered into. This has the; advantage of letting your code work correctly in more cases. GEP does ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:10264,avoid,avoid,10264,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['avoid'],['avoid']
Safety,"wn by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`; 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; rootgeom.C example looks clipped with a tube. \image html geometry014.png ""Ray-tracing example with box-clipping"". \anchor GP05; ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; `TGeo` offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. \anchor GP05a; ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:106156,detect,detector,106156,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,wn. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134329,Redund,Redundant,134329,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Redund'],['Redundant']
Safety,"wningPtr`; return type, which is an alias for `std::unique_ptr` in memory-safe mode or an; alias for a raw pointer otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10453,safe,safe,10453,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['safe'],['safe']
Safety,"work which are dealt with in parallel;; - The Async template function has been added the ROOT::Experimental namespace. The template function is analogous; to *std::async* but without the possibility of specifying the execution policy and without creating a thread but; directly submitting the work to the runtime in order to use the same pool as any other item of work spawned by ROOT.; - The TFuture template has been added to the ROOT::Experimental namespace. It represents a future and is compatible; with the ROOT::Experimental::Async function. It has the same properties of an STL future and can be initialised by; one of these classes. For example, *TFuture<int> = std::async(myfunc,a,b,c);*; - Reintroduced greedy reduction in TProcessExecutor.; - Fix empty chunks in the result vector of TThreadExecutor::Map. If the integer partition of the data in nChunks causes the existence of empty chunks (e.g the—rounded up—division of 12 elements in 5 chunks), the number of chunks is decreased to avoid empty chunks and, as a consequence, accesses to uninitialized memory in the reduction step. ## Language Bindings; - PyROOT now supports list initialisation with tuples. For example, suppose to have a function `void f(const TH1F& h)`. In C++, this can be invoked with this syntax: `f({""name"", ""title"", 64, -4, 4})`. In PyROOT this translates too `f(('name', 'title', 64, -4, 4))`. ## JavaScript ROOT. Upgrade JSROOT to v5.3.1. Following new features implemented:. - New supported classes:; - TGraphPolar; - TGraphTime; - TSpline3; - TSpline5; - TPolyLine3D; - TPolyMarker; - TEfficiency; - TH1K; - New supported options:; * ""PFC"" - auto fill color (histograms and graphs); * ""PLC"" - auto line color; * ""PMC"" - auto marker color; * ""A"" - fully disables axes drawing for histograms painters; * ""TEXT"" - for TH2Poly; * ""SAMES"" - draw stat box for superimposed histograms; * ""NOCOL"" - ignore stored in the TCanvas colors list; * ""NOPAL"" - ignore stored in the TCanvas color palette; - Improvements in e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:24714,avoid,avoid,24714,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['avoid'],['avoid']
Safety,"ws to either keep all benchmarks, or filter out (ignore) either all the; ones that do involve memory (involve instructions that may read or write to; memory), or the opposite, to only keep such benchmarks. .. option:: --analysis-clustering=[dbscan,naive]. Specify the clustering algorithm to use. By default DBSCAN will be used.; Naive clustering algorithm is better for doing further work on the; `-analysis-inconsistencies-output-file=` output, it will create one cluster; per opcode, and check that the cluster is stable (all points are neighbours). .. option:: --analysis-numpoints=<dbscan numPoints parameter>. Specify the numPoints parameters to be used for DBSCAN clustering; (`analysis` mode, DBSCAN only). .. option:: --analysis-clustering-epsilon=<dbscan epsilon parameter>. Specify the epsilon parameter used for clustering of benchmark points; (`analysis` mode). .. option:: --analysis-inconsistency-epsilon=<epsilon>. Specify the epsilon parameter used for detection of when the cluster; is different from the LLVM schedule profile values (`analysis` mode). .. option:: --analysis-display-unstable-clusters. If there is more than one benchmark for an opcode, said benchmarks may end up; not being clustered into the same cluster if the measured performance; characteristics are different. by default all such opcodes are filtered out.; This flag will instead show only such unstable opcodes. .. option:: --ignore-invalid-sched-class=false. If set, ignore instructions that do not have a sched class (class idx = 0). .. option:: --mtriple=<triple name>. Target triple. See `-version` for available targets. .. option:: --mcpu=<cpu name>. If set, measure the cpu characteristics using the counters for this CPU. This; is useful when creating new sched models (the host CPU is unknown to LLVM).; (`-mcpu=help` for details). .. option:: --analysis-override-benchmark-triple-and-cpu. By default, llvm-exegesis will analyze the benchmarks for the triple/CPU they; were measured for, but if you",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:16218,detect,detection,16218,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['detect'],['detection']
Safety,"ws; debuggers and other tools that consume PDB files like ETW. Work to teach lld; about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4344,safe,safe,4344,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['safe'],['safe']
Safety,"x -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note:** this part is not implemented as of Oct 2019. MemTagSanitizer will use :doc:`ScudoHardenedAllocator`; with additional code to update memory tags when. * New memory is obtained from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:2179,safe,safety,2179,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['safe'],['safety']
Safety,"x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:30946,avoid,avoid,30946,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['avoid'],['avoid']
Safety,"xit code (default 77) used if libFuzzer reports a timeout.; ``-error_exitcode``; Exit code (default 77) used if libFuzzer itself (not a sanitizer) reports a bug (leak, OOM, etc).; ``-max_total_time``; If positive, indicates the maximum total time in seconds to run the fuzzer.; If 0 (the default), run indefinitely.; ``-merge``; If set to 1, any corpus inputs from the 2nd, 3rd etc. corpus directories; that trigger new code coverage will be merged into the first corpus; directory. Defaults to 0. This flag can be used to minimize a corpus.; ``-merge_control_file``; Specify a control file used for the merge process.; If a merge process gets killed it tries to leave this file in a state; suitable for resuming the merge. By default a temporary file will be used.; ``-minimize_crash``; If 1, minimizes the provided crash input.; Use with -runs=N or -max_total_time=N to limit the number of attempts.; ``-reload``; If set to 1 (the default), the corpus directory is re-read periodically to; check for new inputs; this allows detection of new inputs that were discovered; by other fuzzing processes.; ``-jobs``; Number of fuzzing jobs to run to completion. Default value is 0, which runs a; single fuzzing process until completion. If the value is >= 1, then this; number of jobs performing fuzzing are run, in a collection of parallel; separate worker processes; each such worker process has its; ``stdout``/``stderr`` redirected to ``fuzz-<JOB>.log``.; ``-workers``; Number of simultaneous worker processes to run the fuzzing jobs to completion; in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is used.; ``-dict``; Provide a dictionary of input keywords; see Dictionaries_.; ``-use_counters``; Use `coverage counters`_ to generate approximate counts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:12387,detect,detection,12387,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detection']
Safety,"xmm2 ## xmm2 = xmm0[3,0,0,0]; 	movhlps	%xmm0, %xmm0 ## xmm0 = xmm0[1,1]; 	movaps	%xmm0, %xmm3; 	addss	%xmm1, %xmm3; 	movdqa	%xmm2, %xmm0; 	addss	%xmm3, %xmm0; 	ret. Also, there are cases where some simple local SLP would improve codegen a bit.; compiling this:. _Complex float f32(_Complex float A, _Complex float B) {; return A+B;; }. into:. _f32: ## @f32; 	movdqa	%xmm0, %xmm2; 	addss	%xmm1, %xmm2; 	pshufd	$1, %xmm1, %xmm1 ## xmm1 = xmm1[1,0,0,0]; 	pshufd	$1, %xmm0, %xmm3 ## xmm3 = xmm0[1,0,0,0]; 	addss	%xmm1, %xmm3; 	movaps	%xmm2, %xmm0; 	unpcklps	%xmm3, %xmm0 ## xmm0 = xmm0[0],xmm3[0],xmm0[1],xmm3[1]; 	ret. seems silly when it could just be one addps. //===---------------------------------------------------------------------===//. Expand libm rounding functions inline: Significant speedups possible.; http://gcc.gnu.org/ml/gcc-patches/2006-10/msg00909.html. //===---------------------------------------------------------------------===//. When compiled with unsafemath enabled, ""main"" should enable SSE DAZ mode and; other fast SSE modes. //===---------------------------------------------------------------------===//. Think about doing i64 math in SSE regs on x86-32. //===---------------------------------------------------------------------===//. This testcase should have no SSE instructions in it, and only one load from; a constant pool:. double %test3(bool %B) {; %C = select bool %B, double 123.412, double 523.01123123; ret double %C; }. Currently, the select is being lowered, which prevents the dag combiner from; turning 'select (load CPI1), (load CPI2)' -> 'load (select CPI1, CPI2)'. The pattern isel got this one right. //===---------------------------------------------------------------------===//. Lower memcpy / memset to a series of SSE 128 bit move instructions when it's; feasible. //===---------------------------------------------------------------------===//. Codegen:; if (copysign(1.0, x) == copysign(1.0, y)); into:; if (x^y & mask); when using SSE. //===----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:2202,unsafe,unsafemath,2202,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,2,['unsafe'],['unsafemath']
Safety,"xt. (gdb) show-coro-frame 0x4412c0; {; __resume_fn = 0x410960 <detail::chain_fn<18>()>,; __destroy_fn = 0x410d60 <detail::chain_fn<18>()>,; __promise = {; continuation = {; _M_fr_ptr = 0x441270; },; result = 0; },; struct_Awaiter_0 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x441310; }; }; },; struct_task_1 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; }; },; struct_task__promise_type__FinalSuspend_2 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; },; __coro_index = 1 '\001',; struct_std____n4861__suspend_always_3 = {; __int_8 = 0 '\000'; }. Get the living coroutines; =========================. Another useful task when debugging coroutines is to enumerate the list of; living coroutines, which is often done with threads. While technically; possible, this task is not recommended in production code as it is costly at; runtime. One such solution is to store the list of currently running coroutines; in a collection:. .. code-block:: c++. inline std::unordered_set<void*> lived_coroutines;; // For all promise_type we want to record; class promise_type {; public:; promise_type() {; // Note to avoid data races; lived_coroutines.insert(std::coroutine_handle<promise_type>::from_promise(*this).address());; }; ~promise_type() {; // Note to avoid data races; lived_coroutines.erase(std::coroutine_handle<promise_type>::from_promise(*this).address());; }; };. In the above code snippet, we save the address of every lived coroutine in the; `lived_coroutines` `unordered_set`. As before, once we know the address of the; coroutine we can derive the function, `promise_type`, and other members of the; frame. Thus, we could print the list of lived coroutines from that collection. Please note that the above is expensive from a storage perspective, and requires; some level of locking (not pictured) on the collection to prevent data races.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:26500,avoid,avoid,26500,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,2,['avoid'],['avoid']
Safety,"xtra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will convert ``auto`` to an explicit type or add; comments with deduced types. The motivation is that there are developers; that don't want to use ``auto`` because they are afraid that they might lose; control over their code. * C++14: less verbose operator function objects (`N3421; <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm>`_).; For example:. .. code-block:: c++. sort(v.begin(), v.end(), greater<ValueType>());. should be rewritten to:. .. code-block:: c++. sort(v.be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4803,detect,detect,4803,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['detect'],['detect']
Safety,"y expensive call to the interpreter if the; information is not the PCH. For example, ROOT's libGeom and other third-party; code. This is done to circumvent the costly call to `ShowMembers` which will; require parsing. ROOTMAP files reduce parsing for code which is not in the PCH. Consider; `foo::bar` and `S` are defined in `libFoo`'s `Foo.h`:; ```cpp; // Foo.h; namespace foo { struct bar{}; }; struct S{};; ```. ```bash; # libFoo.rootmap; { decls }; namespace foo { }; struct S;; ; [ libFoo.so ]; # List of selected classes; class bar; struct S; ```. ```cpp; // G__Foo.cxx (aka libFoo dictionary); namespace {; void TriggerDictionaryInitialization_libFoo_Impl() {; static const char* headers[] = {""Foo.h""}; // More scaffolding; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; }; ```. The code snippet bellow demonstrates the efforts which ROOT does to; avoid parsing redundant code. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; ```. When starting up ROOT, it will locate all files with extensions \*.rootmap. It; parses the code in section {decls} and creates an internal map for the entities; defined in \[libFoo.so\] section. Upon seeing an unknown identifier, the; implementation searches in the database if this is a known entity. Line #1 does not require a definition and the forward declaration consumed at; startup is sufficient. Parsing of `Foo.h` is not required. This comes at a cost; of having some non-trivial patches in clang to merge default function arguments; and default template arguments. The design of the ROOTMAP infrastructure; requires the default arguments to be attached to more than one declaration which; is not allowed by standard C++. The behavior of line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:7632,avoid,avoid,7632,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"y instrumentation of 'safe' variables. SafeStack is going to be the; first user. 'safe' variables can be defined as variables that can not be used out-of-scope; (e.g. use-after-return) or accessed out of bounds. In the future it can be; extended to track other variable properties. E.g. we plan to extend; implementation with a check to make sure that variable is always initialized; before every read to optimize use-of-uninitialized-memory checks. How it works; ============. The analysis is implemented in two stages:. The intra-procedural, or 'local', stage performs a depth-first search inside; functions to collect all uses of each alloca, including loads/stores and uses as; arguments functions. After this stage we know which parts of the alloca are used; by functions itself but we don't know what happens after it is passed as; an argument to another function. The inter-procedural, or 'global', stage, resolves what happens to allocas after; they are passed as function arguments. This stage performs a depth-first search; on function calls inside a single module and propagates allocas usage through; functions calls. When used with ThinLTO, the global stage performs a whole program analysis over; the Module Summary Index. Testing; =======. The analysis is covered with lit tests. We expect that users can tolerate false classification of variables as; 'unsafe' when in-fact it's 'safe'. This may lead to inefficient code. However, we; can't accept false 'safe' classification which may cause sanitizers to miss actual; bugs in instrumented code. To avoid that we want additional validation tool. AddressSanitizer may help with this validation. We can instrument all variables; as usual but additionally store stack-safe information in the; ``ASanStackVariableDescription``. Then if AddressSanitizer detects a bug on; a 'safe' variable we can produce an additional report to let the user know that; probably Stack Safety Analysis failed and we should check for a bug in the; compiler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst:1692,unsafe,unsafe,1692,interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,7,"['avoid', 'detect', 'safe', 'unsafe']","['avoid', 'detects', 'safe', 'unsafe']"
Safety,"y out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update local values in the; current frame. If we don't, we'll be accessing a potential invalid reference; once we eventually return from the call. In this example, we need to relocate the SSA value ``%obj``. Since we can't; actually change the value in the SSA value ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 7, i32 7); ret i8 addrspace(1)* %obj.relocated; }. Ideally, this sequence would have been represented as a M argument, N; return value function (where M is the number of values being; relocated + the original call arguments and N is the original return; value + each relocated value), but LLVM does not easily support such a; representation. Instead, the statepoint intrinsic marks the actual site of the; safepoint or statepoint. The statepoint returns a token value (which; exists only at compile time). To get",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:8697,safe,safepoint,8697,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"y want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52139,risk,risk,52139,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['risk'],['risk']
Safety,"y; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc673",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73439,unsafe,unsafe,73439,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['unsafe'],['unsafe']
Safety,"ze-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3423,recover,recover,3423,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"zer does not exist as of Oct 2019. MemTagSanitizer is a fast memory error detector and **a code hardening; tool** based on the Armv8.5-A `Memory Tagging Extension`_. It; detects a similar class of errors as `AddressSanitizer`_ or `HardwareAssistedAddressSanitizer`_, but with; **much** lower overhead. MemTagSanitizer overhead is expected to be in low single digits, both; CPU and memory. There are plans for a debug mode with slightly higher; memory overhead and better diagnostics. The primary use case of; MemTagSanitizer is code hardening in production binaries, where it is; expected to be a strong mitigation for both stack and heap-based; memory bugs. Usage; =====. Compile and link your program with ``-fsanitize=memtag`` flag. This; will only work when targeting AArch64 with MemTag extension. One; possible way to achieve that is to add ``-target; aarch64-linux -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:1308,safe,safety,1308,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['safe'],['safety']
Safety,"{; entry:; %a.addr = alloca i32, align 4, !DIAssignID !13; call void @llvm.dbg.assign(metadata i1 undef, metadata !14, metadata !DIExpression(), metadata !13, metadata i32* %a.addr, metadata !DIExpression()), !dbg !15; store i32 %a, i32* %a.addr, align 4, !DIAssignID !16; call void @llvm.dbg.assign(metadata i32 %a, metadata !14, metadata !DIExpression(), metadata !16, metadata i32* %a.addr, metadata !DIExpression()), !dbg !15; %0 = load i32, i32* %a.addr, align 4, !dbg !17; ret i32 %0, !dbg !18; }. ...; !13 = distinct !DIAssignID(); !14 = !DILocalVariable(name: ""a"", ...); ...; !16 = distinct !DIAssignID(); ```. The first `llvm.dbg.assign` refers to the `alloca` through `!DIAssignID !13`,; and the second refers to the `store` through `!DIAssignID !16`. ### Store-like instructions. In the absence of a linked `llvm.dbg.assign`, a store to an address that is; known to be the backing storage for a variable is considered to represent an; assignment to that variable. This gives us a safe fall-back in cases where `llvm.dbg.assign` intrinsics have; been deleted, the `DIAssignID` attachment on the store has been dropped, or the; optimiser has made a once-indirect store (not tracked with Assignment Tracking); direct. ### Middle-end: Considerations for pass-writers. #### Non-debug instruction updates. **Cloning** an instruction: nothing new to do. Cloning automatically clones a; `DIAssignID` attachment. Multiple instructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:5424,safe,safe,5424,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['safe'],['safe']
Safety,"| Q3 | S3 | | | Exit |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+------+; | Thread2 | Entry | | | | R2 | S2 | P2 | Q2 | S2 | P4 | ... | Exit |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+------+. |. Thus, when diverged paths reach different entries of an irreducible; cycle from outside the cycle, the static analysis conservatively; reports every node in the cycle as not m-converged. .. _convergence-reducible-cycle:. Reducible Cycle; ---------------. If ``C`` is a reducible cycle with header ``H``, then in any DFS,; ``H`` :ref:`must be the header of some cycle<cycle-reducible-headers>`; ``C'`` that contains ``C``. Independent of the DFS, there is no entry; to the subgraph ``C`` other than ``H`` itself. Thus, we have the; following:. 1. The diverged entry criterion is trivially satisfied for a divergent; branch and its join, where both are inside subgraph ``C``.; 2. When diverged paths reach the subgraph ``C`` from outside, their; convergence is always determined by the same header ``H``. Clearly, this can be determined only in a cycle hierarchy ``T`` where; ``C`` is detected as a reducible cycle. No such conclusion can be made; in a different cycle hierarchy ``T'`` where ``C`` is part of a larger; cycle ``C'`` with the same header, but this does not contradict the; conclusion in ``T``. Controlled Convergence; ======================. :ref:`Convergence control tokens <dynamic_instances_and_convergence_tokens>`; provide an explicit semantics for determining which threads are converged at a; given point in the program. The impact of this is incorporated in a; :ref:`controlled maximal converged-with <controlled_maximal_converged_with>`; relation over dynamic instances and a :ref:`controlled m-converged; <controlled_m_converged>` property of static instances. The :ref:`uniformity; analysis <uniformity-analysis>` implemented in LLVM includes this for targets; that support convergence control tokens.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:28960,detect,detected,28960,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detected']
Safety,"| count 3; ; This should produce one 'or' or 'cror' instruction per function. ; RUN: llvm-as < %s | llc -march=ppc32 | grep mfcr | count 3; ; PR2964. define i32 @test(double %x, double %y) nounwind {; entry:; 	%tmp3 = fcmp ole double %x, %y		; <i1> [#uses=1]; 	%tmp345 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp345; }. define i32 @test2(double %x, double %y) nounwind {; entry:; 	%tmp3 = fcmp one double %x, %y		; <i1> [#uses=1]; 	%tmp345 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp345; }. define i32 @test3(double %x, double %y) nounwind {; entry:; 	%tmp3 = fcmp ugt double %x, %y		; <i1> [#uses=1]; 	%tmp34 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp34; }. //===---------------------------------------------------------------------===//; for the following code:. void foo (float *__restrict__ a, int *__restrict__ b, int n) {; a[n] = b[n] * 2.321;; }. we load b[n] to GPR, then move it VSX register and convert it float. We should ; use vsx scalar integer load instructions to avoid direct moves. //===----------------------------------------------------------------------===//; ; RUN: llvm-as < %s | llc -march=ppc32 | not grep fneg. ; This could generate FSEL with appropriate flags (FSEL is not IEEE-safe, and ; ; should not be generated except with -enable-finite-only-fp-math or the like).; ; With the correctness fixes for PR642 (58871) LowerSELECT_CC would need to; ; recognize a more elaborate tree than a simple SETxx. define double @test_FNEG_sel(double %A, double %B, double %C) {; %D = fsub double -0.000000e+00, %A ; <double> [#uses=1]; %Cond = fcmp ugt double %D, -0.000000e+00 ; <i1> [#uses=1]; %E = select i1 %Cond, double %B, double %C ; <double> [#uses=1]; ret double %E; }. //===----------------------------------------------------------------------===//; The save/restore sequence for CR in prolog/epilog is terrible:; - Each CR subreg is saved individually, rather than doing one save as a unit.; - On Darwin, the save is done after the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:12307,avoid,avoid,12307,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,2,['avoid'],['avoid']
Safety,"}. ""``CHECK-NEXT:``"" directives reject the input unless there is exactly one; newline between it and the previous directive. A ""``CHECK-NEXT:``"" cannot be; the first directive in a file. The ""CHECK-SAME:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes you want to match lines and would like to verify that matches happen; on the same line as the previous match. In this case, you can use ""``CHECK:``""; and ""``CHECK-SAME:``"" directives to specify this. If you specified a custom; check prefix, just use ""``<PREFIX>-SAME:``"". ""``CHECK-SAME:``"" is particularly powerful in conjunction with ""``CHECK-NOT:``""; (described below). For example, the following works like you'd expect:. .. code-block:: llvm. !0 = !DILocation(line: 5, scope: !1, inlinedAt: !2). ; CHECK: !DILocation(line: 5,; ; CHECK-NOT: column:; ; CHECK-SAME: scope: ![[SCOPE:[0-9]+]]. ""``CHECK-SAME:``"" directives reject the input if there are any newlines between; it and the previous directive. ""``CHECK-SAME:``"" is also useful to avoid writing matchers for irrelevant; fields. For example, suppose you're writing a test which parses a tool that; generates output like this:. .. code-block:: text. Name: foo; Field1: ...; Field2: ...; Field3: ...; Value: 1. Name: bar; Field1: ...; Field2: ...; Field3: ...; Value: 2. Name: baz; Field1: ...; Field2: ...; Field3: ...; Value: 1. To write a test that verifies ``foo`` has the value ``1``, you might first; write this:. .. code-block:: text. CHECK: Name: foo; CHECK: Value: 1{{$}}. However, this would be a bad test: if the value for ``foo`` changes, the test; would still pass because the ""``CHECK: Value: 1``"" line would match the value; from ``baz``. To fix this, you could add ``CHECK-NEXT`` matchers for every; ``FieldN:`` line, but that would be verbose, and need to be updated when; ``Field4`` is added. A more succinct way to write the test using the; ""``CHECK-SAME:``"" matcher would be as follows:. .. code-block:: text. CHECK: Name: foo; CHECK: Value:; CHECK-SAME: {{ 1$}}. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:14931,avoid,avoid,14931,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['avoid'],['avoid']
Safety,"~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9390,redund,redundant,9390,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['redund'],['redundant']
Security," 	%esi = MOV32rm %esi, 1, %noreg, 0; 	MOV32mr %stack.4, 1, %noreg, 0, %esi; 	%eax = LEA32r %esi, 1, %eax, -3; 	%esi = MOV32rm %stack.7, 1, %noreg, 0; 	%esi = MOV32rm %esi, 1, %noreg, 32; 	%edi = MOV32rr %eax; 	SHL32ri %edi<def&use>, 4; 	ADD32rr %edi<def&use>, %esi; 	%xmm0 = MOVAPSrm %ecx, 1, %noreg, 0; 	%xmm1 = MOVAPSrr %xmm0; 	SHUFPSrr %xmm1<def&use>, %xmm1, 170; 	%xmm2 = MOVAPSrr %xmm0; 	SHUFPSrr %xmm2<def&use>, %xmm2, 0; 	%xmm3 = MOVAPSrr %xmm0; 	SHUFPSrr %xmm3<def&use>, %xmm3, 255; 	SHUFPSrr %xmm0<def&use>, %xmm0, 85; 	%ebx = MOV32rr %edi; 	AND32ri8 %ebx<def&use>, 15; 	CMP32ri8 %ebx, 0; 	JE mbb<cond_next204,0xa914d30>. This looks really bad. The problem is shufps is a destructive opcode. Since it; appears as operand two in more than one shufps ops. It resulted in a number of; copies. Note icc also suffers from the same problem. Either the instruction; selector should select pshufd or The register allocator can made the two-address; to three-address transformation. It also exposes some other problems. See MOV32ri -3 and the spills. //===---------------------------------------------------------------------===//. Consider:. __m128 test(float a) {; return _mm_set_ps(0.0, 0.0, 0.0, a*a);; }. This compiles into:. movss 4(%esp), %xmm1; mulss %xmm1, %xmm1; xorps %xmm0, %xmm0; movss %xmm1, %xmm0; ret. Because mulss doesn't modify the top 3 elements, the top elements of ; xmm1 are already zero'd. We could compile this to:. movss 4(%esp), %xmm0; mulss %xmm0, %xmm0; ret. //===---------------------------------------------------------------------===//. Here's a sick and twisted idea. Consider code like this:. __m128 test(__m128 a) {; float b = *(float*)&A;; ...; return _mm_set_ps(0.0, 0.0, 0.0, b);; }. This might compile to this code:. movaps c(%esp), %xmm1; xorps %xmm0, %xmm0; movss %xmm1, %xmm0; ret. Now consider if the ... code caused xmm1 to get spilled. This might produce; this code:. movaps c(%esp), %xmm1; movaps %xmm1, c2(%esp); ... xorps %xmm0, %xmm0; movaps c2(%esp), ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:6551,expose,exposes,6551,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,2,['expose'],['exposes']
Security," ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17002,access,access,17002,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['access'],['access']
Security," ""C""`` and reports them as ``CXCursor_LinkageSpec``.; - Changed the libclang library on AIX to export only the necessary symbols to; prevent issues of resolving to the wrong duplicate symbol. Static Analyzer; ---------------. New features; ^^^^^^^^^^^^. - Implemented the ``[[clang::suppress]]`` attribute for suppressing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.ht",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:69707,access,accesses,69707,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['accesses']
Security," ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This will automatically take care of the; clean up. See ""Input/Output"". ### Executing a Script From a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ```. `ProcessLine` takes a parameter, which is a pointer to an `int` or to; a `TInterpreter::EErrorCode` to let you access the interpreter error; code after an attempt to interpret. This will contain the error; as defined in `enum TInterpreter::EErrorCode` with `TInterpreter::kSuccess` being; the value for a successful execution. ### Executing a Script From the Invocation. Instead if starting ROOT and running a script on the prompt you can also pass; it to ROOT in its invocation:. ```; $ root -l -b 'myCode.C(""some String"", 12)'; ```. The exact kind of quoting depends on your shell; the one shown here works for; bash-like shells. ROOT can evaluate any expression as part of the invocation; another version of; the previous example can be spelled like this:. ```; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; ```. ## C++ Extensions To Ease Scripting. In the next example, we demonstrate three of the most important; extensions ROOT and Cling make to C++. Start ROOT in the directory; `$ROOTSYS/tutorials` (make sure to have first run `.x hsimple.C`):. ``` {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:9675,access,access,9675,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['access'],['access']
Security," '``llvm.instrprof.increment``'; intrinsic. The last argument specifies the value of the increment of the counter variable. Semantics:; """"""""""""""""""""; See description of '``llvm.instrprof.increment``' intrinsic. '``llvm.instrprof.timestamp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.timestamp(i8* <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a; timestamp representing when this function was executed for the first time. '``llvm.instrprof.cover``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.cover(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.cover``' intrinsic is used to implement coverage; instrumentation. Arguments:; """"""""""""""""""""; The arguments are the same as the first four arguments of; '``llvm.instrprof.increment``'. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:529746,hash,hash,529746,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security," '``llvm.pcmarker``' intrinsic is a method to export a Program; Counter (PC) in a region of code to simulators and other tools. The; method is target specific, but it is expected that the marker will use; exported symbols to transmit the PC of the marker. The marker makes no; guarantees that it will remain with any specific instruction after; optimizations. It is possible that the presence of a marker will inhibit; optimizations. The intended use is to be inserted after optimizations to; allow correlations of simulation runs. Arguments:; """""""""""""""""""". ``id`` is a numerical id identifying the marker. Semantics:; """""""""""""""""""". This intrinsic does not modify the behavior of the program. Backends; that do not support this intrinsic may ignore it. '``llvm.readcyclecounter``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i64 @llvm.readcyclecounter(). Overview:; """""""""""""""""". The '``llvm.readcyclecounter``' intrinsic provides access to the cycle; counter register (or similar low latency, high accuracy clocks) on those; targets that support it. On X86, it should map to RDTSC. On Alpha, it; should map to RPCC. As the backing counters overflow quickly (on the; order of 9 seconds on alpha), this should only be used for small; timings. Semantics:; """""""""""""""""""". When directly supported, reading the cycle counter should not modify any; memory. Implementations are allowed to either return an application; specific value or a system wide value. On backends without support, this; is lowered to a constant 0. Note that runtime support may be conditional on the privilege-level code is; running at and the host platform. '``llvm.clear_cache``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.clear_cache(ptr, ptr). Overview:; """""""""""""""""". The '``llvm.clear_cache``' intrinsic ensures visibility of modifications; in the specified range to the execution unit of the processor. On; targets with non-unified instruction and data cache, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:525150,access,access,525150,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61374,secur,security,61374,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security," (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-check",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24648,secur,security,24648,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security," (e.g. ORC ``JITDylib``) or; executable, but not from elsewhere. A symbol with local scope should only be; visible within the current ``LinkGraph``. * ``Callable`` is a boolean which is set to true if this symbol can be called,; and is accessible via the ``isCallable`` method. This can be used to; automate the introduction of call-stubs for lazy compilation. * ``Live`` is a boolean that can be set to mark this symbol as root for; dead-stripping purposes (see :ref:`generic_link_algorithm`). JITLink's; dead-stripping algorithm will propagate liveness flags through the graph to; all reachable symbols before deleting any symbols (and blocks) that are not; marked live. * ``Edge`` -- A quad of an ``Offset`` (implicitly from the start of the; containing ``Block``), a ``Kind`` (describing the relocation type), a; ``Target``, and an ``Addend``. Edges represent relocations, and occasionally other relationships, between; blocks and symbols. * ``Offset``, accessible via ``getOffset``, is an offset from the start of the; ``Block`` containing the ``Edge``. * ``Kind``, accessible via ``getKind`` is a relocation type -- it describes; what kinds of changes (if any) should be made to block content at the given; ``Offset`` based on the address of the ``Target``. * ``Target``, accessible via ``getTarget``, is a pointer to a ``Symbol``,; representing whose address is relevant to the fixup calculation specified by; the edge's ``Kind``. * ``Addend``, accessible via ``getAddend``, is a constant whose interpretation; is determined by the edge's ``Kind``. * ``Section`` -- A set of ``Symbol`` instances, plus a set of ``Block``; instances, with a ``Name``, a set of ``ProtectionFlags``, and an ``Ordinal``. Sections make it easy to iterate over the symbols or blocks associated with; a particular section in the source object file. * ``blocks()`` returns an iterator over the set of blocks defined in the; section (as ``Block*`` pointers). * ``symbols()`` returns an iterator over the set of symbols d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:11759,access,accessible,11759,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security," *TODO*; Streamout Registers 128 N/A GS_REGS; ===================================== =============== =========== ================ ======= ============================. **Generic**; The generic address space is supported unless the *Target Properties* column; of :ref:`amdgpu-processor-table` specifies *Does not support generic address; space*. The generic address space uses the hardware flat address support for two fixed; ranges of virtual addresses (the private and local apertures), that are; outside the range of addressable global memory, to map from a flat address to; a private or local address. This uses FLAT instructions that can take a flat; address and access global, private (scratch), and group (LDS) memory depending; on if the address is within one of the aperture ranges. Flat access to scratch requires hardware aperture setup and setup in the; kernel prologue (see :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat; access to LDS requires hardware aperture setup and M0 (GFX7-GFX8) register; setup (see :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a private or group address space address (termed a segment; address) and a flat address the base address of the corresponding aperture; can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline; constant registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``.; In 64-bit address mode the aperture sizes are 2^32 bytes and the base is; aligned to 2^32 which makes it easier to convert from flat to segment or; segment to flat. A global address space address has the same value when used as a flat address; so no conversion is needed. **Global and Constant**; The global and constant address spaces both use global virtual addresses,; which are the same virtual address space us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:23709,access,access,23709,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:95550,access,accessed,95550,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['access'],['accessed']
Security," + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly descr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:4413,secur,security,4413,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security," - Per object statsoverflow flag has been added. This change is required to prevent non reproducible behaviours in a multithreaded environments. For example, if several threads change the; `TH1::fgStatOverflows` flag and fill histograms, the behaviour will be undefined.; - A fix has been added in resetting the statistics of histograms with label. The bug was causing the histogram entries to be set as zero and this was making failing the merging of those; histogram (see ROOT-9336). . ## Math Libraries. ## RooFit Libraries. - A fix has been added in the component selection, which is used for plotting simultaneous models. See [PR #2033](https://github.com/root-project/root/pull/2033). ## TMVA Library. #### New Deep Learning Module. - TMVA contains a new set of Deep Learning classes ( `MethodDL` ), with support, in addition to dense layer, also convolutional and recurrent layer. . #### Other New TMVA Features. - Support for Parallelization of BDT using Multi-Threads; - Several improvements in Cross Validation including support for Multi-Process cross-validation running. . ## 2D Graphics Libraries; - `TMultiGraph::GetHistogram` now works even if the multigraph is not drawn. Make sure; it never returns a null pointer.; - X11 line `width = 0` doesn't work on OpenSuSE Thumbleweed for non solid lines. Now fixed.; - TCanvas::SetWindowsSize has been changed to get the same window size in interactive mode…and batch mode.; - Change the `TGraph` default fill color to white to avoid black box in legend; when `gPad->BuildLegend()` is called.; - Auto-coloring for TF1 (drawing options PFC, PLC and PMC) is implemented.; - Auto-coloring for TH1::DrawCopy (drawing options PFC, PLC and PMC) is implemented.; - Improve the option management in `TF1::Draw` to allow to combine the option; `SAME` with other drawing options.; - `TGraph::Draw(""AB"")` was malfunctioning when using `TAxis::SetRangeUser`.; It was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-9144).; - The errors end-caps ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:11877,validat,validation,11877,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['validat'],['validation']
Security," - ``a``: A 32, 64, or 128-bit integer address register (excludes R0, which in an; address context evaluates as zero).; - ``h``: A 32-bit value in the high part of a 64bit data register; (LLVM-specific); - ``f``: A 32, 64, or 128-bit floating-point register. X86:. - ``I``: An immediate integer between 0 and 31.; - ``J``: An immediate integer between 0 and 64.; - ``K``: An immediate signed 8-bit integer.; - ``L``: An immediate integer, 0xff or 0xffff or (in 64-bit mode only); 0xffffffff.; - ``M``: An immediate integer between 0 and 3.; - ``N``: An immediate unsigned 8-bit integer.; - ``O``: An immediate integer between 0 and 127.; - ``e``: An immediate 32-bit signed integer.; - ``Z``: An immediate 32-bit unsigned integer.; - ``q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit; ``l`` integer register. On X86-32, this is the ``a``, ``b``, ``c``, and ``d``; registers, and on X86-64, it is all of the integer registers.; - ``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit; ``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` registers.; - ``r`` or ``l``: An 8, 16, 32, or 64-bit integer register.; - ``R``: An 8, 16, 32, or 64-bit ""legacy"" integer register -- one which has; existed since i386, and can be accessed without the REX prefix.; - ``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register.; - ``y``: A 64-bit MMX register, if MMX is enabled.; - ``v``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector; operand in a SSE register. If AVX is also enabled, can also be a 256-bit; vector operand in an AVX register. If AVX-512 is also enabled, can also be a; 512-bit vector operand in an AVX512 register. Otherwise, an error.; - ``Ws``: A symbolic reference with an optional constant addend or a label; reference.; - ``x``: The same as ``v``, except that when AVX-512 is enabled, the ``x`` code; only allocates into the first 16 AVX-512 registers, while the ``v`` code; allocates into any of the 32 AVX-51",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:233157,access,accessed,233157,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security," - ``llvm/XRay/InstrumentationMap.h``: A convenient tool for analyzing the; instrumentation map in XRay-instrumented object files and binaries. The; ``extract`` and ``stack`` subcommands uses this particular library. Minimizing Binary Size; ----------------------. XRay supports several different instrumentation points including ``function-entry``,; ``function-exit``, ``custom``, and ``typed`` points. These can be enabled individually; using the ``-fxray-instrumentation-bundle=`` flag. For example if you only wanted to; instrument function entry and custom points you could specify:. ::. clang -fxray-instrument -fxray-instrumentation-bundle=function-entry,custom ... This will omit the other sled types entirely, reducing the binary size. You can also; instrument just a sampled subset of functions using instrumentation groups.; For example, to instrument only a quarter of available functions invoke:. ::. clang -fxray-instrument -fxray-function-groups=4. A subset will be chosen arbitrarily based on a hash of the function name. To sample a; different subset you can specify ``-fxray-selected-function-group=`` with a group number; in the range of 0 to ``xray-function-groups`` - 1. Together these options could be used; to produce multiple binaries with different instrumented subsets. If all you need is; runtime control over which functions are being traced at any given time it is better; to selectively patch and unpatch the individual functions you need using the XRay; Runtime Library's ``__xray_patch_function()`` method. Future Work; ===========. There are a number of ongoing efforts for expanding the toolset building around; the XRay instrumentation system. Trace Analysis Tools; --------------------. - Work is in progress to integrate with or develop tools to visualize findings; from an XRay trace. Particularly, the ``stack`` tool is being expanded to; output formats that allow graphing and exploring the duration of time in each; call stack.; - With a large instrumented bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:13706,hash,hash,13706,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['hash'],['hash']
Security," - flang; - Multiple meeting series, `documented here <https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls>`__; -; -; * - OpenMP; - Multiple meeting series, `documented here <https://openmp.llvm.org/docs/SupportAndFAQ.html>`__; -; -; * - LLVM Alias Analysis; - Every 4 weeks on Tuesdays; - `ics <http://lists.llvm.org/pipermail/llvm-dev/attachments/20201103/a3499a67/attachment-0001.ics>`__; - `Minutes/docs <https://docs.google.com/document/d/17U-WvX8qyKc3S36YUKr3xfF-GHunWyYowXbxEdpHscw>`__; * - Vector Predication; - Every 2 weeks on Tuesdays, 3pm UTC; -; - `Minutes/docs <https://docs.google.com/document/d/1q26ToudQjnqN5x31zk8zgq_s0lem1-BF8pQmciLa4k8/edit?usp=sharing>`__; * - LLVM Pointer Authentication; - Every month on Mondays; - `ics <https://calendar.google.com/calendar/ical/fr1qtmrmt2s9odufjvurkb6j70%40group.calendar.google.com/public/basic.ics>`__; - `Minutes/docs <https://discourse.llvm.org/t/llvm-pointer-authentication-sync-ups/62661>`__; * - MemorySSA in LLVM; - Every 8 weeks on Mondays; - `ics <https://calendar.google.com/calendar/ical/c_1mincouiltpa24ac14of14lhi4%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/embed?src=c_1mincouiltpa24ac14of14lhi4%40group.calendar.google.com>`__; - `Minutes/docs <https://docs.google.com/document/d/1-uEEZfmRdPThZlctOq9eXlmUaSSAAi8oKxhrPY_lpjk/edit#>`__; * - LLVM Embedded Toolchains; - Every 4 weeks on Thursdays; - `ics <https://drive.google.com/file/d/1uNa-PFYkhAfT83kR2Nc4Fi706TAQFBEL/view?usp=sharing>`__; `gcal <https://calendar.google.com/calendar/u/0?cid=ZDQyc3ZlajJmbjIzNG1jaTUybjFsdjA2dWNAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ>`__; - `Minutes/docs <https://docs.google.com/document/d/1GahxppHJ7o1O_fn1Mbidu1DHEg7V2aOr92LXCtNV1_o/edit?usp=sharing>`__; * - Clang C and C++ Language Working Group; - 1st and 3rd Wednesday of the month; - `gcal <https://calendar.google.com/calendar/u/0?cid=cW1lZGg0ZXNpMnIyZDN2aTVydGVrdWF1YzRAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:7589,authenticat,authentication-sync-ups,7589,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['authenticat'],['authentication-sync-ups']
Security," - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemallo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4737,secur,security,4737,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['secur'],['security']
Security," -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:21814,hash,hash,21814,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['hash'],['hash']
Security," -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualiza",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79580,sanitiz,sanitizers,79580,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitizers']
Security," .. admonition:: Historical Note. We started with an alternative representation, where MRI tracks a size for; each generic virtual register, and instructions have lists of types.; That had two flaws: the type and size are redundant, and there was no generic; way of getting a given operand's type (as there was no 1:1 mapping between; instruction types and operands).; We considered putting the type in some variant of MCInstrDesc instead:; See `PR26576 <https://llvm.org/PR26576>`_: [GlobalISel] Generic MachineInstrs; need a type but this increases the memory footprint of the related objects. .. _gmir-regbank:. Register Bank; -------------. A Register Bank is a set of register classes defined by the target. This; definition is rather loose so let's talk about what they can achieve. Suppose we have a processor that has two register files, A and B. These are; equal in every way and support the same instructions for the same cost. They're; just physically stored apart and each instruction can only access registers from; A or B but never a mix of the two. If we want to perform an operation on data; that's in split between the two register files, we must first copy all the data; into a single register file. Given a processor like this, we would benefit from clustering related data; together into one register file so that we minimize the cost of copying data; back and forth to satisfy the (possibly conflicting) requirements of all the; instructions. Register Banks are a means to constrain the register allocator to; use a particular register file for a virtual register. In practice, register files A and B are rarely equal. They can typically store; the same data but there's usually some restrictions on what operations you can; do on each register file. A fairly common pattern is for one of them to be; accessible to integer operations and the other accessible to floating point; operations. To accommodate this, let's rename A and B to GPR (general purpose; registers) and FPR (fl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:3749,access,access,3749,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['access'],['access']
Security," .. note::. This section replaces parts of DWARF Version 5 section 2.5.1.1, 2.5.1.2,; 2.5.1.3, and 2.6.1.1.2. Each of the target architecture specific address spaces has a corresponding; memory location storage that denotes the linear addressable memory of that; address space. The size of each memory location storage corresponds to the range; of the addresses in the corresponding address space. *It is target architecture defined how address space location storage maps to; target architecture physical memory. For example, they may be independent; memory, or more than one location storage may alias the same physical memory; possibly at different offsets and with different interleaving. The mapping may; also be dictated by the source language address classes.*. A memory location description specifies a memory location storage. The bit; offset corresponds to a bit position within a byte of the memory. Bits accessed; using a memory location description, access the corresponding target; architecture memory starting at the bit position within the byte specified by; the bit offset. A memory location description that has a bit offset that is a multiple of 8 (the; byte size) is defined to be a byte address memory location description. It has a; memory byte address A that is equal to the bit offset divided by 8. A memory location description that does not have a bit offset that is a multiple; of 8 (the byte size) is defined to be a bit field memory location description.; It has a bit position B equal to the bit offset modulo 8, and a memory byte; address A equal to the bit offset minus B that is then divided by 8. The address space AS of a memory location description is defined to be the; address space that corresponds to the memory location storage associated with; the memory location description. A location description that is comprised of one byte address memory location; description SL is defined to be a memory byte address location description. It; has a byte address equa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:105015,access,accessed,105015,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['access'],"['access', 'accessed']"
Security," // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:69830,hash,hash,69830,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security," // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the **htdigest** utility. ```bash; [shell] htdigest -c .htdigest domain_name user_name; ```. It is recommended not to use special symbols in domain or user names. Several users can be add to the "".htdigest"" file. When starting the server, the following arguments should be specified:. ```cpp; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; ```. After that, the web browser will automatically request to input a name/password for the domain ""domain_name"". Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using `THttpServer::Restrict()` method. For instance, one could hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or objects can not be accessed via http protocol. By default server runs in readonly mode and do not allow methods execution via 'exe.json' or 'exe.bin' requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:8768,password,password,8768,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['password'],['password']
Security," // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5504,access,accessed,5504,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['access'],['accessed']
Security," 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1333,secur,security-issue,1333,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security-issue']
Security," 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24043,access,access,24043,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security," 5.24 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52600/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Brian Bockelman, UNL,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/Atlas, RooStats; Valeri Fine, BNL/STAR,; Lucie Flekova, CERN/SFT summer student,; Fabrizio Furano, CERN/IT, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Mary-Louise Gill, CERN/SFT summer student,; David Gonzalez Maline, CERN/SFT, ; Andreas Hoecker, CERN/Atlas, TMVA ; Louis Höfler, ; Jan Iwaszkiewicz, CERN, ; Daniele Kruse, CERN, GDML; Wim Lavrijsen, LBNL, PyRoot; Alfio Lazzaro, Milano/AtlasMinuit; Sergei Linev, GSI,; Anar Manafov, GSI, ; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v526/index.html:1236,authenticat,authentication,1236,doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v526/index.html,2,['authenticat'],['authentication']
Security, 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating exception specifications; Unknown. 831; CD2; Limit on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55720,Access,Access,55720,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security," :raw-html:`<tr>`; :raw-html:`<td>40</td>`; :raw-html:`<td>Saved FP (r31)</td>`; :raw-html:`</tr>`; :raw-html:`</table>`. The *parameter area* is used to store arguments being passed to a callee; function. Following the PowerPC ABI, the first few arguments are actually; passed in registers, with the space in the parameter area unused. However, if; there are not enough registers or the callee is a thunk or vararg function,; these register arguments can be spilled into the parameter area. Thus, the; parameter area must be large enough to store all the parameters for the largest; call sequence made by the caller. The size must also be minimally large enough; to spill registers r3-r10. This allows callees blind to the call signature,; such as thunks and vararg functions, enough space to cache the argument; registers. Therefore, the parameter area is minimally 32 bytes (64 bytes in 64; bit mode.) Also note that since the parameter area is a fixed offset from the; top of the frame, that a callee can access its split arguments using fixed; offsets from the stack pointer (or base pointer.). Combining the information about the linkage, parameter areas and alignment. A; stack frame is minimally 64 bytes in 32 bit mode and 128 bytes in 64 bit mode. The *dynamic area* starts out as size zero. If a function uses dynamic alloca; then space is added to the stack, the linkage and parameter areas are shifted to; top of stack, and the new space is available immediately below the linkage and; parameter areas. The cost of shifting the linkage and parameter areas is minor; since only the link value needs to be copied. The link value can be easily; fetched by adding the original frame size to the base pointer. Note that; allocations in the dynamic space need to observe 16 byte alignment. The *locals area* is where the llvm compiler reserves space for local variables. The *saved registers area* is where the llvm compiler spills callee saved; registers on entry to the callee. Prolog/Epilog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:99449,access,access,99449,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['access']
Security," :ref:`amdgpu-amdhsa-kernel-prolog-private-segment-buffer`):. * Base address pointing to the beginning of the wavefront scratch backing; memory.; * Swizzled with dword element size and stride of wavefront size elements. 2. The FLAT_SCRATCH register pair is setup. See; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`.; 3. GFX6-GFX8: M0 register set to the size of LDS in bytes. See; :ref:`amdgpu-amdhsa-kernel-prolog-m0`.; 4. The EXEC register is set to the lanes active on entry to the function.; 5. MODE register: *TBD*; 6. VGPR0-31 and SGPR4-29 are used to pass function input arguments as described; below.; 7. SGPR30-31 return address (RA). The code address that the function must; return to when it completes. The value is undefined if the function is *no; return*.; 8. SGPR32 is used for the stack pointer (SP). It is an unswizzled scratch; offset relative to the beginning of the wavefront scratch backing memory. The unswizzled SP can be used with buffer instructions as an unswizzled SGPR; offset with the scratch V# in SGPR0-3 to access the stack in a swizzled; manner. The unswizzled SP value can be converted into the swizzled SP value by:. | swizzled SP = unswizzled SP / wavefront size. This may be used to obtain the private address space address of stack; objects and to convert this address to a flat address by adding the flat; scratch aperture base address. The swizzled SP value is always 4 bytes aligned for the ``r600``; architecture and 16 byte aligned for the ``amdgcn`` architecture. .. note::. The ``amdgcn`` value is selected to avoid dynamic stack alignment for the; OpenCL language which has the largest base type defined as 16 bytes. On entry, the swizzled SP value is the address of the first function; argument passed on the stack. Other stack passed arguments are positive; offsets from the entry swizzled SP value. The function may use positive offsets beyond the last stack passed argument; for stack allocated local variables and register spill slots. If necessary",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:388466,access,access,388466,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memmove.*``' intrinsics move a block of memory from the; source location to the destination location. It is similar to the; '``llvm.memcpy``' intrinsic but allows the two memory locations to; overlap. Note that, unlike the standard libc function, the ``llvm.memmove.*``; intrinsics do not return a value, takes an extra isvolatile; argument and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is an integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memmove`` call; is a :ref:`volatile operation <volatile>`. The detailed access behavior is; not very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memmove.*``' intrinsics copy a block of memory from the; source location to the destination location, which may overlap. It; copies ""len"" bytes of memory over. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be well-defined,; otherwise the behavior is undefined. .. _int_memset:. '``llvm.memset.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.memset on any integer; bit width and for different address spaces. However, not all targets; support all bit widths. ::. declare void @llvm.memset.p0.i32(ptr <dest>, i8 <val>,; i32 <len>, i1 <isvolatile>); decla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:551925,access,access,551925,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," <fstream>. void test() {; std::filebuf fb;; std::istream in(&fb);; std::filebuf::off_type pos(-1);; in.seekg(pos); // warn; }. different. Name, DescriptionExampleProgress. different.SuccessiveAssign; (C); Successive assign to a variable. int test() {; int i;; i=1;; i=2; // warn; return i;; }. different.NullDerefStmtOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {; int x;; };. struct S* f();. void test() {; struct S *p1 = f();; int x1 = p1->x; // warn; if (p1) {};. struct S *p2 = f();; int x2 = p2->x; // ok; }. different.NullDerefCondOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {int i;};. struct S* f();. void test() {; struct S *p = f();; if (p->i && p) {}; // warn; }. different.MultipleAccessors; (C++); Identical accessor bodies. Possibly a misprint. class A {; int i;; int j;; public:; int getI() { return i; }; int getJ() { return i; } // warn; };. class A {; int i;; int j;; public:; void setI(int& ii) { i = ii; }; void setJ(int& jj) { i = jj; } // warn; };. different.AccessorsForPublic; (C++); Accessors exist for a public class field. Should this field really be; public?. class A {; public:; int i; // warn; int getI() { return i; }; void setI(int& ii) { i = ii; }; };. different.LibFuncResultUnised; (C, C++); Calling a function ignoring its return value is of no use (create the list of; known system/library/API functions falling into this category). #include <vector>. void test() {; std::vector<int> v;; v.empty(); // warn; }. different.WrongVarForStmt; (C, C++); Wrong variable is possibly used in the loop/cond-expression of; the for statement. Did you mean; 'proper_variable_name'?. void test() {; int i = 0;; int j = 0;; for (i = 0; i < 3; j += 1); // warn; }. void test() {; int i = 0;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:20510,access,accessor,20510,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,2,['access'],['accessor']
Security," == cpu_x86_64 ); io.mapRequired(""flags"", *(My86_64Flags*)info.flags);; else; io.mapRequired(""flags"", *(My86Flags*)info.flags);; }; };. Tags; ----. The YAML syntax supports tags as a way to specify the type of a node before; it is parsed. This allows dynamic types of nodes. But the YAML I/O model uses; static typing, so there are limits to how you can use tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mappin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23280,validat,validate,23280,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['validat'],['validate']
Security," @llvm.memset.p0.i32(ptr <dest>, i8 <val>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memset.p0.i64(ptr <dest>, i8 <val>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memset.*``' intrinsics fill a block of memory with a; particular byte value. Note that, unlike the standard libc function, the ``llvm.memset``; intrinsic does not return a value and takes an extra volatile; argument. Also, the destination can be in an arbitrary address space. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination to fill, the second; is the byte value with which to fill it, the third argument is an; integer argument specifying the number of bytes to fill, and the fourth; is a boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memset`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memset.*``' intrinsics fill ""len"" bytes of memory starting; at the destination location. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, ``<dest>`` should be well-defined, otherwise the; behavior is undefined. .. _int_memset_inline:. '``llvm.memset.inline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memset.inline`` on any; integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memset.inline.p0.p0i8.i32(ptr <dest>, i8 <val>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memset.inline.p0.p0.i64(ptr <dest>, i8 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:553847,access,access,553847,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security, AMDGPU DWARF Register Mapping; :name: amdgpu-dwarf-register-mapping-table. ============== ================= ======== ==================================; DWARF Register AMDGPU Register Bit Size Description; ============== ================= ======== ==================================; 0 PC_32 32 Program Counter (PC) when; executing in a 32-bit process; address space. Used in the CFI to; describe the PC of the calling; frame.; 1 EXEC_MASK_32 32 Execution Mask Register when; executing in wavefront 32 mode.; 2-15 *Reserved* *Reserved for highly accessed; registers using DWARF shortcut.*; 16 PC_64 64 Program Counter (PC) when; executing in a 64-bit process; address space. Used in the CFI to; describe the PC of the calling; frame.; 17 EXEC_MASK_64 64 Execution Mask Register when; executing in wavefront 64 mode.; 18-31 *Reserved* *Reserved for highly accessed; registers using DWARF shortcut.*; 32-95 SGPR0-SGPR63 32 Scalar General Purpose; Registers.; 96-127 *Reserved* *Reserved for frequently accessed; registers using DWARF 1-byte ULEB.*; 128 STATUS 32 Status Register.; 129-511 *Reserved* *Reserved for future Scalar; Architectural Registers.*; 512 VCC_32 32 Vector Condition Code Register; when executing in wavefront 32; mode.; 513-767 *Reserved* *Reserved for future Vector; Architectural Registers when; executing in wavefront 32 mode.*; 768 VCC_64 64 Vector Condition Code Register; when executing in wavefront 64; mode.; 769-1023 *Reserved* *Reserved for future Vector; Architectural Registers when; executing in wavefront 64 mode.*; 1024-1087 *Reserved* *Reserved for padding.*; 1088-1129 SGPR64-SGPR105 32 Scalar General Purpose Registers.; 1130-1535 *Reserved* *Reserved for future Scalar; General Purpose Registers.*; 1536-1791 VGPR0-VGPR255 32*32 Vector General Purpose Registers; when executing in wavefront 32; mode.; 1792-2047 *Reserved* *Reserved for future Vector; General Purpose Registers when; executing in wavefront 32 mode.*; 2048-2303 AGPR0-AGPR255 32*32 Vector Accumul,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:87888,access,accessed,87888,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security," Arm SVE; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/bjms39pe6k6bo5egtsp7don414%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/u/0/embed?src=bjms39pe6k6bo5egtsp7don414@group.calendar.google.com>`__; - `Minutes/docs <https://docs.google.com/document/d/1UPH2Hzou5RgGT8XfO39OmVXKEibWPfdYLELSaHr3xzo/edit>`__; * - ML Guided Compiler Optimizations; - Monthly; -; - `Minutes/docs <https://docs.google.com/document/d/1JecbplF09l3swTjze-UVeLh4L48svJxGVy4mz_e9Rhs/edit?usp=gmail#heading=h.ts9cmcjbir1j>`__; * - `LLVM security group <https://llvm.org/docs/Security.html>`__; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/eoh3m9k1l6vqbd1fkp94fv5q74%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/embed?src=eoh3m9k1l6vqbd1fkp94fv5q74%40group.calendar.google.com>`__; - `Minutes/docs <https://discourse.llvm.org/t/llvm-security-group-public-sync-ups/62735>`__; * - `CIRCT <https://github.com/llvm/circt>`__; - Weekly, on Wednesday; -; - `Minutes/docs <https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.mulvhjtr8dk9>`__; * - `MLIR <https://mlir.llvm.org>`__ design meetings; - Weekly, on Thursdays; -; - `Minutes/docs <https://docs.google.com/document/d/1y_9f1AbfgcoVdJh4_aM6-BaSHvrHl8zuA5G4jv_94K8/edit#heading=h.cite1kolful9>`__; * - flang; - Multiple meeting series, `documented here <https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls>`__; -; -; * - OpenMP; - Multiple meeting series, `documented here <https://openmp.llvm.org/docs/SupportAndFAQ.html>`__; -; -; * - LLVM Alias Analysis; - Every 4 weeks on Tuesdays; - `ics <http://lists.llvm.org/pipermail/llvm-dev/attachments/20201103/a3499a67/attachment-0001.ics>`__; - `Minutes/docs <https://docs.google.com/document/d/17U-WvX8qyKc3S36YUKr3xfF-GHunWyYowXbxEdpHscw>`__; * - Vector Predication; - Every 2 weeks on Tue",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:6177,secur,security-group-public-sync-ups,6177,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['secur'],['security-group-public-sync-ups']
Security," BDT, but BDT remains the default for boosted; decision trees, because it has pruning (among other; additional features). . Other improvements . Improved handling of small Likelihood values such that; Likelihood performance increases in analyses with many variables; (~>10). Thanks to Ralph Schaefer (Bonn U.) for reporting this. Nicer plotting: custom variable titles and units can be; assigned in ""AddVariable"" call. Introduced the inverse transformation InverseTransform for; the variable transformations into the framework. While this is; not necessary for classification, it is necessary for; regression. The inverse transformation of the normalization; transformation has been implemented. Started to extend the variable transformations to the; regression targets as well. MethodCuts now produces the 'optimal-cut' histograms needed; by macro mvaeffs.C. (macro 5a of TMVAGui.C); ; MsgLogger can be silenced in order to prevent excess output; during boosting. Third dataset type added centrally (Training, Validation; and Testing). The validation data is split off the original; training data set. Update of GUI and other Macros according to the new; features of PDF and the addition of MethodBoost.; ; Updates in TMVA 4.0.1. ""Spectator"" variables can be defined now which are computed; just as the input variables and which are written out into the; TestTree, but which don't participate in any MVA calculation; (useful for correlation studies).; ; New booking option ""IgnoreNegWeightsInTraining"" to test the; effect of events with negative weights on the training. This is; especially useful for methods, which do not properly deal with; such events. Note that this new option is not available for all; methods (a training interrupt is issued if not available). ; Bug fixes:. Fixed regression bug in VariableNormalizeTransform (Use; number of targets from Event instead of DataSet); ; Fixed Multitarget-Regression in PDEFoam, foam dimensions; were miscalculated. Added writing of targets to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:5909,Validat,Validation,5909,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,1,['Validat'],['Validation']
Security," CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1823. 398; CD1; Ambiguous wording on naming a type in deduction; Yes. 399; CD6; Destructor lookup redux; Clang 11. 400; CD1; Using-declarations and the ""struct hack""; Yes. 401; CD1; When is access for template parameter default arguments checked?; Clang 2.8. 402; open; More on partial ordering of function templates; Not resolved. 403; CD1; Reference to a type as a template-id; Yes. 404; CD1; Unclear reference to construction with non-trivial constructor; N/A. 405; CD6; Unqualified function name lookup; Yes. 406; CD1; Static data member in class with name for linkage purposes; Clang 2.9. 407; C++11; Named class with associated typedef: two names or one?; Clang 3.8. 408; CD2; sizeof applied to unknown-bound array static data member of template; Clang 3.4. 409; CD1; Obsolete paragraph missed by changes for issue 224; Yes. 410; CD1; Paragraph missed in changes for issue 166; No. 411; CD6; Use of universal-character-name in character versus string literals; Unknown. 412; NAD; Can a replacement allocation function be inline?; Clang 3.4. 413; CD1; Definition of ""empty class""; Yes. 414; CD1; Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instanti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:26931,access,access,26931,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security," CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local L2 cache; lines if configured to have multiple L2 caches. * PCIe access from the GPU to the CPU can be kept coherent by using the MTYPE; UC (uncached) which bypasses the L2. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:289683,access,access,289683,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:20599,hash,hashing,20599,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['hash'],['hashing']
Security," Check `b1` again -- unnecessary!; g();; }; }; }; ```. A checker that finds this pattern syntactically is already implemented in; ClangTidy using AST matchers (`bugprone-redundant-branch-condition`). To implement it using the data flow analysis framework, we can produce a warning; if any part of the branch condition is implied by the flow condition. ```c++; int F(bool b1, bool b2) {; // Flow condition: true.; if (b1) {; // Flow condition: b1.; f();; if (b1 && b2) { // `b1` is implied by the flow condition.; g();; }; }; }; ```. One way to check this implication is to use a SAT solver. Without a SAT solver,; we could keep the flow condition in the CNF form and then it would be easy to; check the implication. ## Example: finding unchecked `std::optional` unwraps. Calling `optional::value()` is only valid if `optional::has_value()` is true. We; want to show that when `x.value()` is executed, the flow condition implies; `x.has_value()`. In the example below `x.value()` is accessed safely because it is guarded by the; `x.has_value()` check. ```c++; void Example(std::optional<int> &x) {; if (x.has_value()) {; use(x.value());; }; }; ```. While entering the if branch we deduce that `x.has_value()` is implied by the; flow condition. ```c++; void Example(std::optional<int> x) {; // Flow condition: true.; if (x.has_value()) {; // Flow condition: x.has_value() == true.; use(x.value());; }; // Flow condition: true.; }; ```. We also need to prove that `x` is not modified between check and value access.; The modification of `x` may be very subtle:. ```c++; void F(std::optional<int> &x);. void Example(std::optional<int> &x) {; if (x.has_value()) {; // Flow condition: x.has_value() == true.; unknown_function(x); // may change x.; // Flow condition: true.; use(x.value());; }; }; ```. ## Example: finding dead code behind A/B experiment flags. Finding dead code is a classic application of data flow analysis. Unused flags for A/B experiment hide dead code. However, this flavor of dead; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:27039,access,accessed,27039,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['access'],['accessed']
Security," Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5314,access,accessed,5314,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['access'],['accessed']
Security," Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note that each type of vector is constructed by passing its coordinate; representation, so a **`XYZTVector`**`(1,2,3,4)` is different from a; `PtEtaPhiEVector(1,2,3,4)`. In addition, the Vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`,; `z()` and `t()`. This can be another `ROOT::Math::`**`LorentzVector`** based on a; different coordinate system or any vector of a different package, like; the CLHEP **`HepLorentzVector`** that implements the required signature. ``` {.cpp}; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector`**. For example:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; ```. To get information on all the coordinate accessors see the; `ROOT::Math::`**`LorentzVector`** reference documentation. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; //sets the (x,y,z,t) for a XYZTVector; v1.SetCo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:87872,access,accessors,87872,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['access'],['accessors']
Security," Deduce function attributes on SCC (f); BISECT: NOT running pass (17) Remove unused exception handling info on SCC (g); BISECT: NOT running pass (18) Function Integration/Inlining on SCC (g); BISECT: NOT running pass (19) Deduce function attributes on SCC (g); BISECT: NOT running pass (20) SROA on function (g); BISECT: NOT running pass (21) Early CSE on function (g); BISECT: NOT running pass (22) Speculatively execute instructions if target has divergent branches on function (g); ... etc. ... Pass Skipping Implementation; ============================. The -opt-bisect-limit implementation depends on individual passes opting in to; the opt-bisect process. The OptBisect object that manages the process is; entirely passive and has no knowledge of how any pass is implemented. When a; pass is run if the pass may be skipped, it should call the OptBisect object to; see if it should be skipped. The OptBisect object is intended to be accessed through LLVMContext and each; Pass base class contains a helper function that abstracts the details in order; to make this check uniform across all passes. These helper functions are:. .. code-block:: c++. bool ModulePass::skipModule(Module &M);; bool CallGraphSCCPass::skipSCC(CallGraphSCC &SCC);; bool FunctionPass::skipFunction(const Function &F);; bool LoopPass::skipLoop(const Loop *L);. A MachineFunctionPass should use FunctionPass::skipFunction() as such:. .. code-block:: c++. bool MyMachineFunctionPass::runOnMachineFunction(Function &MF) {; if (skipFunction(*MF.getFunction()); return false;; // Otherwise, run the pass normally.; }. In addition to checking with the OptBisect class to see if the pass should be; skipped, the skipFunction(), skipLoop() and skipBasicBlock() helper functions; also look for the presence of the ""optnone"" function attribute. The calling; pass will be unable to determine whether it is being skipped because the; ""optnone"" attribute is present or because the opt-bisect-limit has been; reached. This is desirable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:7246,access,accessed,7246,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['access'],['accessed']
Security," FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23413,secur,security,23413,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security," GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhyIWYU.md for a good overview of the motivation. Even more includes will be ""hidden"" when ROOT configured with `-Ddev=ON` build option.; In that case ROOT uses `#ifdef R__LESS_INCLUDES` to replace unused includes by class forward declarations.; Such `dev` builds can be used to verify that ROOT-based code really inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:8153,sanitiz,sanitizer,8153,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['sanitiz'],['sanitizer']
Security," If the identifier names a macro, the offset of the macro definition within; the :ref:`pchinternals-preprocessor`.; * If the identifier names one or more declarations visible from translation; unit scope, the :ref:`declaration IDs <pchinternals-decls>` of these; declarations. When an AST file is loaded, the AST file reader mechanism introduces itself; into the identifier table as an external lookup source. Thus, when the user; program refers to an identifier that has not yet been seen, Clang will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialized,; at which point the corresponding ``IdentifierInfo`` structure will have the; same contents it would have after parsing the headers in the AST file. Within the AST file, the identifiers used to name declarations are represented; with an integral value. A separate table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represented as an on-disk hash table that serves two; purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:19964,hash,hash,19964,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['hash'],['hash']
Security," It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-address / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address % 4)``. If each lane of a wavefront accesses the same private address, the; interleaving results in adjacent dwords being accessed and hence requires; fewer cache lines to be fetched. There are different ways that the wavefront scratch base address is; determined by a wavefront (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Scratch memory can be accessed in an interleaved manner using buffer; instructions with the scratch buffer descriptor and per wavefront scratch; offset, by the scratch instructions, or by flat instructions. Multi-dword; access is not supported except by flat and scratch instructions in; GFX9-GFX11. Code that manipulates the stack values in other lanes of a wavefront,; such as by ``addrspacecast``-ing stack pointers to generic ones and taking offsets; that reach other lanes or by explicitly constructing the scratch buffer descriptor,; triggers undefined behavior when it modifies the scratch values of other lanes.; The compiler may assume that such modifications do not occur.; When using code object V5 ``LIBOMPTARGET_STACK_SIZE`` may be used to pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:27333,access,accesses,27333,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],"['accessed', 'accesses']"
Security," Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" -; e-Print Archive: hep ex/0011057 and more information can be found; also in ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; and ""Jann Ben -, Univariate kernel; density estimation document for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12251,Access,Access,12251,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,2,['Access'],['Access']
Security," L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW_OP_call_frame_cfa``. ``DW_OP_call_frame_cfa`` pushes the location description L of the Canonical; Frame Address (CFA) of the current subprogram, obtained from the call frame; information on the stack. See :ref:`amdgpu-dwarf-call-frame-information`. *Although the value of the* ``DW_AT_frame_base`` *attribute of the debugger; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:113262,access,accessed,113262,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessed']
Security," LDS operations of a WGP are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; WGP. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations.; Completion of load/store/sample operations are reported to a wavefront in; execution order of other load/store/sample operations performed by that; wavefront.; * The vector memory operations access a vector L0 cache. There is a single L0; cache per CU. Each SIMD of a CU accesses the same L0 cache. Therefore, no; special action is required for coherence between the lanes of a single; wavefront. However, a ``buffer_gl0_inv`` is required for coherence between; wavefronts executing in the same work-group as they may be executing on SIMDs; of different CUs that access different L0s. A ``buffer_gl0_inv`` is also; required for coherence between wavefronts executing in different work-groups; as they may be executing on different WGPs.; * The scalar memory operations access a scalar L0 cache shared by all wavefronts; on a WGP. The scalar and vector L0 caches are not coherent. However, scalar; operations are used in a restricted way so do not impact the memory model. See; :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory L0 caches use an L1 cache shared by all WGPs on; the same SA. Therefore, no special action is required for coherence between; the wavefronts o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:336776,access,access,336776,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," LLVM, see `the download page; <https://llvm.org/releases/>`_ to find your documentation. The LLVM compiler infrastructure supports a wide range of projects, from; industrial strength compilers to specialized JIT applications to small; research projects. Similarly, documentation is broken down into several high-level groupings; targeted at different audiences:. LLVM Design & Overview; ======================. Several introductory papers and presentations. .. toctree::; :hidden:. FAQ; Lexicon. `Introduction to the LLVM Compiler`__; Presentation providing a users introduction to LLVM. .. __: https://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.html. `Intro to LLVM`__; A chapter from the book ""The Architecture of Open Source Applications"" that; describes high-level design decisions that shaped LLVM. .. __: http://www.aosabook.org/en/llvm.html. `LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation`__; Design overview. .. __: https://llvm.org/pubs/2004-01-30-CGO-LLVM.html. `LLVM: An Infrastructure for Multi-Stage Optimization`__; More details (quite old now). .. __: https://llvm.org/pubs/2002-12-LattnerMSThesis.html. Documentation; =============. Getting Started, How-tos, Developer Guides, and Tutorials. .. toctree::; :hidden:. GettingStartedTutorials; Reference; UserGuides; DiscourseMigrationGuide. :doc:`GettingStartedTutorials`; For those new to the LLVM system. :doc:`UserGuides`; User guides and How-tos. :doc:`Reference`; LLVM and API reference documentation. :doc:`DiscourseMigrationGuide`; Guide for users to migrate to Discourse. Community; =========. LLVM welcomes contributions of all kinds. To learn more, see the following articles:. .. toctree::; :hidden:. GettingInvolved. * :doc:`GettingInvolved`; * :ref:`development-process`; * :ref:`lists-forums`; * :ref:`meetups-social-events`; * :ref:`community-proposals`. Reporting a security issue. * :ref:`report-security-issue`. Indices and tables; ==================. * :ref:`genindex`; * :ref:`search`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/index.rst:1945,secur,security,1945,interpreter/llvm-project/llvm/docs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/index.rst,2,['secur'],"['security', 'security-issue']"
Security," Make an aligned typedef of the AVX-512 16-int vector type.; typedef __v16si __aligned_v16si __attribute__((aligned(64)));. void initialize_vector(__aligned_v16si *v) {; // The compiler may assume that ‘v’ is 64-byte aligned, regardless of the; // value of -fmax-type-align.; }. .. option:: -faddrsig, -fno-addrsig. Controls whether Clang emits an address-significance table into the object; file. Address-significance tables allow linkers to implement `safe ICF; <https://research.google.com/pubs/archive/36912.pdf>`_ without the false; positives that can result from other implementation techniques such as; relocation scanning. Address-significance tables are enabled by default; on ELF targets when using the integrated assembler. This flag currently; only has an effect on ELF targets. .. option:: -f[no]-unique-internal-linkage-names. Controls whether Clang emits a unique (best-effort) symbol name for internal; linkage symbols. When this option is set, compiler hashes the main source; file path from the command line and appends it to all internal symbols. If a; program contains multiple objects compiled with the same command-line source; file path, the symbols are not guaranteed to be unique. This option is; particularly useful in attributing profile information to the correct; function when multiple functions with the same private linkage name exist; in the binary. It should be noted that this option cannot guarantee uniqueness and the; following is an example where it is not unique when two modules contain; symbols with the same private linkage name:. .. code-block:: console. $ cd $P/foo && clang -c -funique-internal-linkage-names name_conflict.c; $ cd $P/bar && clang -c -funique-internal-linkage-names name_conflict.c; $ cd $P && clang foo/name_conflict.o && bar/name_conflict.o. .. option:: -fbasic-block-sections=[labels, all, list=<arg>, none]. Controls how Clang emits text sections for basic blocks. With values ``all``; and ``list=<arg>``, each basic block or a subset",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:87310,hash,hashes,87310,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['hash'],['hashes']
Security," MergeRecursive (fixes bug #54591); Fix a major leak when merging files with collections; written using kSingleKey option.  The merger was reading each; key in memory and deleted the object at the end, but the container is; not owner by default, so all objects inside leaked. PROOF-Lite. Fix a couple of memory leaks showing up when running; repeated queries; Fix a problem in TProofServ::CopyFromCache affecting; the case where the sandbox dir has a '.' and the macro name has no '.',; e.g. compiled selectors in PROOF-Lite. TProofOutputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effect was to delete the; outputfile just after having open it. XrdProofd plugin. Make sure that the limit on the number of old; sessions is applied whenever a new session is started and not only when; the daemon is started.; Fix the behaviour of the xpd.allowedusers directive: if; at least one of these directives is present, users in the password file; are not allowed by default but must be explicitly appear in one; xpd.allowedusers directive  ; Fix a source for memory leak in; XrdProofdProtocol::SendMsg; Optimize the usage of strings in a few places. DataSet manager. Correctly classify as TTree all TTree derived classes; (e.g. TNtuple's); Fix a problem in saving the end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacke",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:7713,password,password,7713,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,['password'],['password']
Security," PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64042,secur,security,64042,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security," Prefer 'Nullability' and other annotations when possible. We parse the specified type as if it appeared at the location of the; declaration whose type is being modified. Macros are not available and; nullability must be applied explicitly (even in an ``NS_ASSUME_NONNULL_BEGIN``; section). ::. - Name: delegate; PropertyKind: Instance; Type: ""id"". :ResultType:. Used for methods and functions. This completely overrides the return type; it; should ideally only be used for Swift backwards compatibility, when existing; type information has been made more precise in a header. We parse the specified type as if it appeared at the location of the; declaration whose type is being modified. Macros are not available and; nullability must be applied explicitly (even in an ``NS_ASSUME_NONNULL_BEGIN``; section). ::. - Selector: ""subviews""; MethodKind: Instance; ResultType: ""NSArray * _Nonnull"". :SwiftImportAsAccessors:. Used for properties. If true, the property will be exposed in Swift as its; accessor methods, rather than as a computed property using ``var``. ::. - Name: currentContext; PropertyKind: Class; SwiftImportAsAccessors: true. :NSErrorDomain:. Used for ``NSError`` code enums. The value is the name of the associated; domain ``NSString`` constant; an empty string (``""""``) means the enum is a; normal enum rather than an error code. ::. - Name: MKErrorCode; NSErrorDomain: MKErrorDomain. :SwiftWrapper:. Controls ``NS_STRING_ENUM`` and ``NS_EXTENSIBLE_STRING_ENUM``. There are three; options:. - ""struct"" (extensible); - ""enum""; - ""none"". Note that even an ""enum"" wrapper is still presented as a struct in Swift;; it's just a ""more enum-like"" struct. ::. - Name: AVMediaType; SwiftWrapper: none. :EnumKind:. Has the same effect as ``NS_ENUM`` and ``NS_OPTIONS``. There are four options:. - ""NSEnum"" / ""CFEnum""; - ""NSClosedEnum"" / ""CFClosedEnum""; - ""NSOptions"" / ""CFOptions""; - ""none"". ::. - Name: GKPhotoSize; EnumKind: none. :Parameters:. Used for methods and functions. Parameters are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst:7593,expose,exposed,7593,interpreter/llvm-project/clang/docs/APINotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst,2,"['access', 'expose']","['accessor', 'exposed']"
Security," Princeton and CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Zhe Zhang, Nebraska,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. ### Deprecated packages. The Virtual Monte Carlo (VMC) interfaces have been deprecated for this release; and will be removed in a future release. It is no longer built by default, but; can still be enabled with the option `-Dvmc=ON` in the CMake configuration phase.; A standalone version of VMC is being developed at [https://github.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; removed:. * PROOF's PQ2 module; * `THttpServer::ExecuteHttp()` and `THttpServer::SubmitHttp` from `THttpServer`. ### Other changes. The deprecation of the GraphViz integration has been reverted since the code is; still in use. The ODBC interface, deprecated in ROOT 6.16, is no longer deprecated in ROOT 6.18.; It is the main option to support databases on Windows, so the decision to deprecate; it was reverted. The `xft` option has been merged into `x11` and is no longer used (its value is; now ignored by ROOT). ## Preprocessor deprecation macros; ### Deprecated Classes; * `R__SUGGEST_ALTERNATIVE(""Suggestion text"")` macro allows to suggest alternatives to classes. It must be used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:2023,authenticat,authentication,2023,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,3,['authenticat'],['authentication']
Security," Public License has appeared, then you can specify; that version instead if you wish.) Do not make any other change in; these notices.; ; Once this change is made in a given copy, it is irreversible for; that copy, so the ordinary GNU General Public License applies to all; subsequent copies and derivative works made from that copy. This option is useful when you wish to copy part of the code of; the Library into a program that is not a library. 4. You may copy and distribute the Library (or a portion or; derivative of it, under Section 2) in object code or executable form; under the terms of Sections 1 and 2 above provided that you accompany; it with the complete corresponding machine-readable source code, which; must be distributed under the terms of Sections 1 and 2 above on a; medium customarily used for software interchange. If distribution of object code is made by offering access to copy; from a designated place, then offering equivalent access to copy the; source code from the same place satisfies the requirement to; distribute the source code, even though third parties are not; compelled to copy the source along with the object code. 5. A program that contains no derivative of any portion of the; Library, but is designed to work with the Library by being compiled or; linked with it, is called a ""work that uses the Library"". Such a; work, in isolation, is not a derivative work of the Library, and; therefore falls outside the scope of this License. However, linking a ""work that uses the Library"" with the Library; creates an executable that is a derivative of the Library (because it; contains portions of the Library), rather than a ""work that uses the; library"". The executable is therefore covered by this License.; Section 6 states terms for distribution of such executables. When a ""work that uses the Library"" uses material from a header file; that is part of the Library, the object code for the work may be a; derivative work of the Library even though the sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:12096,access,access,12096,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,2,['access'],['access']
Security," ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; ```. The above is another good reason to prefer 'import ROOT' over 'from ROOT; import \*'. #### Access to Python. The access to Python from Cling goes through the **`TPython`** class, or; directly if a Python object or class has crossed the border. The; **`TPython`** class, which looks approximately like this:. ``` {.cpp}; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:14976,access,access,14976,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['access']
Security, Reference overload tiebreakers should apply to rvalue references; Unknown. 1411; CD3; More on global scope :: in nested-name-specifier; Unknown. 1412; CD3; Problems in specifying pointer conversions; Unknown. 1413; CD3; Missing cases of value-dependency; Clang 12. 1414; drafting; Binding an rvalue reference to a reference-unrelated lvalue; Not resolved. 1415; CD3; Missing prohibition of block-scope definition of extern object; Unknown. 1416; CD3; Function cv-qualifiers and typeid; Unknown. 1417; C++14; Pointers/references to functions with cv-qualifiers or ref-qualifier; Unknown. 1418; CD3; Type of initializer_list backing array; Unknown. 1419; NAD; Evaluation order in aggregate initialization; Unknown. 1420; NAD; Abstract final classes; Unknown. 1421; NAD; Full expressions and aggregate initialization; Unknown. 1422; dup; Type of character literals containing universal-character-names; Unknown. 1423; CD3; Convertibility of nullptr to bool; Clang 11. 1424; C++14; When must sub-object destructors be accessible?; Unknown. 1425; CD3; Base-class subobjects of standard-layout structs; N/A (ABI constraint). 1426; CD5; Allowing additional parameter types in defaulted functions; Unknown. 1427; NAD; Default constructor and deleted or inaccessible destructors; Unknown. 1428; CD3; Dynamic const objects; Unknown. 1429; NAD; Scope of a member template's template parameter; Unknown. 1430; open; Pack expansion into fixed alias template parameter list; Not resolved. 1431; CD3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of inv,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:95653,access,accessible,95653,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['accessible']
Security," Such a; work, in isolation, is not a derivative work of the Library, and; therefore falls outside the scope of this License. However, linking a ""work that uses the Library"" with the Library; creates an executable that is a derivative of the Library (because it; contains portions of the Library), rather than a ""work that uses the; library"". The executable is therefore covered by this License.; Section 6 states terms for distribution of such executables. When a ""work that uses the Library"" uses material from a header file; that is part of the Library, the object code for the work may be a; derivative work of the Library even though the source code is not.; Whether this is true is especially significant if the work can be; linked without the Library, or if the work is itself a library. The; threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data; structure layouts and accessors, and small macros and small inline; functions (ten lines or less in length), then the use of the object; file is unrestricted, regardless of whether it is legally a derivative; work. (Executables containing this object code plus portions of the; Library will still fall under Section 6.). Otherwise, if the work is a derivative of the Library, you may; distribute the object code for the work under the terms of Section 6.; Any executables containing that work also fall under Section 6,; whether or not they are linked directly with the Library itself. 6. As an exception to the Sections above, you may also combine or; link a ""work that uses the Library"" with the Library to produce a; work containing portions of the Library, and distribute that work; under terms of your choice, provided that the terms permit; modification of the work for the customer's own use and reverse; engineering for debugging such modifications. You must give prominent notice with each copy of the work that the; Library is used in it and that the Library and its",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:15771,access,accessors,15771,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['access'],['accessors']
Security," Such a; work, in isolation, is not a derivative work of the Library, and; therefore falls outside the scope of this License. However, linking a ""work that uses the Library"" with the Library; creates an executable that is a derivative of the Library (because it; contains portions of the Library), rather than a ""work that uses the; library"". The executable is therefore covered by this License.; Section 6 states terms for distribution of such executables. When a ""work that uses the Library"" uses material from a header file; that is part of the Library, the object code for the work may be a; derivative work of the Library even though the source code is not.; Whether this is true is especially significant if the work can be; linked without the Library, or if the work is itself a library. The; threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data; structure layouts and accessors, and small macros and small inline; functions (ten lines or less in length), then the use of the object; file is unrestricted, regardless of whether it is legally a derivative; work. (Executables containing this object code plus portions of the; Library will still fall under Section 6.). Otherwise, if the work is a derivative of the Library, you may; distribute the object code for the work under the terms of Section 6.; Any executables containing that work also fall under Section 6,; whether or not they are linked directly with the Library itself.; ; 6. As an exception to the Sections above, you may also combine or; link a ""work that uses the Library"" with the Library to produce a; work containing portions of the Library, and distribute that work; under terms of your choice, provided that the terms permit; modification of the work for the customer's own use and reverse; engineering for debugging such modifications. You must give prominent notice with each copy of the work that the; Library is used in it and that the Library and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:13503,access,accessors,13503,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['access'],['accessors']
Security," Table; ################. Low 32 bits of the GPU address for an optional buffer in the ``.data``; section of the ELF. The high 32 bits of the address match the high 32 bits; of the shader's program counter. The buffer can be anything the shader compiler needs it for, and; allows each shader to have its own region of the ``.data`` section.; Typically, this could be a table of buffer SRD's and the data pointed to; by the buffer SRD's, but it could be a flat-address region of memory as; well. Its layout and usage are defined by the shader compiler. Each shader's table in the ``.data`` section is referenced by the symbol; ``_amdgpu_``\ *xs*\ ``_shdr_intrl_data`` where *xs* corresponds with the; hardware shader stage the data is for. E.g.,; ``_amdgpu_cs_shdr_intrl_data`` for the compute shader hardware stage. .. _amdgpu-amdpal-code-object-metadata-user-data-spill-table-section:. Spill Table; ###########. It is possible for a hardware shader to need access to more *user data; entries* than there are slots available in user data registers for one; or more hardware shader stages. In that case, the PAL runtime expects; the necessary *user data entries* to be spilled to GPU memory and use; one user data register to point to the spilled user data memory. The; value of the *user data entry* must then represent the location where; a shader expects to read the low 32-bits of the table's GPU virtual; address. The *spill table* itself represents a set of 32-bit values; managed by the PAL runtime in GPU-accessible memory that can be made; indirectly accessible to a hardware shader. Unspecified OS; --------------. This section provides code conventions used when the target triple OS is; empty (see :ref:`amdgpu-target-triples`). Trap Handler ABI; ~~~~~~~~~~~~~~~~. For code objects generated by AMDGPU backend for non-amdhsa OS, the runtime does; not install a trap handler. The ``llvm.trap`` and ``llvm.debugtrap``; instructions are handled as follows:. .. table:: AMDGPU Trap Handler for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:419413,access,access,419413,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140674,access,accessibility,140674,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessibility']
Security," The data store; (DS) instructions can be used to access it. The private memory space uses the hardware scratch memory support. If the kernel; uses scratch, then the hardware allocates memory that is accessed using; wavefront lane dword (4 byte) interleaving. The mapping used from private; address to physical address is:. ``wavefront-scratch-base +; (private-address * wavefront-size * 4) +; (wavefront-lane-id * 4)``. There are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155275,access,access,155275,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," The goal of the walker is to provide answers to clobber; queries beyond what's represented directly by ``MemoryAccess``\ es. For example,; given:. .. code-block:: llvm. define void @foo() {; %a = alloca i8; %b = alloca i8. ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %a; ; 2 = MemoryDef(1); store i8 0, ptr %b; }. The store to ``%a`` is clearly not a clobber for the store to ``%b``. It would; be the walker's goal to figure this out, and return ``liveOnEntry`` when queried; for the clobber of ``MemoryAccess`` ``2``. By default, ``MemorySSA`` provides a walker that can optimize ``MemoryDef``\ s; and ``MemoryUse``\ s by consulting whatever alias analysis stack you happen to; be using. Walkers were built to be flexible, though, so it's entirely reasonable; (and expected) to create more specialized walkers (e.g. one that specifically; queries ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the access clobbering memory location ``Loc``, starting at ``MA``.; Because this API does not request the clobbering access of a specific memory; access, there are no results that can be cached. Locating clobbers yourself; ^^^^^^^^^^^^^^^^^^^^^^^^^^. If you choose to make your own walker, you can find the clobber for a; ``MemoryAccess`` by walking every ``MemoryDef`` that dominates said; ``MemoryAccess``. The structure of ``MemoryDef``\ s makes this relatively simple;; they ultimately form a linked list of every clobber that dominates the; ``MemoryAccess`` that you're trying to optimize. In other words, the; ``definingAccess`` of a ``MemoryDef`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:9880,access,access,9880,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security," The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the fol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139392,access,access,139392,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['access'],['access']
Security," The serialization format supports hash tables of arbitrarily large size and; capacity, as well as value types and hash functions. The only supported key; value type is a uint32. The only requirement is that the producer and consumer; agree on the hash function. As such, the hash function can is not discussed; further in this document, it is assumed that for a particular instance of a PDB; file hash table, the appropriate hash function is being used. On-Disk Format; ==============. .. code-block:: none. .--------------------.-- +0; | Size |; .--------------------.-- +4; | Capacity |; .--------------------.-- +8; | Present Bit Vector |; .--------------------.-- +N; | Deleted Bit Vector |; .--------------------.-- +M ─╮; | Key | │; .--------------------.-- +M+4 │; | Value | │; .--------------------.-- +M+4+sizeof(Value) │; ... ├─ |Capacity| Bucket entries; .--------------------. │; | Key | │; .--------------------. │; | Value | │; .--------------------. ─╯. - **Size** - The number of values contained in the hash table. - **Capacity** - The number of buckets in the hash table. Producers should; maintain a load factor of no greater than ``2/3*Capacity+1``. - **Present Bit Vector** - A serialized bit vector which contains information; about which buckets have valid values. If the bucket has a value, the; corresponding bit will be set, and if the bucket doesn't have a value (either; because the bucket is empty or because the value is a tombstone value) the bit; will be unset. - **Deleted Bit Vector** - A serialized bit vector which contains information; about which buckets have tombstone values. If the entry in this bucket is; deleted, the bit will be set, otherwise it will be unset. - **Keys and Values** - A list of ``Capacity`` hash buckets, where the first; entry is the key (always a uint32), and the second entry is the value. The; state of each bucket (valid, empty, deleted) can be determined by examining; the present and deleted bit vectors. .. _hash_bit_vectors:. Pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/HashTable.rst:1482,hash,hash,1482,interpreter/llvm-project/llvm/docs/PDB/HashTable.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/HashTable.rst,1,['hash'],['hash']
Security," These intrinsics modify the pointer value to be a valid pointer in the target; non-generic address space. Reading PTX Special Registers; -----------------------------. '``llvm.nvvm.read.ptx.sreg.*``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". .. code-block:: llvm. declare i32 @llvm.nvvm.read.ptx.sreg.tid.x(); declare i32 @llvm.nvvm.read.ptx.sreg.tid.y(); declare i32 @llvm.nvvm.read.ptx.sreg.tid.z(); declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x(); declare i32 @llvm.nvvm.read.ptx.sreg.ntid.y(); declare i32 @llvm.nvvm.read.ptx.sreg.ntid.z(); declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(); declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.y(); declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.z(); declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x(); declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.y(); declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.z(); declare i32 @llvm.nvvm.read.ptx.sreg.warpsize(). Overview:; """""""""""""""""". The '``@llvm.nvvm.read.ptx.sreg.*``' intrinsics provide access to the PTX; special registers, in particular the kernel launch bounds. These registers; map in the following way to CUDA builtins:. ============ =====================================; CUDA Builtin PTX Special Register Intrinsic; ============ =====================================; ``threadId`` ``@llvm.nvvm.read.ptx.sreg.tid.*``; ``blockIdx`` ``@llvm.nvvm.read.ptx.sreg.ctaid.*``; ``blockDim`` ``@llvm.nvvm.read.ptx.sreg.ntid.*``; ``gridDim`` ``@llvm.nvvm.read.ptx.sreg.nctaid.*``; ============ =====================================. Barriers; --------. '``llvm.nvvm.barrier0``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". .. code-block:: llvm. declare void @llvm.nvvm.barrier0(). Overview:; """""""""""""""""". The '``@llvm.nvvm.barrier0()``' intrinsic emits a PTX ``bar.sync 0``; instruction, equivalent to the ``__syncthreads()`` call in CUDA. Other Intrinsics; ----------------. For the full set of NVPTX intrinsics, please see the; ``include/llvm/IR/IntrinsicsNVVM.td`` file in the LLVM source tree. .. _libdevice:. Link",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:6507,access,access,6507,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['access'],['access']
Security," This is intended for writing language bindings, where C string; conversion would add unnecessary overhead and new error cases. Unicode; strings should be encoded as UTF-8. Application code in C should prefer `llvm_blake3_hasher_init_derive_key`,; which takes the context as a C string. If you need to use arbitrary; bytes as a context string in application code, consider whether you're; violating the requirement that context strings should be hardcoded. ---. ```c; void llvm_blake3_hasher_finalize_seek(; const llvm_blake3_hasher *self,; uint64_t seek,; uint8_t *out,; size_t out_len);; ```. The same as `llvm_blake3_hasher_finalize`, but with an additional `seek`; parameter for the starting byte position in the output stream. To; efficiently stream a large output without allocating memory, call this; function in a loop, incrementing `seek` by the output length each time. ---. ```c; void llvm_blake3_hasher_reset(; llvm_blake3_hasher *self);; ```. Reset the hasher to its initial state, prior to any calls to; `llvm_blake3_hasher_update`. Currently this is no different from calling; `llvm_blake3_hasher_init` or similar again. However, if this implementation gains; multithreading support in the future, and if `llvm_blake3_hasher` holds (optional); threading resources, this function will reuse those resources. # Building. This implementation is just C and assembly files. ## x86. Dynamic dispatch is enabled by default on x86. The implementation will; query the CPU at runtime to detect SIMD support, and it will use the; widest instruction set available. By default, `blake3_dispatch.c`; expects to be linked with code for five different instruction sets:; portable C, SSE2, SSE4.1, AVX2, and AVX-512. For each of the x86 SIMD instruction sets, four versions are available:; three flavors of assembly (Unix, Windows MSVC, and Windows GNU) and one; version using C intrinsics. The assembly versions are generally; preferred. They perform better, they perform more consistently across; diff",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:6568,hash,hasher,6568,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hasher']
Security," U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *MU = cast_of_null<MemoryUse>MA) {; // Process MemoryUse as needed.; }; else {; // Process MemoryDef or MemoryPhi as needed. // As a user can come up twice, as an optimized access and defining; // access, keep a visited list. // Check transitive uses as needed; checkUses (MA); // use a worklist for an iterative algorithm; }; }; }. An example of similar traversals can be found in the DeadStoreElimination pass. Invalidation and updating; -------------------------. Because ``MemorySSA`` keeps track of LLVM IR, it needs to be updated whenever; the IR is updated. ""Update"", in this case, includes the addition, deletion, and; motion of ``Instructions``. The update API is being made on an as-needed basis.; If you'd like examples, ``GVNHoist`` and ``LICM`` are users of ``MemorySSA``\ s; update API.; Note that adding new ``MemoryDef``\ s (by calling ``insertDef``) can be a; time-consuming update, if the new access triggers many ``MemoryPhi`` insertions and; renaming (optimization invalidation) of many ``MemoryAccesses``\ es. Phi placement; ^^^^^^^^^^^^^. ``MemorySSA`` only places ``MemoryPhi``\ s where they're actually; needed. That is, it is a pruned SSA form, like LLVM's SSA form. For; example, consider:. .. code-block:: llvm. define void @foo() {; entry:; %p1 = alloca i8; %p2 = alloca i8; %p3 = alloca i8; ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %p3; br label %while.cond. while.cond:; ; 3 = MemoryPhi({%0,1},{if.end,2}); br i1 undef, label %if.then, label %if.else. if.then:; br label %if.end. if.else:; br label %if.end. if.end:; ; MemoryUse(1); %1 = load i8, ptr %p1; ; 2 = MemoryDef(3); store i8 2, ptr %p2; ; MemoryUse(1); %2 = load i8, ptr %p3; br label %while.cond; }. Because we removed the stores from ``if.then`` and ``if.else``, a ``MemoryPhi``; for ``if.end`` would be pointless, so we don't place one. So, if you need to; place a ``MemoryDef`` in ``if.then`` or ``if.else``, you'll ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:14552,access,access,14552,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security," Wavefronts are executed in native mode with in-order reporting of loads and; sample instructions. In this mode vmcnt reports completion of load, atomic with; return and sample instructions in order, and the vscnt reports the completion of; store and atomic without return in order. See ``MEM_ORDERED`` field in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`. Wavefronts can be executed in WGP or CU wavefront execution mode:. * In WGP wavefront execution mode the wavefronts of a work-group are executed; on the SIMDs of both CUs of the WGP. Therefore, explicit management of the per; CU L0 caches is required for work-group synchronization. Also accesses to L1; at work-group scope need to be explicitly ordered as the accesses from; different CUs are not ordered.; * In CU wavefront execution mode the wavefronts of a work-group are executed on; the SIMDs of a single CU of the WGP. Therefore, all global memory access by; the work-group access the same L0 which in turn ensures L1 accesses are; ordered and so do not require explicit management of the caches for; work-group synchronization. See ``WGP_MODE`` field in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table` and; :ref:`amdgpu-target-features`. The code sequences used to implement the memory model for GFX10-GFX11 are defined in; table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx10-gfx11-table`. .. table:: AMDHSA Memory Model Code Sequences GFX10-GFX11; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx10-gfx11-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX10-GFX11; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* - global - !volatile & !nontemporal; - generic; - private 1. buffer/global/flat_load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:342742,access,access,342742,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,3,['access'],"['access', 'accesses']"
Security," [tma_lo] Low 32 bits of *trap memory address* register (an SP3 syntax). GFX7, GFX8; [tma_hi] High 32 bits of *trap memory address* register (an SP3 syntax). GFX7, GFX8; ================= ======================================================================= ==================. .. _amdgpu_synid_flat_scratch:. flat_scratch; ------------. Flat scratch address, 64-bits wide. Holds the base address of scratch memory. ================================== ================================================================; Syntax Description; ================================== ================================================================; flat_scratch 64-bit *flat scratch* address register.; [flat_scratch] 64-bit *flat scratch* address register (an SP3 syntax).; [flat_scratch_lo,flat_scratch_hi] 64-bit *flat scratch* address register (an SP3 syntax).; ================================== ================================================================. High and low 32 bits of *flat scratch* address may be accessed as separate registers:. ========================= =========================================================================; Syntax Description; ========================= =========================================================================; flat_scratch_lo Low 32 bits of *flat scratch* address register.; flat_scratch_hi High 32 bits of *flat scratch* address register.; [flat_scratch_lo] Low 32 bits of *flat scratch* address register (an SP3 syntax).; [flat_scratch_hi] High 32 bits of *flat scratch* address register (an SP3 syntax).; ========================= =========================================================================. .. _amdgpu_synid_xnack:; .. _amdgpu_synid_xnack_mask:. xnack_mask; ----------. Xnack mask, 64-bits wide. Holds a 64-bit mask of which threads; received an *XNACK* due to a vector memory operation. For availability of *xnack* feature, refer to :ref:`this table<amdgpu-processors>`. ============================== =======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:15378,access,accessed,15378,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['accessed']
Security," `--deep` has no effect and will be removed. Please remove it; from the genreflex invocation.; * rootcling warns if it sees and unrecognized flag (usually coming from the; CXXFLAGS of the build system). Please remove them from the invocation because; the warning will become a hard error in the next releases.; * The empty headers `Gtypes.h` and `Htypes.h` are deprecated. Please include; `Rtypes.h`; * TInterpreter::EnableAutoLoading currently does nothing and is deprecated. ### Deprecated packages. ### Removed packages. ## Core Libraries. * Speed-up startup, in particular in case of no or poor network accesibility, by avoiding; a network access that was used as input to generate a globally unique ID for the current; process.; * This network access is replaced by a passive scan of the network interface. This; reduces somewhat the uniqueness of the unique ID as the IP address is no longer; guaranteed by the DNS server to be unique. Note that this was already the case when; the network access (used to look up the hostname and its IP address) failed. ## I/O Libraries. * TFile: A new bit `TFile::kReproducible` was introduced. It can be enabled by; specifying the `""reproducible""` url option when creating the file:; ~~~ {.cpp}; TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; ~~~; Unlike regular `TFile`s, the content of such file has reproducible binary; content when writing exactly same data. This achieved by writing pre-defined; values for creation and modification date of TKey/TDirectory objects and null; value for TUUID objects inside TFile. As drawback, TRef objects stored in such; file cannot be read correctly.; * Significantly improved the scaling of hadd tear-down/cleanup-phase in the presence; of large number histograms and in the presence of large number of directories.; * TMemFile: Apply customization of minimal block size also to the first block.; * Add renaming rule for instances of the math classes from `genvector` and `smatrix` to; ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:3173,access,access,3173,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['access'],['access']
Security," `Browser Help → About ROOT`. ## Deprecation and Removal; * rootcling flags `-cint`, `-gccxml`, `-p`, `-r` and `-c` have no effect; and will be removed. Please remove them from the rootcling invocations.; * rootcling legacy cint flags `+P`, `+V` and `+STUB` have no effect and will be; removed. Please remove them from the rootcling invocations.; * genreflex flag `--deep` has no effect and will be removed. Please remove it; from the genreflex invocation.; * rootcling warns if it sees and unrecognized flag (usually coming from the; CXXFLAGS of the build system). Please remove them from the invocation because; the warning will become a hard error in the next releases.; * The empty headers `Gtypes.h` and `Htypes.h` are deprecated. Please include; `Rtypes.h`; * TInterpreter::EnableAutoLoading currently does nothing and is deprecated. ### Deprecated packages. ### Removed packages. ## Core Libraries. * Speed-up startup, in particular in case of no or poor network accesibility, by avoiding; a network access that was used as input to generate a globally unique ID for the current; process.; * This network access is replaced by a passive scan of the network interface. This; reduces somewhat the uniqueness of the unique ID as the IP address is no longer; guaranteed by the DNS server to be unique. Note that this was already the case when; the network access (used to look up the hostname and its IP address) failed. ## I/O Libraries. * TFile: A new bit `TFile::kReproducible` was introduced. It can be enabled by; specifying the `""reproducible""` url option when creating the file:; ~~~ {.cpp}; TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; ~~~; Unlike regular `TFile`s, the content of such file has reproducible binary; content when writing exactly same data. This achieved by writing pre-defined; values for creation and modification date of TKey/TDirectory objects and null; value for TUUID objects inside TFile. As drawback, TRef objects stored in such; file c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:2821,access,access,2821,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['access'],['access']
Security," `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability of the code, which the reviewer is; in a better position to judge; if this feels like it's not the right; option, you can contact the cfe-dev mailing list to get more feedback; on the direction;. Commit access; =============. Once you've contributed a handful of patches to LLVM, start to think; about getting commit access yourself. It's probably a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.org), as discussion often happens; there if a new patch causes problems. Post-commit errors; ------------------. Once your change is submitted it will be picked up by automated build; bots that will build and test your patch in a variety of configurations. You can see all configurations and their current state in a waterfall; view at http://lab.llvm.org/buildbot/#/waterfall. The waterfall view is good; to get a general overview over the tested configurations and to see; which configuration have been broken for a whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:13009,access,access,13009,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['access'],['access']
Security," `DataLoader` to switch off computation of correlation matrix. The new option is called *CalcCorrelations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new cmake flags, `tmva-cpu` and `tmva-gpu`, which can be used to swicth on/off the CPU and GPU (based on CUDA) implementations of the TMVA Deep Learning module. `tmva-cpu` is enabled by; default if a Blas or CBlas library is found in the system. `tmva-gpu` is enabled when the cmake flag `cuda` is enabled and a compatible Cuda library is found. ; enabled if the corre; - Add possibility to independently configure building of optional pymva part of tmva with flag `-Dpymva=ON|OFF`. - New Cross Validation features:; - Add stratified splitting for cross validation.; - New plotting option in cross validation, average ROC curve. - Bugfixes:; - Fix bug in BDT training with imt=on; - Improved handling of large event numbers in cross validation using deterministic splitting. - Documentation:; - Update TMVA Users' guide. ## 2D Graphics Libraries. - Highlight mode is implemented for `TH1` and for `TGraph` classes. When; highlight mode is on, mouse movement over the bin will be represented; graphically. Histograms bins or graph points will be highlighted. Moreover,; any highlight emits signal `TCanvas::Highlighted()` which allows the user to; react and call their own function. For a better understanding see also; the tutorials `$ROOTSYS/tutorials/hist/hlHisto*.C` and; `$ROOTSYS/tutorials/graphs/hlGraph*.C` .; - Implement fonts embedding for PDF output. The ""EmbedFonts"" option allows to; embed the fonts used in a PDF file inside that file. This option relies on; the ""gs"" command (https://ghostscript.com). Example:. ~~~ {.cpp}; canvas->Print(""example.pdf"",""EmbedFonts"");; ~~~; - In TAttAxis::SaveAttributes` take into account the new default value for `TitleOffset`.; - When the histograms' ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:16203,validat,validation,16203,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['validat'],['validation']
Security," ``Block`` -- An ``Addressable`` node that has ``Content`` (or is marked as; zero-filled), a parent ``Section``, a ``Size``, an ``Alignment`` (and an; ``AlignmentOffset``), and a list of ``Edge`` instances. Blocks provide a container for binary content which must remain contiguous in; the target address space (a *layout unit*). Many interesting low level; operations on ``LinkGraph`` instances involve inspecting or mutating block; content or edges. * ``Content`` is represented as an ``llvm::StringRef``, and accessible via; the ``getContent`` method. Content is only available for content blocks,; and not for zero-fill blocks (use ``isZeroFill`` to check, and prefer; ``getSize`` when only the block size is needed as it works for both; zero-fill and content blocks). * ``Section`` is represented as a ``Section&`` reference, and accessible via; the ``getSection`` method. The ``Section`` class is described in more detail; below. * ``Size`` is represented as a ``size_t``, and is accessible via the; ``getSize`` method for both content and zero-filled blocks. * ``Alignment`` is represented as a ``uint64_t``, and available via the; ``getAlignment`` method. It represents the minimum alignment requirement (in; bytes) of the start of the block. * ``AlignmentOffset`` is represented as a ``uint64_t``, and accessible via the; ``getAlignmentOffset`` method. It represents the offset from the alignment; required for the start of the block. This is required to support blocks; whose minimum alignment requirement comes from data at some non-zero offset; inside the block. E.g. if a block consists of a single byte (with byte; alignment) followed by a uint64_t (with 8-byte alignment), then the block; will have 8-byte alignment with an alignment offset of 7. * list of ``Edge`` instances. An iterator range for this list is returned by; the ``edges`` method. The ``Edge`` class is described in more detail below. * ``Symbol`` -- An offset from an ``Addressable`` (often a ``Block``), with an; opti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:8872,access,accessible,8872,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security," ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not currently have analogous APIs to support code generation; in the JIT, nor using the object writers. .. code-block:: c++. // lib/MyGC/MyGCPrinter.cpp - Example LLVM GC printer. #include ""llvm/CodeGen/GCMetadataPrinter.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGCPrinter : public GCMetadataPrinter {; public:; virtual void beginAssembly(AsmPrinter &AP);. virtual void finishAssembly(AsmPrinter &AP);; };. GCMetadataPrinterRegistry::Add<MyGCPrinter>; X(""mygc"", ""My bespoke garbage collector."");; }. The collector should use ``AsmPrinter`` to print portable assembly code. The; collector itself contains the stack map for the entire module, and may access; the ``GCFunctionInfo`` using its own ``begin()`` and ``end()`` methods. Here's; a realistic example:. .. code-block:: c++. #include ""llvm/CodeGen/AsmPrinter.h""; #include ""llvm/IR/Function.h""; #include ""llvm/IR/DataLayout.h""; #include ""llvm/Target/TargetAsmInfo.h""; #include ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:36599,access,access,36599,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['access'],['access']
Security," ``Section`` -- A set of ``Symbol`` instances, plus a set of ``Block``; instances, with a ``Name``, a set of ``ProtectionFlags``, and an ``Ordinal``. Sections make it easy to iterate over the symbols or blocks associated with; a particular section in the source object file. * ``blocks()`` returns an iterator over the set of blocks defined in the; section (as ``Block*`` pointers). * ``symbols()`` returns an iterator over the set of symbols defined in the; section (as ``Symbol*`` pointers). * ``Name`` is represented as an ``llvm::StringRef``, and is accessible via the; ``getName`` method. * ``ProtectionFlags`` are represented as a sys::Memory::ProtectionFlags enum,; and accessible via the ``getProtectionFlags`` method. These flags describe; whether the section is readable, writable, executable, or some combination; of these. The most common combinations are ``RW-`` for writable data,; ``R--`` for constant data, and ``R-X`` for code. * ``SectionOrdinal``, accessible via ``getOrdinal``, is a number used to order; the section relative to others. It is usually used to preserve section; order within a segment (a set of sections with the same memory protections); when laying out memory. For the graph-theorists: The ``LinkGraph`` is bipartite, with one set of; ``Symbol`` nodes and one set of ``Addressable`` nodes. Each ``Symbol`` node has; one (implicit) edge to its target ``Addressable``. Each ``Block`` has a set of; edges (possibly empty, represented as ``Edge`` instances) back to elements of; the ``Symbol`` set. For convenience and performance of common algorithms,; symbols and blocks are further grouped into ``Sections``. The ``LinkGraph`` itself provides operations for constructing, removing, and; iterating over sections, symbols, and blocks. It also provides metadata; and utilities relevant to the linking process:. * Graph element operations. * ``sections`` returns an iterator over all sections in the graph. * ``findSectionByName`` returns a pointer to the section with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:13325,access,accessible,13325,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security," ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds annotation defines an invariant for the pointer type, and the model; ensures that this invariant remains true. In the example below, pointer ``p``; annotated with ``__counted_by(count)`` must always point to a memory buffer; containing at least ``count`` elements of the pointee type. Changing the value; of ``count``, like in the example below, may violate this invariant and permit; out-of-bounds access to the pointer. To avoid this, the compiler employs; compile-time restrictions and emits run-time checks as necessary to ensure the; new count value doesn't exceed the actual length of the buffer. Section; `Maintaining correctness of bounds annotations`_ provides more details about; this programming model. .. code-block:: c. int g;. void foo(int *__counted_by(count) p, size_t count) {; count++; // may violate the invariant of __counted_by; count--; // may violate the invariant of __counted_by if count was 0.; count = g; // may violate the invariant of __counted_by; // depending on the value of `g`.; }. The requirement to annotate all pointers with explicit bounds information could; present a significant adoption burden. To tackle this issue, the model; incorporates the concept of a ""wide pointer"" (a.k.a. fat pointer) – a larger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:4383,access,access,4383,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['access']
Security," ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the pointer and passes the result as the argument %1 into ``^3``.; This record itself does not tell us how ``^3`` will access the parameter.; Parameter %3 is not a pointer. .. _refs_summary:. Refs; ^^^^. The optional ``Refs`` field looks like:. .. code-block:: text. refs: ((Ref)[, (Ref)]*). where each ``Ref`` contains a reference to the summary id of the referenced; value (e.g. ``^1``). .. _typeidinfo_summary:. TypeIdInfo; ^^^^^^^^^^. The optional ``TypeIdInfo`` field, used for; `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; looks like:. .. code-block:: text. typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstVCalls)]?[, (TypeCheckedLoadConstVCalls)]?. These optional fields have the following forms:. Type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:346079,access,access,346079,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," ``llc a.out.0.5.precodegen.bc``. If one of these do crash, you should be able to reduce; this with :program:`llvm-reduce`; command line (use the bc file corresponding to the command above that failed):. .. code-block:: bash. llvm-reduce --test reduce.sh a.out.0.2.internalize.bc. Example of reduce.sh script. .. code-block:: bash. $ cat reduce.sh; #!/bin/bash -e. path/to/not --crash path/to/opt ""-passes=lto<O3>"" $1 -o temp.bc 2> err.log; grep -q ""It->second == &Insn"" err.log. Here we have grepped the failed assert message. Please run this, then file a bug with the instructions and reduced .bc file; that llvm-reduce emits. .. _miscompiling:. Miscompilations; ===============. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization passes. Incorrect code generation; =========================. Similar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:8316,sanitiz,sanitizers,8316,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['sanitiz'],['sanitizers']
Security," ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[]"" array above; };. ``buckets`` is an array of 32 bit indexes into the ``hashes`` array. The; ``hashes`` array contains all of the 32 bit hash values for all names in the; hash table. Each hash in the ``hashes`` table has an offset in the ``offsets``; array that points to the data for the hash value. This table setup makes it very easy to repurpose these tables to contain; different data, while keeping the lookup mechanism the same for all tables.; This layout also makes it possible to save the table to disk and map it in; later and do very efficient name lookups with little or no parsing. DWARF lookup tables can be implemented in a variety of ways and can store a lot; of information for each name. We want to make the DWARF tables extensible and; able to store the data efficiently so we have used some of the DWARF features; that enable efficient data storage to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:70767,hash,hash,70767,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security," `b1` is implied by the flow condition.; g();; }; }; }; ```. One way to check this implication is to use a SAT solver. Without a SAT solver,; we could keep the flow condition in the CNF form and then it would be easy to; check the implication. ## Example: finding unchecked `std::optional` unwraps. Calling `optional::value()` is only valid if `optional::has_value()` is true. We; want to show that when `x.value()` is executed, the flow condition implies; `x.has_value()`. In the example below `x.value()` is accessed safely because it is guarded by the; `x.has_value()` check. ```c++; void Example(std::optional<int> &x) {; if (x.has_value()) {; use(x.value());; }; }; ```. While entering the if branch we deduce that `x.has_value()` is implied by the; flow condition. ```c++; void Example(std::optional<int> x) {; // Flow condition: true.; if (x.has_value()) {; // Flow condition: x.has_value() == true.; use(x.value());; }; // Flow condition: true.; }; ```. We also need to prove that `x` is not modified between check and value access.; The modification of `x` may be very subtle:. ```c++; void F(std::optional<int> &x);. void Example(std::optional<int> &x) {; if (x.has_value()) {; // Flow condition: x.has_value() == true.; unknown_function(x); // may change x.; // Flow condition: true.; use(x.value());; }; }; ```. ## Example: finding dead code behind A/B experiment flags. Finding dead code is a classic application of data flow analysis. Unused flags for A/B experiment hide dead code. However, this flavor of dead; code is invisible to the compiler because the flag can be turned on at any; moment. We could make a tool that deletes experiment flags. The user tells us which flag; they want to delete, and we assume that the it's value is a given constant. For example, the user could use the tool to remove `example_flag` from this; code:. ```c++; DEFINE_FLAG(std::string, example_flag, """", ""A sample flag."");. void Example() {; bool x = GetFlag(FLAGS_example_flag).empty();; f();; if (x)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:27562,access,access,27562,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['access'],['access']
Security," `clang-proto-fuzzer`_ can be enabled by; adding ``-DCLANG_ENABLE_PROTO_FUZZER=ON`` to the flags described in; :ref:`building-fuzzers`. The only in-tree fuzzer that uses ``libprotobuf-mutator`` today is; `clang-proto-fuzzer`_. .. _libprotobuf-mutator: https://github.com/google/libprotobuf-mutator; .. _protobuf: https://github.com/google/protobuf. .. _fuzzing-llvm-ir:. Structured Fuzzing of LLVM IR; -----------------------------. We also use a more direct form of structured fuzzing for fuzzers that take; :doc:`LLVM IR <LangRef>` as input. This is achieved through the ``FuzzMutate``; library, which was `discussed at EuroLLVM 2017`_. The ``FuzzMutate`` library is used to structurally fuzz backends in; `llvm-isel-fuzzer`_. .. _discussed at EuroLLVM 2017: https://www.youtube.com/watch?v=UBbQ_s6hNgg. Building and Running; ====================. .. _building-fuzzers:. Configuring LLVM to Build Fuzzers; ---------------------------------. Fuzzers will be built and linked to libFuzzer by default as long as you build; LLVM with sanitizer coverage enabled. You would typically also enable at least; one sanitizer to find bugs faster. The most common way to build the fuzzers is; by adding the following two flags to your CMake invocation:; ``-DLLVM_USE_SANITIZER=Address -DLLVM_USE_SANITIZE_COVERAGE=On``. .. note:: If you have ``compiler-rt`` checked out in an LLVM tree when building; with sanitizers, you'll want to specify ``-DLLVM_BUILD_RUNTIME=Off``; to avoid building the sanitizers themselves with sanitizers enabled. .. note:: You may run into issues if you build with BFD ld, which is the; default linker on many unix systems. These issues are being tracked; in https://llvm.org/PR34636. Continuously Running and Finding Bugs; -------------------------------------. There used to be a public buildbot running LLVM fuzzers continuously, and while; this did find issues, it didn't have a very good way to report problems in an; actionable way. Because of this, we're moving towards using `O",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:8115,sanitiz,sanitizer,8115,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['sanitiz'],['sanitizer']
Security," `ics <https://calendar.google.com/calendar/ical/lowrisc.org_0n5pkesfjcnp0bh5hps1p0bd80%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/b/1?cid=bG93cmlzYy5vcmdfMG41cGtlc2ZqY25wMGJoNWhwczFwMGJkODBAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ>`__; - `Minutes/docs <https://docs.google.com/document/d/1G3ocHm2zE6AYTS2N3_3w2UxFnSEyKkcF57siLWe-NVs>`__; * - Scalable Vectors and Arm SVE; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/bjms39pe6k6bo5egtsp7don414%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/u/0/embed?src=bjms39pe6k6bo5egtsp7don414@group.calendar.google.com>`__; - `Minutes/docs <https://docs.google.com/document/d/1UPH2Hzou5RgGT8XfO39OmVXKEibWPfdYLELSaHr3xzo/edit>`__; * - ML Guided Compiler Optimizations; - Monthly; -; - `Minutes/docs <https://docs.google.com/document/d/1JecbplF09l3swTjze-UVeLh4L48svJxGVy4mz_e9Rhs/edit?usp=gmail#heading=h.ts9cmcjbir1j>`__; * - `LLVM security group <https://llvm.org/docs/Security.html>`__; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/eoh3m9k1l6vqbd1fkp94fv5q74%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/embed?src=eoh3m9k1l6vqbd1fkp94fv5q74%40group.calendar.google.com>`__; - `Minutes/docs <https://discourse.llvm.org/t/llvm-security-group-public-sync-ups/62735>`__; * - `CIRCT <https://github.com/llvm/circt>`__; - Weekly, on Wednesday; -; - `Minutes/docs <https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.mulvhjtr8dk9>`__; * - `MLIR <https://mlir.llvm.org>`__ design meetings; - Weekly, on Thursdays; -; - `Minutes/docs <https://docs.google.com/document/d/1y_9f1AbfgcoVdJh4_aM6-BaSHvrHl8zuA5G4jv_94K8/edit#heading=h.cite1kolful9>`__; * - flang; - Multiple meeting series, `documented here <https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls>`__; -; -; * - OpenMP; - M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:5798,secur,security,5798,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['secur'],['security']
Security," a 32-bit x86 target; cannot be used when compiling for a 64-bit x86 target. The metadata block; contains information about:. Language options; Describes the particular language dialect used to compile the AST file,; including major options (e.g., Objective-C support) and more minor options; (e.g., support for ""``//``"" comments). The contents of this record correspond to; the ``LangOptions`` class. Target architecture; The target triple that describes the architecture, platform, and ABI for; which the AST file was generated, e.g., ``i386-apple-darwin9``. AST version; The major and minor version numbers of the AST file format. Changes in the; minor version number should not affect backward compatibility, while changes; in the major version number imply that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the AST file. Predefines buffer; Although not explicitly stored as part of the metadata, the predefines buffer; is used in the validation of the AST file. The predefines buffer itself; contains code generated by the compiler to initialize the preprocessor state; according to the current target, platform, and command-line options. For; example, the predefines buffer will contain ""``#define __STDC__ 1``"" when we; are compiling C without Microsoft extensions. The predefines buffer itself; is stored within the :ref:`pchinternals-sourcemgr`, but its contents are; verified along with the rest of the metadata. A chained PCH file (that is, one that references another PCH) and a module; (which may import other modules) have additional metadata containing the list; of all AST files that this AST file depends on. Each of those files will be; loaded along with this AST file. For chained precompiled headers, the language options, target architecture and; predefines buffer data is taken from the end of the chain, since they have to; match anyway. .. _pchinternals-sourcemgr:. Source",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:8728,validat,validation,8728,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['validat'],['validation']
Security, a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Un,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159231,inject,injected-class-name,159231,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected-class-name']
Security," a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:4371,access,access,4371,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['access'],['access']
Security," a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with Windows SEH Asynchrous Exception option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile stores. '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.scope.begin(); declare void @llvm.seh.scope.end(). Overview:; """""""""""""""""". The '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' intrinsics mark; the boundary of a CPP object lifetime for Windows SEH Asynchrous Exception; Handling (MSVC option -EHa). Semantics:; """""""""""""""""""". LLVM's ordinary exception-handling representation associates EH cleanups and; handlers only with ``invoke``s, which normally correspond only to call sites. To; support arbitrary faulting instructions, it must be possible to recover the current; EH scope for any in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:515703,inject,injected,515703,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['inject'],['injected']
Security," a relocation type -- it describes; what kinds of changes (if any) should be made to block content at the given; ``Offset`` based on the address of the ``Target``. * ``Target``, accessible via ``getTarget``, is a pointer to a ``Symbol``,; representing whose address is relevant to the fixup calculation specified by; the edge's ``Kind``. * ``Addend``, accessible via ``getAddend``, is a constant whose interpretation; is determined by the edge's ``Kind``. * ``Section`` -- A set of ``Symbol`` instances, plus a set of ``Block``; instances, with a ``Name``, a set of ``ProtectionFlags``, and an ``Ordinal``. Sections make it easy to iterate over the symbols or blocks associated with; a particular section in the source object file. * ``blocks()`` returns an iterator over the set of blocks defined in the; section (as ``Block*`` pointers). * ``symbols()`` returns an iterator over the set of symbols defined in the; section (as ``Symbol*`` pointers). * ``Name`` is represented as an ``llvm::StringRef``, and is accessible via the; ``getName`` method. * ``ProtectionFlags`` are represented as a sys::Memory::ProtectionFlags enum,; and accessible via the ``getProtectionFlags`` method. These flags describe; whether the section is readable, writable, executable, or some combination; of these. The most common combinations are ``RW-`` for writable data,; ``R--`` for constant data, and ``R-X`` for code. * ``SectionOrdinal``, accessible via ``getOrdinal``, is a number used to order; the section relative to others. It is usually used to preserve section; order within a segment (a set of sections with the same memory protections); when laying out memory. For the graph-theorists: The ``LinkGraph`` is bipartite, with one set of; ``Symbol`` nodes and one set of ``Addressable`` nodes. Each ``Symbol`` node has; one (implicit) edge to its target ``Addressable``. Each ``Block`` has a set of; edges (possibly empty, represented as ``Edge`` instances) back to elements of; the ``Symbol`` set. For conveni",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:12912,access,accessible,12912,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security," a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this sectio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:25790,inject,injected,25790,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['inject'],['injected']
Security," abstract syntax tree"". Consult your favorite compiler book or search engine for more details. B; -. .. _lexicon-bb-vectorization:. **BB Vectorization**; Basic-Block Vectorization. **BDCE**; Bit-tracking dead code elimination. Some bit-wise instructions (shifts,; ands, ors, etc.) ""kill"" some of their input bits -- that is, they make it; such that those bits can be either zero or one without affecting control or; data flow of a program. The BDCE pass removes instructions that only; compute these dead bits. **BURS**; Bottom Up Rewriting System --- A method of instruction selection for code; generation. An example is the `BURG; <http://www.program-transformation.org/Transform/BURG>`_ tool. C; -. **CFI**; This abbreviation has two meanings.; Either:; Call Frame Information. Used in DWARF debug info and in C++ unwind info; to show how the function prolog lays out the stack frame. Or:; Control Flow Integrity. A general term for computer security techniques; that prevent a wide variety of malware attacks from redirecting the flow; of execution (the control flow) of a program. **CIE**; Common Information Entry. A kind of CFI used to reduce the size of FDEs.; The compiler creates a CIE which contains the information common across all; the FDEs. Each FDE then points to its CIE. **CSE**; Common Subexpression Elimination. An optimization that removes common; subexpression computation. For example ``(a+b)*(a+b)`` has two; subexpressions that are the same: ``(a+b)``. This optimization would; perform the addition only once and then perform the multiply (but only if; it's computationally correct/safe). D; -. **DAG**; Directed Acyclic Graph. .. _derived pointer:; .. _derived pointers:. **Derived Pointer**; A pointer to the interior of an object, such that a garbage collector is; unable to use the pointer for reachability analysis. While a derived pointer; is live, the corresponding object pointer must be kept in a root, otherwise; the collector might free the referenced object. With ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:1684,secur,security,1684,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,2,"['attack', 'secur']","['attacks', 'security']"
Security," accepted without being in the ``-march`` string. LLVM also allows the explicit specification of the extensions in an ``-march`` string. .. _riscv-profiles-extensions-note:. ``Za128rs``, ``Za64rs``, ``Zic64b``, ``Ziccamoa``, ``Ziccif``, ``Zicclsm``, ``Ziccrse``; These extensions are defined as part of the `RISC-V Profiles specification <https://github.com/riscv/riscv-profiles/releases/tag/v1.0>`_. They do not introduce any new features themselves, but instead describe existing hardware features. Experimental Extensions; =======================. LLVM supports (to various degrees) a number of experimental extensions. All experimental extensions have ``experimental-`` as a prefix. There is explicitly no compatibility promised between versions of the toolchain, and regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:9980,validat,validate,9980,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['validat'],['validate']
Security," access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recomputed during the re-binning. ## Filling Histograms. A histogram is typically filled with stateme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6308,access,access,6308,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['access'],['access']
Security," accesses a different L2 channel. Each L1; quadrant has a separate request queue per L2 channel. Therefore, the vector; and scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is; required to ensure synchronization between vector memory operations of; different SAs. It ensures a previous vector memory operation has completed; before executing a subsequent vector memory and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence.; * On GFX10.3 and GFX11 a memory attached last level (MALL) cache exists for GPU memory.; The MALL cache is fully coherent with GPU memory and has no impact on system; coherence. All agents (GPU and CPU) access GPU memory through the MALL cache. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:339923,access,access,339923,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," across targets which; support such instructions. This performs signed dot product; with two v2i16 operands, summed with the third i32 operand. The; i1 fourth operand is used to clamp the output.; When applicable (e.g. no clamping), this is lowered into; v_dot2c_i32_i16 for targets which support it. llvm.amdgcn.sdot4 Provides direct access to v_dot4_i32_i8 across targets which; support such instructions. This performs signed dot product; with two i32 operands (holding a vector of 4 8bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output.; When applicable (i.e. no clamping / operand modifiers), this is lowered; into v_dot4c_i32_i8 for targets which support it.; RDNA3 does not offer v_dot4_i32_i8, and rather offers; v_dot4_i32_iu8 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sdot8 Provides direct access to v_dot8_u32_u4 across targets which; support such instructions. This performs signed dot product; with two i32 operands (holding a vector of 8 4bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output.; When applicable (i.e. no clamping / operand modifiers), this is lowered; into v_dot8c_i32_i4 for targets which support it.; RDNA3 does not offer v_dot8_i32_i4, and rather offers; v_dot4_i32_iu4 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sudot4 Provides direct access to v_dot4_i32_iu8 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 4 8bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sudot8 Provides direct access to v_dot8_i32_iu4 on gfx11 targets. This performs; dot product wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:41005,access,access,41005,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," addition `TFitResult` derives from `TNamed` and can be conveniently; stored in a file. When fitting an histogram ( a **`TH1`** object) or a graph (a `TGraph` object) it is possible to return a `TFitResult` via the `TFitResultPtr` object,; which behaves as a smart pointer to a `TFitResult`.; `TFitResultPtr` is the return object by `TH1::Fit` or `TGraph::Fit`.; By default the TFitResultPtr contains only the status of the fit and can be obtained by an automatic conversion of the TFitResultPtr to an integer. If the fit option *`S`* is instead used, `TFitResultPtr` contains the `TFitResult` and behaves as a smart; pointer to it. This is an example:. ``` {.cpp}; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:51573,access,access,51573,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['access'],['access']
Security," allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1798,Access,Access,1798,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security," along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:44946,attack,attacks,44946,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,2,"['attack', 'secur']","['attacks', 'security']"
Security," alternative is; allowed only for noncommercial distribution and only if you; received the program in object code or executable form with such; an offer, in accord with Subsection b above.). The source code for a work means the preferred form of the work for; making modifications to it. For an executable work, complete source; code means all the source code for all modules it contains, plus any; associated interface definition files, plus the scripts used to; control compilation and installation of the executable. However, as a; special exception, the source code distributed need not include; anything that is normally distributed (in either source or binary; form) with the major components (compiler, kernel, and so on) of the; operating system on which the executable runs, unless that component; itself accompanies the executable. If distribution of executable or object code is made by offering; access to copy from a designated place, then offering equivalent; access to copy the source code from the same place counts as; distribution of the source code, even though third parties are not; compelled to copy the source along with the object code. 4. You may not copy, modify, sublicense, or distribute the Program; except as expressly provided under this License. Any attempt; otherwise to copy, modify, sublicense or distribute the Program is; void, and will automatically terminate your rights under this License.; However, parties who have received copies, or rights, from you under; this License will not have their licenses terminated so long as such; parties remain in full compliance. 5. You are not required to accept this License, since you have not; signed it. However, nothing else grants you permission to modify or; distribute the Program or its derivative works. These actions are; prohibited by law if you do not accept this License. Therefore, by; modifying or distributing the Program (or any work based on the; Program), you indicate your acceptance of this License to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:8681,access,access,8681,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,8,['access'],['access']
Security," an ``MDString`` denoting; the name of the struct type. Like in scalar type descriptors the actual; value of this name operand is irrelevant to LLVM. After the name operand,; the struct type descriptors have a sequence of alternating ``MDNode`` and; ``ConstantInt`` operands. With N starting from 1, the 2N - 1 th operand,; an ``MDNode``, denotes a contained field, and the 2N th operand, a; ``ConstantInt``, is the offset of the said contained field. The offsets; must be in non-decreasing order. Access tags are represented as ``MDNode`` s with either 3 or 4 operands.; The first operand is an ``MDNode`` pointing to the node representing the; base type. The second operand is an ``MDNode`` pointing to the node; representing the access type. The third operand is a ``ConstantInt`` that; states the offset of the access. If a fourth field is present, it must be; a ``ConstantInt`` valued at 0 or 1. If it is 1 then the access tag states; that the location being accessed is ""constant"" (meaning; ``pointsToConstantMemory`` should return true; see `other useful; AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_). The TBAA root of; the access type and the base type of an access tag must be the same, and; that is the TBAA root of the access tag. '``tbaa.struct``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The :ref:`llvm.memcpy <int_memcpy>` is often used to implement; aggregate assignment operations in C and similar languages, however it; is defined to copy a contiguous region of memory, which is more than; strictly necessary for aggregate types which contain holes due to; padding. Also, it doesn't contain any TBAA information about the fields; of the aggregate. ``!tbaa.struct`` metadata can describe which memory subregions in a; memcpy are padding and what the TBAA tags of the struct are. The current metadata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:279253,access,access,279253,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],"['access', 'accessed']"
Security," an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34159,access,accessible,34159,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessible']
Security," an intrinsic function is the; method of choice for LLVM extension. Before you invest a significant amount of effort into a non-trivial extension,; **ask on the list** if what you are looking to do can be done with; already-existing infrastructure, or if maybe someone else is already working on; it. You will save yourself a lot of time and effort by doing so. .. _intrinsic function:. Adding a new intrinsic function; ===============================. Adding a new intrinsic function to LLVM is much easier than adding a new; instruction. Almost all extensions to LLVM should start as an intrinsic; function and then be turned into an instruction if warranted. #. ``llvm/docs/LangRef.html``:. Document the intrinsic. Decide whether it is code generator specific and; what the restrictions are. Talk to other people about it so that you are; sure it's a good idea. #. ``llvm/include/llvm/IR/Intrinsics*.td``:. Add an entry for your intrinsic. Describe its memory access; characteristics for optimization (this controls whether it will be; DCE'd, CSE'd, etc). If any arguments need to be immediates, these; must be indicated with the ImmArg property. Note that any intrinsic; using one of the ``llvm_any*_ty`` types for an argument or return; type will be deemed by ``tblgen`` as overloaded and the; corresponding suffix will be required on the intrinsic's name. #. ``llvm/lib/Analysis/ConstantFolding.cpp``:. If it is possible to constant fold your intrinsic, add support to it in the; ``canConstantFoldCallTo`` and ``ConstantFoldCall`` functions. #. ``llvm/test/*``:. Add test cases for your test cases to the test suite. Once the intrinsic has been added to the system, you must add code generator; support for it. Generally you must do the following steps:. Add support to the .td file for the target(s) of your choice in; ``lib/Target/*/*.td``. This is usually a matter of adding a pattern to the .td file that matches the; intrinsic, though it may obviously require adding the instructions you w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst:2222,access,access,2222,interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,1,['access'],['access']
Security," analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8892,hash,hash,8892,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,2,['hash'],"['hash', 'hashed']"
Security," and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -------------------------------------------------------------. This pass promotes ""by reference"" arguments to be ""by value"" arguments. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11578,access,access,11578,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['access'],['access']
Security," and check buttons change their appearance; when they are selected and keep that appearance afterwards. A text button is represented by the class **`TGTextButton`**. We already; used its constructor in the example. The button label indicates the; action to be taken when the button is selected or pressed. The text can; be a hot string defining a hot key (known as shortcut key also) for this; selection. The hot key is an underlined character in a button label that; shows the assigned keyboard mnemonic for its choice. A button that; prompts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:55932,access,access,55932,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security," and diagnostics; =================================================. .. program:: llvm-pdbutil. .. contents::; :local:. Synopsis; --------. :program:`llvm-pdbutil` [*subcommand*] [*options*]. Description; -----------. Display types, symbols, CodeView records, and other information from a; PDB file, as well as manipulate and create PDB files. :program:`llvm-pdbutil`; is normally used by FileCheck-based tests to test LLVM's PDB reading and; writing functionality, but can also be used for general PDB file investigation; and forensics, or as a replacement for cvdump. Subcommands; -----------. :program:`llvm-pdbutil` is separated into several subcommands each tailored to; a different purpose. A brief summary of each command follows, with more detail; in the sections that follow. * :ref:`pretty_subcommand` - Dump symbol and type information in a format that; tries to look as much like the original source code as possible.; * :ref:`dump_subcommand` - Dump low level types and structures from the PDB; file, including CodeView records, hash tables, PDB streams, etc.; * :ref:`bytes_subcommand` - Dump data from the PDB file's streams, records,; types, symbols, etc as raw bytes.; * :ref:`yaml2pdb_subcommand` - Given a yaml description of a PDB file, produce; a valid PDB file that matches that description.; * :ref:`pdb2yaml_subcommand` - For a given PDB file, produce a YAML; description of some or all of the file in a way that the PDB can be; reconstructed.; * :ref:`merge_subcommand` - Given two PDBs, produce a third PDB that is the; result of merging the two input PDBs. .. _pretty_subcommand:. pretty; ~~~~~~. .. program:: llvm-pdbutil pretty. .. important::; The **pretty** subcommand is built on the Windows DIA SDK, and as such is not; supported on non-Windows platforms. USAGE: :program:`llvm-pdbutil` pretty [*options*] <input PDB file>. Summary; ^^^^^^^^^^^. The *pretty* subcommand displays a very high level representation of your; program's debug info. Since it is built on the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:1075,hash,hash,1075,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['hash'],['hash']
Security," and not the context of the expression that contained the*; ``DW_OP_implicit_pointer`` *or* ``DW_OP_LLVM_aspace_implicit_pointer``; *operation that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target architecture specific address space identifier AS. The location description L that is pushed on the stack is the same as for; ``DW_OP_implicit_pointer``, except that the address space identifier used is; AS. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. .. note::. This definition of ``DW_OP_LLVM_aspace_implicit_point",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:127157,access,accessed,127157,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessed']
Security," and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4934,secur,security,4934,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['secur'],['security']
Security," and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3587,access,access,3587,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,1,['access'],['access']
Security," and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All conten",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11818,confidential,confidentiality,11818,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['confidential'],['confidentiality']
Security," are currently reserved for user-defined code. The GS-segment is; represented by address space 256, the FS-segment is represented by address space; 257, and the SS-segment is represented by address space 258. Other x86 segments; have yet to be allocated address space numbers. While these address spaces may seem similar to TLS via the ``thread_local``; keyword, and often use the same underlying hardware, there are some fundamental; differences. The ``thread_local`` keyword applies to global variables and specifies that they; are to be allocated in thread-local memory. There are no type qualifiers; involved, and these variables can be pointed to with normal pointers and; accessed with normal loads and stores. The ``thread_local`` keyword is; target-independent at the LLVM IR level (though LLVM doesn't yet have; implementations of it for some configurations). Special address spaces, in contrast, apply to static types. Every load and store; has a particular address space in its address operand type, and this is what; determines which address space is accessed. LLVM ignores these special address; space qualifiers on global variables, and does not provide a way to directly; allocate storage in them. At the LLVM IR level, the behavior of these special; address spaces depends in part on the underlying OS or runtime environment, and; they are specific to x86 (and LLVM doesn't yet handle them correctly in some; cases). Some operating systems and runtime environments use (or may in the future use); the FS/GS-segment registers for various low-level purposes, so care should be; taken when considering them. Instruction naming; ^^^^^^^^^^^^^^^^^^. An instruction name consists of the base name, a default operand size, and a; character per operand with an optional special size. For example:. ::. ADD8rr -> add, 8-bit register, 8-bit register; IMUL16rmi -> imul, 16-bit register, 16-bit memory, 16-bit immediate; IMUL16rmi8 -> imul, 16-bit register, 16-bit memory, 8-bit immediate; MOVSX",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:93196,access,accessed,93196,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accessed']
Security," are expected in that directory with the same base name as the source; file. .. option:: -p, --preserve-paths. Preserve path components when naming the coverage output files. In addition; to the source file name, include the directories from the path to that; file. The directories are separate by ``#`` characters, with ``.`` directories; removed and ``..`` directories replaced by ``^`` characters. When used with; the --long-file-names option, this applies to both the main file name and the; included file name. .. option:: -r. Only dump files with relative paths or absolute paths with the prefix specified; by ``-s``. .. option:: -s <string>. Source prefix to elide. .. option:: -t, --stdout. Print to stdout instead of producing ``.gcov`` files. .. option:: -u, --unconditional-branches. Include unconditional branches in the output for the --branch-probabilities; option. .. option:: -version. Display the version of llvm-cov. .. option:: -x, --hash-filenames. Use md5 hash of file name when naming the coverage output files. The source; file name will be suffixed by ``##`` followed by MD5 hash calculated for it. EXIT STATUS; ^^^^^^^^^^^. :program:`llvm-cov gcov` returns 1 if it cannot read input files. Otherwise,; it exits with zero. .. program:: llvm-cov show. .. _llvm-cov-show:. SHOW COMMAND; ------------. SYNOPSIS; ^^^^^^^^. :program:`llvm-cov show` [*options*] -instr-profile *PROFILE* [*BIN*] [*-object BIN*]... [*-sources*] [*SOURCE*]... DESCRIPTION; ^^^^^^^^^^^. The :program:`llvm-cov show` command shows line by line coverage of the; binaries *BIN*... using the profile data *PROFILE*. It can optionally be; filtered to only show the coverage for the files listed in *SOURCE*.... *BIN* may be an executable, object file, dynamic library, or archive (thin or; otherwise). To use :program:`llvm-cov show`, you need a program that is compiled with; instrumentation to emit profile and coverage data. To build such a program with; ``clang`` use the ``-fprofile-instr-generate`` and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:5990,hash,hash,5990,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['hash'],['hash']
Security," at location ``L + offsetof(T, .f)``; and. - if ``T`` is the array type ``E[N]``, then for each ``i`` satisfying; ``0 <= i < N``, the static subobjects of ``E`` at location; ``L + i * sizeof(E)``. If an l-value is converted to an r-value, then all static subobjects; whose types are non-trivial to copy are accessed. If an l-value is; assigned to, or if an object of automatic storage duration goes out of; scope, then all static subobjects of types that are non-trivial to destroy; are accessed. A dynamic object is created at a location if an initialization initializes; an object of that type there. A dynamic object ceases to exist at a; location if the memory is repurposed. Memory is repurposed if it is; freed or if a different dynamic object is created there, for example by; assigning into a different union member. An implementation may provide; additional rules for what constitutes creating or destroying a dynamic; object. If an object is accessed under these rules at a location where no such; dynamic object exists, the program has undefined behavior.; If memory for a location is repurposed while a dynamic object that is; non-trivial to destroy exists at that location, the program has; undefined behavior. .. admonition:: Rationale. While these rules are far less fine-grained than C++, they are; nonetheless sufficient to express a wide spectrum of types.; Types that express some sort of ownership will generally be non-trivial; to both copy and destroy and either non-trivial or illegal to; default-initialize. Types that don't express ownership may still; be non-trivial to copy because of some sort of address sensitivity;; for example, a relative reference. Distinguishing default; initialization allows types to impose policies about how they are; created. These rules assume that assignment into an l-value is always a; modification of an existing object rather than an initialization.; Assignment is then a compound operation where the old value is; read and destroyed, if n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:58033,access,accessed,58033,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accessed']
Security," automatic storage duration of that type,; - assigns to an l-value of that type, or; - converts an l-value of that type to an r-value. A program calls for a type to be default-initialized if it:. - declares a variable of that type without an initializer. An expression is ill-formed if calls for a type to be copied,; destroyed, or default-initialized and that type is illegal to; (respectively) copy, destroy, or default-initialize. A program is ill-formed if it contains a function type specifier; with a parameter or return type that is illegal to copy or; destroy. If a function type specifier would be ill-formed for this; reason except that the parameter or return type was incomplete at; that point in the translation unit, the program is ill-formed but; no diagnostic is required. A ``goto`` or ``switch`` is ill-formed if it jumps into the scope of; an object of automatic storage duration whose type is non-trivial to; destroy. C specifies that it is generally undefined behavior to access an l-value; if there is no object of that type at that location. Implementations; are often lenient about this, but non-trivial types generally require; it to be enforced more strictly. The following rules apply:. The *static subobjects* of a type ``T`` at a location ``L`` are:. - an object of type ``T`` spanning from ``L`` to ``L + sizeof(T)``;. - if ``T`` is a struct type, then for each field ``f`` of that struct,; the static subobjects of ``T`` at location ``L + offsetof(T, .f)``; and. - if ``T`` is the array type ``E[N]``, then for each ``i`` satisfying; ``0 <= i < N``, the static subobjects of ``E`` at location; ``L + i * sizeof(E)``. If an l-value is converted to an r-value, then all static subobjects; whose types are non-trivial to copy are accessed. If an l-value is; assigned to, or if an object of automatic storage duration goes out of; scope, then all static subobjects of types that are non-trivial to destroy; are accessed. A dynamic object is created at a location if an initi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:56623,access,access,56623,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['access']
Security," be displayed as is, while the; markup elements will be replaced with expanded text, or converted into active UI; elements, that present more details in symbolic form. This means there is no need for symbol tables, DWARF debugging sections, or; similar information to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes intact whole lines. If; long lines might be split during some stage of a logging pipeline, they must be; reassembled to restore the original line breaks before feeding lines into the; symbolizing filter. Most markup elements must appear entirely on a single line; (often with other text before and/or after the markup element). There are some; markup ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:1621,sanitiz,sanitizing,1621,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['sanitiz'],['sanitizing']
Security," be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ~~~{.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ~~~. \anchor GP02f; ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigation algorithms, but user code is also allowed to access it. This; works on any stack principle by using PUSH and POP calls and user code; is responsible for popping the pushed states in order to keep the stack; clean. ~~~{.cpp}; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stack index; gGeoManager->PopPath(Int_t index);; ~~~. \anchor GP02g; ### Navigation Queries. After initializing the current state related to a given point and; direction defined in `MARS` `(‘Where am I?')`, one can query for several; geometrical quantities. All the related a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:73348,access,access,73348,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['access']
Security," be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9053,authenticat,authentication,9053,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['authenticat'],['authentication']
Security," being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a representable value?; Yes. 433; C11; Issue with constraints for wide character function arguments involving RSIZE_MAX; N/A. 434; C11; Possible defect report: Missing constraint w.r.t. Atomic; Yes. 435; NAD; Possible defect report: Missing constraint w.r.t. Imaginary; Yes. 436; C11; Request for interpretation of C11 6.8.5#6; Yes. 437; C11; clock overflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22738,access,access,22738,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['access'],['access']
Security," both. Using the constant address space indicates that the data will not change; during the execution of the kernel. This allows scalar read instructions to; be used. As the constant address space could only be modified on the host; side, a generic pointer loaded from the constant address space is safe to be; assumed as a global pointer since only the device global memory is visible; and managed on the host side. The vector and scalar L1 caches are invalidated; of volatile data before each kernel dispatch execution to allow constant; memory to change values between kernel dispatches. **Region**; The region address space uses the hardware Global Data Store (GDS). All; wavefronts executing on the same device will access the same memory for any; given region address. However, the same region address accessed by wavefronts; executing on different devices will access different memory. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kerne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:25917,access,access,25917,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[]"" array above; };. ``buckets`` is an array of 32 bit indexes into the ``hashes`` array. The; ``hashes`` array contains all of the 32 bit hash values for all names in the; hash table. Each hash in the ``hashes`` table has an offset in the ``offsets``; array that points to the data for the hash value. This table setup makes it very easy to repurpose these tables to contain; different data, while keeping the lookup mechanism the same for all tables.; This layout also makes it possible to save the table to disk and map it in; later and do very efficient name lookups with little or no parsing. DWARF lookup tables ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:70526,hash,hashes,70526,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['hash'],"['hash', 'hashes']"
Security," caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L0 and L1 caches at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is accessed as MTYPE UC (uncached) to avoid; needing to invalidate the L2 cache.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC (non-coherent). Since the private address space is only accessed; by a single thread, and is always write-before-read, there is never a need to; invalidate these entries from the L0 or L1 caches. Wavefronts are executed in native mode with in-order reporting of loads and; sample instructions. In this mode vmcnt reports completion of load, atomic with; return and sample instructions in order, and the vscnt reports the completion of; store and atomic without return in order. See ``MEM_ORDERED`` field in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`. Wavefronts can be executed in WGP or CU wavefront execution mode:. * In WGP wavefront execution mode the wavefronts of a work-group ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:341301,access,accessed,341301,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security," can add it to the ``LLVM_ALL_TARGETS`` variable; located in the main ``CMakeLists.txt``. Target Machine; ==============. ``LLVMTargetMachine`` is designed as a base class for targets implemented with; the LLVM target-independent code generator. The ``LLVMTargetMachine`` class; should be specialized by a concrete target class that implements the various; virtual methods. ``LLVMTargetMachine`` is defined as a subclass of; ``TargetMachine`` in ``include/llvm/Target/TargetMachine.h``. The; ``TargetMachine`` class implementation (``TargetMachine.cpp``) also processes; numerous command-line options. To create a concrete target-specific subclass of ``LLVMTargetMachine``, start; by copying an existing ``TargetMachine`` class and header. You should name the; files that you create to reflect your specific target. For instance, for the; SPARC target, name the files ``SparcTargetMachine.h`` and; ``SparcTargetMachine.cpp``. For a target machine ``XXX``, the implementation of ``XXXTargetMachine`` must; have access methods to obtain objects that represent target components. These; methods are named ``get*Info``, and are intended to obtain the instruction set; (``getInstrInfo``), register set (``getRegisterInfo``), stack frame layout; (``getFrameInfo``), and similar information. ``XXXTargetMachine`` must also; implement the ``getDataLayout`` method to access an object with target-specific; data characteristics, such as data type size and alignment requirements. For instance, for the SPARC target, the header file ``SparcTargetMachine.h``; declares prototypes for several ``get*Info`` and ``getDataLayout`` methods that; simply return a class member. .. code-block:: c++. namespace llvm {. class Module;. class SparcTargetMachine : public LLVMTargetMachine {; const DataLayout DataLayout; // Calculates type size & alignment; SparcSubtarget Subtarget;; SparcInstrInfo InstrInfo;; TargetFrameInfo FrameInfo;. protected:; virtual const TargetAsmInfo *createTargetAsmInfo() const;. public:; Spar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:8849,access,access,8849,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['access'],['access']
Security," can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:64490,access,access,64490,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['access'],"['access', 'accessed']"
Security," can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kernels), these approaches require manual and/or static analysis aided auditing; of code and explicit source changes to apply the mitigation. They are unlikely; to scale well to large applications. We are proposing a comprehensive; mitigation approach that would apply automatically across an entire program; rather than through manual changes to the code. While this is likely to have a; high performance cost, some applications may be in a good position to take this; performance / security tradeoff. The specific technique we propose is to cause loads to be checked using; branchless code to ensure that they are executing along a valid control flow; path. Consider the following C-pseudo-code representi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:2288,access,access,2288,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['access'],['access']
Security," change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:14900,access,accessed,14900,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['access'],['accessed']
Security," class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9431,hash,hashing,9431,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['hash'],['hashing']
Security," commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4186,access,accessing,4186,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['access'],['accessing']
Security," commit <https://github.com/llvm/llvm-project/commit/7bf73bcf6d93>`_ describing; the purpose of the group and the processes it follows. Many of the group's; processes were still not well-defined enough for the group to operate well.; Over the course of 2021, the key processes were defined well enough to enable; the group to operate reasonably well:. * We defined details on how to report security issues, see `this commit on; 20th of May 2021 <https://github.com/llvm/llvm-project/commit/c9dbaa4c86d2>`_; * We refined the nomination process for new group members, see `this; commit on 30th of July 2021 <https://github.com/llvm/llvm-project/commit/4c98e9455aad>`_; * We started writing an annual transparency report (you're reading the 2021; report here). Over the course of 2021, we had 2 people leave the LLVM Security group and 4; people join. In 2021, the security group received 13 issue reports that were made publicly; visible before 31st of December 2021. The security group judged 2 of these; reports to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=5; * https://bugs.chromium.org/p/llvm/issues/detail?id=11. Both issues were addressed with source changes: #5 in clangd/vscode-clangd, and; #11 in llvm-project. No dedicated LLVM release was made for either. We believe that with the publishing of this first annual transparency report,; the security group now has implemented all necessary processes for the group to; operate as promised. The group's processes can be improved further, and we do; expect further improvements to get implemented in 2022. Many of the potential; improvements end up being discussed on the `monthly public call on LLVM's; security group <https://llvm.org/docs/GettingInvolved.html#online-sync-ups>`_. 2022; ----. In this section we report on the issues the group received in 2022, or on issues; that were received earlier, but were disclosed in 2022. In 2022, the llvm security group received 15 issues that have been disclosed at; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst:1288,secur,security,1288,interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,2,['secur'],['security']
Security," compare. .. option:: --compare=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below elements. .. code-block:: text. =lines: Include lines.; =scopes: Include scopes.; =symbols: Include symbols.; =types: Include types. :program:`llvm-debuginfo-analyzer` takes the first binary file on the; command line as the **reference** and the second one as the **target**.; To get a more descriptive report, the comparison is done twice. The; reference and target views are swapped, in order to produce those; **missing** elements from the target view and those **added** elements; to the reference view. See :option:`--report` options on how to describe the comparison; reports. .. _warning_:. WARNING; ~~~~~~~; When reading the input object files, :program:`llvm-debuginfo-analyzer`; can detect issues in the raw debug information. These may not be; considered fatal to the purpose of printing a logical view but they can; give an indication about the quality and potentially expose issues with; the generated debug information. The following options describe the warnings to be recorded for later; printing, if they are requested by :option:`--print`. .. option:: --warning=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below warnings. The following options collect additional information during the creation; of the logical view, to include invalid coverage values and locations; for symbols; invalid code ranges; lines that are zero. .. code-block:: text. =coverages: Invalid symbol coverages values.; =lines: Debug lines that are zero.; =locations: Invalid symbol locations.; =ranges: Invalid code ranges. .. _internal_:. INTERNAL; ~~~~~~~~; For a better understanding of the logical view, access to more detailed; internal information could be needed. Such data would help to identify; debug information processed or incorrect logical element ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:21554,expose,expose,21554,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['expose'],['expose']
Security," compiler`_ for Python functions that can be statically typed; based on their input arguments.; Since C++ objects are always statically typed and already implemented at the; machine level, they can be dynamically integrated into the Numba type tracing; and lowering by exposing type details through C++ reflection at runtime. JIT-compiling traces of mixed Python/bound C++ code reduces, and in some; cases removes, the overhead of boxing/unboxing native data into their Python; proxies and vice versa.; It can also reduce or remove temporaries, especially for template; expressions.; Thus, there can be significant speedups for mixed code, beyond the Numba; compilation of Python code itself.; The current implementation integrates compiled C++ through function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:1231,expose,exposed,1231,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['expose'],['exposed']
Security, conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminat,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41154,access,access,41154,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security," configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:8941,certificate,certificate,8941,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,2,"['authenticat', 'certificate']","['authentication', 'certificate']"
Security," confused with ``tbaa.struct``), consists of the following high level; concepts: *Type Descriptors*, further subdivided into scalar type; descriptors and struct type descriptors; and *Access Tags*. **Type descriptors** describe the type system of the higher level language; being compiled. **Scalar type descriptors** describe types that do not; contain other types. Each scalar type has a parent type, which must also; be a scalar type or the TBAA root. Via this parent relation, scalar types; within a TBAA root form a tree. **Struct type descriptors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:274772,access,access,274772,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overload",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:850686,access,access,850686,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," constructs a new ThreadSafeContext value from a std::unique_ptr<LLVMContext>:. .. code-block:: c++. // Maximize concurrency opportunities by loading every module on a; // separate context.; for (const auto &IRPath : IRPaths) {; auto Ctx = std::make_unique<LLVMContext>();; auto M = std::make_unique<LLVMContext>(""M"", *Ctx);; CompileLayer.add(MainJD, ThreadSafeModule(std::move(M), std::move(Ctx)));; }. Clients who plan to run single-threaded may choose to save memory by loading; all modules on the same context:. .. code-block:: c++. // Save memory by using one context for all Modules:; ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());; for (const auto &IRPath : IRPaths) {; ThreadSafeModule TSM(parsePath(IRPath, *TSCtx.getContext()), TSCtx);; CompileLayer.add(MainJD, ThreadSafeModule(std::move(TSM));; }. .. _ProcessAndLibrarySymbols:. How to Add Process and Library Symbols to JITDylibs; ===================================================. JIT'd code may need to access symbols in the host program or in supporting; libraries. The best way to enable this is to reflect these symbols into your; JITDylibs so that they appear the same as any other symbol defined within the; execution session (i.e. they are findable via `ExecutionSession::lookup`, and; so visible to the JIT linker during linking). One way to reflect external symbols is to add them manually using the; absoluteSymbols function:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. JD.define(; absoluteSymbols({; { Mangle(""puts""), ExecutorAddr::fromPtr(&puts)},; { Mangle(""gets""), ExecutorAddr::fromPtr(&getS)}; }));. Using absoluteSymbols is reasonable if the set of symbols to be reflected is; small and fixed. On the other hand, if the set of symbols is large or variable; it may make more sense to have the definitions added for you on demand by a; *definition generator*.A definition generator is an object that can be attached;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:31686,access,access,31686,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['access']
Security," conversion. If BPF_CLASS(code) == BPF_JMP, BPF_OP(code) is one of. ::. BPF_JA 0x0 unconditional jump; BPF_JEQ 0x1 jump ==; BPF_JGT 0x2 jump >; BPF_JGE 0x3 jump >=; BPF_JSET 0x4 jump if (DST & SRC); BPF_JNE 0x5 jump !=; BPF_JSGT 0x6 jump signed >; BPF_JSGE 0x7 jump signed >=; BPF_CALL 0x8 function call; BPF_EXIT 0x9 function return. Instruction encoding (load, store); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; For load and store instructions the 8-bit 'code' field is divided as:. ::. +--------+--------+-------------------+; | 3 bits | 2 bits | 3 bits |; | mode | size | instruction class |; +--------+--------+-------------------+; (MSB) (LSB). Size modifier is one of. ::. BPF_W 0x0 word; BPF_H 0x1 half word; BPF_B 0x2 byte; BPF_DW 0x3 double word. Mode modifier is one of. ::. BPF_IMM 0x0 immediate; BPF_ABS 0x1 used to access packet data; BPF_IND 0x2 used to access packet data; BPF_MEM 0x3 memory; (reserved) 0x4; (reserved) 0x5; BPF_XADD 0x6 exclusive add. Packet data access (BPF_ABS, BPF_IND); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Two non-generic instructions: (BPF_ABS | <size> | BPF_LD) and; (BPF_IND | <size> | BPF_LD) which are used to access packet data.; Register R6 is an implicit input that must contain pointer to sk_buff.; Register R0 is an implicit output which contains the data fetched; from the packet. Registers R1-R5 are scratch registers and must not; be used to store the data across BPF_ABS | BPF_LD or BPF_IND | BPF_LD; instructions. These instructions have implicit program exit condition; as well. When eBPF program is trying to access the data beyond; the packet boundary, the interpreter will abort the execution of the program. BPF_IND | BPF_W | BPF_LD is equivalent to:; R0 = ntohl(\*(u32 \*) (((struct sk_buff \*) R6)->data + src_reg + imm32)). eBPF maps; ^^^^^^^^^. eBPF maps are provided for sharing data between kernel and user-space.; Currently implemented types are hash and array, with potential extension to; support bloom filters, radix trees, etc. A map i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:105668,access,access,105668,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['access']
Security," could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:24541,expose,exposed,24541,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['expose'],['exposed']
Security," count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. code-block:: c++. #pragma clang loop unroll(enable); for(...) {; ...; }. If ``unroll(full)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time identically to; ``unroll(enable)``. However, with ``unro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:166091,expose,exposes,166091,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['expose'],['exposes']
Security," cppyy.gbl.std.string at 0x7fa75edbf8a0>; >>> s == ""aap""; True; >>>. To pass an argument through a C++ ``char`` (signed or unsigned) use a Python; string of size 1.; In many cases, the explicit C types from module ``ctypes`` can also be used,; but that module does not have a public API (for type conversion or otherwise),; so support is somewhat limited. There are automatic conversions between C++'s ``std::vector`` and Python's; ``list`` and ``tuple``, where possible, as they are often used in a similar; manner.; These datatypes have completely different memory layouts, however, and the; ``std::vector`` requires that all elements are of the same type and laid; out consecutively in memory.; Conversion thus requires type checks, memory allocation, and copies.; This can be rather expensive.; See the section on :ref:`STL <stl>`. `Arrays`; """""""""""""""". Builtin arrays are supported through arrays from module ``array`` (or any; other builtin-type array that implements the Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:3338,access,access,3338,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['access'],['access']
Security," currently being written cannot be read. ### RNTupleReader; The RNTupleReader is the primary interface to read and inspect an RNTuple.; An RNTupleReader owns a model: either a model created from the on-disk information or an imposed, user-provided model.; The user-provided model can be limited to a subset of fields.; Data is populated to an explicit `REntry` or the model's default entry through `RNTupleReader::LoadEntry()`. The reader can create `RNTupleView` objects for the independent reading of individual fields.; The reader can create `RBulk` objects for bulk reading of individual fields. Additionally, the reader provides access to a cached copy of the descriptor.; It can display individual entries (`RNTupleReader::Show()`) and summary information (`RNTupleReader::PrintInfo()`). ### RNTupleView<T>; RNTuple views provide read access to individual fields.; Views are created from an RNTupleReader.; Views are templated; for simple types (e.g., `float`, `int`), views provide read-only access directly to an RNTuple page in memory.; Complex types and void views require additional memory copies to populate an object in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data source for RDataFrame.; It is part of the `ROOTDataFrame` library.; The RNTuple data source supports chains with a constructor that takes a list of input files.; The RNTupl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:13676,access,access,13676,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security," currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:144525,access,accessible,144525,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessible']
Security," data hash table when raw profiles are; converted into indexed profiles. They are also crucial for ``llvm-profdata`` to; show the profiles in a human-readable way. Value Profile Data; ^^^^^^^^^^^^^^^^^^^^. This section contains the profile data for value profiling. The value profiles corresponding to a profile metadata are serialized contiguously; as one record, and value profile records are stored in the same order as the; respective profile data, such that a raw profile reader `advances`_ the pointer to; profile data and the pointer to value profile records simutaneously [5]_ to find; value profiles for a per function, per `FuncHash`_ profile data. .. _`advances`: https://github.com/llvm/llvm-project/blob/7e15fa9161eda7497a5d6abf0d951a1d12d86550/llvm/include/llvm/ProfileData/InstrProfReader.h#L456-L457. Indexed Profile Format; ===========================. Indexed profiles are generated from ``llvm-profdata``. In the indexed profiles,; function data are organized as on-disk hash table such that compilers can; look up profile data for functions in an IR module. Compilers and tools must retain backward compatibility with indexed profiles.; That is, a tool or a compiler built at newer versions of code must understand; profiles generated by older tools or compilers. General Storage Layout; -----------------------. ::. +-----------------------+---+; | Magic | |; +-----------------------+ |; | Version | |; +-----------------------+ |; | HashType | H; +-----------------------+ E; +-------| HashOffset | A; | +-----------------------+ D; +-----------| MemProfOffset | E; | | +-----------------------+ R; | | +--| BinaryIdOffset | |; | | | +-----------------------+ |; +---------------| TemporalProf- | |; | | | | | TracesOffset | |; | | | | +-----------------------+---+; | | | | | Profile Summary | |; | | | | +-----------------------+ P; | | +------>| Function data | A; | | | +-----------------------+ Y; | +---------->| MemProf profile data | L; | | +-----------------------+ O; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst:13260,hash,hash,13260,interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,1,['hash'],['hash']
Security," declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139462,access,accessors,139462,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['accessors']
Security," declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in which case the property can be referred to in user code directly using the; standard C dereference syntax as well as through the property ""dot"" syntax, but; there is no entry in the ``@interface`` declaration corresponding to this ivar. To facilitate debugging, these properties we will add a new DWARF TAG into the; ``DW_TAG_structure_type`` definition for the class to hold the description of a; given property, and a set of DWARF attributes that provide said description.; The property tag will also contain the name and declared type of the property. If there is a related ivar, there will also be a DWARF property attribute placed; in the ``DW_TAG_member`` DIE for that ivar referring back to the property TAG; for that property. And in the case where the compiler synthesizes the ivar; directly, the compiler is expected to generate a ``DW_TAG_member`` for that; ivar (with the ``DW_AT_artificial`` set to 1), whose name will be the name used; to access this ivar directly in code, and with the property attribute pointing; back to the property it is backing. The following examples will serve as illustration for our discussion:. .. code-block:: objc. @interface I1 {; int n2;; }. @property int p1;; @property int p2;; @end. @implementation I1; @synthesize p1;; @synthesize p2 = n2;; @end. This produces the following DWARF (this is a ""pseudo dwarfdump"" output):. .. code-block:: none. 0x00000100: TAG_structure_type [7] *; AT_APPLE_runtime_class( 0x10 ); AT_name( ""I1"" ); AT_decl_file( ""Objc_Property.m"" ); AT_decl_line( 3 ). 0x00000110 TAG_APPLE_property; AT_name ( ""p1"" ); AT_type ( {0x00000150} ( int ) ). 0x00000120: TAG_APPLE_property; AT_name ( ""p2"" ); AT_type ( {0x00000150} ( int ) ). 0x00000130: TAG_member [8]; AT_name( ""_p1"" ); AT_APPLE_property ( {0x00000110} ""p1"" ); AT_type( {0x00000150} ( int ) ); AT_artificial ( 0x1 ). 0x00000140: TAG_member [8]; AT_name( ""n2"" ); AT_APPLE_pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:51254,access,access,51254,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['access'],['access']
Security," default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1484,secur,security-taint-TaintPropagation,1484,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['secur'],['security-taint-TaintPropagation']
Security," define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and dynamic analysis tools could use the bounds information to improve; diagnostics for out-of-bounds accesses, even if ``-fbounds-safety`` is not used.; The bounds annotations could be used to improve C interoperability with; bounds-safe languages, providing a better mapping to bounds-safe types in the; safe language interface. The bounds annotations can also serve as documentation; specifying the relationship between declarations. Limitations; ===========. ``-fbounds-safety`` aims to bring the bounds safety guarantee to the C language,; and it does not guarantee other types of memory safety properties. Consequently,; it may not prevent some of the secondary bounds safety violations caused by; other types of safety violations such as type confusion. For instance,; ``-fbounds-safety`` does not perform type-safety checks on conversions between; `__single`` pointers of different pointee types (e.g., ``char *__single`` →; ``void *__single`` → ``int *__single``) beyond what the foundation languages; (C/C++) already offer. ``-fbounds-safety`` heavily rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:46808,access,accesses,46808,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['accesses']
Security," deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * An",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1366,secur,security,1366,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security," dereferenced to read memory. The exception is; ``DW_CFA_val_offset`` which uses the address to set the value of a register. In; order to support address spaces, the CFA DWARF expression is defined to be a; memory location description. This allows it to specify an address space which is; used to convert the offset address back to an address in that address space. See; :ref:`amdgpu-dwarf-call-frame-information`. This approach of extending memory location descriptions to support address; spaces, allows all existing DWARF Version 5 expressions to have the identical; semantics. It allows the compiler to explicitly specify the address space it is; using. For example, a compiler could choose to access private memory in a; swizzled manner when mapping a source language thread to the lane of a wavefront; in a SIMT manner. Or a compiler could choose to access it in an unswizzled; manner if mapping the same language with the wavefront being the thread. It also allows the compiler to mix the address space it uses to access private; memory. For example, for SIMT it can still spill entire vector registers in an; unswizzled manner, while using a swizzled private memory for SIMT variable; access. This approach also allows memory location descriptions for different address; spaces to be combined using the regular ``DW_OP_*piece`` operations. Location descriptions are an abstraction of storage. They give freedom to the; consumer on how to implement them. They allow the address space to encode lane; information so they can be used to read memory with only the memory location; description and no extra information. The same set of operations can operate on; locations independent of their kind of storage. The ``DW_OP_deref*`` therefore; can be used on any storage kind, including memory location descriptions of; different address spaces. Therefore, the ``DW_OP_xderef*`` operations are; unnecessary, except to become a more compact way to encode a non-default address; space address followe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:22447,access,access,22447,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security," done --- are a; bit too likely to be accidentally accepted, leading to mysterious behavior. For loads from ``const`` global variables of :ref:`C retainable pointer type; <arc.misc.c-retainable>`, it is reasonable to assume that global system; constants were initialized with true constants (e.g. string literals), but; user constants might have been initialized with something dynamically; allocated, using a global initializer. .. _arc.objects.restrictions.conversion-exception-contextual:. Conversion from retainable object pointer type in certain contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`. If an expression of retainable object pointer type is explicitly cast to a; :ref:`C retainable pointer type <arc.misc.c-retainable>`, the program is; ill-formed as discussed above unless the result is immediately used:. * to initialize a parameter in an Objective-C message send where the parameter; is not marked with the ``cf_consumed`` attribute, or; * to initialize a parameter in a direct call to an; :ref:`audited <arc.misc.c-retainable.audit>` function where the parameter is; not marked with the ``cf_consumed`` attribute. .. admonition:: Rationale. Consumed parameters are left out because ARC would naturally balance them; with a retain, which was judged too treacherous. This is in part because; several of the most common consuming functions are in the ``Release`` family,; and it would be quite unfortunate for explicit releases to be silently; balanced out in this way. .. _arc.ownership:. Ownership qualification; =======================. This section describes the behavior of *objects* of retainable object pointer; type; that is, locations in memory which store retainable object pointers. A type is a :arc-term:`retainable object owner type` if it is a retainable; object pointer type or an array type whose element type is a retainable object; owner type. An :arc-term:`ownership qualifier` is a type q",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:29763,audit,audited,29763,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['audit'],['audited']
Security," dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_label dfsan_get_label(long data);. /// Retrieves the label associated with the data at the given address.; dfsan_label dfsan_read_label(const void *addr, size_t size);. /// Returns whether the given label contains the label elem.; int dfsan_has_label(dfsan_label label, dfsan_label el",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:1314,sanitiz,sanitizer,1314,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['sanitiz'],['sanitizer']
Security," easy for later stages of the compiler (e.g. code generation) to; interpret. We basically want one object for each construct in the; language, and the AST should closely model the language. In; Kaleidoscope, we have expressions, a prototype, and a function object.; We'll start with expressions first:. .. code-block:: c++. /// ExprAST - Base class for all expression nodes.; class ExprAST {; public:; virtual ~ExprAST() = default;; };. /// NumberExprAST - Expression class for numeric literals like ""1.0"".; class NumberExprAST : public ExprAST {; double Val;. public:; NumberExprAST(double Val) : Val(Val) {}; };. The code above shows the definition of the base ExprAST class and one; subclass which we use for numeric literals. The important thing to note; about this code is that the NumberExprAST class captures the numeric; value of the literal as an instance variable. This allows later phases; of the compiler to know what the stored numeric value is. Right now we only create the AST, so there are no useful accessor; methods on them. It would be very easy to add a virtual method to pretty; print the code, for example. Here are the other expression AST node; definitions that we'll use in the basic form of the Kaleidoscope; language:. .. code-block:: c++. /// VariableExprAST - Expression class for referencing a variable, like ""a"".; class VariableExprAST : public ExprAST {; std::string Name;. public:; VariableExprAST(const std::string &Name) : Name(Name) {}; };. /// BinaryExprAST - Expression class for a binary operator.; class BinaryExprAST : public ExprAST {; char Op;; std::unique_ptr<ExprAST> LHS, RHS;. public:; BinaryExprAST(char Op, std::unique_ptr<ExprAST> LHS,; std::unique_ptr<ExprAST> RHS); : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}; };. /// CallExprAST - Expression class for function calls.; class CallExprAST : public ExprAST {; std::string Callee;; std::vector<std::unique_ptr<ExprAST>> Args;. public:; CallExprAST(const std::string &Callee,; std::vector<st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:2205,access,accessor,2205,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['access'],['accessor']
Security," entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code base when; finding the direct stack frame triggering the failure for every failure is; difficult.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:3826,sanitiz,sanitizers,3826,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,2,['sanitiz'],"['sanitize', 'sanitizers']"
Security," equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:3683,sanitiz,sanitizer,3683,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,1,['sanitiz'],['sanitizer']
Security," example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:15406,access,accessible,15406,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['access'],['accessible']
Security," exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class. When command is registered with THttpServer::RegisterCommand() method,; one could configure additional arguments which should be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:19829,expose,expose,19829,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,2,['expose'],"['expose', 'exposed']"
Security," fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:32554,access,accessed,32554,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['accessed']
Security," files opened even further. Update hadd and TFileMerger so that they prefix all their information message; with their names (when running hadd, the TFileMerger message are prefixed by hadd):. $ hadd -v 0 -f output.root input1.root input2.root; $ hadd -v 1 -f output.root input1.root input2.root; hadd merged 2 input files in output.root.; $ hadd -v 2 -f output.root input1.root input2.root; hadd target file: output.root; hadd Source file 1: input1.root; hadd Source file 2: input2.root; hadd Target path: output.root:/. Introduce non-static version of TFile::Cp allows the copy of; an existing TFile object. Introduce new explicit interface for providing reseting; capability after a merge. If a class has a method with; the name and signature:. void ResetAfterMerge(TFileMergeInfo*);. it will be used by a TMemFile to reset its objects after; a merge operation has been done. If this method does not exist, the TClass will use; a method with the name and signature:. void Reset(Optiont_t *);. TClass now provides a quick access to these merging; function via TClass::GetResetAfterMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetResetAfterMerge. The wrapper function should have; the signature/type ROOT::ResetAfterMergeFunc_t:. void (*)(void *thisobj, TFileMergeInfo*);. ResetAfterMerge functions were added to the following classes:; TDirectoryFile, TMemFile, TTree, TChain, TBranch, TBranchElement,; TBranchClones, TBranchObject and TBranchRef. Avoid leaking the inner object in a container like vector<vector<MyClass*> > ; and vector<vector<MyClass*> *> . Put in place the infrastructure to optimize the I/O writes in the same way we optimized the I/O reads. Add the function TBuffer::AutoExpand to centralize the automatic; buffer extension policy. This enable the ability to tweak it later; (for example instead of always doubling the size, increasing by; only at most 2Mb or take hints from the number of entries already; in a TBasket). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:8780,access,access,8780,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['access'],['access']
Security," for authenticated users only. First of all, one should create a password file, using the **htdigest** utility. ```bash; [shell] htdigest -c .htdigest domain_name user_name; ```. It is recommended not to use special symbols in domain or user names. Several users can be add to the "".htdigest"" file. When starting the server, the following arguments should be specified:. ```cpp; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; ```. After that, the web browser will automatically request to input a name/password for the domain ""domain_name"". Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using `THttpServer::Restrict()` method. For instance, one could hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or objects can not be accessed via http protocol. By default server runs in readonly mode and do not allow methods execution via 'exe.json' or 'exe.bin' requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; ```. Complete list of supported options could be found in [TRootSniffer:Restrict()](https://root.cern/doc/master/classTRootSniffer.html#a8af1f11cbfb9c895f968ec0594794120) method documentation. ## Using FastCGI interface. [FastCGI](http://en.wikipedia.org/wiki/FastCGI) is a protocol for interfacing interactive programs with a web server like `Apache`, `lighttpd`, `Microsoft ISS` and many others. When starting THttpServer, one could specify:. ```c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:9232,access,accessed,9232,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['accessed']
Security," for canvases and files (default) |; | noglobal | disable scan of global directories |; | basic_sniffer | use basic `TRootSniffer` without support of hist, gpad, graph, tree classes |. Example:. ```cpp; new THttpServer(""http:8080;ro;noglobal""); ```. ## Registering objects. At any time, one could register other objects with the command:. ```cpp; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. One should specify sub-folder name, where objects will be registered.; If sub-folder name does not starts with slash `/`, than top-name folder `/Objects/` will be prepended.; At any time one could unregister objects:. ```cpp; serv->Unregister(gr);; ```. THttpServer does not take ownership over registered objects - they should be deleted by user. If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4100,access,access,4100,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security," for functions included-but-not-used in a translation; unit) reduces size bloat in the coverage mapping data. As part of this; change, region mapping information for a function is now included within the; function record, instead of being affixed to the coverage header. * The filename list for a translation unit may optionally be zlib-compressed. The only difference between versions 3 and 2 is that a special encoding for; column end locations was introduced to indicate gap regions. In version 1, the function record for *foo* was defined as follows:. .. code-block:: llvm. { i8*, i32, i32, i64 } { i8* getelementptr inbounds ([3 x i8]* @__profn_foo, i32 0, i32 0), ; Function's name; i32 3, ; Function's name length; i32 9, ; Function's encoded coverage mapping data string length; i64 0 ; Function's structural hash; }. In version 2, the function record for *foo* was defined as follows:. .. code-block:: llvm. { i64, i32, i64 } {; i64 0x5cf8c24cdb18bdac, ; Function's name MD5; i32 9, ; Function's encoded coverage mapping data string length; i64 0 ; Function's structural hash. Coverage Mapping Header:; ------------------------. As shown above, the coverage mapping header has the following fields:. * The number of function records affixed to the coverage header. Always 0, but present for backwards compatibility. * The length of the string in the third field of *__llvm_coverage_mapping* that contains the encoded translation unit filenames. * The length of the string in the third field of *__llvm_coverage_mapping* that contains any encoded coverage mapping data affixed to the coverage header. Always 0, but present for backwards compatibility. * The format version. The current version is 6 (encoded as a 5). .. _function records:. Function record:; ----------------. A function record is a structure of the following type:. .. code-block:: llvm. { i64, i32, i64, i64, [? x i8] }. It contains the function name's MD5, the length of the encoded mapping data for; that function, the func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:17347,hash,hash,17347,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['hash'],['hash']
Security," for open source; projects. Any of these could replace the code-hosting infrastructure that we; have today. These services also have a dedicated team to monitor, migrate, improve and; distribute the contents of the repositories depending on region and load. GitHub has one important advantage over GitLab and; BitBucket: it offers read-write **SVN** access to the repository; (https://github.com/blog/626-announcing-svn-support).; This would enable people to continue working post-migration as though our code; were still canonically in an SVN repository. In addition, there are already multiple LLVM mirrors on GitHub, indicating that; part of our community has already settled there. On Managing Revision Numbers with Git; -------------------------------------. The current SVN repository hosts all the LLVM sub-projects alongside each other.; A single revision number (e.g. r123456) thus identifies a consistent version of; all LLVM sub-projects. Git does not use sequential integer revision number but instead uses a hash to; identify each commit. The loss of a sequential integer revision number has been a sticking point in; past discussions about Git:. - ""The 'branch' I most care about is mainline, and losing the ability to say; 'fixed in r1234' (with some sort of monotonically increasing number) would; be a tragic loss."" [LattnerRevNum]_; - ""I like those results sorted by time and the chronology should be obvious, but; timestamps are incredibly cumbersome and make it difficult to verify that a; given checkout matches a given set of results."" [TrickRevNum]_; - ""There is still the major regression with unreadable version numbers.; Given the amount of Bugzilla traffic with 'Fixed in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:4239,hash,hash,4239,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security," for the possible memory location; kinds (``argmem``, ``inaccessiblemem``, as well as a default). It is best; understood by example:. - ``memory(none)``: Does not access any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:85780,access,accesses,85780,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,4,['access'],"['accesses', 'accessible', 'accessing']"
Security," formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can be interactively rotated, zoomed in wire-frame, solid,; hidden line or stereo mode. ![](pictures/0300000C.png). #### Options Menu. - *Auto Resize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8861,access,access,8861,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security," function declarations. For non-opaque pointers, the type; passed to ``elementtype`` must match the pointer element type. .. _attr_align:. ``align <n>`` or ``align(<n>)``; This indicates that the pointer value or vector of pointers has the; specified alignment. If applied to a vector of pointers, *all* pointers; (elements) have the specified alignment. If the pointer value does not have; the specified alignment, :ref:`poison value <poisonvalues>` is returned or; passed instead. The ``align`` attribute should be combined with the; ``noundef`` attribute to ensure a pointer is aligned, or otherwise the; behavior is undefined. Note that ``align 1`` has no effect on non-byval,; non-preallocated arguments. Note that this attribute has additional semantics when combined with the; ``byval`` or ``preallocated`` attribute, which are documented there. .. _noalias:. ``noalias``; This indicates that memory locations accessed via pointer values; :ref:`based <pointeraliasing>` on the argument or return value are not also; accessed, during the execution of the function, via pointer values not; *based* on the argument or return value. This guarantee only holds for; memory locations that are *modified*, by any means, during the execution of; the function. The attribute on a return value also has additional semantics; described below. The caller shares the responsibility with the callee for; ensuring that these requirements are met. For further details, please see; the discussion of the NoAlias response in :ref:`alias analysis <Must, May,; or No>`. Note that this definition of ``noalias`` is intentionally similar; to the definition of ``restrict`` in C99 for function arguments. For function return values, C99's ``restrict`` is not meaningful,; while LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias``; attribute on return values are stronger than the semantics of the attribute; when used on function arguments. On function return values, the ``noalias``; attribute indica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:57902,access,accessed,57902,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['accessed']
Security," function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:26277,inject,injected,26277,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['inject'],['injected']
Security," function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4636,access,access,4636,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,2,['access'],['access']
Security," function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the pointer and passes the result as the argument %1 into ``^3``.; This record itself does not tell us how ``^3`` will access the parameter.; Parameter %3 is not a pointer. .. _refs_summary:. Refs; ^^^^. The optional ``Refs`` field looks like:. .. code-block:: text. refs: ((Ref)[, (Ref)]*). where each ``Ref`` contains a reference to the summary id of the referenced; value (e.g. ``^1``). .. _typeidinfo_summary:. TypeIdInfo; ^^^^^^^^^^. The optional ``TypeIdInfo`` field, used for; `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; looks like:. .. code-block:: text. typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstVCalls)]?[, (TypeCheckedLoadConstVCalls)]?. These optional fields have the following forms:. TypeTests; """""""""""""""""". .. code-block:: text. typeTests: (TypeIdRef[, TypeIdRef]*). Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>`; by summary id or ``GUID``. TypeTestAssumeVCalls; """""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeTestAssumeVCalls: (VFuncId[, VFuncId]*). Where each VFu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:346390,access,access,346390,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:102794,access,accessed,102794,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security," functions.; Example:. .. code-block:: python. >>> import cppyy; >>> import cppyy.numba_ext; >>> import numba; >>> import numpy as np; >>> cppyy.cppdef(""""""; ... template<typename T>; ... T square(T t) { return t*t; }; ... """"""); >>> @numba.jit(nopython=True); ... def tsa(a):; ... total = type(a[0])(0); ... for i in range(len(a)):; ... total += cppyy.gbl.square(a[i]); ... return total; >>> a = np.array(range(10), dtype=np.float32); >>> print(""Float array: "", a); Float array: [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]; >>> print(""Sum of squares: "", tsa(a)); Sum of squares: 285.0; >>> print(); >>> a = np.array(range(10), dtype=np.int32); >>> print(""Integer array: "", a); Integer array: [0 1 2 3 4 5 6 7 8 9]; >>> print(""Sum of squares: "", tsa(a)); Sum of squares: 285. Instances of C++ classes can be passed into Numba traces.; They can be returned from functions called *within* the trace, but cannot yet; be returned *from* the trace.; Their public data is accessible (read-only) if of built-in type and their; public methods can be called, for which overload selection works.; Example:. .. code-block:: python. >>> import cppyy; >>> import numba; >>> import numpy as np; >>> ; >>> cppyy.cppdef(""""""\; ... class MyData {; ... public:; ... MyData(int i, int j) : fField1(i), fField2(j) {}; ...; ... public:; ... int get_field1() { return fField1; }; ... int get_field2() { return fField2; }; ...; ... MyData copy() { return *this; }; ...; ... public:; ... int fField1;; ... int fField2;; ... };""""""); True; >>> @numba.jit(nopython=True); >>> def tsdf(a, d):; ... total = type(a[0])(0); ... for i in range(len(a)):; ... total += a[i] + d.fField1 + d.fField2; ... return total; ...; >>> d = cppyy.gbl.MyData(5, 6); >>> a = np.array(range(10), dtype=np.int32); >>> print(tsdf(a, d)); 155; >>> # example of method calls; >>> @numba.jit(nopython=True); >>> def tsdm(a, d):; ... total = type(a[0])(0); ... for i in range(len(a)):; ... total += a[i] + d.get_field1() + d.get_field2(); ... return total; ...; >>> pri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:6618,access,accessible,6618,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['access'],['accessible']
Security," generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64005,access,access-external-data,64005,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['access-external-data']
Security," global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; C++ rules. .. _opbundles:. Operand Bundles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:116169,access,accesses,116169,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security," global*; Generic flat flat 64 0x0000000000000000; Region N/A GDS 32 *not implemented; for AMDHSA*; ================= =========== ======== ======= ==================. The global and constant memory spaces both use global virtual addresses, which; are the same virtual address space used by the CPU. However, some virtual; addresses may only be accessible to the CPU, some only accessible by the GPU,; and some by both. Using the constant memory space indicates that the data will not change during; the execution of the kernel. This allows scalar read instructions to be; used. The vector and scalar L1 caches are invalidated of volatile data before; each kernel dispatch execution to allow constant memory to change values between; kernel dispatches. The local memory space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates work-groups of wavefronts, and; freed when all the wavefronts of a work-group have terminated. The data store; (DS) instructions can be used to access it. The private memory space uses the hardware scratch memory support. If the kernel; uses scratch, then the hardware allocates memory that is accessed using; wavefront lane dword (4 byte) interleaving. The mapping used from private; address to physical address is:. ``wavefront-scratch-base +; (private-address * wavefront-size * 4) +; (wavefront-lane-id * 4)``. There are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instruction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:154358,access,access,154358,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to reproduced results in isolation with a single pass; when the result relies on the state acquired by ``MemorySSA`` due to being updated by; multiple subsequent passes.; Passes that use and update ``MemorySSA`` should do so through the APIs provided by the; ``MemorySSAUpdater``, or through calls on the Walker.; Direct optimizations to ``MemorySSA`` are not permitted.; There is currently a single, narrowly scoped exception where DSE (DeadStoreElimination); updates an optimized access of a store, after a traversal that guarantees the; optimization is correct. This is solely allowed due to the traversals and inferences; being beyond what ``MemorySSA`` does and them being ""free"" (i.e. DSE does them anyway).; This exception is set under a flag (""-dse-optimize-memoryssa"") and can be disabled to; help reproduce optimizations in isolation. LLVM Developers Meeting presentations; -------------------------------------. - `2016 LLVM Developers' Meeting: G. Burgess - MemorySSA in Five Minutes <https://www.youtube.com/watch?v=bdxWmryoHak>`_.; - `2020 LLVM Developers' Meeting: S. Baziotis & S. Moll - Finding Your Way Around the LLVM Dependence Analysis Zoo <https://www.youtube.com/watch?v=1e5y6WDbXCQ>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:19495,access,access,19495,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security," hash tables have a header, buckets, and each bucket points to the; bucket contents:. .. code-block:: none. .------------.; | HEADER |; |------------|; | BUCKETS |; |------------|; | DATA |; `------------'. The BUCKETS are an array of offsets to DATA for each hash:. .. code-block:: none. .------------.; | 0x00001000 | BUCKETS[0]; | 0x00002000 | BUCKETS[1]; | 0x00002200 | BUCKETS[2]; | 0x000034f0 | BUCKETS[3]; | | ...; | 0xXXXXXXXX | BUCKETS[n_buckets]; '------------'. So for ``bucket[3]`` in the example above, we have an offset into the table; 0x000034f0 which points to a chain of entries for the bucket. Each bucket must; contain a next pointer, full 32 bit hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem with this layout for debuggers is that we need to optimize for the; negative lookup case where the symbol we're searching for is not present. So; if we were to lookup ""``printf``"" in the table above, we would make a 32-bit; hash for ""``printf``"", it might match ``bucket[3]``. We would need to go to; the offset 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:61720,hash,hash,61720,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,3,['hash'],['hash']
Security," holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23979,access,access,23979,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security," i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The suc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436915,access,access,436915,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," i32 <element_size>); declare void @llvm.memcpy.element.unordered.atomic.p0.p0.i64(ptr <dest>,; ptr <src>,; i64 <len>,; i32 <element_size>). Overview:; """""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic is a specialization of the; '``llvm.memcpy.*``' intrinsic. It differs in that the ``dest`` and ``src`` are treated; as arrays with elements that are exactly ``element_size`` bytes, and the copy between; buffers uses a sequence of :ref:`unordered atomic <ordering>` load/store operations; that are a positive integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the :ref:`@llvm.memcpy <int_memcpy>`; intrinsic, with the added constraint that ``len`` is required to be a positive integer; multiple of the ``element_size``. If ``len`` is not a positive integer multiple of; ``element_size``, then the behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no greater than; target-specific atomic access size limit. For each of the input pointers ``align`` parameter attribute must be specified. It; must be a power of two no less than the ``element_size``. Caller guarantees that; both the source and destination pointers are aligned to that boundary. Semantics:; """""""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic copies ``len`` bytes of; memory from the source location to the destination location. These locations are not; allowed to overlap. The memory copy is performed as a sequence of load/store operations; where each access is guaranteed to be a multiple of ``element_size`` bytes wide and; aligned at an ``element_size`` boundary. The order of the copy is unspecified. The same value may be read from the source; buffer many times, but only one write is issued to the destination buffer per; element. It is well defined to have concurrent reads and writes to both source and; destination provided those reads and writes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:958507,access,access,958507,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," if a; given machine operand is a register, use the boolean function; ``MachineOperand::isRegister()``. To obtain the integer code of a register, use; ``MachineOperand::getReg()``. An instruction may define or use a register. For; instance, ``ADD reg:1026 := reg:1025 reg:1024`` defines the registers 1024, and; uses registers 1025 and 1026. Given a register operand, the method; ``MachineOperand::isUse()`` informs if that register is being used by the; instruction. The method ``MachineOperand::isDef()`` informs if that registers is; being defined. We will call physical registers present in the LLVM bitcode before register; allocation *pre-colored registers*. Pre-colored registers are used in many; different situations, for instance, to pass parameters of functions calls, and; to store results of particular instructions. There are two types of pre-colored; registers: the ones *implicitly* defined, and those *explicitly*; defined. Explicitly defined registers are normal operands, and can be accessed; with ``MachineInstr::getOperand(int)::getReg()``. In order to check which; registers are implicitly defined by an instruction, use the; ``TargetInstrInfo::get(opcode)::ImplicitDefs``, where ``opcode`` is the opcode; of the target instruction. One important difference between explicit and; implicit physical registers is that the latter are defined statically for each; instruction, whereas the former may vary depending on the program being; compiled. For example, an instruction that represents a function call will; always implicitly define or use the same set of physical registers. To read the; registers implicitly used by an instruction, use; ``TargetInstrInfo::get(opcode)::ImplicitUses``. Pre-colored registers impose; constraints on any register allocation algorithm. The register allocator must; make sure that none of them are overwritten by the values of virtual registers; while still alive. Mapping virtual registers to physical registers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:62877,access,accessed,62877,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accessed']
Security," if the value is something other than ``VC70``. - **Signature** - A 32-bit time-stamp generated with a call to ``time()`` at; the time the PDB file is written. Note that due to the inherent uniqueness; problems of using a timestamp with 1-second granularity, this field does not; really serve its intended purpose, and as such is typically ignored in favor; of the ``Guid`` field, described below. - **Age** - The number of times the PDB file has been written. This can be used; along with ``Guid`` to match the PDB to its corresponding executable. - **Guid** - A 128-bit identifier guaranteed to be unique across space and time.; In general, this can be thought of as the result of calling the Win32 API; `UuidCreate <https://msdn.microsoft.com/en-us/library/windows/desktop/aa379205(v=vs.85).aspx>`__,; although LLVM cannot rely on that, as it must work on non-Windows platforms. .. _pdb_named_stream_map:. Named Stream Map; ================. Following the header is a serialized hash table whose key type is a string, and; whose value type is an integer. The existence of a mapping ``X -> Y`` means; that the stream with the name ``X`` has stream index ``Y`` in the underlying MSF; file. Note that not all streams are named (for example, the; :doc:`TPI Stream <TpiStream>` has a fixed index and as such there is no need to; look up its index by name). In practice, there are usually only a small number; of named streams and these are enumerated in the table of streams in :doc:`index`.; A corollary of this is if a stream does have a name (and as such is in the named; stream map) then consulting the Named Stream Map is likely to be the only way to; discover the stream's MSF stream index. Several important streams (such as the; global string table, which is called ``/names``) can only be located this way, and; so it is important to both produce and consume this correctly as tools will not; function correctly without it. .. important::; Some streams are located by fixed indices (e.g TPI Str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:2018,hash,hash,2018,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,1,['hash'],['hash']
Security," in WriteQueryLog fill also the field 'totevents'; in; PacketEvent, add switch to control whether to send te information to; the monitoring system on per packet level (may be too much for SQL).; The switch is called fMonitorPerPacket and it is globally controlled by; the rootrc variable 'Proof.MonitorPerPacket' and at session level with; the parameter PROOF_MonitorPerPacket .; Improve treatment of the case when temporary files are asked to be; created on a shared file system not containing the sandboxes. This; case, which seems to be a rather common one, should be now fully; supported.; Correctly honour selector abort status settings; TSelector::kAbortProcess and TSelector::kAbortFile.; Improve reporting of the non-processed {files, events} in the final; 'MissingFiles' list.  ; Improved algorithm for TPacketizerUnit to fix issue with non; homogeneous machines.; Improve the way the information about log files is saved in case of; failures. The log paths for these failing now should be now correctly; saved and accessible via TProofLog.; Improve merging of histograms. Just use TH1::Add whne the axis are; equal; much faster than TH1::Merge. Fixes; ; In TDataSetManagerFile::NotifyUpdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:5113,access,accessible,5113,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['access'],['accessible']
Security," in,; such as `llvm-commits; <http://lists.llvm.org/mailman/listinfo/llvm-commits>`_, `cfe-commits; <http://lists.llvm.org/mailman/listinfo/cfe-commits>`_, or `lldb-commits; <http://lists.llvm.org/mailman/listinfo/lldb-commits>`_. Missing features and bugs are tracked through our `GitHub issue tracker <https://github.com/llvm/llvm-project/issues>`_; and assigned labels. We recommend that active developers monitor incoming issues.; You can subscribe for notification for specific components by joining; one of the `issue-subscribers-* <https://github.com/orgs/llvm/teams?query=issue-subscribers>`_; teams.; You may also subscribe to the `llvm-bugs; <http://lists.llvm.org/mailman/listinfo/llvm-bugs>`_ email list to keep track; of bugs and enhancements occurring in the entire project. We really appreciate people; who are proactive at catching incoming bugs in their components and dealing with them; promptly. Please be aware that all public LLVM mailing lists and discourse forums are public and archived, and; that notices of confidentiality or non-disclosure cannot be respected. .. _patch:; .. _one-off patches:. Making and Submitting a Patch; -----------------------------. When making a patch for review, the goal is to make it as easy for the reviewer; to read it as possible. As such, we recommend that you:. #. Make your patch against git main, not a branch, and not an old version; of LLVM. This makes it easy to apply the patch. For information on how to; clone from git, please see the :ref:`Getting Started Guide; <checkout>`. #. Similarly, patches should be submitted soon after they are generated. Old; patches may not apply correctly if the underlying code changes between the; time the patch was created and the time it is applied. #. Once you have created your patch, create a; :ref:`GitHub Pull Request <github-reviews>` for; it (or commit it directly if applicable). When submitting patches, please do not add confidentiality or non-disclosure; notices to the patches themselv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:3639,confidential,confidentiality,3639,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['confidential'],['confidentiality']
Security," including but; not limited to compiled object code, generated documentation,; and conversions to other media types. ""Work"" shall mean the work of authorship, whether in Source or; Object form, made available under the License, as indicated by a; copyright notice that is included in or attached to the work; (an example is provided in the Appendix below). ""Derivative Works"" shall mean any work, whether in Source or Object; form, that is based on (or derived from) the Work and for which the; editorial revisions, annotations, elaborations, or other modifications; represent, as a whole, an original work of authorship. For the purposes; of this License, Derivative Works shall not include works that remain; separable from, or merely link (or bind by name) to the interfaces of,; the Work and Derivative Works thereof. ""Contribution"" shall mean any work of authorship, including; the original version of the Work and any modifications or additions; to that Work or Derivative Works thereof, that is intentionally; submitted to Licensor for inclusion in the Work by the copyright owner; or by an individual or Legal Entity authorized to submit on behalf of; the copyright owner. For the purposes of this definition, ""submitted""; means any form of electronic, verbal, or written communication sent; to the Licensor or its representatives, including but not limited to; communication on electronic mailing lists, source code control systems,; and issue tracking systems that are managed by, or on behalf of, the; Licensor for the purpose of discussing and improving the Work, but; excluding communication that is conspicuously marked or otherwise; designated in writing by the copyright owner as ""Not a Contribution."". ""Contributor"" shall mean Licensor and any individual or Legal Entity; on behalf of whom a Contribution has been received by Licensor and; subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of; this License, each Contributor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:2617,authoriz,authorized,2617,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,5,['authoriz'],['authorized']
Security," including object format features that require; non-trivial action in the executor (e.g. running initializers, managing thread; local storage, registering with language runtimes, etc.). ORC Runtime support for object format features typically requires cooperation; between the runtime (which executes in the executor process) and JITLink (which; runs in the JIT process and can inspect LinkGraphs to determine what actions; must be taken in the executor). For example: Execution of MachO static; initializers in the ORC runtime is performed by the ``jit_dlopen`` function,; which calls back to the JIT process to ask for the list of address ranges of; ``__mod_init`` sections to walk. This list is collated by the; ``MachOPlatformPlugin``, which installs a pass to record this information for; each object as it is linked into the target. .. _constructing_linkgraphs:. Constructing LinkGraphs; =======================. Clients usually access and manipulate ``LinkGraph`` instances that were created; for them by an ``ObjectLinkingLayer`` instance, but they can be created manually:. #. By directly constructing and populating a ``LinkGraph`` instance. #. By using the ``createLinkGraph`` family of functions to create a; ``LinkGraph`` from an in-memory buffer containing an object file. This is how; ``ObjectLinkingLayer`` usually creates ``LinkGraphs``. #. ``createLinkGraph_<Object-Format>_<Architecture>`` can be used when; both the object format and architecture are known ahead of time. #. ``createLinkGraph_<Object-Format>`` can be used when the object format is; known ahead of time, but the architecture is not. In this case the; architecture will be determined by inspection of the object header. #. ``createLinkGraph`` can be used when neither the object format nor; the architecture are known ahead of time. In this case the object header; will be inspected to determine both the format and architecture. .. _jit_linking:. JIT Linking; ===========. The JIT linker concept was introduced in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:33747,access,access,33747,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['access']
Security," inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds annotation defines an invariant for the pointer type, and the model; ensures that this invariant remains true. In the example below, pointer ``p``; annotated with ``__counted_by(count)`` must always point to a memory buffer; containing at least ``count`` elements of the pointee type. Changing the value; of ``count``, like in the example below, may violate this invariant and permit; out-of-bounds access to the pointer. To avoid this, the compiler employs; compile-time restrictions and emits run-time checks as necessary to ensure the; new count v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:3562,access,access,3562,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['access']
Security," insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80066,hash,hash,80066,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['hash'],['hash']
Security," integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4196,access,access,4196,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['access'],['access']
Security," into scalar type; descriptors and struct type descriptors; and *Access Tags*. **Type descriptors** describe the type system of the higher level language; being compiled. **Scalar type descriptors** describe types that do not; contain other types. Each scalar type has a parent type, which must also; be a scalar type or the TBAA root. Via this parent relation, scalar types; within a TBAA root form a tree. **Struct type descriptors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:274875,access,access,274875,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," involved in RNTuple I/O (objects read from disk or written to disk) are passed to RNTuple as shared pointers.; Both RNTuple or the application may create the object.; Raw pointers to objects can be passed to RNTuple -- such objects are considered as owned by the application.; The caller has to ensure that the lifetime of the object lasts during the I/O operations. An RNTuple writer that is constructed without a `TFile` object (`RNTupleWriter::Recreate()`) assumes exclusive access to the underlying file.; An RNTuple writer that uses a `TFile` for writing (`RNTupleWriter::Append()`) assumes that the `TFile` object outlives the writer's lifetime.; The serial writer assumes exclusive access to the underlying file during construction, destruction and `Fill()` as well as `CommitCluster()` and `FlushCluster()`.; For `FlushColumns()` and `FillNoFlush()`, the sequential writer assumes exclusive access only if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses the `RMiniFile` and `RRawFile` classes to open a given storage path and find the `RNTuple` anchor.; When creating a `RNTupleReader` from an existing anchor object, RNTuple uses `RRawFile` only for files of dynamic type `TFile`, `TDavixFile`, and `TNetXNGFile`.; In either case, the `RRawFile` owns its own file descriptor and does not interfere with `TFile` objects concurrently reading the file.; For anchors from files of other dynamic type, including all other `TFile` subclasses, the file is wrapped in a `RRawFileTFile` and access is shared. On-Disk Encoding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:18117,access,access,18117,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security," is inconvenient and wasteful for every front-end to; have to reproduce this logic. Memory in LLVM; ==============. The 'trick' here is that while LLVM does require all register values to; be in SSA form, it does not require (or permit) memory objects to be in; SSA form. In the example above, note that the loads from G and H are; direct accesses to G and H: they are not renamed or versioned. This; differs from some other compiler systems, which do try to version memory; objects. In LLVM, instead of encoding dataflow analysis of memory into; the LLVM IR, it is handled with `Analysis; Passes <../../WritingAnLLVMPass.html>`_ which are computed on demand. With this in mind, the high-level idea is that we want to make a stack; variable (which lives in memory, because it is on the stack) for each; mutable object in a function. To take advantage of this trick, we need; to talk about how LLVM represents stack variables. In LLVM, all memory accesses are explicit with load/store instructions,; and it is carefully designed not to have (or need) an ""address-of""; operator. Notice how the type of the @G/@H global variables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:4347,access,accesses,4347,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['access'],['accesses']
Security," is only valid at call sites for; direct calls to functions that are declared with the ``nobuiltin``; attribute.; ``cold``; This attribute indicates that this function is rarely called. When; computing edge weights, basic blocks post-dominated by a cold; function call are also considered to be cold; and, thus, given low; weight. .. _attr_convergent:. ``convergent``; This attribute indicates that this function is convergent.; When it appears on a call/invoke, the convergent attribute; indicates that we should treat the call as though we’re calling a; convergent function. This is particularly useful on indirect; calls; without this we may treat such calls as though the target; is non-convergent. See :doc:`ConvergentOperations` for further details. It is an error to call :ref:`llvm.experimental.convergence.entry; <llvm.experimental.convergence.entry>` from a function that; does not have this attribute.; ``disable_sanitizer_instrumentation``; When instrumenting code with sanitizers, it can be important to skip certain; functions to ensure no instrumentation is applied to them. This attribute is not always similar to absent ``sanitize_<name>``; attributes: depending on the specific sanitizer, code can be inserted into; functions regardless of the ``sanitize_<name>`` attribute to prevent false; positive reports. ``disable_sanitizer_instrumentation`` disables all kinds of instrumentation,; taking precedence over the ``sanitize_<name>`` attributes and other compiler; flags.; ``""dontcall-error""``; This attribute denotes that an error diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``""dontcall-warn""``; This attribute denotes that a warning diagnostic should be emitted when a; call of a function with this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:81481,sanitiz,sanitizers,81481,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['sanitiz'],['sanitizers']
Security," is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:12130,secur,security,12130,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security," is their defining or optimized; access.; Traditionally ``MemorySSA`` optimized ``MemoryUse``\ s at build-time, up to a; given threshold.; Specifically, the operand of every ``MemoryUse`` was optimized to point to the; actual clobber of said ``MemoryUse``. This can be seen in the above example; the; second ``MemoryUse`` in ``if.end`` has an operand of ``1``, which is a; ``MemoryDef`` from the entry block. This is done to make walking,; value numbering, etc, faster and easier.; As of `this revision <https://reviews.llvm.org/D121381>`_, the default was; changed to not optimize uses at build time, in order to provide the option to; reduce compile-time if the walking is not necessary in a pass. Most users call; the new API ``ensureOptimizedUses()`` to keep the previous behavior and do a; one-time optimization of ``MemoryUse``\ s, if this was not done before.; New pass users are recommended to call ``ensureOptimizedUses()``. Initially it was not possible to optimize ``MemoryDef``\ s in the same way, as we; restricted ``MemorySSA`` to one operand per access.; This was changed and ``MemoryDef``\ s now keep two operands.; The first one, the defining access, is; always the previous ``MemoryDef`` or ``MemoryPhi`` in the same basic block, or; the last one in a dominating predecessor if the current block doesn't have any; other accesses writing to memory. This is needed for walking Def chains.; The second operand is the optimized access, if there was a previous call on the; walker's ``getClobberingMemoryAccess(MA)``. This API will cache information; as part of ``MA``.; Optimizing all ``MemoryDef``\ s has quadratic time complexity and is not done; by default. A walk of the uses for any MemoryDef can find the accesses that were optimized; to it.; A code snippet for such a walk looks like this:. .. code-block:: c++. MemoryDef *Def; // find who's optimized or defining for this MemoryDef; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:12110,access,access,12110,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security," is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[:8884]` (a single server to; contact directly). If the variable is not set, yet the plugin is loaded, MonALISA; monitoring is inhibited until a valid configuration variable is; provided. dsmgrd.apmonprefix *MY::CLUSTER::PREFIX*; : Since MonALISA organizes information in ""clusters"" and ""hosts"", here; you can specify what to use as cluster prefix for monitoring; datasets information and daemon status. If this variable is not set,; MonALISA monitoring is inhibited. Please note that the suffix; `_datasets` or `_status` is appended for each of the two types of; monitoring. A sample configuration file; ---------------------------. xpd.stagereqrepo /opt/aaf/var/proof/datasets; dsmgrd.purgenoopds true; dsmgrd.urlregex alien://(.*)$ /storage$1; dsmgrd.sleepsecs 20; dsmgrd.scandseveryloops 30; dsmgrd.parallelxfrs 10; dsmgrd.stagecmd /opt/aaf/bin/af-xrddm-verify.sh ""$URLTOSTAGE"" ""$TREENAME""; dsmgrd.cmdtimeoutsecs 3600; dsmgrd.corruptafterfails 0; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:5434,password,password,5434,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['password'],['password']
Security," isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310787,access,access,310787,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,3,['access'],['access']
Security," large size and; capacity, as well as value types and hash functions. The only supported key; value type is a uint32. The only requirement is that the producer and consumer; agree on the hash function. As such, the hash function can is not discussed; further in this document, it is assumed that for a particular instance of a PDB; file hash table, the appropriate hash function is being used. On-Disk Format; ==============. .. code-block:: none. .--------------------.-- +0; | Size |; .--------------------.-- +4; | Capacity |; .--------------------.-- +8; | Present Bit Vector |; .--------------------.-- +N; | Deleted Bit Vector |; .--------------------.-- +M ─╮; | Key | │; .--------------------.-- +M+4 │; | Value | │; .--------------------.-- +M+4+sizeof(Value) │; ... ├─ |Capacity| Bucket entries; .--------------------. │; | Key | │; .--------------------. │; | Value | │; .--------------------. ─╯. - **Size** - The number of values contained in the hash table. - **Capacity** - The number of buckets in the hash table. Producers should; maintain a load factor of no greater than ``2/3*Capacity+1``. - **Present Bit Vector** - A serialized bit vector which contains information; about which buckets have valid values. If the bucket has a value, the; corresponding bit will be set, and if the bucket doesn't have a value (either; because the bucket is empty or because the value is a tombstone value) the bit; will be unset. - **Deleted Bit Vector** - A serialized bit vector which contains information; about which buckets have tombstone values. If the entry in this bucket is; deleted, the bit will be set, otherwise it will be unset. - **Keys and Values** - A list of ``Capacity`` hash buckets, where the first; entry is the key (always a uint32), and the second entry is the value. The; state of each bucket (valid, empty, deleted) can be determined by examining; the present and deleted bit vectors. .. _hash_bit_vectors:. Present and Deleted Bit Vectors; ==============================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/HashTable.rst:1540,hash,hash,1540,interpreter/llvm-project/llvm/docs/PDB/HashTable.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/HashTable.rst,1,['hash'],['hash']
Security," legal for Clang, error for GCC:; typedef bool bool4 __attribute__((ext_vector_type(4)));; // Objects of bool4 type hold 8 bits, sizeof(bool4) == 1. bool4 foo(bool4 a) {; bool4 v;; v = a;; return v;; }. Boolean vectors are a Clang extension of the ext vector type. Boolean vectors; are intended, though not guaranteed, to map to vector mask registers. The size; parameter of a boolean vector type is the number of bits in the vector. The; boolean vector is dense and each bit in the boolean vector is one vector; element. The semantics of boolean vectors borrows from C bit-fields with the following; differences:. * Distinct boolean vectors are always distinct memory objects (there is no; packing).; * Only the operators `?:`, `!`, `~`, `|`, `&`, `^` and comparison are allowed on; boolean vectors.; * Casting a scalar bool value to a boolean vector type means broadcasting the; scalar value onto all lanes (same as general ext_vector_type).; * It is not possible to access or swizzle elements of a boolean vector; (different than general ext_vector_type). The size and alignment are both the number of bits rounded up to the next power; of two, but the alignment is at most the maximum vector alignment of the; target. Vector Literals; ---------------. Vector literals can be used to create vectors from a set of scalars, or; vectors. Either parentheses or braces form can be used. In the parentheses; form the number of literal values specified must be one, i.e. referring to a; scalar value, or must match the size of the vector type being created. If a; single scalar literal value is specified, the scalar literal value will be; replicated to all the components of the vector type. In the brackets form any; number of literals can be specified. For example:. .. code-block:: c++. typedef int v4si __attribute__((__vector_size__(16)));; typedef float float4 __attribute__((ext_vector_type(4)));; typedef float float2 __attribute__((ext_vector_type(2)));. v4si vsi = (v4si){1, 2, 3, 4};; float4 v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:17528,access,access,17528,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security," less than 100 bins per axis),; sparsely populated TH2 will render faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis) that are; not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of; magnitude faster with the COL2 option. The COL2 option will also scale its performance based on the size of the pixmap; the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: inst",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:23108,access,access,23108,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['access'],['access']
Security," less than the size of `fClosestDistance`, and will draw; `fMatrix[i]+0` for the other value of `i`. 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four special variables; giving some indications of the state of the loops implied by the; formula:. `Entry$ :` return the current entry number (`TTree::GetReadEntry()`). `Entries$ :` return the total number of entries (`TTree::GetEntries()`). `Length$ :` return the total number of element of this formula for; this entry. `Iteration$:` return the current iteration over this formula for this; entry (i.e. varies from 0 to `Length$`). 43. **`tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");`**. **`TRef`** and **`TRefArray`** are automatically deferenced and this; shows the value of the `fPx` of the track referenced by `fLastTrack`. To; access the **`TRef`** object itself use the '`@`' notation (see next; example). This auto dereferencing can be extended (via an implementation; of **`TVirtualRefProxy`**) to any reference type. 44. **`tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");`**. Will cast the return value of `GetObject()` (which happens to be; **`TObject*`** in this case) before requesting the `GetPx()` member; functions. 45. **`tree->Draw(""This->GetReadEntry()"");`**. You can refer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:92586,access,access,92586,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security," libraries (or sets of libraries) a warning is issued.; A typical Rootmap file look like:; ``` {.cpp}; { decls }; fwd declaration 1;; fwd declaration 2;; [...]; fwd declaration N;. [ libraryName1 libraryName2 ... ]; class className1; class className2; ...; typedef typedefName1; typedef typedefName2; ...; header headerName1; header headerName2; ... ```. ### TROOT. The list returned by `GetListOfTypes` is no longer filled when the dictionary; are loaded but instead are filled on demand, when the user explicitly (directly; or indirectly) request each typedef. In particular this means that. ``` {.cpp}; gROOT->GetListOfTypes()->ls(); // or Print(); ```. no longer prints the list of all available typedef but instead list only the; typedefs that have been previously accessed throught the list (plus the builtins; types). ### ACliC. ACLiC has the following backward incompatibilities:. - Since rootcling no longer re-\#defines the private and protected; keyword to public, the code compiled by ACLIC no longer has access; to protected and private members of a class (except where allowed by; the C++ standard). ### Collection. New collection `TListOfTypes` that implements on demand creation; of the `TDataType` describing a typedef. ### TUnixSystem. - Simplify `Setenv` coding.; - Implement `Unsetenv` using the system function `unsetenv`. ### TMacOSXSystem. - The file descriptors' management improved/fixed. ### TColor. - 5 new predefined palettes with 255 colors are available vis; `gStyle->SetPalette(n)`:. - n = 51 a Deep Sea palette is used.; - n = 52 a Grey Scale palette is used.; - n = 53 a Dark Body Radiator palette is used.; - n = 54 a two-color hue palette palette is used.(dark blue; through neutral gray to bright yellow); - n = 55 a Rain Bow palette is used. ![New 255 colors palettes](pal255.png). - Add the optional parameter ""alpha"" to `TColor::SetPalette` and; `TStyle::SetPalette`. The default value is 1. (opaque palette). Any; value between 0. and 1 define the level of tran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:11299,access,access,11299,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['access'],['access']
Security," long unless there are critical issues remaining. In most cases, the only; kind of bugs that are critical enough to block a release would be a major regression; from a previous release. Official Testing; ----------------. A few developers in the community have dedicated time to validate the release; candidates and volunteered to be the official release testers for each; architecture. These will be the ones testing, generating and uploading the official binaries; to the server, and will be the minimum tests *necessary* for the release to; proceed. This will obviously not cover all OSs and distributions, so additional community; validation is important. However, if community input is not reached before the; release is out, all bugs reported will have to go on the next stable release. The official release managers are:. * Even releases: Tom Stellard (tstellar@redhat.com); * Odd releases: Tobias Hieta (tobias@hieta.se). The official release testers are volunteered from the community and have; consistently validated and released binaries for their targets/OSs. To contact; them, you should post on the `Discourse forums (Project; Infrastructure - Release Testers). <https://discourse.llvm.org/c/infrastructure/release-testers/66>`_. The official testers list is in the file ``RELEASE_TESTERS.TXT``, in the ``LLVM``; repository. Community Testing; -----------------. Once all testing has been completed and appropriate bugs filed, the release; candidate tarballs are put on the website and the LLVM community is notified. We ask that all LLVM developers test the release in any the following ways:. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build LLVM. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the ``clang`` sources. Compile; everything. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:7609,validat,validated,7609,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['validat'],['validated']
Security," map-like types such as `std::map` as parameters, for example the [RooCategory constructor](https://root.cern/doc/v626/classRooCategory.html#ae63ae78231765d184b7a839c74746a49). In the past, you had to create the correct C++ class in Python, but now you can usually pass a Python dictionary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arrays with histogram counts and bin edges (static method); - `RooDataHist.to_numpy`: Export a RooDataHist to numpy arrays with histogram cou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22342,access,access,22342,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['access'],['access']
Security," matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4604,access,access,4604,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['access'],['access']
Security," may be smaller than the size of a; ``DW_ASPACE_AMDGPU_private_wave`` address. .. _amdgpu-dwarf-lane-identifier:. Lane identifier; ---------------. DWARF lane identifies specify a target architecture lane position for hardware; that executes in a SIMD or SIMT manner, and on which a source language maps its; threads of execution onto those lanes. The DWARF lane identifier is pushed by; the ``DW_OP_LLVM_push_lane`` DWARF expression operation. See DWARF Version 5; section 2.5 which is updated by *DWARF Extensions For Heterogeneous Debugging*; section :ref:`amdgpu-dwarf-operation-expressions`. For AMDGPU, the lane identifier corresponds to the hardware lane ID of a; wavefront. It is numbered from 0 to the wavefront size minus 1. Operation Expressions; ---------------------. DWARF expressions are used to compute program values and the locations of; program objects. See DWARF Version 5 section 2.5 and; :ref:`amdgpu-dwarf-operation-expressions`. DWARF location descriptions describe how to access storage which includes memory; and registers. When accessing storage on AMDGPU, bytes are ordered with least; significant bytes first, and bits are ordered within bytes with least; significant bits first. For AMDGPU CFI expressions, ``DW_OP_LLVM_select_bit_piece`` is used to describe; unwinding vector registers that are spilled under the execution mask to memory:; the zero-single location description is the vector register, and the one-single; location description is the spilled memory location description. The; ``DW_OP_LLVM_form_aspace_address`` is used to specify the address space of the; memory location description. In AMDGPU expressions, ``DW_OP_LLVM_select_bit_piece`` is used by the; ``DW_AT_LLVM_lane_pc`` attribute expression where divergent control flow is; controlled by the execution mask. An undefined location description together; with ``DW_OP_LLVM_extend`` is used to indicate the lane was not active on entry; to the subprogram. See :ref:`amdgpu-dwarf-dw-at-llvm-lane-pc` f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:98610,access,access,98610,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," member ``m_int``:. .. code-block:: python. >>> c.m_int, d.m_int; (42, 13); >>>. Note however, that the data members are typed: setting them results in a; memory write on the C++ side.; This is different in Python, where references are replaced, and thus any; type will do:. .. code-block:: python. >>> c.m_int = 3.14 # a float does not fit in an int; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: int/long conversion expects an integer object; >>> c.m_int = int(3.14); >>> c.m_int, d.m_int; (3, 13); >>>. Private and protected data members are not accessible, contrary to Python; data members, and C++ const-ness is respected:. .. code-block:: python. >>> c.m_const_int = 71 # declared 'const int' in class definition; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: assignment to const data not allowed; >>>. Static C++ data members act like Python class-level data members.; They are also represented by property objects and both read and write access; behave as expected:. .. code-block:: python. >>> Concrete.s_int # access through class; 321; >>> c.s_int = 123 # access through instance; >>> Concrete.s_int; 123. .. _sec-operators-label:. `Structs/Unions`; ----------------. Structs and unions are both supported, named or anonymous.; If the latter, the field are accessible through the parent scope by their; declared name.; For example:. .. code-block:: python. >>> cppyy.cppdef(""""""\; ... struct PointXYZ {; ... PointXYZI() : intensity(5.) {}; ... double x, y, z;; ... union {; ... int offset1;; ... struct {; ... int offset2;; ... float intensity;; ... };; ... float data_c[4];; ... };; ... };""""""); True; >>> p = cppyy.gbl.PointXYZI(); >>> type(p.x); <class 'float'>; >>> p.intensity; 5.0; >>> type(p.data_c[1]); <class 'float'>; >>> p.data_c[1] = 3.0; >>> p.intensity; 3.0; >>>. `Operators`; -----------. Many C++ operators can be mapped to their Python equivalent.; When the operators are part of the C++ class defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:8782,access,access,8782,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['access'],['access']
Security," members are typed: setting them results in a; memory write on the C++ side.; This is different in Python, where references are replaced, and thus any; type will do:. .. code-block:: python. >>> c.m_int = 3.14 # a float does not fit in an int; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: int/long conversion expects an integer object; >>> c.m_int = int(3.14); >>> c.m_int, d.m_int; (3, 13); >>>. Private and protected data members are not accessible, contrary to Python; data members, and C++ const-ness is respected:. .. code-block:: python. >>> c.m_const_int = 71 # declared 'const int' in class definition; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: assignment to const data not allowed; >>>. Static C++ data members act like Python class-level data members.; They are also represented by property objects and both read and write access; behave as expected:. .. code-block:: python. >>> Concrete.s_int # access through class; 321; >>> c.s_int = 123 # access through instance; >>> Concrete.s_int; 123. .. _sec-operators-label:. `Structs/Unions`; ----------------. Structs and unions are both supported, named or anonymous.; If the latter, the field are accessible through the parent scope by their; declared name.; For example:. .. code-block:: python. >>> cppyy.cppdef(""""""\; ... struct PointXYZ {; ... PointXYZI() : intensity(5.) {}; ... double x, y, z;; ... union {; ... int offset1;; ... struct {; ... int offset2;; ... float intensity;; ... };; ... float data_c[4];; ... };; ... };""""""); True; >>> p = cppyy.gbl.PointXYZI(); >>> type(p.x); <class 'float'>; >>> p.intensity; 5.0; >>> type(p.data_c[1]); <class 'float'>; >>> p.data_c[1] = 3.0; >>> p.intensity; 3.0; >>>. `Operators`; -----------. Many C++ operators can be mapped to their Python equivalent.; When the operators are part of the C++ class definition, this is done; directly.; If they are defined globally, the lookup is done lazily (ie. can resolve; af",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:8856,access,access,8856,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['access'],['access']
Security," memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and Samplers; ~~~~~~~~~~~~~~~~~~. Image and sample handles created by an HSA compatible runtime (see; :ref:`amdgpu-os`) are 64-bit addresses of a hardware 32-byt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155821,access,access,155821,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," merge, and fork locally without touching the remote server.; * Maintain local branches, enabling multiple threads of development.; * Collaborate on these branches (e.g. through your own fork of llvm on GitHub).; * Inspect the repository history (blame, log, bisect) without Internet access.; * Maintain remote forks and branches on Git hosting services and; integrate back to the main repository. In addition, because Git seems to be replacing many OSS projects' version; control systems, there are many tools that are built over Git.; Future tooling may support Git first (if not only). Why GitHub?; -----------. GitHub, like GitLab and BitBucket, provides free code hosting for open source; projects. Any of these could replace the code-hosting infrastructure that we; have today. These services also have a dedicated team to monitor, migrate, improve and; distribute the contents of the repositories depending on region and load. GitHub has one important advantage over GitLab and; BitBucket: it offers read-write **SVN** access to the repository; (https://github.com/blog/626-announcing-svn-support).; This would enable people to continue working post-migration as though our code; were still canonically in an SVN repository. In addition, there are already multiple LLVM mirrors on GitHub, indicating that; part of our community has already settled there. On Managing Revision Numbers with Git; -------------------------------------. The current SVN repository hosts all the LLVM sub-projects alongside each other.; A single revision number (e.g. r123456) thus identifies a consistent version of; all LLVM sub-projects. Git does not use sequential integer revision number but instead uses a hash to; identify each commit. The loss of a sequential integer revision number has been a sticking point in; past discussions about Git:. - ""The 'branch' I most care about is mainline, and losing the ability to say; 'fixed in r1234' (with some sort of monotonically increasing number) would; be a tragic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:3568,access,access,3568,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['access'],['access']
Security," merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger is used by the `TFileMerger` and thus provides RNTuple merge support in `hadd` and `TBufferMerger`. ### RNTupleImporter; The RNTupleImporter creates RNTuple data sets from ROOT trees.; It is part of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e.g. the distribution of data volume wrt. column types.; It is part of the `ROOTNTupleUtil` library. Ownership Model; ---------------. By default, objects involved in RNTuple I/O (objects read from disk or written to disk) are passed to RNTuple as shared pointers.; Both RNTuple or the application may create the object.; Raw pointers to objects can be passed to RNTuple -- such objects are considered as owned by the application.; The caller has to ensure that the lifetime of the object lasts during the I/O operations. An RNTuple writer that is constructed without a `TFile` object (`RNTupleWriter::Recreate()`) assumes exclusive access to the underlying file.; An RNTuple writer that uses a `TFile` for writing (`RNTupleWriter::Append()`) assumes that the `TFile` object outlives the writer's lifetime.; The serial writer assumes exclusive access to the underlying file during construction, destruction and `Fill()` as well as `CommitCluster()` and `FlushCluster()`.; For `FlushColumns()` and `FillNoFlush()`, the sequential writer assumes exclusive access only if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:17610,access,access,17610,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security," modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22065,hash,hash,22065,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,['hash'],"['hash', 'hash-table']"
Security," multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313080,access,access,313080,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311791,access,access,311791,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:61217,access,accessed,61217,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['accessed']
Security," need to feed some distilled form of the contextual information to those; processes. An example of a type identifier is ``sancov``, for dumps from LLVM; `SanitizerCoverage <https://clang.llvm.org/docs/SanitizerCoverage.html>`_. Example::. {{{dumpfile:sancov:sancov.8675}}}. Contextual elements; ===================. These are elements that supply information necessary to convert presentation; elements to symbolic form. Unlike presentation elements, they are not directly; related to the surrounding text. Contextual elements should appear alone on; lines with no other non-whitespace text, so that the symbolizing filter might; elide the whole line from its output without hiding any other log text. The contextual elements themselves do not necessarily need to be presented in; human-readable output. However, the information they impart may be essential to; understanding the logging text even after symbolization. So it's recommended; that this information be preserved in some form when the original raw log with; markup may no longer be readily accessible for whatever reason. Contextual elements should appear in the logging stream before they are needed.; That is, if some piece of context may affect how the symbolizing filter would; interpret or present a later presentation element, the necessary contextual; elements should have appeared somewhere earlier in the logging stream. It should; always be possible for the symbolizing filter to be implemented as a single pass; over the raw logging stream, accumulating context and massaging text as it goes. ``{{{reset}}}``. This should be output before any other contextual element. The need for this; contextual element is to support implementations that handle logs coming from; multiple processes. Such implementations might not know when a new process; starts or ends. Because some identifying information (like process IDs) might; be the same between old and new processes, a way is needed to distinguish two; processes with such identic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:17722,access,accessible,17722,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['access'],['accessible']
Security," new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. One should specify sub-folder name, where objects will be registered.; If sub-folder name does not starts with slash `/`, than top-name folder `/Objects/` will be prepended.; At any time one could unregister objects:. ```cpp; serv->Unregister(gr);; ```. THttpServer does not take ownership over registered objects - they should be deleted by user. If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4457,access,accessed,4457,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['accessed']
Security," no appreciable difference in wall clock time to JIT a; trace using Numba's included math functions (from module ``math`` or; ``numpy``) or one that uses C++ bound ones whether from the standard library; or a templated versions from e.g. Eigen.; Use of very complex template expressions may change this balance, but in; principle, wherever it makes sense in the first place to use Numba JITing, it; is also fine, performance-wise, to use ``cppyy`` bound C++ inside the trace. A second important overhead is in unboxing Python proxies of C++ objects,; in particular when passed as an argument to a Numba-JITed function.; The main costs are in the lookup (types are matched at every invocation) and; to a lesser extent the subsequent copying of the instance data.; Thus, functions that take a C++ object as an argument will require more time; spent in the function body for JITing to be worth it than functions that do; not. The current implementation invokes C++ callables through function pointers; and accesses data through offsets calculations from the object's base; address.; A future implementation may be able to inline C++ into the Numba trace if; code is available in headers files or was JITed. Further Information; -------------------. - Numba documentation:; `numba.readthedocs.io <https://numba.readthedocs.io/en/stable/user/index.html>`_. - ""Using C++ From Numba, Fast and Automatic"", presented at `PyHEP 2022 <https://compiler-research.org/presentations/#CppyyNumbaPyHEP2022>`_. - `PyHEP 2022 video <https://www.youtube.com/watch?v=RceFPtB4m1I>`_; - `PyHEP 2022 slides <https://compiler-research.org/assets/presentations/B_Kundu-PyHEP22_Cppyy_Numba.pdf>`_; - `PyHEP 2022 notebook <https://github.com/sudo-panda/PyHEP-2022>`_. - Presentation at CERN's ROOT Parallelism, Performance and Programming Model; (`PPP <https://indico.cern.ch/event/1196174/>`_) Meeting. - `PPP slides <https://indico.cern.ch/event/1196174/contributions/5028203/attachments/2501253/4296778/PPP.pdf>`_; - `PPP not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:10730,access,accesses,10730,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['access'],['accesses']
Security," not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; har",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15136,secur,security,15136,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security," object. This; is useful in particular in roottest. Use this in hadd; and TFileMerger. TROOT. New routine CloseFiles used automatically shortly before termination to ; insure closing of files and sockets before the unload of any library.; New collection 'ClosedObjects' holding pointers to TFile or TSocket that; have been closed but not deleted it. In the case of TSocket, they are added only; if they are closed by the CloseFiles.; Add a Close member function to TProofMgr since it is added to the list of socket.; Migrate the closing of files from various to a single place (T*System::Exit).; Fill in the implementation of TROOT::FindObjectAnyFile.; Mark TROOT as TObject::kInvalidObject as soon as its destructor starts,; in order to be able to veto some action later on (like autoloading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:1447,access,accessors,1447,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,2,['access'],['accessors']
Security," object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtone",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11668,access,accessed,11668,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['access'],['accessed']
Security," of **`TObject`** derived classes can be stored; in ROOT containers. However, the **`TObject`** class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9337,hash,hash,9337,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['hash'],['hash']
Security," of a; polymorphic class type. This CFI scheme can be enabled on its own using; ``-fsanitize=cfi-nvcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. .. _cfi-strictness:. Strictness; ----------. If a class has a single non-virtual base and does not introduce or override; virtual member functions or fields other than an implicitly defined virtual; destructor, it will have the same layout and virtual function semantics as; its base. By default, casts to such classes are checked as if they were made; to the least derived such class. Casting an instance of a base class to such a derived class is technically; undefined behavior, but it is a relatively common hack for introducing; member functions on class instances with specific properties that works under; most compilers and should not have security implications, so we allow it by; default. It can be disabled with ``-fsanitize=cfi-cast-strict``. Indirect Function Call Checking; ===============================. This scheme checks that function calls take place using a function of the; correct dynamic type; that is, the dynamic type of the function must match; the static type used at the call. This CFI scheme can be enabled on its own; using ``-fsanitize=cfi-icall``. For this scheme to work, each indirect function call in the program, other; than calls in :ref:`ignored <cfi-ignorelist>` functions, must call a; function which was either compiled with ``-fsanitize=cfi-icall`` enabled,; or whose address was taken by a function in a translation unit compiled with; ``-fsanitize=cfi-icall``. If a function in a translation unit compiled with ``-fsanitize=cfi-icall``; takes the address of a function not compiled with ``-fsaniti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:8527,secur,security,8527,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['secur'],['security']
Security," of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67047,access,access,67047,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security," of the cases. They provide a buffered input; data and an address of the in-memory target object and allow user to specify the; conversion function mapping the data being read to the output format. The second type; of the rules, the raw rules, also provide the pointer to the target object but the; input is a raw TBuffer object containing the input data member declared as an input; to the rule. This type of a rule is provided mainly to handle the file format changes; that couldn't have been handled otherwise and in general should not be used unless there; is no other option. #### The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either in a LinkDef file or in the selection xml file being fed to genreflex.; The syntax of the rules is the following:. - For dictionaries created from a LinkDef file:. ``` {.cpp}; #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:78420,checksum,checksum,78420,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['checksum'],['checksum']
Security," of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77819,sanitiz,sanitize-trap,77819,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-trap']
Security," on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another point",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:141394,access,access,141394,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security," operand modifiers), this is lowered; into v_dot4c_i32_i8 for targets which support it.; RDNA3 does not offer v_dot4_i32_i8, and rather offers; v_dot4_i32_iu8 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sdot8 Provides direct access to v_dot8_u32_u4 across targets which; support such instructions. This performs signed dot product; with two i32 operands (holding a vector of 8 4bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output.; When applicable (i.e. no clamping / operand modifiers), this is lowered; into v_dot8c_i32_i4 for targets which support it.; RDNA3 does not offer v_dot8_i32_i4, and rather offers; v_dot4_i32_iu4 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sudot4 Provides direct access to v_dot4_i32_iu8 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 4 8bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sudot8 Provides direct access to v_dot8_i32_iu4 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 8 4bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sched_barrier Controls the types of instructions that may be allowed to cross the intrinsic; during instruction scheduling. The parameter is a mask for the instruction types; that can cross the intrinsic. - 0x0000: No instructions may be scheduled across sched_barrier.; - 0x0001: All, non-memory, non-side-effect producing instructions may be; scheduled across sched_barrier, *i.e.* allow ALU instructions to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:41646,access,access,41646,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security," operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_ORDERED_PS_DONE 7 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_GET_DOORBELL 10 \- \- \-; MSG_GET_DDID 11 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_GS, GS_OP_EMIT); s_sendmsg sendmsg(MSG_GS, 2); s_sendmsg sendmsg(MSG_GS_DONE, GS_OP_EMIT_CUT, 1); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC); s_sendmsg sendmsg(MSG_GET_DOORBELL). // sendmsg with validation of value range only; msg = 2; op = 3; stream = 1; s_sendmsg sendmsg(msg, op, stream); s_sendmsg sendmsg(2, GS_OP_CUT); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst:2720,validat,validated,2720,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,6,['validat'],"['validated', 'validation']"
Security," optimal number) do.                     ; proof->SetParameter(""PROOF_UseMergers"", S). The new functionality can be tested in tutorials by adding the argument; 'submergers' to runProof, e.g. .        ;        ;      root [0] .L; tutorials/proof/runProof.C+ ;        ;        ;      root [1]; runProof(""simple(nhist=10000,submergers)"") . (see the top of tutorials/proof/runProof.C for additional options). A test for the submerger functionality has also been added to; test/stressProof.cxx .; In PROOF-Lite, add the possibility for the administrator; to control the number of workers. This is done using; the rootrc variable ProofLite.MaxWorkers, which is read out of; /etc/system.rootrc and cannot be overwritten by users. Setting the; value to 0 disables PROOF-Lite. Improvements. TFileMerger. A few improvements on the way to make TFileMerger and; hadd totally equivalent:. import from hadd an optimization of key hashing; import from hadd a better way to invoke Merge for; generic objects; add option to merge histograms in one go, instead of; one-by-one as for generic objects (this option is not yet supported by; hadd). TProofOutputFile. Add support for the placeholder <file>; the definition of the outputfile. This allows to have complete URL and; to pass options to TFile::Open. XrdProofd plugin. Add automatically the line 'Path.ForceRemote 1' to the; session rootrc file if the ROOT version is < 5.24/00 ; this acts; as a workaround for the wrong TTreeCache initialization at the; transition between local and remote files fixed in 5.24/00 . Enable mass storage domain settings when working with; TChain's; in multi-master mode. The Mass Storage Domain must be specified as; option in the URL.              ; chain.AddFile(""root:// .....?msd=CERN"").  and the string must match the value specified in defining the; submaster node.; Improved performance monitoring: the 'Rate plot' button; in the dialog box has been renamed 'Performance Plot' and now shows up; to 4 plots as a function of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:3679,hash,hashing,3679,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,['hash'],['hashing']
Security," option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69302,access,access,69302,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['access'],['access']
Security," optional sequence; of non-ownership qualifiers; or; * the conversion is requested with a ``reinterpret_cast`` in Objective-C++; or; * the conversion is a well-formed :ref:`pass-by-writeback; <arc.ownership.restrictions.pass_by_writeback>`. The analogous rule applies to ``T&`` and ``U&`` in Objective-C++. .. admonition:: Rationale. These rules provide a reasonable level of type-safety for indirect pointers,; as long as the underlying memory is not deallocated. The conversion to; ``const __unsafe_unretained`` is permitted because the semantics of reads are; equivalent across all these ownership semantics, and that's a very useful and; common pattern. The interconversion with ``void*`` is useful for allocating; memory or otherwise escaping the type system, but use it carefully.; ``reinterpret_cast`` is considered to be an obvious enough sign of taking; responsibility for any problems. It is undefined behavior to access an ownership-qualified object through an; lvalue of a differently-qualified type, except that any non-``__weak`` object; may be read through an ``__unsafe_unretained`` lvalue. It is undefined behavior if the storage of a ``__strong`` or ``__weak``; object is not properly initialized before the first managed operation; is performed on the object, or if the storage of such an object is freed; or reused before the object has been properly deinitialized. Storage for; a ``__strong`` or ``__weak`` object may be properly initialized by filling; it with the representation of a null pointer, e.g. by acquiring the memory; with ``calloc`` or using ``bzero`` to zero it out. A ``__strong`` or; ``__weak`` object may be properly deinitialized by assigning a null pointer; into it. A ``__strong`` object may also be properly initialized; by copying into it (e.g. with ``memcpy``) the representation of a; different ``__strong`` object whose storage has been properly initialized;; doing this properly deinitializes the source object and causes its storage; to no longer be pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:44828,access,access,44828,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['access']
Security," parsed-literal::. print __coro_frame. Just as printing the `promise_type` is possible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5790,access,accessible,5790,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['access'],['accessible']
Security, phase 1 and 2 transformations in raw string literals; Unknown. 1104; C++11; Global-scope template arguments vs the <: digraph; Unknown. 1105; C++11; Issues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74061,access,access,74061,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security," pipeline. Modifications; of the current function are outside the scope of the intrinsic. '``llvm.instrprof.increment``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. These will be; lowered by the ``-instrprof`` pass to generate execution counts of a; program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source, and; the third is the number of counters associated with ``name``. It is an; error if ``hash`` or ``num-counters`` differ between two instances of; ``instrprof.increment`` that refer to the same name. The last argument refers to which of the counters for ``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment.step(ptr <name>, i64 <hash>,; i32 <num-counters>,; i32 <index>, i64 <step>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment.step``' intrinsic is an extension to; the '``llvm.instrprof.increment``' intrinsic with an additional fifth; argument to specify the step of the increment. Argum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:527671,hash,hash,527671,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security," proxy docu](https://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html).; After restarting apache server one should be able to open address: `http://apache_host_name/root.app/`.; There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:. ```; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; ```. ### Configure fastcgi with lighttpd. An example of configuration file for **lighttpd** server is:. ```; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); ```. Be aware, that with *lighttpd* one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: `http://lighttpd_host_name/root.app/`. Example of authorization configuration for FastCGI connection:. auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658daf379e87a4832fe9dc5c1483ed) call. Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the `gSystem->ProcessEvents()` call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session. If an application runs in compiled code and does not contain `gSystem->ProcessEvents()` cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:12409,authoriz,authorization,12409,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['authoriz'],['authorization']
Security," purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21293,hash,hash,21293,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['hash'],['hash']
Security," put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56954,access,access,56954,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security," rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium issue tracker: https://crbug.com; .. _GitHub security: https://help.github.com/en/articles/about-maintainer-security-advisories; .. _Discourse forums: https://discourse.llvm.org; .. _MITRE: https://cve.mitre.org; .. _example nomination is available here: https://reviews.llvm.org/D99232; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15674,secur,security,15674,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,['secur'],"['security', 'security-sensitive']"
Security," reproducer can not be shared for some reason (e.g.; requires hardware patch author doesn't have access to, sharp regression in; compile time of internal workload, etc.), the reverter is expected to be; proactive about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the author a bit to; respond, and then proceed with the revert if the author doesn't seem to be; actively responding.; * When re-applying a reverted patch, the commit message should be updated to; indicate the problem that was addressed and how it was addressed. Obtaining Commit Access; -----------------------. We grant commit access to contributors with a track record of submitting high; quality patches. If you would like commit access, please send an email to; `Chris <mailto:clattner@llvm.org>`_ with your GitHub username. This is true; for former contributors with SVN access as well as new contributors. If; approved, a GitHub invitation will be sent to your GitHub account. In case you; don't get notification from GitHub, go to; `Invitation Link <https://github.com/orgs/llvm/invitation>`_ directly. Once; accept the invitation, you'll get commit access. Prior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on a commits mailing list soon after the commit lands (e.g. llvm-commits_).; Note that these mailing lists are moderated, and it is not unusual for a large; commit to requi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:23001,access,access,23001,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['access'],['access']
Security," resolve symbols in the target. RuntimeDyld; -----------. In order to keep RuntimeDyld's implementation simple MCJIT imposed some; restrictions on compiled code:. #. It had to use the Large code model, and often restricted available relocation; models in order to limit the kinds of relocations that had to be supported. #. It required strong linkage and default visibility on all symbols -- behavior; for other linkages/visibilities was not well defined. #. It constrained and/or prohibited the use of features requiring runtime; support, e.g. static initializers or thread local storage. As a result of these restrictions not all language features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not access RuntimeDyld's; internal object representations. Eliminating these restrictions and limitations was one of the primary motivations; for the development of JITLink. The llvm-jitlink tool; =====================. The ``llvm-jitlink`` tool is a command line wrapper for the JITLink library.; It loads some set of relocatable object files and then links them using; JITLink. Depending on the options used it will then execute them, or validate; the linked memory. The ``llvm-jitlink`` tool was originally designed to aid JITLink development by; providing a simple environment for testing. Basic usage; -----------. By default, ``llvm-jitlink`` will link the set of objects passed on the command; line, then search for a ""main"" function and execute it:. .. code-block:: sh. % cat hello-world.c; #include <stdio.h>. int main(int argc, char *argv[]) {; printf(""hello, world!\n"");; return 0;; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:36590,access,access,36590,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,2,['access'],['access']
Security," resolving.; Examples of reasons for resolving are:. * If the issue has been resolved by a particular commit, close the issue with; a brief comment mentioning which commit(s) fixed it. If you are authoring; the fix yourself, your git commit message may include the phrase; ``Fixes #<issue number>`` on a line by itself. GitHub recognizes such commit; messages and will automatically close the specified issue with a reference; to your commit. * If the reported behavior is not a bug, it is appropriate to close the issue; with a comment explaining why you believe it is not a bug, and adding the; ``invalid`` tag. * If the bug duplicates another issue, close it as a duplicate by adding the; ``duplicate`` label with a comment pointing to the issue it duplicates. * If there is a sound reason for not fixing the issue (difficulty, ABI, open; research questions, etc), add the ``wontfix`` label and a comment explaining; why no changes are expected. * If there is a specific and plausible reason to think that a given bug is; otherwise inapplicable or obsolete. One example is an open bug that doesn't; contain enough information to clearly understand the problem being reported; (e.g. not reproducible). It is fine to close such a bug, adding with the; ``worksforme`` label and leaving a comment to encourage the reporter to; reopen the bug with more information if it's still reproducible for them. .. _Maintenance of metadata:. Maintenance of metadata; =======================. Project member with write access to the project can create new labels, but we; discourage adding ad hoc labels because we want to control the proliferation of; labels and avoid single-use labels. If you would like a new label added, please; open an issue asking to create an issue label and add the ``infrastructure``; label to the issue. The request should include a description of what the label; is for. Alternatively, you can ask for the label to be created on the; ``#infrastructure`` channel on the LLVM Discord.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:5256,access,access,5256,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['access'],['access']
Security," restrictions translate to certain responsibilities for you if you; distribute copies of the software, or if you modify it. For example, if you distribute copies of such a program, whether; gratis or for a fee, you must give the recipients all the rights that; you have. You must make sure that they, too, receive or can get the; source code. And you must show them these terms so they know their; rights. We protect your rights with two steps: (1) copyright the software, and; (2) offer you this license which gives you legal permission to copy,; distribute and/or modify the software. Also, for each author's protection and ours, we want to make certain; that everyone understands that there is no warranty for this free; software. If the software is modified by someone else and passed on, we; want its recipients to know that what they have is not the original, so; that any problems introduced by others will not reflect on the original; authors' reputations. Finally, any free program is threatened constantly by software; patents. We wish to avoid the danger that redistributors of a free; program will individually obtain patent licenses, in effect making the; program proprietary. To prevent this, we have made it clear that any; patent must be licensed for everyone's free use or not licensed at all. The precise terms and conditions for copying, distribution and; modification follow. GNU GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License applies to any program or other work which contains; a notice placed by the copyright holder saying it may be distributed; under the terms of this General Public License. The ""Program"", below,; refers to any such program or work, and a ""work based on the Program""; means either the Program or any derivative work under copyright law:; that is to say, a work containing the Program or a portion of it,; either verbatim or with modifications and/or translated into another; language. (Hereinafter, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:2417,threat,threatened,2417,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,4,['threat'],['threatened']
Security," result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,; i32 gep_index,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic returns the getelementptr address; based on struct base ``base`` and IR struct member index ``gep_index``.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide struct debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``ret_type`` is a pointer type to the structure member. Arguments:; """""""""""""""""""". The ``base`` is the structure base address. The ``gep_index`` is the struct member index; based on IR structures. The ``di_index`` is the struct member index based on debuginfo. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:974876,access,access,974876,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," return; type must match the argument type. .. _int_memcpy:. '``llvm.memcpy``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memcpy`` on any; integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memcpy.p0.p0.i32(ptr <dest>, ptr <src>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memcpy.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the; source location to the destination location. Note that, unlike the standard libc function, the ``llvm.memcpy.*``; intrinsics do not return a value, takes extra isvolatile; arguments and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is an integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source; location to the destination location, which must either be equal or; non-overlapping. It copies ""len"" bytes of memory over. If the argument is known; to be aligned to some boundary, this can be specified as an attribute on the; argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be well-defined,; otherwise the behavior is undefined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:547656,access,access,547656,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," right by at least the number of original bits using the BMI2; `shrx` instruction:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; addl (%rsi), %edi # Load and accumulate 32 bits of data.; shrxq %rax, %rdi, %rdi # Shift out all 32 bits loaded.; ```. Because on x86 the zero-extend is free, this can efficiently harden the loaded; value. ##### Hardening the address of the load. When hardening the loaded value is inapplicable, most often because the; instruction directly leaks information (like `cmp` or `jmpq`), we switch to; hardening the _address_ of the load instead of the loaded value. This avoids; increasing register pressure by unfolding the load or paying some other high; cost. To understand how this works in practice, we need to examine the exact; semantics of the x86 addressing modes which, in its fully general form, looks; like `(%base,%index,scale)offset`. Here `%base` and `%index` are 64-bit; registers that can potentially be any value, and may be attacker controlled,; and `scale` and `offset` are fixed immediate values. `scale` must be `1`, `2`,; `4`, or `8`, and `offset` can be any 32-bit sign extended value. The exact; computation performed to find the address is then: `%base + (scale * %index) +; offset` under 64-bit 2's complement modular arithmetic. One issue with this approach is that, after hardening, the `%base + (scale *; %index)` subexpression will compute a value near zero (`-1 + (scale * -1)`) and; then a large, positive `offset` will index into memory within the first two; gigabytes of address space. While these offsets are not attacker controlled,; the attacker could chose to attack a load which happens to have the desired; offset and then successfully read memory in that region. This significantly; raises the burden on the attacker and limits the scope of attack but does not; eliminate it. To fully close the attack we must work with the operating system; to preclude mapping memory in the low two gigabyt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:28124,attack,attacker,28124,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacker']
Security," should be able to reduce; this with :program:`llvm-reduce`; command line (use the bc file corresponding to the command above that failed):. .. code-block:: bash. llvm-reduce --test reduce.sh a.out.0.2.internalize.bc. Example of reduce.sh script. .. code-block:: bash. $ cat reduce.sh; #!/bin/bash -e. path/to/not --crash path/to/opt ""-passes=lto<O3>"" $1 -o temp.bc 2> err.log; grep -q ""It->second == &Insn"" err.log. Here we have grepped the failed assert message. Please run this, then file a bug with the instructions and reduced .bc file; that llvm-reduce emits. .. _miscompiling:. Miscompilations; ===============. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization passes. Incorrect code generation; =========================. Similarly to debugging incorrect compilation by mis-behaving passes, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:8355,sanitiz,sanitizers,8355,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['sanitiz'],['sanitizers']
Security," should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist betwee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310664,access,access,310664,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," size; of the covariance matrix is according to the number of variable; parameters (free and limited). ### MnUserCovariance(const std::vector$<$double$>$&, unsigned int nrow) ###. Construct from data, positions of the elements in the array are arranged; according to the packed storage format. The size of the array must be; $nrow*(nrow+1)/2$. The array must contain the upper triangular part of; the symmetric matrix packed sequentially, column by column, so that; arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and; covar(1,1) respectively, and so on. The number of rows (columns) has to; be specified. ### MnUserCovariance(unsigned int nrow) ###. Specify the number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## MnUserParameters ##. [api:parameters] MnUserParameters is the main class for user interaction; with the parameters. It serves both as input to the minimization as well; as output as the result of the minimization is converted into the user; representable format in order to allow for further interaction.; Parameters for M can be added (defined) specifying a name, value and; initial uncertainty. ### add(...) ###. The method MnUserParameters::add(...) is overloaded for three kind of; parameters:. - add(const char\*, double, double) for adding a free variable; parameter. - add(const char\*, double, double, double, double) for adding a; variable parameter with limits (lower and upper). - add(const char\*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will; be the same as in the std::vector$<$double$>$ in the; FCNBase::operator(). That means the first parameter the user adds gets; inde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:52978,access,accessed,52978,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['accessed']
Security," slightly higher; memory overhead and better diagnostics. The primary use case of; MemTagSanitizer is code hardening in production binaries, where it is; expected to be a strong mitigation for both stack and heap-based; memory bugs. Usage; =====. Compile and link your program with ``-fsanitize=memtag`` flag. This; will only work when targeting AArch64 with MemTag extension. One; possible way to achieve that is to add ``-target; aarch64-linux -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:1659,access,access,1659,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['access'],['access']
Security," ssize_t. 2022-03-08: 2.3.0; -----------------. * CUDA support (up to version 10.2); * Allow `std::string_view<char>` initialization from Python `str` (copies); * Provide access to extern ""C"" declared functions in namespaces; * Support for (multiple and nested) anonymous structs; * Pull forward upstream patch for PPC; * Only apply system_dirs patch (for asan) on Linux; * Add not-yet loaded classes to namespaces in dir(); * Fix lookup of templates of function with template args; * Fix lookup of templates types with << in name; * Fix regression for accessing `char16_t` data member arrays; * Add custom `__reshape__` method to CPPInstance to allow array cast; * Prioritize callee exceptions over bindings exceptions; * Prevent infinite recursion when instantiating class with no constructors. 2021-11-14: 2.2.0; -----------------. * Migrated repos to github/wlav; * Properly resolve enum type of class enums; * Get proper shape of ``void*`` and enum arrays; * Fix access to (const) ref data members; * Fix sometimes PCH uninstall issue; * Fix argument passing of fixed arrays of pointers; * Include all gcc system paths (for asan); * Initial support for Apple M1. 2021-07-17: 2.1.0; -----------------. * Support for vector calls with CPython 3.8 and newer; * Support for typed C++ literals as defaults when mixing with keywords; * Enable reshaping of multi-dim LowLevelViews; * Refactored multi-dim arrays and support for multi-dim assignment; * Support tuple-based indexing for multi-dim arrays; * Direct support for C's _Complex (_Complex_double/_float on Windows); * sizeof() forwards to ctypes.sizeof() for ctypes' types; * Upgrade cmake fragments for Clang9; * Prevent clash with Julia's LLVM when loading cppyy into PyCall; * Upgrade to latest Cling patch release. 2021-05-14: 2.0.0; -----------------. * Upgrade to latest Cling based on Clang/LLVM 9; * Make C++17 the default standard on Windows. 2021-04-28: 1.9.6; -----------------. * Reverse operators for ``std::complex`` targeting Pyth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:5314,access,access,5314,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['access'],['access']
Security," standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * Assembler/disassembler support has been added for 2023 architecture; extensions. * Support has been added for Stack Clash Protection. During function frame; creation and dynamic stack allocations, the compiler will issue memory; accesses at reguilar intervals so that a guard area at the top of the stack; can't be skipped over. Changes to the AMDGPU Backend; -----------------------------. * `llvm.sqrt.f32` is now lowered correctly. Use `llvm.amdgcn.sqrt.f32`; for raw instruction access. * Implemented `llvm.stacksave` and `llvm.stackrestore` intrinsics. * Implemented :ref:`llvm.get.rounding <int_get_rounding>`. * The default :ref:`AMDHSA code object version <amdgpu-amdhsa-code-object-metadata-v5>` is now 5. Changes to the ARM Backend; --------------------------. * Added support for Cortex-M52 CPUs.; * Added execute-only support for Armv6-M. Changes to the AVR Backend; --------------------------. Changes to the DirectX Backend; ------------------------------. Changes to the Hexagon Backend; ------------------------------. Changes to the LoongArch Backend; --------------------------------. * Added intrinsics support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; * Added definition and intrinsic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:3669,access,accesses,3669,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['access'],['accesses']
Security," start with; `RQ_OBJECT(""ClassName"") `macro. This macro allows the signals/slots; communication mechanism to be applied between compiled and interpreted; classes in an interactive ROOT session without having the class derive; from **`TQObject`**. Every signal method declaration is followed by a; comment `""*SIGNAL*"".` Only instances of a class that defines a signal or; instances of its subclasses can emit the signal. The ROOT implementation; of a popular example presenting signals and slots is the next. Let's; have a minimal class declaration:. ``` {.cpp}; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. It will become the following as interpreted:. ``` {.cpp}; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; ```. Both class declarations have the same data member and public methods to; access the value. By placing the `RQ_OBJECT(""MyClass"")` macro inside the; `MyClass` body (`MyClass` is not inherited from **`TQObject`**) we allow; this class to use the signal/slot communication. Any instance of this; class can tell the outside world that the state of its data member has; changed by emitting a signal `SetValue(Int_t).` A possible; implementation of `MyClass::SetValue()` can be:. ``` {.cpp}; void MyClass::SetValue(Int_t v) {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"",v);; }; }; ```. The line `Emit(""SetValue(Int_t)"",v)` activates the signal; `SetValue(Int_t)` with argument v. You can use any of the methods; **`TQObject::Emit(""full_method_name"",arguments)`** to emit a signal. We; create two instances of `MyClass` and connect them together:. ``` {.cpp}; MyClass *objA = new MyClass();; MyClass *objB = new MyClass();; objA->Connect(""SetValue(Int_t)"",""MyClass"",objB,""SetValue(Int_t)"");; objB->SetValue(11);; objA->SetValue(79);; objB->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:44067,access,access,44067,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security," statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116102,access,access,116102,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security," string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8429,access,access,8429,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['access'],['access']
Security," such as C or C++. These programs are compiled using a user specified compiler and set of; flags, and then executed to capture the program output and timing; information. The output of these programs is compared to a reference; output to ensure that the program is being compiled correctly. In addition to compiling and executing programs, whole program tests; serve as a way of benchmarking LLVM performance, both in terms of the; efficiency of the programs generated as well as the speed with which; LLVM compiles, optimizes, and generates code. The test-suite is located in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_. See the :doc:`TestSuiteGuide` for details. Debugging Information tests; ---------------------------. The test suite contains tests to check quality of debugging information.; The test are written in C based languages or in LLVM assembly language. These tests are compiled and run under a debugger. The debugger output; is checked to validate of debugging information. See README.txt in the; test suite for more information. This test suite is located in the; ``cross-project-tests/debuginfo-tests`` directory. Quick start; ===========. The tests are located in two separate repositories. The unit and; regression tests are in the main ""llvm""/ directory under the directories; ``llvm/unittests`` and ``llvm/test`` (so you get these tests for free with the; main LLVM tree). Use ``make check-all`` to run the unit and regression tests; after building LLVM. The ``test-suite`` module contains more comprehensive tests including whole C; and C++ programs. See the :doc:`TestSuiteGuide` for details. Unit and Regression tests; -------------------------. To run all of the LLVM unit tests use the check-llvm-unit target:. .. code-block:: bash. % make check-llvm-unit. To run all of the LLVM regression tests use the check-llvm target:. .. code-block:: bash. % make check-llvm. In order to get reasonable testing performance, build LLVM an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:4352,validat,validate,4352,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['validat'],['validate']
Security," table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate with; code compiled in other languages. You could also generate code by; implicitly making every function return an error value and checking; it. You could also make explicit use of setjmp/longjmp. There are; many different ways to go here.; - **object orientation, generics, database access, complex numbers,; geometric programming, ...** - Really, there is no end of crazy; features that you can add to the language.; - **unusual domains** - We've be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:3263,access,access,3263,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['access'],['access']
Security," tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further information. ### PROOF on Demand. > Latest recommended PROOF on Demand version is 3.12.; >; > **On CernVM-FS:** `/cvmfs/sft.cern.ch/lcg/external/PoD/3.12`; >; > **Source code:** [PoD download page](http://pod.gsi.de/download.html); > and [Installation; > instructions](http://pod.gsi.de/doc/3.12/Installation.html). [PROOF on Demand](http://pod.gsi.de/) is required on the head node and on the; user's client. In case your experiment provides a version of PoD on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:4076,authenticat,authentication,4076,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['authenticat'],['authentication']
Security," test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21434,secur,security,21434,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security," the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same clu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:1896,access,accessible,1896,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['access'],['accessible']
Security," the LLVM coding standards and provides useful information on writing; efficient C++ code. :doc:`GitHub`; Describes how to use the llvm-project repository and code reviews on GitHub. :doc:`GitBisecting`; Describes how to use ``git bisect`` on LLVM's repository. :doc:`GitRepositoryPolicy`; Collection of policies around the git repositories. .. _development-process:. Development Process; -------------------. Information about LLVM's development process. .. toctree::; :hidden:. Projects; HowToReleaseLLVM; Packaging; ReleaseProcess; HowToAddABuilder; ReleaseNotes. :doc:`Projects`; How-to guide and templates for new projects that *use* the LLVM; infrastructure. The templates (directory organization, Makefiles, and test; tree) allow the project code to be located outside (or inside) the ``llvm/``; tree, while using LLVM header files and libraries. :doc:`HowToReleaseLLVM`; This is a guide to preparing LLVM releases. Most developers can ignore it. :doc:`ReleaseProcess`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to all these forums and mailing lists. `LLVM Discourse`__; The forums for all things LLVM and related sub-projects. There are categories and subcategories for a wide variety of areas within LLVM. You can also view tags or search for a specific topic. .. __: https://discourse.llvm.org/. `Commits Archive (llvm-commits)`__; This list contains all commit messages that are made when LLVM d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:2006,validat,validate,2006,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['validat'],['validate']
Security," the Module in which the function is defined. If this; argument is provided, the function will automatically be inserted into that; module's list of functions. * ``bool isDeclaration()``. Return whether or not the ``Function`` has a body defined. If the function is; ""external"", it does not have a body, and thus must be resolved by linking with; a function defined in a different translation unit. * | ``Function::iterator`` - Typedef for basic block list iterator; | ``Function::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``, ``insert()``,; ``splice()``, ``erase()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's BasicBlock_ list. * | ``Function::arg_iterator`` - Typedef for the argument list iterator; | ``Function::const_arg_iterator`` - Typedef for const_iterator.; | ``arg_begin()``, ``arg_end()``, ``arg_size()``, ``arg_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's Argument_ list. * ``Function::ArgumentListType &getArgumentList()``. Returns the list of Argument_. This is necessary to use when you need to; update the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxyge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:157507,access,access,157507,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security," the behaviour of the xpd.allowedusers directive: if; at least one of these directives is present, users in the password file; are not allowed by default but must be explicitly appear in one; xpd.allowedusers directive  ; Fix a source for memory leak in; XrdProofdProtocol::SendMsg; Optimize the usage of strings in a few places. DataSet manager. Correctly classify as TTree all TTree derived classes; (e.g. TNtuple's); Fix a problem in saving the end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacketizerAdaptive, TPacketizer. Improve data node / worker matching by always using the; host FQDN. TPacketizerUnit, TEventIter. Make sure that the entry; number passed to TSelector::Process is unique and in increasing order; for non-data driven processing (packetizer TPacketizerUnit). This; allows to give a meaning to this variable, for example to related it to; one dimension of an integration. Fixes in PROOF-Lite:. Make sure that with envs settings via TProof::AddEnvVar; are effective; this enables, for example, the automatic valgrind setup; introduced in 5.24/00 or the experiment specific settings via the; script defined by the env PROOF_INIT; Fix a problem with TProof::Load so that now it can be; also be used for PROOF-Lite. TProofPlayerRemote. In SendSelector, add misisng; option kCpBin when sending the selector source; the binary files were;  never retrieved, even if present",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:8619,validat,validation,8619,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,['validat'],['validation']
Security," the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch register. Furthermore it also preserves; all floating-point registers (XMMs/YMMs). - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD -; floating point registers. The idea behind this convention is to support calls to runtime functions; that don't need to call out to any other functions. This calling convention, like the `PreserveMost` calling convention, will be; used by a future version of the ObjectiveC runtime and should be considered; experimental at this time.; ""``cxx_fast_tlscc``"" - The `CXX_FAST_TLS` calling convention for access functions; Clang generates an access function to access C++-style TLS. The access; function generally has an entry block, an exit block and an initialization; block that is run at the first time. The entry and exit blocks can access; a few TLS IR variables, each access will be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc,; except for an additional guarantee that tail calls will be produced; whenever possible. `Tail calls can only be optimized",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:20177,access,access,20177,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security," the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79526,integrity,integrity,79526,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['integrity'],['integrity']
Security," the following code from ROOT 5:. ``` {.cpp}; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; ```. Instead, write:. ``` {.cpp}; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; ```. #### TClass. Introduced new overload for calculating the TClass CheckSum:. ``` {.cpp}; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; ```. which indicates via the 'isvalid' boolean whether the checksum could be; calculated correctly or not. ### TROOT. Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory.; This is $ROOTSYS/tutorials when not configuring with --prefix or -Dgnuinstall for CMake. ### TColor. Add an enum to access the palette by name. Add new palettes with 255 colors. Names and colors' definitions have been taken from; [here](http://www.rcnp.osaka-u.ac.jp/~noji/colormap). Except for the `kBird` palette.; These palettes can be accessed with `gStyle->SetPalette(num)`. `num` can be taken; within the following enum:. * kDeepSea = 51; * kGreyScale = 52; * kDarkBodyRadiator = 53; * kBlueYellow = 54; * kRainBow = 55; * kInvertedDarkBodyRadiator = 56; * kBird = 57; * kCubehelix = 58; * kGreenRedViolet = 59; * kBlueRedYellow = 60; * kOcean = 61; * kColorPrintableOnGrey = 62; * kAlpine = 63; * kAquamarine = 64; * kArmy = 65; * kAtlantic = 66; * kAurora = 67; * kAvocado = 68; * kBeach = 69; * kBlackBody = 70; * kBlueGreenYellow = 71; * kBrownCyan = 72; * kCMYK = 73; * kCandy = 74; * kCherry = 75; * kCoffee = 76; * kDarkRainBow = 77; * kDarkTerrain = 78; * kFall = 79; * kFruitPunch = 80; * kFuchsia = 81; * kGreyYellow = 82; * kGreenBrownTerrain = 83; * kGreenPink = 84; * kIsland = 85; * kLake = 86; * kLightTemperature = 87; * kLightTerrain = 88; * kMint = 89; * kNeon = 90; * kPastel = 91; * kPearl = 92; * kPigeon = 93; * kPlum = 94; * kRedBlue = 95; * kRose = 96; * kRust = 97; * kSandyTerrain = 98; * kSienna = 99; * kSolar = 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:4096,access,accessed,4096,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['access'],['accessed']
Security," the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the hash tables a bit; differently: a header, buckets, an array of all unique 32 bit hash values,; followed by an array of hash value data offsets, one for each hash value, then; the data for all hash values:. .. code-block:: none. .-------------.; | HEADER |; |-------------|; | BUCKETS |; |-------------|; | HASHES |; |-------------|; | OFFSETS |; |-------------|; | DATA |; `-------------'. The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array. By; making all of the full 32 bit hash values contiguous in memory, we allow; ourselves to efficiently check for a match while touching as little memory as; possible. Most often checking the 32 bit hash values is as far as the lookup; goes. If it does match, it usually is a match with no collisions. So for a; table with ""``n_buckets``"" buckets, and ""``n_hashes``"" unique 32 bit hash; values, we can clarify the contents of the ``BUCKETS``, ``HASHES`` and; ``OFFSETS`` as:. .. code-block:: none. .-------------------------.; | HEADER.magic | uint32_t; | HEADER.version | uint16_t; | HEADER.hash_function | uint16_t; | HEADER.bucket_count | uint32_t; | HEADER.hashes_count | uint32_t; | HEADER.header_data_len | uint32_t; | HEADER_DATA | HeaderData; |-------------------------|; | BUCKETS | uint32_t[n_buckets] // 32 bit hash indexes; |-------------------------|; | HASHES | uint32_t[n_hashes] // 32 bit hash values; |-------------------------|; | OFFSETS | uint32_t[n_hashes] // 32 bit offsets to hash value data; |-------------------------|; | ALL HASH DATA |; `-------------------------'. So taking the exact same data from the standard hash example above we end up; with:. .. code-block:: none. .---",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:63539,hash,hash,63539,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security," the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94803,access,accessed,94803,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['accessed']
Security," the name of the ROOT class you are dealing with, e.g.; `TCanvas` for the display window itself, `TFrame` for the frame of the; plot, `TAxis` for the axes, `TPaveText` for the plot name. Depending on; which plot you are investigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:14360,access,access,14360,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['access'],['access']
Security," the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ~~~. The lines above will create a new TGeoManager class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:126220,access,access,126220,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['access']
Security," the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc.ownership.semantics:. Semantics; ---------. There are five :arc-term:`managed operations` which may be performed on an; object of retainable object pointer type. Each qualifier specifies different; semantics for each of these operations. It is still undefined behavior to; access an object outside of its lifetime. A load or store with ""primitive semantics"" has the same semantics as the; respective operation would have on an ``void*`` lvalue with the same alignment; and non-ownership qualification. :arc-term:`Reading` occurs when performing a lvalue-to-rvalue conversion on an; object lvalue. * For ``__weak`` objects, the current pointee is retained and then released at; the end of the current full-expression. In particular, messaging a ``__weak``; object keeps the object retained until the end of the full expression. .. code-block:: objc. __weak MyObject *weakObj;. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:37186,access,accesses,37186,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accesses']
Security," the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via using the following scripts. Similarly to the local environment, configuration is split in different files; to allow for a system-wide configuration, which has precedence over; user's configuration in the home directory. If a script cannot be found,; it will be silently skipped. - `<output_of_payload>`. - `common.before`. - `remote.before`. - `remote.conf`. - `common.after`. - `remote.after`. For an explanation on how to pass extra data to the workers safely; through the payload, see below. ### Payload: sending local files to the remote nodes. In many cases it is necessary to send some local data to the remote; workers: it is very common, for instance, to distribute a local Grid; authentication proxy on the remote workers to let them authenticate to; access a data storage. The `payload` file must be an executable generating some output that; will be prepended to the remote environment preparation. Differently; than the other environment scripts, it is not executed: instead, it is; first run, then *the output it produces will be executed*. Let's see a practical example to better understand how it works. We need; to send our Grid proxy to the master node. This is our `payload` executable script:. ``` {.bash}; #!/bin/bash; echo ""echo '`cat /tmp/x509up_u$UID | base64 | tr -d '\r\n'`'"" \; ""| base64 -d > /tmp/x509up_u\$UID""; ```. This script will be executed locally, providing another ""script line"" as; output:. ``` {.bash}; echo 'VGhpcyBpcyB0aGUgZmFrZSBjb250ZW50IG9mIG91ciBHcmlkIHByb3h5IGZpbGUuCg==' | base64 -d > /tmp/x509up_u$UID; ```. This line will be prepended to the remote environment script and will be; executed before anything else on the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:5219,authenticat,authentication,5219,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,3,"['access', 'authenticat']","['access', 'authenticate', 'authentication']"
Security," the same material. \anchor GM00b; ### Radionuclides. A new class TGeoElementRN was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (TGeoElementTable class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ~~~. One can make materials or mixtures from radionuclides:. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ~~~. The following properties of radionuclides can be currently accessed via; getters in the TGeoElementRN class:. Atomic number and charge (from the base class TGeoElement). - Isomeric number (`ISO`); - ENDF code - following the convention: `ENDF=10000*Z+100*A+ISO`; - Isomeric energy level [`MeV`]; - Mass excess [`MeV`]; - Half life [`s`]; - Spin/Parity - can be retrieved with: `TGeoElementRN::GetTitle()`; - Hynalation and ingestion toxicities; - List of decays - `TGeoElementRN::GetDecays()`. The radioactive decays of a radionuclide are represented by the class; TGeoDecayChannel and they are stored in a TObjArray. Decay; provides:. - Decay mode; - Variation of isomeric number; - `Q` value for the decay [`GeV`]; - Parent element; - Daughter element. Radionuclides are linked one to each other via their decays, until the; last element in the decay chain which must be stable. One can iterate; decay chains using the iterator TGeoElemIter:. ~~~{.cpp}; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Pri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:5898,access,accessed,5898,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['access'],['accessed']
Security," the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithmetic conversion is performed.; * If one operand is of matrix type and the other operand is of a real type,; convert the real type operand to the matrix type; according to the standard conversion rules. Matrix Type Element Access Operator; -----------------------------------. An expression of the form ``E1 [E2] [E3]``, where ``E1`` has matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:3611,access,access,3611,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['access'],['access']
Security," the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54487,access,access,54487,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security," there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15253,secur,security,15253,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security," things like stack usage in the kernel and called; functions. Some of this initialization requires the compiler to request certain; User and System SGPRs be present in the; :ref:`amdgpu-amdhsa-initial-kernel-execution-state` via the; :ref:`amdgpu-amdhsa-kernel-descriptor`. .. _amdgpu-amdhsa-kernel-prolog-cfi:. CFI; +++. 1. The CFI return address is undefined. 2. The CFI CFA is defined using an expression which evaluates to a location; description that comprises one memory location description for the; ``DW_ASPACE_AMDGPU_private_lane`` address space address ``0``. .. _amdgpu-amdhsa-kernel-prolog-m0:. M0; ++. GFX6-GFX8; The M0 register must be initialized with a value at least the total LDS size; if the kernel may access LDS via DS or flat operations. Total LDS size is; available in dispatch packet. For M0, it is also possible to use maximum; possible value of LDS for given target (0x7FFF for GFX6 and 0xFFFF for; GFX7-GFX8).; GFX9-GFX11; The M0 register is not used for range checking LDS accesses and so does not; need to be initialized in the prolog. .. _amdgpu-amdhsa-kernel-prolog-stack-pointer:. Stack Pointer; +++++++++++++. If the kernel has function calls it must set up the ABI stack pointer described; in :ref:`amdgpu-amdhsa-function-call-convention-non-kernel-functions` by setting; SGPR32 to the unswizzled scratch offset of the address past the last local; allocation. .. _amdgpu-amdhsa-kernel-prolog-frame-pointer:. Frame Pointer; +++++++++++++. If the kernel needs a frame pointer for the reasons defined in; ``SIFrameLowering`` then SGPR33 is used and is always set to ``0`` in the; kernel prolog. If a frame pointer is not required then all uses of the frame; pointer are replaced with immediate ``0`` offsets. .. _amdgpu-amdhsa-kernel-prolog-flat-scratch:. Flat Scratch; ++++++++++++. There are different methods used for initializing flat scratch:. * If the *Target Properties* column of :ref:`amdgpu-processor-table`; specifies *Does not support generic address space*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:192979,access,accesses,192979,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security," this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, or if code faulted; while accessing a particular memory address range. LLVM does not currently have; IR to represent filter expressions because it is difficult to represent their; control dependencies. Filter expressions run during the first phase of EH,; before cleanups run, making it very difficult to build a faithful control flow; graph. For now, the new EH instructions cannot represent SEH filter; expressions, and frontends must outline them ahead of time. Local variables of; the parent function can be escaped and accessed using the ``llvm.localescape``; and ``llvm.localrecover`` intrinsics. New exception handling instructions; ------------------------------------. The primary design goal of the new EH instructions is to support funclet; generation while preserving information about the CFG so that SSA formation; still works. As a secondary goal, they are designed to be generic across MSVC; and Itanium C++ exceptions. They make very few assumptions about the data; required by the personality, so long as it uses the familiar core EH actions:; catch, cleanup, and terminate. However, the new instructions are hard to modify; without knowing details of the EH personality. While they can be used to; represent Itanium EH, the landingpad model is strictly better for optimization; purposes. The following new instructions are considered ""exception handling pads"", in that; they must be the first non-phi instruction of a basic block that may be the; unwind destination of an EH flow edge:; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:24796,access,accessed,24796,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['access'],['accessed']
Security," this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used to block inlining of the; async coroutine until after coroutine splitting. Arguments:; """""""""""""""""""". The first argument should be an async coroutine of type `void (ptr, ptr, ptr)`.; Lowering will replace this intrinsic with its coroutine function argument. .. _coro.suspend.retcon:. 'llvm.coro.suspend.retcon' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.suspend.retcon(...). Overview:; """""""""""""""""". The '``llvm.coro.suspend.retcon``' intrinsic marks the point where; execution of a returned-continuation coroutine is suspended and control; is returned back to the caller. `llvm.coro.suspend.retcon`` does not support separate save points;; they are not useful when the continuation function is not locally; accessible. That would be a more appropriate feature for a ``passcon``; lowering that is not yet implemented. Arguments:; """""""""""""""""""". The types of the arguments must exactly match the yielded-types sequence; of the coroutine. They will be turned into return values from the ramp; and continuation functions, along with the next continuation function. Semantics:; """""""""""""""""""". The result of the intrinsic indicates whether the coroutine should resume; abnormally (non-zero). In a normal coroutine, it is undefined behavior if the coroutine executes; a call to ``llvm.coro.suspend.retcon`` after resuming abnormally. In a yield-once coroutine, it is undefined behavior if the coroutine; executes a call to ``llvm.coro.suspend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the corouti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:55467,access,accessible,55467,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['access'],['accessible']
Security," this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### THttpServer. Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of; objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class. When command is registered with THttpServer::RegisterCommand() method,; one could configure additional arguments which should be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:19538,authenticat,authentication,19538,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['authenticat'],['authentication']
Security," thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2850,checksum,checksummed,2850,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,3,"['access', 'checksum']","['accessed', 'checksummed']"
Security," three arguments are the same as they are in the :ref:`@llvm.memcpy <int_memcpy>`; intrinsic, with the added constraint that ``len`` is required to be a positive integer; multiple of the ``element_size``. If ``len`` is not a positive integer multiple of; ``element_size``, then the behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no greater than; target-specific atomic access size limit. For each of the input pointers ``align`` parameter attribute must be specified. It; must be a power of two no less than the ``element_size``. Caller guarantees that; both the source and destination pointers are aligned to that boundary. Semantics:; """""""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic copies ``len`` bytes of; memory from the source location to the destination location. These locations are not; allowed to overlap. The memory copy is performed as a sequence of load/store operations; where each access is guaranteed to be a multiple of ``element_size`` bytes wide and; aligned at an ``element_size`` boundary. The order of the copy is unspecified. The same value may be read from the source; buffer many times, but only one write is issued to the destination buffer per; element. It is well defined to have concurrent reads and writes to both source and; destination provided those reads and writes are unordered atomic when specified. This intrinsic does not provide any additional ordering guarantees over those; provided by a set of unordered loads from the source location and stores to the; destination. Lowering:; """""""""""""""""". In the most general case call to the '``llvm.memcpy.element.unordered.atomic.*``' is; lowered to a call to the symbol ``__llvm_memcpy_element_unordered_atomic_*``. Where '*'; is replaced with an actual element size. See :ref:`RewriteStatepointsForGC intrinsic; lowering <RewriteStatepointsForGC_intrinsic_lowering>` for details on GC specific; lowering. Optimizer is allowed to inl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:959057,access,access,959057,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," to arrays of composites: each field and base; class is preceded by an inline descriptor. The ``InlineDescriptor``; has the following fields:. * **Offset**: byte offset into the array or record, used to step back to the; parent array or record.; * **IsConst**: flag indicating if the field is const-qualified.; * **IsInitialized**: flag indicating whether the field or element was; initialized. For non-primitive fields, this is only relevant to determine; the dynamic type of objects during construction.; * **IsBase**: flag indicating whether the record is a base class. In that; case, the offset can be used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8387,access,access,8387,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,1,['access'],['access']
Security," to complete the transition to GitHub by Oct 21, 2019. See; the GitHub migration `status page <https://llvm.org/GitHubMigrationStatus.html>`_; for the latest updates and instructions for how to migrate your workflows. .. contents:: Table of Contents; :depth: 4; :local:. Introduction; ============. This is a proposal to move our current revision control system from our own; hosted Subversion to GitHub. Below are the financial and technical arguments as; to why we are proposing such a move and how people (and validation; infrastructure) will continue to work with a Git-based LLVM. What This Proposal is *Not* About; =================================. Changing the development policy. This proposal relates only to moving the hosting of our source-code repository; from SVN hosted on our own servers to Git hosted on GitHub. We are not proposing; using GitHub's issue tracker, pull-requests, or code-review. Contributors will continue to earn commit access on demand under the Developer; Policy, except that that a GitHub account will be required instead of SVN; username/password-hash. Why Git, and Why GitHub?; ========================. Why Move At All?; ----------------. This discussion began because we currently host our own Subversion server; and Git mirror on a voluntary basis. The LLVM Foundation sponsors the server and; provides limited support, but there is only so much it can do. Volunteers are not sysadmins themselves, but compiler engineers that happen; to know a thing or two about hosting servers. We also don't have 24/7 support,; and we sometimes wake up to see that continuous integration is broken because; the SVN server is either down or unresponsive. We should take advantage of one of the services out there (GitHub, GitLab,; and BitBucket, among others) that offer better service (24/7 stability, disk; space, Git server, code browsing, forking facilities, etc) for free. Why Git?; --------. Many new coders nowadays start with Git, and a lot of people have never used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:1097,access,access,1097,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,2,"['access', 'password']","['access', 'password-hash']"
Security," to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable res",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11260,secur,security,11260,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,['secur'],['security']
Security," to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual machine, we have much more room; for value add. The nice safe ""sandbox"" VM can be provided as a layer; on top of it. It also lets us focus on the more interesting compilers; related projects. > 2. Design issues to consider (an initial list that we should continue; > to modify). Note that I'm not trying to suggest actual solutions here,; > but just various directions we can pursue:. Understood. :). > a. A single-assignment VM, which we've both already been thinking; > about. Yup, I think that this makes a lot of sense. I am still intrigued,; however, by the prospect of a minimally allocated VM representation... I; think that it could have definit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:1936,validat,validate,1936,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['validat'],['validate']
Security," to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the pointer and passes the result as the argument %1 into ``^3``.; This record itself does not tell us how ``^3`` will access the parameter.; Parameter %3 is not a pointer. .. _refs_summary:. Refs; ^^^^. The optional ``Refs`` field looks like:. .. code-block:: text. refs: ((Ref)[, (Ref)]*). where each ``Ref`` contains a reference to the summary id of the referenced; value (e.g. ``^1``). .. _typeidinfo_summary:. TypeIdInfo; ^^^^^^^^^^. The optional ``TypeIdInfo`` field, used for; `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; looks like:. .. code-block:: text. typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstVCalls)]?[, (TypeCheckedLoadConstVCalls)]?. These optional fields have the following forms:. TypeTests; """""""""""""""""". .. code-block:: text. typeTests: (TypeId",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:346123,access,access,346123,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security," two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TConditi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:7136,access,access,7136,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security," type descriptors have a sequence of alternating ``MDNode`` and; ``ConstantInt`` operands. With N starting from 1, the 2N - 1 th operand,; an ``MDNode``, denotes a contained field, and the 2N th operand, a; ``ConstantInt``, is the offset of the said contained field. The offsets; must be in non-decreasing order. Access tags are represented as ``MDNode`` s with either 3 or 4 operands.; The first operand is an ``MDNode`` pointing to the node representing the; base type. The second operand is an ``MDNode`` pointing to the node; representing the access type. The third operand is a ``ConstantInt`` that; states the offset of the access. If a fourth field is present, it must be; a ``ConstantInt`` valued at 0 or 1. If it is 1 then the access tag states; that the location being accessed is ""constant"" (meaning; ``pointsToConstantMemory`` should return true; see `other useful; AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_). The TBAA root of; the access type and the base type of an access tag must be the same, and; that is the TBAA root of the access tag. '``tbaa.struct``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The :ref:`llvm.memcpy <int_memcpy>` is often used to implement; aggregate assignment operations in C and similar languages, however it; is defined to copy a contiguous region of memory, which is more than; strictly necessary for aggregate types which contain holes due to; padding. Also, it doesn't contain any TBAA information about the fields; of the aggregate. ``!tbaa.struct`` metadata can describe which memory subregions in a; memcpy are padding and what the TBAA tags of the struct are. The current metadata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the byte offset of a; field in bytes, the second gives its size in bytes, and the third gives; its tbaa tag. e.g.:. .. code-block:: llvm. !4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }. This des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:279474,access,access,279474,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,3,['access'],['access']
Security," type; <arc.misc.c-retainable>`, it is reasonable to assume that global system; constants were initialized with true constants (e.g. string literals), but; user constants might have been initialized with something dynamically; allocated, using a global initializer. .. _arc.objects.restrictions.conversion-exception-contextual:. Conversion from retainable object pointer type in certain contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`. If an expression of retainable object pointer type is explicitly cast to a; :ref:`C retainable pointer type <arc.misc.c-retainable>`, the program is; ill-formed as discussed above unless the result is immediately used:. * to initialize a parameter in an Objective-C message send where the parameter; is not marked with the ``cf_consumed`` attribute, or; * to initialize a parameter in a direct call to an; :ref:`audited <arc.misc.c-retainable.audit>` function where the parameter is; not marked with the ``cf_consumed`` attribute. .. admonition:: Rationale. Consumed parameters are left out because ARC would naturally balance them; with a retain, which was judged too treacherous. This is in part because; several of the most common consuming functions are in the ``Release`` family,; and it would be quite unfortunate for explicit releases to be silently; balanced out in this way. .. _arc.ownership:. Ownership qualification; =======================. This section describes the behavior of *objects* of retainable object pointer; type; that is, locations in memory which store retainable object pointers. A type is a :arc-term:`retainable object owner type` if it is a retainable; object pointer type or an array type whose element type is a retainable object; owner type. An :arc-term:`ownership qualifier` is a type qualifier which applies only to; retainable object owner types. An array type is ownership-qualified according; to its element type, and adding an ownership qualifier",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:29794,audit,audit,29794,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['audit'],['audit']
Security, types; Clang 3.0. 660; CD1; Unnamed scoped enumerations; Clang 3.0. 661; CD1; Semantics of arithmetic comparisons; Unknown. 662; NAD; Forming a pointer to a reference type; Yes. 663; CD1; Valid Cyrillic identifier characters; Superseded by P1949. 664; CD2; Direct binding of references to non-class rvalue references; Yes. 665; CD2; Problems in the specification of dynamic_cast; Clang 2.8. 666; CD1; Dependent qualified-ids without the typename keyword; Clang 2.8. 667; CD2; Trivial special member functions that cannot be implicitly defined; Clang 8. 668; CD2; Throwing an exception from the destructor of a local static object; Unknown. 669; NAD; Confusing specification of the meaning of decltype; Yes. 670; CD4; Copy initialization via derived-to-base conversion in the second step; Unknown. 671; CD1; Explicit conversion from a scoped enumeration type to integral type; Clang 2.9. 672; CD2; Sequencing of initialization in new-expressions; Unknown. 673; NAD; Injection of names from elaborated-type-specifiers in friend declarations; Yes. 674; C++11; “matching specialization” for a friend declaration; Clang 8. 675; CD3; Signedness of bit-field with typedef or template parameter type; Duplicate of 739. 676; C++11; static_assert-declarations and general requirements for declarations; N/A. 677; CD1; Deleted operator delete and virtual destructors; No. 678; C++11; Language linkage of member function parameter types and the ODR; Unknown. 679; CD1; Equivalence of template-ids and operator function templates; Yes. 680; CD2; What is a move constructor?; N/A. 681; CD1; Restrictions on declarators with late-specified return types; Partial. 682; CD5; Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/defin,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:46022,Inject,Injection,46022,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Inject'],['Injection']
Security," uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; break;. case 1:; predicate_state = (condition != 1) ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; break;. // ...; }; }; ```. The core idea remains the same: validate the control flow using data-flow and; use that validation to check that loads cannot leak information along; misspeculated paths. Typically this involves passing the desired target of such; control flow across the edge and checking that it is correct afterwards. Note; that while it is tempting to think that this mitigates variant #2 attacks, it; does not. Those attacks go to arbitrary gadgets that don't include the checks. ### Variant #1.1 and #1.2 attacks: ""Bounds Check Bypass Store"". Beyond the core variant #1 attack, there are techniques to extend this attack.; The primary technique is known as ""Bounds Check Bypass Store"" and is discussed; in this research paper: https://people.csail.mit.edu/vlk/spectre11.pdf. We will analyze these two variants independently. First, variant #1.1 works by; speculatively storing over the return address after a bounds check bypass. This; speculative store then ends up being used by the CPU during speculative; execution of the return, potentially directing speculative execution to; arbitrary gadgets in the binary. Let's look at an example.; ```; unsigned char local_buffer[4];; unsigned char *untrusted_data_from_caller = ...;; unsigned long untrusted_size_from_caller = ...;; if (untrusted_size_from_caller < sizeof(local_buffer)) {; // Speculative execution enters here with a too-large size.; memcpy(local_buffer, untrusted_data_from_caller",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:10883,attack,attacks,10883,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
